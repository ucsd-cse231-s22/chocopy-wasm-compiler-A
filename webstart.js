/******/ (() => { // webpackBootstrap
/******/ 	var __webpack_modules__ = ({

/***/ "./node_modules/codemirror/addon/edit/closebrackets.js":
/*!*************************************************************!*\
  !*** ./node_modules/codemirror/addon/edit/closebrackets.js ***!
  \*************************************************************/
/***/ ((__unused_webpack_module, __unused_webpack_exports, __webpack_require__) => {

// CodeMirror, copyright (c) by Marijn Haverbeke and others
// Distributed under an MIT license: https://codemirror.net/LICENSE

(function(mod) {
  if (true) // CommonJS
    mod(__webpack_require__(/*! ../../lib/codemirror */ "./node_modules/codemirror/lib/codemirror.js"));
  else {}
})(function(CodeMirror) {
  var defaults = {
    pairs: "()[]{}''\"\"",
    closeBefore: ")]}'\":;>",
    triples: "",
    explode: "[]{}"
  };

  var Pos = CodeMirror.Pos;

  CodeMirror.defineOption("autoCloseBrackets", false, function(cm, val, old) {
    if (old && old != CodeMirror.Init) {
      cm.removeKeyMap(keyMap);
      cm.state.closeBrackets = null;
    }
    if (val) {
      ensureBound(getOption(val, "pairs"))
      cm.state.closeBrackets = val;
      cm.addKeyMap(keyMap);
    }
  });

  function getOption(conf, name) {
    if (name == "pairs" && typeof conf == "string") return conf;
    if (typeof conf == "object" && conf[name] != null) return conf[name];
    return defaults[name];
  }

  var keyMap = {Backspace: handleBackspace, Enter: handleEnter};
  function ensureBound(chars) {
    for (var i = 0; i < chars.length; i++) {
      var ch = chars.charAt(i), key = "'" + ch + "'"
      if (!keyMap[key]) keyMap[key] = handler(ch)
    }
  }
  ensureBound(defaults.pairs + "`")

  function handler(ch) {
    return function(cm) { return handleChar(cm, ch); };
  }

  function getConfig(cm) {
    var deflt = cm.state.closeBrackets;
    if (!deflt || deflt.override) return deflt;
    var mode = cm.getModeAt(cm.getCursor());
    return mode.closeBrackets || deflt;
  }

  function handleBackspace(cm) {
    var conf = getConfig(cm);
    if (!conf || cm.getOption("disableInput")) return CodeMirror.Pass;

    var pairs = getOption(conf, "pairs");
    var ranges = cm.listSelections();
    for (var i = 0; i < ranges.length; i++) {
      if (!ranges[i].empty()) return CodeMirror.Pass;
      var around = charsAround(cm, ranges[i].head);
      if (!around || pairs.indexOf(around) % 2 != 0) return CodeMirror.Pass;
    }
    for (var i = ranges.length - 1; i >= 0; i--) {
      var cur = ranges[i].head;
      cm.replaceRange("", Pos(cur.line, cur.ch - 1), Pos(cur.line, cur.ch + 1), "+delete");
    }
  }

  function handleEnter(cm) {
    var conf = getConfig(cm);
    var explode = conf && getOption(conf, "explode");
    if (!explode || cm.getOption("disableInput")) return CodeMirror.Pass;

    var ranges = cm.listSelections();
    for (var i = 0; i < ranges.length; i++) {
      if (!ranges[i].empty()) return CodeMirror.Pass;
      var around = charsAround(cm, ranges[i].head);
      if (!around || explode.indexOf(around) % 2 != 0) return CodeMirror.Pass;
    }
    cm.operation(function() {
      var linesep = cm.lineSeparator() || "\n";
      cm.replaceSelection(linesep + linesep, null);
      moveSel(cm, -1)
      ranges = cm.listSelections();
      for (var i = 0; i < ranges.length; i++) {
        var line = ranges[i].head.line;
        cm.indentLine(line, null, true);
        cm.indentLine(line + 1, null, true);
      }
    });
  }

  function moveSel(cm, dir) {
    var newRanges = [], ranges = cm.listSelections(), primary = 0
    for (var i = 0; i < ranges.length; i++) {
      var range = ranges[i]
      if (range.head == cm.getCursor()) primary = i
      var pos = range.head.ch || dir > 0 ? {line: range.head.line, ch: range.head.ch + dir} : {line: range.head.line - 1}
      newRanges.push({anchor: pos, head: pos})
    }
    cm.setSelections(newRanges, primary)
  }

  function contractSelection(sel) {
    var inverted = CodeMirror.cmpPos(sel.anchor, sel.head) > 0;
    return {anchor: new Pos(sel.anchor.line, sel.anchor.ch + (inverted ? -1 : 1)),
            head: new Pos(sel.head.line, sel.head.ch + (inverted ? 1 : -1))};
  }

  function handleChar(cm, ch) {
    var conf = getConfig(cm);
    if (!conf || cm.getOption("disableInput")) return CodeMirror.Pass;

    var pairs = getOption(conf, "pairs");
    var pos = pairs.indexOf(ch);
    if (pos == -1) return CodeMirror.Pass;

    var closeBefore = getOption(conf,"closeBefore");

    var triples = getOption(conf, "triples");

    var identical = pairs.charAt(pos + 1) == ch;
    var ranges = cm.listSelections();
    var opening = pos % 2 == 0;

    var type;
    for (var i = 0; i < ranges.length; i++) {
      var range = ranges[i], cur = range.head, curType;
      var next = cm.getRange(cur, Pos(cur.line, cur.ch + 1));
      if (opening && !range.empty()) {
        curType = "surround";
      } else if ((identical || !opening) && next == ch) {
        if (identical && stringStartsAfter(cm, cur))
          curType = "both";
        else if (triples.indexOf(ch) >= 0 && cm.getRange(cur, Pos(cur.line, cur.ch + 3)) == ch + ch + ch)
          curType = "skipThree";
        else
          curType = "skip";
      } else if (identical && cur.ch > 1 && triples.indexOf(ch) >= 0 &&
                 cm.getRange(Pos(cur.line, cur.ch - 2), cur) == ch + ch) {
        if (cur.ch > 2 && /\bstring/.test(cm.getTokenTypeAt(Pos(cur.line, cur.ch - 2)))) return CodeMirror.Pass;
        curType = "addFour";
      } else if (identical) {
        var prev = cur.ch == 0 ? " " : cm.getRange(Pos(cur.line, cur.ch - 1), cur)
        if (!CodeMirror.isWordChar(next) && prev != ch && !CodeMirror.isWordChar(prev)) curType = "both";
        else return CodeMirror.Pass;
      } else if (opening && (next.length === 0 || /\s/.test(next) || closeBefore.indexOf(next) > -1)) {
        curType = "both";
      } else {
        return CodeMirror.Pass;
      }
      if (!type) type = curType;
      else if (type != curType) return CodeMirror.Pass;
    }

    var left = pos % 2 ? pairs.charAt(pos - 1) : ch;
    var right = pos % 2 ? ch : pairs.charAt(pos + 1);
    cm.operation(function() {
      if (type == "skip") {
        moveSel(cm, 1)
      } else if (type == "skipThree") {
        moveSel(cm, 3)
      } else if (type == "surround") {
        var sels = cm.getSelections();
        for (var i = 0; i < sels.length; i++)
          sels[i] = left + sels[i] + right;
        cm.replaceSelections(sels, "around");
        sels = cm.listSelections().slice();
        for (var i = 0; i < sels.length; i++)
          sels[i] = contractSelection(sels[i]);
        cm.setSelections(sels);
      } else if (type == "both") {
        cm.replaceSelection(left + right, null);
        cm.triggerElectric(left + right);
        moveSel(cm, -1)
      } else if (type == "addFour") {
        cm.replaceSelection(left + left + left + left, "before");
        moveSel(cm, 1)
      }
    });
  }

  function charsAround(cm, pos) {
    var str = cm.getRange(Pos(pos.line, pos.ch - 1),
                          Pos(pos.line, pos.ch + 1));
    return str.length == 2 ? str : null;
  }

  function stringStartsAfter(cm, pos) {
    var token = cm.getTokenAt(Pos(pos.line, pos.ch + 1))
    return /\bstring/.test(token.type) && token.start == pos.ch &&
      (pos.ch == 0 || !/\bstring/.test(cm.getTokenTypeAt(pos)))
  }
});


/***/ }),

/***/ "./node_modules/codemirror/addon/hint/show-hint.js":
/*!*********************************************************!*\
  !*** ./node_modules/codemirror/addon/hint/show-hint.js ***!
  \*********************************************************/
/***/ ((__unused_webpack_module, __unused_webpack_exports, __webpack_require__) => {

// CodeMirror, copyright (c) by Marijn Haverbeke and others
// Distributed under an MIT license: https://codemirror.net/LICENSE

// declare global: DOMRect

(function(mod) {
  if (true) // CommonJS
    mod(__webpack_require__(/*! ../../lib/codemirror */ "./node_modules/codemirror/lib/codemirror.js"));
  else {}
})(function(CodeMirror) {
  "use strict";

  var HINT_ELEMENT_CLASS        = "CodeMirror-hint";
  var ACTIVE_HINT_ELEMENT_CLASS = "CodeMirror-hint-active";

  // This is the old interface, kept around for now to stay
  // backwards-compatible.
  CodeMirror.showHint = function(cm, getHints, options) {
    if (!getHints) return cm.showHint(options);
    if (options && options.async) getHints.async = true;
    var newOpts = {hint: getHints};
    if (options) for (var prop in options) newOpts[prop] = options[prop];
    return cm.showHint(newOpts);
  };

  CodeMirror.defineExtension("showHint", function(options) {
    options = parseOptions(this, this.getCursor("start"), options);
    var selections = this.listSelections()
    if (selections.length > 1) return;
    // By default, don't allow completion when something is selected.
    // A hint function can have a `supportsSelection` property to
    // indicate that it can handle selections.
    if (this.somethingSelected()) {
      if (!options.hint.supportsSelection) return;
      // Don't try with cross-line selections
      for (var i = 0; i < selections.length; i++)
        if (selections[i].head.line != selections[i].anchor.line) return;
    }

    if (this.state.completionActive) this.state.completionActive.close();
    var completion = this.state.completionActive = new Completion(this, options);
    if (!completion.options.hint) return;

    CodeMirror.signal(this, "startCompletion", this);
    completion.update(true);
  });

  CodeMirror.defineExtension("closeHint", function() {
    if (this.state.completionActive) this.state.completionActive.close()
  })

  function Completion(cm, options) {
    this.cm = cm;
    this.options = options;
    this.widget = null;
    this.debounce = 0;
    this.tick = 0;
    this.startPos = this.cm.getCursor("start");
    this.startLen = this.cm.getLine(this.startPos.line).length - this.cm.getSelection().length;

    if (this.options.updateOnCursorActivity) {
      var self = this;
      cm.on("cursorActivity", this.activityFunc = function() { self.cursorActivity(); });
    }
  }

  var requestAnimationFrame = window.requestAnimationFrame || function(fn) {
    return setTimeout(fn, 1000/60);
  };
  var cancelAnimationFrame = window.cancelAnimationFrame || clearTimeout;

  Completion.prototype = {
    close: function() {
      if (!this.active()) return;
      this.cm.state.completionActive = null;
      this.tick = null;
      if (this.options.updateOnCursorActivity) {
        this.cm.off("cursorActivity", this.activityFunc);
      }

      if (this.widget && this.data) CodeMirror.signal(this.data, "close");
      if (this.widget) this.widget.close();
      CodeMirror.signal(this.cm, "endCompletion", this.cm);
    },

    active: function() {
      return this.cm.state.completionActive == this;
    },

    pick: function(data, i) {
      var completion = data.list[i], self = this;
      this.cm.operation(function() {
        if (completion.hint)
          completion.hint(self.cm, data, completion);
        else
          self.cm.replaceRange(getText(completion), completion.from || data.from,
                               completion.to || data.to, "complete");
        CodeMirror.signal(data, "pick", completion);
        self.cm.scrollIntoView();
      });
      if (this.options.closeOnPick) {
        this.close();
      }
    },

    cursorActivity: function() {
      if (this.debounce) {
        cancelAnimationFrame(this.debounce);
        this.debounce = 0;
      }

      var identStart = this.startPos;
      if(this.data) {
        identStart = this.data.from;
      }

      var pos = this.cm.getCursor(), line = this.cm.getLine(pos.line);
      if (pos.line != this.startPos.line || line.length - pos.ch != this.startLen - this.startPos.ch ||
          pos.ch < identStart.ch || this.cm.somethingSelected() ||
          (!pos.ch || this.options.closeCharacters.test(line.charAt(pos.ch - 1)))) {
        this.close();
      } else {
        var self = this;
        this.debounce = requestAnimationFrame(function() {self.update();});
        if (this.widget) this.widget.disable();
      }
    },

    update: function(first) {
      if (this.tick == null) return
      var self = this, myTick = ++this.tick
      fetchHints(this.options.hint, this.cm, this.options, function(data) {
        if (self.tick == myTick) self.finishUpdate(data, first)
      })
    },

    finishUpdate: function(data, first) {
      if (this.data) CodeMirror.signal(this.data, "update");

      var picked = (this.widget && this.widget.picked) || (first && this.options.completeSingle);
      if (this.widget) this.widget.close();

      this.data = data;

      if (data && data.list.length) {
        if (picked && data.list.length == 1) {
          this.pick(data, 0);
        } else {
          this.widget = new Widget(this, data);
          CodeMirror.signal(data, "shown");
        }
      }
    }
  };

  function parseOptions(cm, pos, options) {
    var editor = cm.options.hintOptions;
    var out = {};
    for (var prop in defaultOptions) out[prop] = defaultOptions[prop];
    if (editor) for (var prop in editor)
      if (editor[prop] !== undefined) out[prop] = editor[prop];
    if (options) for (var prop in options)
      if (options[prop] !== undefined) out[prop] = options[prop];
    if (out.hint.resolve) out.hint = out.hint.resolve(cm, pos)
    return out;
  }

  function getText(completion) {
    if (typeof completion == "string") return completion;
    else return completion.text;
  }

  function buildKeyMap(completion, handle) {
    var baseMap = {
      Up: function() {handle.moveFocus(-1);},
      Down: function() {handle.moveFocus(1);},
      PageUp: function() {handle.moveFocus(-handle.menuSize() + 1, true);},
      PageDown: function() {handle.moveFocus(handle.menuSize() - 1, true);},
      Home: function() {handle.setFocus(0);},
      End: function() {handle.setFocus(handle.length - 1);},
      Enter: handle.pick,
      Tab: handle.pick,
      Esc: handle.close
    };

    var mac = /Mac/.test(navigator.platform);

    if (mac) {
      baseMap["Ctrl-P"] = function() {handle.moveFocus(-1);};
      baseMap["Ctrl-N"] = function() {handle.moveFocus(1);};
    }

    var custom = completion.options.customKeys;
    var ourMap = custom ? {} : baseMap;
    function addBinding(key, val) {
      var bound;
      if (typeof val != "string")
        bound = function(cm) { return val(cm, handle); };
      // This mechanism is deprecated
      else if (baseMap.hasOwnProperty(val))
        bound = baseMap[val];
      else
        bound = val;
      ourMap[key] = bound;
    }
    if (custom)
      for (var key in custom) if (custom.hasOwnProperty(key))
        addBinding(key, custom[key]);
    var extra = completion.options.extraKeys;
    if (extra)
      for (var key in extra) if (extra.hasOwnProperty(key))
        addBinding(key, extra[key]);
    return ourMap;
  }

  function getHintElement(hintsElement, el) {
    while (el && el != hintsElement) {
      if (el.nodeName.toUpperCase() === "LI" && el.parentNode == hintsElement) return el;
      el = el.parentNode;
    }
  }

  function Widget(completion, data) {
    this.id = "cm-complete-" + Math.floor(Math.random(1e6))
    this.completion = completion;
    this.data = data;
    this.picked = false;
    var widget = this, cm = completion.cm;
    var ownerDocument = cm.getInputField().ownerDocument;
    var parentWindow = ownerDocument.defaultView || ownerDocument.parentWindow;

    var hints = this.hints = ownerDocument.createElement("ul");
    hints.setAttribute("role", "listbox")
    hints.setAttribute("aria-expanded", "true")
    hints.id = this.id
    var theme = completion.cm.options.theme;
    hints.className = "CodeMirror-hints " + theme;
    this.selectedHint = data.selectedHint || 0;

    var completions = data.list;
    for (var i = 0; i < completions.length; ++i) {
      var elt = hints.appendChild(ownerDocument.createElement("li")), cur = completions[i];
      var className = HINT_ELEMENT_CLASS + (i != this.selectedHint ? "" : " " + ACTIVE_HINT_ELEMENT_CLASS);
      if (cur.className != null) className = cur.className + " " + className;
      elt.className = className;
      if (i == this.selectedHint) elt.setAttribute("aria-selected", "true")
      elt.id = this.id + "-" + i
      elt.setAttribute("role", "option")
      if (cur.render) cur.render(elt, data, cur);
      else elt.appendChild(ownerDocument.createTextNode(cur.displayText || getText(cur)));
      elt.hintId = i;
    }

    var container = completion.options.container || ownerDocument.body;
    var pos = cm.cursorCoords(completion.options.alignWithWord ? data.from : null);
    var left = pos.left, top = pos.bottom, below = true;
    var offsetLeft = 0, offsetTop = 0;
    if (container !== ownerDocument.body) {
      // We offset the cursor position because left and top are relative to the offsetParent's top left corner.
      var isContainerPositioned = ['absolute', 'relative', 'fixed'].indexOf(parentWindow.getComputedStyle(container).position) !== -1;
      var offsetParent = isContainerPositioned ? container : container.offsetParent;
      var offsetParentPosition = offsetParent.getBoundingClientRect();
      var bodyPosition = ownerDocument.body.getBoundingClientRect();
      offsetLeft = (offsetParentPosition.left - bodyPosition.left - offsetParent.scrollLeft);
      offsetTop = (offsetParentPosition.top - bodyPosition.top - offsetParent.scrollTop);
    }
    hints.style.left = (left - offsetLeft) + "px";
    hints.style.top = (top - offsetTop) + "px";

    // If we're at the edge of the screen, then we want the menu to appear on the left of the cursor.
    var winW = parentWindow.innerWidth || Math.max(ownerDocument.body.offsetWidth, ownerDocument.documentElement.offsetWidth);
    var winH = parentWindow.innerHeight || Math.max(ownerDocument.body.offsetHeight, ownerDocument.documentElement.offsetHeight);
    container.appendChild(hints);
    cm.getInputField().setAttribute("aria-autocomplete", "list")
    cm.getInputField().setAttribute("aria-owns", this.id)
    cm.getInputField().setAttribute("aria-activedescendant", this.id + "-" + this.selectedHint)

    var box = completion.options.moveOnOverlap ? hints.getBoundingClientRect() : new DOMRect();
    var scrolls = completion.options.paddingForScrollbar ? hints.scrollHeight > hints.clientHeight + 1 : false;

    // Compute in the timeout to avoid reflow on init
    var startScroll;
    setTimeout(function() { startScroll = cm.getScrollInfo(); });

    var overlapY = box.bottom - winH;
    if (overlapY > 0) {
      var height = box.bottom - box.top, curTop = pos.top - (pos.bottom - box.top);
      if (curTop - height > 0) { // Fits above cursor
        hints.style.top = (top = pos.top - height - offsetTop) + "px";
        below = false;
      } else if (height > winH) {
        hints.style.height = (winH - 5) + "px";
        hints.style.top = (top = pos.bottom - box.top - offsetTop) + "px";
        var cursor = cm.getCursor();
        if (data.from.ch != cursor.ch) {
          pos = cm.cursorCoords(cursor);
          hints.style.left = (left = pos.left - offsetLeft) + "px";
          box = hints.getBoundingClientRect();
        }
      }
    }
    var overlapX = box.right - winW;
    if (scrolls) overlapX += cm.display.nativeBarWidth;
    if (overlapX > 0) {
      if (box.right - box.left > winW) {
        hints.style.width = (winW - 5) + "px";
        overlapX -= (box.right - box.left) - winW;
      }
      hints.style.left = (left = pos.left - overlapX - offsetLeft) + "px";
    }
    if (scrolls) for (var node = hints.firstChild; node; node = node.nextSibling)
      node.style.paddingRight = cm.display.nativeBarWidth + "px"

    cm.addKeyMap(this.keyMap = buildKeyMap(completion, {
      moveFocus: function(n, avoidWrap) { widget.changeActive(widget.selectedHint + n, avoidWrap); },
      setFocus: function(n) { widget.changeActive(n); },
      menuSize: function() { return widget.screenAmount(); },
      length: completions.length,
      close: function() { completion.close(); },
      pick: function() { widget.pick(); },
      data: data
    }));

    if (completion.options.closeOnUnfocus) {
      var closingOnBlur;
      cm.on("blur", this.onBlur = function() { closingOnBlur = setTimeout(function() { completion.close(); }, 100); });
      cm.on("focus", this.onFocus = function() { clearTimeout(closingOnBlur); });
    }

    cm.on("scroll", this.onScroll = function() {
      var curScroll = cm.getScrollInfo(), editor = cm.getWrapperElement().getBoundingClientRect();
      if (!startScroll) startScroll = cm.getScrollInfo();
      var newTop = top + startScroll.top - curScroll.top;
      var point = newTop - (parentWindow.pageYOffset || (ownerDocument.documentElement || ownerDocument.body).scrollTop);
      if (!below) point += hints.offsetHeight;
      if (point <= editor.top || point >= editor.bottom) return completion.close();
      hints.style.top = newTop + "px";
      hints.style.left = (left + startScroll.left - curScroll.left) + "px";
    });

    CodeMirror.on(hints, "dblclick", function(e) {
      var t = getHintElement(hints, e.target || e.srcElement);
      if (t && t.hintId != null) {widget.changeActive(t.hintId); widget.pick();}
    });

    CodeMirror.on(hints, "click", function(e) {
      var t = getHintElement(hints, e.target || e.srcElement);
      if (t && t.hintId != null) {
        widget.changeActive(t.hintId);
        if (completion.options.completeOnSingleClick) widget.pick();
      }
    });

    CodeMirror.on(hints, "mousedown", function() {
      setTimeout(function(){cm.focus();}, 20);
    });

    // The first hint doesn't need to be scrolled to on init
    var selectedHintRange = this.getSelectedHintRange();
    if (selectedHintRange.from !== 0 || selectedHintRange.to !== 0) {
      this.scrollToActive();
    }

    CodeMirror.signal(data, "select", completions[this.selectedHint], hints.childNodes[this.selectedHint]);
    return true;
  }

  Widget.prototype = {
    close: function() {
      if (this.completion.widget != this) return;
      this.completion.widget = null;
      if (this.hints.parentNode) this.hints.parentNode.removeChild(this.hints);
      this.completion.cm.removeKeyMap(this.keyMap);
      var input = this.completion.cm.getInputField()
      input.removeAttribute("aria-activedescendant")
      input.removeAttribute("aria-owns")

      var cm = this.completion.cm;
      if (this.completion.options.closeOnUnfocus) {
        cm.off("blur", this.onBlur);
        cm.off("focus", this.onFocus);
      }
      cm.off("scroll", this.onScroll);
    },

    disable: function() {
      this.completion.cm.removeKeyMap(this.keyMap);
      var widget = this;
      this.keyMap = {Enter: function() { widget.picked = true; }};
      this.completion.cm.addKeyMap(this.keyMap);
    },

    pick: function() {
      this.completion.pick(this.data, this.selectedHint);
    },

    changeActive: function(i, avoidWrap) {
      if (i >= this.data.list.length)
        i = avoidWrap ? this.data.list.length - 1 : 0;
      else if (i < 0)
        i = avoidWrap ? 0  : this.data.list.length - 1;
      if (this.selectedHint == i) return;
      var node = this.hints.childNodes[this.selectedHint];
      if (node) {
        node.className = node.className.replace(" " + ACTIVE_HINT_ELEMENT_CLASS, "");
        node.removeAttribute("aria-selected")
      }
      node = this.hints.childNodes[this.selectedHint = i];
      node.className += " " + ACTIVE_HINT_ELEMENT_CLASS;
      node.setAttribute("aria-selected", "true")
      this.completion.cm.getInputField().setAttribute("aria-activedescendant", node.id)
      this.scrollToActive()
      CodeMirror.signal(this.data, "select", this.data.list[this.selectedHint], node);
    },

    scrollToActive: function() {
      var selectedHintRange = this.getSelectedHintRange();
      var node1 = this.hints.childNodes[selectedHintRange.from];
      var node2 = this.hints.childNodes[selectedHintRange.to];
      var firstNode = this.hints.firstChild;
      if (node1.offsetTop < this.hints.scrollTop)
        this.hints.scrollTop = node1.offsetTop - firstNode.offsetTop;
      else if (node2.offsetTop + node2.offsetHeight > this.hints.scrollTop + this.hints.clientHeight)
        this.hints.scrollTop = node2.offsetTop + node2.offsetHeight - this.hints.clientHeight + firstNode.offsetTop;
    },

    screenAmount: function() {
      return Math.floor(this.hints.clientHeight / this.hints.firstChild.offsetHeight) || 1;
    },

    getSelectedHintRange: function() {
      var margin = this.completion.options.scrollMargin || 0;
      return {
        from: Math.max(0, this.selectedHint - margin),
        to: Math.min(this.data.list.length - 1, this.selectedHint + margin),
      };
    }
  };

  function applicableHelpers(cm, helpers) {
    if (!cm.somethingSelected()) return helpers
    var result = []
    for (var i = 0; i < helpers.length; i++)
      if (helpers[i].supportsSelection) result.push(helpers[i])
    return result
  }

  function fetchHints(hint, cm, options, callback) {
    if (hint.async) {
      hint(cm, callback, options)
    } else {
      var result = hint(cm, options)
      if (result && result.then) result.then(callback)
      else callback(result)
    }
  }

  function resolveAutoHints(cm, pos) {
    var helpers = cm.getHelpers(pos, "hint"), words
    if (helpers.length) {
      var resolved = function(cm, callback, options) {
        var app = applicableHelpers(cm, helpers);
        function run(i) {
          if (i == app.length) return callback(null)
          fetchHints(app[i], cm, options, function(result) {
            if (result && result.list.length > 0) callback(result)
            else run(i + 1)
          })
        }
        run(0)
      }
      resolved.async = true
      resolved.supportsSelection = true
      return resolved
    } else if (words = cm.getHelper(cm.getCursor(), "hintWords")) {
      return function(cm) { return CodeMirror.hint.fromList(cm, {words: words}) }
    } else if (CodeMirror.hint.anyword) {
      return function(cm, options) { return CodeMirror.hint.anyword(cm, options) }
    } else {
      return function() {}
    }
  }

  CodeMirror.registerHelper("hint", "auto", {
    resolve: resolveAutoHints
  });

  CodeMirror.registerHelper("hint", "fromList", function(cm, options) {
    var cur = cm.getCursor(), token = cm.getTokenAt(cur)
    var term, from = CodeMirror.Pos(cur.line, token.start), to = cur
    if (token.start < cur.ch && /\w/.test(token.string.charAt(cur.ch - token.start - 1))) {
      term = token.string.substr(0, cur.ch - token.start)
    } else {
      term = ""
      from = cur
    }
    var found = [];
    for (var i = 0; i < options.words.length; i++) {
      var word = options.words[i];
      if (word.slice(0, term.length) == term)
        found.push(word);
    }

    if (found.length) return {list: found, from: from, to: to};
  });

  CodeMirror.commands.autocomplete = CodeMirror.showHint;

  var defaultOptions = {
    hint: CodeMirror.hint.auto,
    completeSingle: true,
    alignWithWord: true,
    closeCharacters: /[\s()\[\]{};:>,]/,
    closeOnPick: true,
    closeOnUnfocus: true,
    updateOnCursorActivity: true,
    completeOnSingleClick: true,
    container: null,
    customKeys: null,
    extraKeys: null,
    paddingForScrollbar: true,
    moveOnOverlap: true,
  };

  CodeMirror.defineOption("hintOptions", null);
});


/***/ }),

/***/ "./node_modules/codemirror/addon/lint/lint.js":
/*!****************************************************!*\
  !*** ./node_modules/codemirror/addon/lint/lint.js ***!
  \****************************************************/
/***/ ((__unused_webpack_module, __unused_webpack_exports, __webpack_require__) => {

// CodeMirror, copyright (c) by Marijn Haverbeke and others
// Distributed under an MIT license: https://codemirror.net/LICENSE

(function(mod) {
  if (true) // CommonJS
    mod(__webpack_require__(/*! ../../lib/codemirror */ "./node_modules/codemirror/lib/codemirror.js"));
  else {}
})(function(CodeMirror) {
  "use strict";
  var GUTTER_ID = "CodeMirror-lint-markers";
  var LINT_LINE_ID = "CodeMirror-lint-line-";

  function showTooltip(cm, e, content) {
    var tt = document.createElement("div");
    tt.className = "CodeMirror-lint-tooltip cm-s-" + cm.options.theme;
    tt.appendChild(content.cloneNode(true));
    if (cm.state.lint.options.selfContain)
      cm.getWrapperElement().appendChild(tt);
    else
      document.body.appendChild(tt);

    function position(e) {
      if (!tt.parentNode) return CodeMirror.off(document, "mousemove", position);
      tt.style.top = Math.max(0, e.clientY - tt.offsetHeight - 5) + "px";
      tt.style.left = (e.clientX + 5) + "px";
    }
    CodeMirror.on(document, "mousemove", position);
    position(e);
    if (tt.style.opacity != null) tt.style.opacity = 1;
    return tt;
  }
  function rm(elt) {
    if (elt.parentNode) elt.parentNode.removeChild(elt);
  }
  function hideTooltip(tt) {
    if (!tt.parentNode) return;
    if (tt.style.opacity == null) rm(tt);
    tt.style.opacity = 0;
    setTimeout(function() { rm(tt); }, 600);
  }

  function showTooltipFor(cm, e, content, node) {
    var tooltip = showTooltip(cm, e, content);
    function hide() {
      CodeMirror.off(node, "mouseout", hide);
      if (tooltip) { hideTooltip(tooltip); tooltip = null; }
    }
    var poll = setInterval(function() {
      if (tooltip) for (var n = node;; n = n.parentNode) {
        if (n && n.nodeType == 11) n = n.host;
        if (n == document.body) return;
        if (!n) { hide(); break; }
      }
      if (!tooltip) return clearInterval(poll);
    }, 400);
    CodeMirror.on(node, "mouseout", hide);
  }

  function LintState(cm, conf, hasGutter) {
    this.marked = [];
    if (conf instanceof Function) conf = {getAnnotations: conf};
    if (!conf || conf === true) conf = {};
    this.options = {};
    this.linterOptions = conf.options || {};
    for (var prop in defaults) this.options[prop] = defaults[prop];
    for (var prop in conf) {
      if (defaults.hasOwnProperty(prop)) {
        if (conf[prop] != null) this.options[prop] = conf[prop];
      } else if (!conf.options) {
        this.linterOptions[prop] = conf[prop];
      }
    }
    this.timeout = null;
    this.hasGutter = hasGutter;
    this.onMouseOver = function(e) { onMouseOver(cm, e); };
    this.waitingFor = 0
  }

  var defaults = {
    highlightLines: false,
    tooltips: true,
    delay: 500,
    lintOnChange: true,
    getAnnotations: null,
    async: false,
    selfContain: null,
    formatAnnotation: null,
    onUpdateLinting: null
  }

  function clearMarks(cm) {
    var state = cm.state.lint;
    if (state.hasGutter) cm.clearGutter(GUTTER_ID);
    if (state.options.highlightLines) clearErrorLines(cm);
    for (var i = 0; i < state.marked.length; ++i)
      state.marked[i].clear();
    state.marked.length = 0;
  }

  function clearErrorLines(cm) {
    cm.eachLine(function(line) {
      var has = line.wrapClass && /\bCodeMirror-lint-line-\w+\b/.exec(line.wrapClass);
      if (has) cm.removeLineClass(line, "wrap", has[0]);
    })
  }

  function makeMarker(cm, labels, severity, multiple, tooltips) {
    var marker = document.createElement("div"), inner = marker;
    marker.className = "CodeMirror-lint-marker CodeMirror-lint-marker-" + severity;
    if (multiple) {
      inner = marker.appendChild(document.createElement("div"));
      inner.className = "CodeMirror-lint-marker CodeMirror-lint-marker-multiple";
    }

    if (tooltips != false) CodeMirror.on(inner, "mouseover", function(e) {
      showTooltipFor(cm, e, labels, inner);
    });

    return marker;
  }

  function getMaxSeverity(a, b) {
    if (a == "error") return a;
    else return b;
  }

  function groupByLine(annotations) {
    var lines = [];
    for (var i = 0; i < annotations.length; ++i) {
      var ann = annotations[i], line = ann.from.line;
      (lines[line] || (lines[line] = [])).push(ann);
    }
    return lines;
  }

  function annotationTooltip(ann) {
    var severity = ann.severity;
    if (!severity) severity = "error";
    var tip = document.createElement("div");
    tip.className = "CodeMirror-lint-message CodeMirror-lint-message-" + severity;
    if (typeof ann.messageHTML != 'undefined') {
      tip.innerHTML = ann.messageHTML;
    } else {
      tip.appendChild(document.createTextNode(ann.message));
    }
    return tip;
  }

  function lintAsync(cm, getAnnotations) {
    var state = cm.state.lint
    var id = ++state.waitingFor
    function abort() {
      id = -1
      cm.off("change", abort)
    }
    cm.on("change", abort)
    getAnnotations(cm.getValue(), function(annotations, arg2) {
      cm.off("change", abort)
      if (state.waitingFor != id) return
      if (arg2 && annotations instanceof CodeMirror) annotations = arg2
      cm.operation(function() {updateLinting(cm, annotations)})
    }, state.linterOptions, cm);
  }

  function startLinting(cm) {
    var state = cm.state.lint;
    if (!state) return;
    var options = state.options;
    /*
     * Passing rules in `options` property prevents JSHint (and other linters) from complaining
     * about unrecognized rules like `onUpdateLinting`, `delay`, `lintOnChange`, etc.
     */
    var getAnnotations = options.getAnnotations || cm.getHelper(CodeMirror.Pos(0, 0), "lint");
    if (!getAnnotations) return;
    if (options.async || getAnnotations.async) {
      lintAsync(cm, getAnnotations)
    } else {
      var annotations = getAnnotations(cm.getValue(), state.linterOptions, cm);
      if (!annotations) return;
      if (annotations.then) annotations.then(function(issues) {
        cm.operation(function() {updateLinting(cm, issues)})
      });
      else cm.operation(function() {updateLinting(cm, annotations)})
    }
  }

  function updateLinting(cm, annotationsNotSorted) {
    var state = cm.state.lint;
    if (!state) return;
    var options = state.options;
    clearMarks(cm);

    var annotations = groupByLine(annotationsNotSorted);

    for (var line = 0; line < annotations.length; ++line) {
      var anns = annotations[line];
      if (!anns) continue;

      // filter out duplicate messages
      var message = [];
      anns = anns.filter(function(item) { return message.indexOf(item.message) > -1 ? false : message.push(item.message) });

      var maxSeverity = null;
      var tipLabel = state.hasGutter && document.createDocumentFragment();

      for (var i = 0; i < anns.length; ++i) {
        var ann = anns[i];
        var severity = ann.severity;
        if (!severity) severity = "error";
        maxSeverity = getMaxSeverity(maxSeverity, severity);

        if (options.formatAnnotation) ann = options.formatAnnotation(ann);
        if (state.hasGutter) tipLabel.appendChild(annotationTooltip(ann));

        if (ann.to) state.marked.push(cm.markText(ann.from, ann.to, {
          className: "CodeMirror-lint-mark CodeMirror-lint-mark-" + severity,
          __annotation: ann
        }));
      }
      // use original annotations[line] to show multiple messages
      if (state.hasGutter)
        cm.setGutterMarker(line, GUTTER_ID, makeMarker(cm, tipLabel, maxSeverity, annotations[line].length > 1,
                                                       options.tooltips));

      if (options.highlightLines)
        cm.addLineClass(line, "wrap", LINT_LINE_ID + maxSeverity);
    }
    if (options.onUpdateLinting) options.onUpdateLinting(annotationsNotSorted, annotations, cm);
  }

  function onChange(cm) {
    var state = cm.state.lint;
    if (!state) return;
    clearTimeout(state.timeout);
    state.timeout = setTimeout(function(){startLinting(cm);}, state.options.delay);
  }

  function popupTooltips(cm, annotations, e) {
    var target = e.target || e.srcElement;
    var tooltip = document.createDocumentFragment();
    for (var i = 0; i < annotations.length; i++) {
      var ann = annotations[i];
      tooltip.appendChild(annotationTooltip(ann));
    }
    showTooltipFor(cm, e, tooltip, target);
  }

  function onMouseOver(cm, e) {
    var target = e.target || e.srcElement;
    if (!/\bCodeMirror-lint-mark-/.test(target.className)) return;
    var box = target.getBoundingClientRect(), x = (box.left + box.right) / 2, y = (box.top + box.bottom) / 2;
    var spans = cm.findMarksAt(cm.coordsChar({left: x, top: y}, "client"));

    var annotations = [];
    for (var i = 0; i < spans.length; ++i) {
      var ann = spans[i].__annotation;
      if (ann) annotations.push(ann);
    }
    if (annotations.length) popupTooltips(cm, annotations, e);
  }

  CodeMirror.defineOption("lint", false, function(cm, val, old) {
    if (old && old != CodeMirror.Init) {
      clearMarks(cm);
      if (cm.state.lint.options.lintOnChange !== false)
        cm.off("change", onChange);
      CodeMirror.off(cm.getWrapperElement(), "mouseover", cm.state.lint.onMouseOver);
      clearTimeout(cm.state.lint.timeout);
      delete cm.state.lint;
    }

    if (val) {
      var gutters = cm.getOption("gutters"), hasLintGutter = false;
      for (var i = 0; i < gutters.length; ++i) if (gutters[i] == GUTTER_ID) hasLintGutter = true;
      var state = cm.state.lint = new LintState(cm, val, hasLintGutter);
      if (state.options.lintOnChange)
        cm.on("change", onChange);
      if (state.options.tooltips != false && state.options.tooltips != "gutter")
        CodeMirror.on(cm.getWrapperElement(), "mouseover", state.onMouseOver);

      startLinting(cm);
    }
  });

  CodeMirror.defineExtension("performLint", function() {
    startLinting(this);
  });
});


/***/ }),

/***/ "./node_modules/codemirror/addon/scroll/simplescrollbars.js":
/*!******************************************************************!*\
  !*** ./node_modules/codemirror/addon/scroll/simplescrollbars.js ***!
  \******************************************************************/
/***/ ((__unused_webpack_module, __unused_webpack_exports, __webpack_require__) => {

// CodeMirror, copyright (c) by Marijn Haverbeke and others
// Distributed under an MIT license: https://codemirror.net/LICENSE

(function(mod) {
  if (true) // CommonJS
    mod(__webpack_require__(/*! ../../lib/codemirror */ "./node_modules/codemirror/lib/codemirror.js"));
  else {}
})(function(CodeMirror) {
  "use strict";

  function Bar(cls, orientation, scroll) {
    this.orientation = orientation;
    this.scroll = scroll;
    this.screen = this.total = this.size = 1;
    this.pos = 0;

    this.node = document.createElement("div");
    this.node.className = cls + "-" + orientation;
    this.inner = this.node.appendChild(document.createElement("div"));

    var self = this;
    CodeMirror.on(this.inner, "mousedown", function(e) {
      if (e.which != 1) return;
      CodeMirror.e_preventDefault(e);
      var axis = self.orientation == "horizontal" ? "pageX" : "pageY";
      var start = e[axis], startpos = self.pos;
      function done() {
        CodeMirror.off(document, "mousemove", move);
        CodeMirror.off(document, "mouseup", done);
      }
      function move(e) {
        if (e.which != 1) return done();
        self.moveTo(startpos + (e[axis] - start) * (self.total / self.size));
      }
      CodeMirror.on(document, "mousemove", move);
      CodeMirror.on(document, "mouseup", done);
    });

    CodeMirror.on(this.node, "click", function(e) {
      CodeMirror.e_preventDefault(e);
      var innerBox = self.inner.getBoundingClientRect(), where;
      if (self.orientation == "horizontal")
        where = e.clientX < innerBox.left ? -1 : e.clientX > innerBox.right ? 1 : 0;
      else
        where = e.clientY < innerBox.top ? -1 : e.clientY > innerBox.bottom ? 1 : 0;
      self.moveTo(self.pos + where * self.screen);
    });

    function onWheel(e) {
      var moved = CodeMirror.wheelEventPixels(e)[self.orientation == "horizontal" ? "x" : "y"];
      var oldPos = self.pos;
      self.moveTo(self.pos + moved);
      if (self.pos != oldPos) CodeMirror.e_preventDefault(e);
    }
    CodeMirror.on(this.node, "mousewheel", onWheel);
    CodeMirror.on(this.node, "DOMMouseScroll", onWheel);
  }

  Bar.prototype.setPos = function(pos, force) {
    if (pos < 0) pos = 0;
    if (pos > this.total - this.screen) pos = this.total - this.screen;
    if (!force && pos == this.pos) return false;
    this.pos = pos;
    this.inner.style[this.orientation == "horizontal" ? "left" : "top"] =
      (pos * (this.size / this.total)) + "px";
    return true
  };

  Bar.prototype.moveTo = function(pos) {
    if (this.setPos(pos)) this.scroll(pos, this.orientation);
  }

  var minButtonSize = 10;

  Bar.prototype.update = function(scrollSize, clientSize, barSize) {
    var sizeChanged = this.screen != clientSize || this.total != scrollSize || this.size != barSize
    if (sizeChanged) {
      this.screen = clientSize;
      this.total = scrollSize;
      this.size = barSize;
    }

    var buttonSize = this.screen * (this.size / this.total);
    if (buttonSize < minButtonSize) {
      this.size -= minButtonSize - buttonSize;
      buttonSize = minButtonSize;
    }
    this.inner.style[this.orientation == "horizontal" ? "width" : "height"] =
      buttonSize + "px";
    this.setPos(this.pos, sizeChanged);
  };

  function SimpleScrollbars(cls, place, scroll) {
    this.addClass = cls;
    this.horiz = new Bar(cls, "horizontal", scroll);
    place(this.horiz.node);
    this.vert = new Bar(cls, "vertical", scroll);
    place(this.vert.node);
    this.width = null;
  }

  SimpleScrollbars.prototype.update = function(measure) {
    if (this.width == null) {
      var style = window.getComputedStyle ? window.getComputedStyle(this.horiz.node) : this.horiz.node.currentStyle;
      if (style) this.width = parseInt(style.height);
    }
    var width = this.width || 0;

    var needsH = measure.scrollWidth > measure.clientWidth + 1;
    var needsV = measure.scrollHeight > measure.clientHeight + 1;
    this.vert.node.style.display = needsV ? "block" : "none";
    this.horiz.node.style.display = needsH ? "block" : "none";

    if (needsV) {
      this.vert.update(measure.scrollHeight, measure.clientHeight,
                       measure.viewHeight - (needsH ? width : 0));
      this.vert.node.style.bottom = needsH ? width + "px" : "0";
    }
    if (needsH) {
      this.horiz.update(measure.scrollWidth, measure.clientWidth,
                        measure.viewWidth - (needsV ? width : 0) - measure.barLeft);
      this.horiz.node.style.right = needsV ? width + "px" : "0";
      this.horiz.node.style.left = measure.barLeft + "px";
    }

    return {right: needsV ? width : 0, bottom: needsH ? width : 0};
  };

  SimpleScrollbars.prototype.setScrollTop = function(pos) {
    this.vert.setPos(pos);
  };

  SimpleScrollbars.prototype.setScrollLeft = function(pos) {
    this.horiz.setPos(pos);
  };

  SimpleScrollbars.prototype.clear = function() {
    var parent = this.horiz.node.parentNode;
    parent.removeChild(this.horiz.node);
    parent.removeChild(this.vert.node);
  };

  CodeMirror.scrollbarModel.simple = function(place, scroll) {
    return new SimpleScrollbars("CodeMirror-simplescroll", place, scroll);
  };
  CodeMirror.scrollbarModel.overlay = function(place, scroll) {
    return new SimpleScrollbars("CodeMirror-overlayscroll", place, scroll);
  };
});


/***/ }),

/***/ "./node_modules/codemirror/lib/codemirror.js":
/*!***************************************************!*\
  !*** ./node_modules/codemirror/lib/codemirror.js ***!
  \***************************************************/
/***/ (function(module) {

// CodeMirror, copyright (c) by Marijn Haverbeke and others
// Distributed under an MIT license: https://codemirror.net/LICENSE

// This is CodeMirror (https://codemirror.net), a code editor
// implemented in JavaScript on top of the browser's DOM.
//
// You can find some technical background for some of the code below
// at http://marijnhaverbeke.nl/blog/#cm-internals .

(function (global, factory) {
   true ? module.exports = factory() :
  0;
}(this, (function () { 'use strict';

  // Kludges for bugs and behavior differences that can't be feature
  // detected are enabled based on userAgent etc sniffing.
  var userAgent = navigator.userAgent;
  var platform = navigator.platform;

  var gecko = /gecko\/\d/i.test(userAgent);
  var ie_upto10 = /MSIE \d/.test(userAgent);
  var ie_11up = /Trident\/(?:[7-9]|\d{2,})\..*rv:(\d+)/.exec(userAgent);
  var edge = /Edge\/(\d+)/.exec(userAgent);
  var ie = ie_upto10 || ie_11up || edge;
  var ie_version = ie && (ie_upto10 ? document.documentMode || 6 : +(edge || ie_11up)[1]);
  var webkit = !edge && /WebKit\//.test(userAgent);
  var qtwebkit = webkit && /Qt\/\d+\.\d+/.test(userAgent);
  var chrome = !edge && /Chrome\//.test(userAgent);
  var presto = /Opera\//.test(userAgent);
  var safari = /Apple Computer/.test(navigator.vendor);
  var mac_geMountainLion = /Mac OS X 1\d\D([8-9]|\d\d)\D/.test(userAgent);
  var phantom = /PhantomJS/.test(userAgent);

  var ios = safari && (/Mobile\/\w+/.test(userAgent) || navigator.maxTouchPoints > 2);
  var android = /Android/.test(userAgent);
  // This is woefully incomplete. Suggestions for alternative methods welcome.
  var mobile = ios || android || /webOS|BlackBerry|Opera Mini|Opera Mobi|IEMobile/i.test(userAgent);
  var mac = ios || /Mac/.test(platform);
  var chromeOS = /\bCrOS\b/.test(userAgent);
  var windows = /win/i.test(platform);

  var presto_version = presto && userAgent.match(/Version\/(\d*\.\d*)/);
  if (presto_version) { presto_version = Number(presto_version[1]); }
  if (presto_version && presto_version >= 15) { presto = false; webkit = true; }
  // Some browsers use the wrong event properties to signal cmd/ctrl on OS X
  var flipCtrlCmd = mac && (qtwebkit || presto && (presto_version == null || presto_version < 12.11));
  var captureRightClick = gecko || (ie && ie_version >= 9);

  function classTest(cls) { return new RegExp("(^|\\s)" + cls + "(?:$|\\s)\\s*") }

  var rmClass = function(node, cls) {
    var current = node.className;
    var match = classTest(cls).exec(current);
    if (match) {
      var after = current.slice(match.index + match[0].length);
      node.className = current.slice(0, match.index) + (after ? match[1] + after : "");
    }
  };

  function removeChildren(e) {
    for (var count = e.childNodes.length; count > 0; --count)
      { e.removeChild(e.firstChild); }
    return e
  }

  function removeChildrenAndAdd(parent, e) {
    return removeChildren(parent).appendChild(e)
  }

  function elt(tag, content, className, style) {
    var e = document.createElement(tag);
    if (className) { e.className = className; }
    if (style) { e.style.cssText = style; }
    if (typeof content == "string") { e.appendChild(document.createTextNode(content)); }
    else if (content) { for (var i = 0; i < content.length; ++i) { e.appendChild(content[i]); } }
    return e
  }
  // wrapper for elt, which removes the elt from the accessibility tree
  function eltP(tag, content, className, style) {
    var e = elt(tag, content, className, style);
    e.setAttribute("role", "presentation");
    return e
  }

  var range;
  if (document.createRange) { range = function(node, start, end, endNode) {
    var r = document.createRange();
    r.setEnd(endNode || node, end);
    r.setStart(node, start);
    return r
  }; }
  else { range = function(node, start, end) {
    var r = document.body.createTextRange();
    try { r.moveToElementText(node.parentNode); }
    catch(e) { return r }
    r.collapse(true);
    r.moveEnd("character", end);
    r.moveStart("character", start);
    return r
  }; }

  function contains(parent, child) {
    if (child.nodeType == 3) // Android browser always returns false when child is a textnode
      { child = child.parentNode; }
    if (parent.contains)
      { return parent.contains(child) }
    do {
      if (child.nodeType == 11) { child = child.host; }
      if (child == parent) { return true }
    } while (child = child.parentNode)
  }

  function activeElt() {
    // IE and Edge may throw an "Unspecified Error" when accessing document.activeElement.
    // IE < 10 will throw when accessed while the page is loading or in an iframe.
    // IE > 9 and Edge will throw when accessed in an iframe if document.body is unavailable.
    var activeElement;
    try {
      activeElement = document.activeElement;
    } catch(e) {
      activeElement = document.body || null;
    }
    while (activeElement && activeElement.shadowRoot && activeElement.shadowRoot.activeElement)
      { activeElement = activeElement.shadowRoot.activeElement; }
    return activeElement
  }

  function addClass(node, cls) {
    var current = node.className;
    if (!classTest(cls).test(current)) { node.className += (current ? " " : "") + cls; }
  }
  function joinClasses(a, b) {
    var as = a.split(" ");
    for (var i = 0; i < as.length; i++)
      { if (as[i] && !classTest(as[i]).test(b)) { b += " " + as[i]; } }
    return b
  }

  var selectInput = function(node) { node.select(); };
  if (ios) // Mobile Safari apparently has a bug where select() is broken.
    { selectInput = function(node) { node.selectionStart = 0; node.selectionEnd = node.value.length; }; }
  else if (ie) // Suppress mysterious IE10 errors
    { selectInput = function(node) { try { node.select(); } catch(_e) {} }; }

  function bind(f) {
    var args = Array.prototype.slice.call(arguments, 1);
    return function(){return f.apply(null, args)}
  }

  function copyObj(obj, target, overwrite) {
    if (!target) { target = {}; }
    for (var prop in obj)
      { if (obj.hasOwnProperty(prop) && (overwrite !== false || !target.hasOwnProperty(prop)))
        { target[prop] = obj[prop]; } }
    return target
  }

  // Counts the column offset in a string, taking tabs into account.
  // Used mostly to find indentation.
  function countColumn(string, end, tabSize, startIndex, startValue) {
    if (end == null) {
      end = string.search(/[^\s\u00a0]/);
      if (end == -1) { end = string.length; }
    }
    for (var i = startIndex || 0, n = startValue || 0;;) {
      var nextTab = string.indexOf("\t", i);
      if (nextTab < 0 || nextTab >= end)
        { return n + (end - i) }
      n += nextTab - i;
      n += tabSize - (n % tabSize);
      i = nextTab + 1;
    }
  }

  var Delayed = function() {
    this.id = null;
    this.f = null;
    this.time = 0;
    this.handler = bind(this.onTimeout, this);
  };
  Delayed.prototype.onTimeout = function (self) {
    self.id = 0;
    if (self.time <= +new Date) {
      self.f();
    } else {
      setTimeout(self.handler, self.time - +new Date);
    }
  };
  Delayed.prototype.set = function (ms, f) {
    this.f = f;
    var time = +new Date + ms;
    if (!this.id || time < this.time) {
      clearTimeout(this.id);
      this.id = setTimeout(this.handler, ms);
      this.time = time;
    }
  };

  function indexOf(array, elt) {
    for (var i = 0; i < array.length; ++i)
      { if (array[i] == elt) { return i } }
    return -1
  }

  // Number of pixels added to scroller and sizer to hide scrollbar
  var scrollerGap = 50;

  // Returned or thrown by various protocols to signal 'I'm not
  // handling this'.
  var Pass = {toString: function(){return "CodeMirror.Pass"}};

  // Reused option objects for setSelection & friends
  var sel_dontScroll = {scroll: false}, sel_mouse = {origin: "*mouse"}, sel_move = {origin: "+move"};

  // The inverse of countColumn -- find the offset that corresponds to
  // a particular column.
  function findColumn(string, goal, tabSize) {
    for (var pos = 0, col = 0;;) {
      var nextTab = string.indexOf("\t", pos);
      if (nextTab == -1) { nextTab = string.length; }
      var skipped = nextTab - pos;
      if (nextTab == string.length || col + skipped >= goal)
        { return pos + Math.min(skipped, goal - col) }
      col += nextTab - pos;
      col += tabSize - (col % tabSize);
      pos = nextTab + 1;
      if (col >= goal) { return pos }
    }
  }

  var spaceStrs = [""];
  function spaceStr(n) {
    while (spaceStrs.length <= n)
      { spaceStrs.push(lst(spaceStrs) + " "); }
    return spaceStrs[n]
  }

  function lst(arr) { return arr[arr.length-1] }

  function map(array, f) {
    var out = [];
    for (var i = 0; i < array.length; i++) { out[i] = f(array[i], i); }
    return out
  }

  function insertSorted(array, value, score) {
    var pos = 0, priority = score(value);
    while (pos < array.length && score(array[pos]) <= priority) { pos++; }
    array.splice(pos, 0, value);
  }

  function nothing() {}

  function createObj(base, props) {
    var inst;
    if (Object.create) {
      inst = Object.create(base);
    } else {
      nothing.prototype = base;
      inst = new nothing();
    }
    if (props) { copyObj(props, inst); }
    return inst
  }

  var nonASCIISingleCaseWordChar = /[\u00df\u0587\u0590-\u05f4\u0600-\u06ff\u3040-\u309f\u30a0-\u30ff\u3400-\u4db5\u4e00-\u9fcc\uac00-\ud7af]/;
  function isWordCharBasic(ch) {
    return /\w/.test(ch) || ch > "\x80" &&
      (ch.toUpperCase() != ch.toLowerCase() || nonASCIISingleCaseWordChar.test(ch))
  }
  function isWordChar(ch, helper) {
    if (!helper) { return isWordCharBasic(ch) }
    if (helper.source.indexOf("\\w") > -1 && isWordCharBasic(ch)) { return true }
    return helper.test(ch)
  }

  function isEmpty(obj) {
    for (var n in obj) { if (obj.hasOwnProperty(n) && obj[n]) { return false } }
    return true
  }

  // Extending unicode characters. A series of a non-extending char +
  // any number of extending chars is treated as a single unit as far
  // as editing and measuring is concerned. This is not fully correct,
  // since some scripts/fonts/browsers also treat other configurations
  // of code points as a group.
  var extendingChars = /[\u0300-\u036f\u0483-\u0489\u0591-\u05bd\u05bf\u05c1\u05c2\u05c4\u05c5\u05c7\u0610-\u061a\u064b-\u065e\u0670\u06d6-\u06dc\u06de-\u06e4\u06e7\u06e8\u06ea-\u06ed\u0711\u0730-\u074a\u07a6-\u07b0\u07eb-\u07f3\u0816-\u0819\u081b-\u0823\u0825-\u0827\u0829-\u082d\u0900-\u0902\u093c\u0941-\u0948\u094d\u0951-\u0955\u0962\u0963\u0981\u09bc\u09be\u09c1-\u09c4\u09cd\u09d7\u09e2\u09e3\u0a01\u0a02\u0a3c\u0a41\u0a42\u0a47\u0a48\u0a4b-\u0a4d\u0a51\u0a70\u0a71\u0a75\u0a81\u0a82\u0abc\u0ac1-\u0ac5\u0ac7\u0ac8\u0acd\u0ae2\u0ae3\u0b01\u0b3c\u0b3e\u0b3f\u0b41-\u0b44\u0b4d\u0b56\u0b57\u0b62\u0b63\u0b82\u0bbe\u0bc0\u0bcd\u0bd7\u0c3e-\u0c40\u0c46-\u0c48\u0c4a-\u0c4d\u0c55\u0c56\u0c62\u0c63\u0cbc\u0cbf\u0cc2\u0cc6\u0ccc\u0ccd\u0cd5\u0cd6\u0ce2\u0ce3\u0d3e\u0d41-\u0d44\u0d4d\u0d57\u0d62\u0d63\u0dca\u0dcf\u0dd2-\u0dd4\u0dd6\u0ddf\u0e31\u0e34-\u0e3a\u0e47-\u0e4e\u0eb1\u0eb4-\u0eb9\u0ebb\u0ebc\u0ec8-\u0ecd\u0f18\u0f19\u0f35\u0f37\u0f39\u0f71-\u0f7e\u0f80-\u0f84\u0f86\u0f87\u0f90-\u0f97\u0f99-\u0fbc\u0fc6\u102d-\u1030\u1032-\u1037\u1039\u103a\u103d\u103e\u1058\u1059\u105e-\u1060\u1071-\u1074\u1082\u1085\u1086\u108d\u109d\u135f\u1712-\u1714\u1732-\u1734\u1752\u1753\u1772\u1773\u17b7-\u17bd\u17c6\u17c9-\u17d3\u17dd\u180b-\u180d\u18a9\u1920-\u1922\u1927\u1928\u1932\u1939-\u193b\u1a17\u1a18\u1a56\u1a58-\u1a5e\u1a60\u1a62\u1a65-\u1a6c\u1a73-\u1a7c\u1a7f\u1b00-\u1b03\u1b34\u1b36-\u1b3a\u1b3c\u1b42\u1b6b-\u1b73\u1b80\u1b81\u1ba2-\u1ba5\u1ba8\u1ba9\u1c2c-\u1c33\u1c36\u1c37\u1cd0-\u1cd2\u1cd4-\u1ce0\u1ce2-\u1ce8\u1ced\u1dc0-\u1de6\u1dfd-\u1dff\u200c\u200d\u20d0-\u20f0\u2cef-\u2cf1\u2de0-\u2dff\u302a-\u302f\u3099\u309a\ua66f-\ua672\ua67c\ua67d\ua6f0\ua6f1\ua802\ua806\ua80b\ua825\ua826\ua8c4\ua8e0-\ua8f1\ua926-\ua92d\ua947-\ua951\ua980-\ua982\ua9b3\ua9b6-\ua9b9\ua9bc\uaa29-\uaa2e\uaa31\uaa32\uaa35\uaa36\uaa43\uaa4c\uaab0\uaab2-\uaab4\uaab7\uaab8\uaabe\uaabf\uaac1\uabe5\uabe8\uabed\udc00-\udfff\ufb1e\ufe00-\ufe0f\ufe20-\ufe26\uff9e\uff9f]/;
  function isExtendingChar(ch) { return ch.charCodeAt(0) >= 768 && extendingChars.test(ch) }

  // Returns a number from the range [`0`; `str.length`] unless `pos` is outside that range.
  function skipExtendingChars(str, pos, dir) {
    while ((dir < 0 ? pos > 0 : pos < str.length) && isExtendingChar(str.charAt(pos))) { pos += dir; }
    return pos
  }

  // Returns the value from the range [`from`; `to`] that satisfies
  // `pred` and is closest to `from`. Assumes that at least `to`
  // satisfies `pred`. Supports `from` being greater than `to`.
  function findFirst(pred, from, to) {
    // At any point we are certain `to` satisfies `pred`, don't know
    // whether `from` does.
    var dir = from > to ? -1 : 1;
    for (;;) {
      if (from == to) { return from }
      var midF = (from + to) / 2, mid = dir < 0 ? Math.ceil(midF) : Math.floor(midF);
      if (mid == from) { return pred(mid) ? from : to }
      if (pred(mid)) { to = mid; }
      else { from = mid + dir; }
    }
  }

  // BIDI HELPERS

  function iterateBidiSections(order, from, to, f) {
    if (!order) { return f(from, to, "ltr", 0) }
    var found = false;
    for (var i = 0; i < order.length; ++i) {
      var part = order[i];
      if (part.from < to && part.to > from || from == to && part.to == from) {
        f(Math.max(part.from, from), Math.min(part.to, to), part.level == 1 ? "rtl" : "ltr", i);
        found = true;
      }
    }
    if (!found) { f(from, to, "ltr"); }
  }

  var bidiOther = null;
  function getBidiPartAt(order, ch, sticky) {
    var found;
    bidiOther = null;
    for (var i = 0; i < order.length; ++i) {
      var cur = order[i];
      if (cur.from < ch && cur.to > ch) { return i }
      if (cur.to == ch) {
        if (cur.from != cur.to && sticky == "before") { found = i; }
        else { bidiOther = i; }
      }
      if (cur.from == ch) {
        if (cur.from != cur.to && sticky != "before") { found = i; }
        else { bidiOther = i; }
      }
    }
    return found != null ? found : bidiOther
  }

  // Bidirectional ordering algorithm
  // See http://unicode.org/reports/tr9/tr9-13.html for the algorithm
  // that this (partially) implements.

  // One-char codes used for character types:
  // L (L):   Left-to-Right
  // R (R):   Right-to-Left
  // r (AL):  Right-to-Left Arabic
  // 1 (EN):  European Number
  // + (ES):  European Number Separator
  // % (ET):  European Number Terminator
  // n (AN):  Arabic Number
  // , (CS):  Common Number Separator
  // m (NSM): Non-Spacing Mark
  // b (BN):  Boundary Neutral
  // s (B):   Paragraph Separator
  // t (S):   Segment Separator
  // w (WS):  Whitespace
  // N (ON):  Other Neutrals

  // Returns null if characters are ordered as they appear
  // (left-to-right), or an array of sections ({from, to, level}
  // objects) in the order in which they occur visually.
  var bidiOrdering = (function() {
    // Character types for codepoints 0 to 0xff
    var lowTypes = "bbbbbbbbbtstwsbbbbbbbbbbbbbbssstwNN%%%NNNNNN,N,N1111111111NNNNNNNLLLLLLLLLLLLLLLLLLLLLLLLLLNNNNNNLLLLLLLLLLLLLLLLLLLLLLLLLLNNNNbbbbbbsbbbbbbbbbbbbbbbbbbbbbbbbbb,N%%%%NNNNLNNNNN%%11NLNNN1LNNNNNLLLLLLLLLLLLLLLLLLLLLLLNLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLN";
    // Character types for codepoints 0x600 to 0x6f9
    var arabicTypes = "nnnnnnNNr%%r,rNNmmmmmmmmmmmrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrmmmmmmmmmmmmmmmmmmmmmnnnnnnnnnn%nnrrrmrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrmmmmmmmnNmmmmmmrrmmNmmmmrr1111111111";
    function charType(code) {
      if (code <= 0xf7) { return lowTypes.charAt(code) }
      else if (0x590 <= code && code <= 0x5f4) { return "R" }
      else if (0x600 <= code && code <= 0x6f9) { return arabicTypes.charAt(code - 0x600) }
      else if (0x6ee <= code && code <= 0x8ac) { return "r" }
      else if (0x2000 <= code && code <= 0x200b) { return "w" }
      else if (code == 0x200c) { return "b" }
      else { return "L" }
    }

    var bidiRE = /[\u0590-\u05f4\u0600-\u06ff\u0700-\u08ac]/;
    var isNeutral = /[stwN]/, isStrong = /[LRr]/, countsAsLeft = /[Lb1n]/, countsAsNum = /[1n]/;

    function BidiSpan(level, from, to) {
      this.level = level;
      this.from = from; this.to = to;
    }

    return function(str, direction) {
      var outerType = direction == "ltr" ? "L" : "R";

      if (str.length == 0 || direction == "ltr" && !bidiRE.test(str)) { return false }
      var len = str.length, types = [];
      for (var i = 0; i < len; ++i)
        { types.push(charType(str.charCodeAt(i))); }

      // W1. Examine each non-spacing mark (NSM) in the level run, and
      // change the type of the NSM to the type of the previous
      // character. If the NSM is at the start of the level run, it will
      // get the type of sor.
      for (var i$1 = 0, prev = outerType; i$1 < len; ++i$1) {
        var type = types[i$1];
        if (type == "m") { types[i$1] = prev; }
        else { prev = type; }
      }

      // W2. Search backwards from each instance of a European number
      // until the first strong type (R, L, AL, or sor) is found. If an
      // AL is found, change the type of the European number to Arabic
      // number.
      // W3. Change all ALs to R.
      for (var i$2 = 0, cur = outerType; i$2 < len; ++i$2) {
        var type$1 = types[i$2];
        if (type$1 == "1" && cur == "r") { types[i$2] = "n"; }
        else if (isStrong.test(type$1)) { cur = type$1; if (type$1 == "r") { types[i$2] = "R"; } }
      }

      // W4. A single European separator between two European numbers
      // changes to a European number. A single common separator between
      // two numbers of the same type changes to that type.
      for (var i$3 = 1, prev$1 = types[0]; i$3 < len - 1; ++i$3) {
        var type$2 = types[i$3];
        if (type$2 == "+" && prev$1 == "1" && types[i$3+1] == "1") { types[i$3] = "1"; }
        else if (type$2 == "," && prev$1 == types[i$3+1] &&
                 (prev$1 == "1" || prev$1 == "n")) { types[i$3] = prev$1; }
        prev$1 = type$2;
      }

      // W5. A sequence of European terminators adjacent to European
      // numbers changes to all European numbers.
      // W6. Otherwise, separators and terminators change to Other
      // Neutral.
      for (var i$4 = 0; i$4 < len; ++i$4) {
        var type$3 = types[i$4];
        if (type$3 == ",") { types[i$4] = "N"; }
        else if (type$3 == "%") {
          var end = (void 0);
          for (end = i$4 + 1; end < len && types[end] == "%"; ++end) {}
          var replace = (i$4 && types[i$4-1] == "!") || (end < len && types[end] == "1") ? "1" : "N";
          for (var j = i$4; j < end; ++j) { types[j] = replace; }
          i$4 = end - 1;
        }
      }

      // W7. Search backwards from each instance of a European number
      // until the first strong type (R, L, or sor) is found. If an L is
      // found, then change the type of the European number to L.
      for (var i$5 = 0, cur$1 = outerType; i$5 < len; ++i$5) {
        var type$4 = types[i$5];
        if (cur$1 == "L" && type$4 == "1") { types[i$5] = "L"; }
        else if (isStrong.test(type$4)) { cur$1 = type$4; }
      }

      // N1. A sequence of neutrals takes the direction of the
      // surrounding strong text if the text on both sides has the same
      // direction. European and Arabic numbers act as if they were R in
      // terms of their influence on neutrals. Start-of-level-run (sor)
      // and end-of-level-run (eor) are used at level run boundaries.
      // N2. Any remaining neutrals take the embedding direction.
      for (var i$6 = 0; i$6 < len; ++i$6) {
        if (isNeutral.test(types[i$6])) {
          var end$1 = (void 0);
          for (end$1 = i$6 + 1; end$1 < len && isNeutral.test(types[end$1]); ++end$1) {}
          var before = (i$6 ? types[i$6-1] : outerType) == "L";
          var after = (end$1 < len ? types[end$1] : outerType) == "L";
          var replace$1 = before == after ? (before ? "L" : "R") : outerType;
          for (var j$1 = i$6; j$1 < end$1; ++j$1) { types[j$1] = replace$1; }
          i$6 = end$1 - 1;
        }
      }

      // Here we depart from the documented algorithm, in order to avoid
      // building up an actual levels array. Since there are only three
      // levels (0, 1, 2) in an implementation that doesn't take
      // explicit embedding into account, we can build up the order on
      // the fly, without following the level-based algorithm.
      var order = [], m;
      for (var i$7 = 0; i$7 < len;) {
        if (countsAsLeft.test(types[i$7])) {
          var start = i$7;
          for (++i$7; i$7 < len && countsAsLeft.test(types[i$7]); ++i$7) {}
          order.push(new BidiSpan(0, start, i$7));
        } else {
          var pos = i$7, at = order.length, isRTL = direction == "rtl" ? 1 : 0;
          for (++i$7; i$7 < len && types[i$7] != "L"; ++i$7) {}
          for (var j$2 = pos; j$2 < i$7;) {
            if (countsAsNum.test(types[j$2])) {
              if (pos < j$2) { order.splice(at, 0, new BidiSpan(1, pos, j$2)); at += isRTL; }
              var nstart = j$2;
              for (++j$2; j$2 < i$7 && countsAsNum.test(types[j$2]); ++j$2) {}
              order.splice(at, 0, new BidiSpan(2, nstart, j$2));
              at += isRTL;
              pos = j$2;
            } else { ++j$2; }
          }
          if (pos < i$7) { order.splice(at, 0, new BidiSpan(1, pos, i$7)); }
        }
      }
      if (direction == "ltr") {
        if (order[0].level == 1 && (m = str.match(/^\s+/))) {
          order[0].from = m[0].length;
          order.unshift(new BidiSpan(0, 0, m[0].length));
        }
        if (lst(order).level == 1 && (m = str.match(/\s+$/))) {
          lst(order).to -= m[0].length;
          order.push(new BidiSpan(0, len - m[0].length, len));
        }
      }

      return direction == "rtl" ? order.reverse() : order
    }
  })();

  // Get the bidi ordering for the given line (and cache it). Returns
  // false for lines that are fully left-to-right, and an array of
  // BidiSpan objects otherwise.
  function getOrder(line, direction) {
    var order = line.order;
    if (order == null) { order = line.order = bidiOrdering(line.text, direction); }
    return order
  }

  // EVENT HANDLING

  // Lightweight event framework. on/off also work on DOM nodes,
  // registering native DOM handlers.

  var noHandlers = [];

  var on = function(emitter, type, f) {
    if (emitter.addEventListener) {
      emitter.addEventListener(type, f, false);
    } else if (emitter.attachEvent) {
      emitter.attachEvent("on" + type, f);
    } else {
      var map = emitter._handlers || (emitter._handlers = {});
      map[type] = (map[type] || noHandlers).concat(f);
    }
  };

  function getHandlers(emitter, type) {
    return emitter._handlers && emitter._handlers[type] || noHandlers
  }

  function off(emitter, type, f) {
    if (emitter.removeEventListener) {
      emitter.removeEventListener(type, f, false);
    } else if (emitter.detachEvent) {
      emitter.detachEvent("on" + type, f);
    } else {
      var map = emitter._handlers, arr = map && map[type];
      if (arr) {
        var index = indexOf(arr, f);
        if (index > -1)
          { map[type] = arr.slice(0, index).concat(arr.slice(index + 1)); }
      }
    }
  }

  function signal(emitter, type /*, values...*/) {
    var handlers = getHandlers(emitter, type);
    if (!handlers.length) { return }
    var args = Array.prototype.slice.call(arguments, 2);
    for (var i = 0; i < handlers.length; ++i) { handlers[i].apply(null, args); }
  }

  // The DOM events that CodeMirror handles can be overridden by
  // registering a (non-DOM) handler on the editor for the event name,
  // and preventDefault-ing the event in that handler.
  function signalDOMEvent(cm, e, override) {
    if (typeof e == "string")
      { e = {type: e, preventDefault: function() { this.defaultPrevented = true; }}; }
    signal(cm, override || e.type, cm, e);
    return e_defaultPrevented(e) || e.codemirrorIgnore
  }

  function signalCursorActivity(cm) {
    var arr = cm._handlers && cm._handlers.cursorActivity;
    if (!arr) { return }
    var set = cm.curOp.cursorActivityHandlers || (cm.curOp.cursorActivityHandlers = []);
    for (var i = 0; i < arr.length; ++i) { if (indexOf(set, arr[i]) == -1)
      { set.push(arr[i]); } }
  }

  function hasHandler(emitter, type) {
    return getHandlers(emitter, type).length > 0
  }

  // Add on and off methods to a constructor's prototype, to make
  // registering events on such objects more convenient.
  function eventMixin(ctor) {
    ctor.prototype.on = function(type, f) {on(this, type, f);};
    ctor.prototype.off = function(type, f) {off(this, type, f);};
  }

  // Due to the fact that we still support jurassic IE versions, some
  // compatibility wrappers are needed.

  function e_preventDefault(e) {
    if (e.preventDefault) { e.preventDefault(); }
    else { e.returnValue = false; }
  }
  function e_stopPropagation(e) {
    if (e.stopPropagation) { e.stopPropagation(); }
    else { e.cancelBubble = true; }
  }
  function e_defaultPrevented(e) {
    return e.defaultPrevented != null ? e.defaultPrevented : e.returnValue == false
  }
  function e_stop(e) {e_preventDefault(e); e_stopPropagation(e);}

  function e_target(e) {return e.target || e.srcElement}
  function e_button(e) {
    var b = e.which;
    if (b == null) {
      if (e.button & 1) { b = 1; }
      else if (e.button & 2) { b = 3; }
      else if (e.button & 4) { b = 2; }
    }
    if (mac && e.ctrlKey && b == 1) { b = 3; }
    return b
  }

  // Detect drag-and-drop
  var dragAndDrop = function() {
    // There is *some* kind of drag-and-drop support in IE6-8, but I
    // couldn't get it to work yet.
    if (ie && ie_version < 9) { return false }
    var div = elt('div');
    return "draggable" in div || "dragDrop" in div
  }();

  var zwspSupported;
  function zeroWidthElement(measure) {
    if (zwspSupported == null) {
      var test = elt("span", "\u200b");
      removeChildrenAndAdd(measure, elt("span", [test, document.createTextNode("x")]));
      if (measure.firstChild.offsetHeight != 0)
        { zwspSupported = test.offsetWidth <= 1 && test.offsetHeight > 2 && !(ie && ie_version < 8); }
    }
    var node = zwspSupported ? elt("span", "\u200b") :
      elt("span", "\u00a0", null, "display: inline-block; width: 1px; margin-right: -1px");
    node.setAttribute("cm-text", "");
    return node
  }

  // Feature-detect IE's crummy client rect reporting for bidi text
  var badBidiRects;
  function hasBadBidiRects(measure) {
    if (badBidiRects != null) { return badBidiRects }
    var txt = removeChildrenAndAdd(measure, document.createTextNode("A\u062eA"));
    var r0 = range(txt, 0, 1).getBoundingClientRect();
    var r1 = range(txt, 1, 2).getBoundingClientRect();
    removeChildren(measure);
    if (!r0 || r0.left == r0.right) { return false } // Safari returns null in some cases (#2780)
    return badBidiRects = (r1.right - r0.right < 3)
  }

  // See if "".split is the broken IE version, if so, provide an
  // alternative way to split lines.
  var splitLinesAuto = "\n\nb".split(/\n/).length != 3 ? function (string) {
    var pos = 0, result = [], l = string.length;
    while (pos <= l) {
      var nl = string.indexOf("\n", pos);
      if (nl == -1) { nl = string.length; }
      var line = string.slice(pos, string.charAt(nl - 1) == "\r" ? nl - 1 : nl);
      var rt = line.indexOf("\r");
      if (rt != -1) {
        result.push(line.slice(0, rt));
        pos += rt + 1;
      } else {
        result.push(line);
        pos = nl + 1;
      }
    }
    return result
  } : function (string) { return string.split(/\r\n?|\n/); };

  var hasSelection = window.getSelection ? function (te) {
    try { return te.selectionStart != te.selectionEnd }
    catch(e) { return false }
  } : function (te) {
    var range;
    try {range = te.ownerDocument.selection.createRange();}
    catch(e) {}
    if (!range || range.parentElement() != te) { return false }
    return range.compareEndPoints("StartToEnd", range) != 0
  };

  var hasCopyEvent = (function () {
    var e = elt("div");
    if ("oncopy" in e) { return true }
    e.setAttribute("oncopy", "return;");
    return typeof e.oncopy == "function"
  })();

  var badZoomedRects = null;
  function hasBadZoomedRects(measure) {
    if (badZoomedRects != null) { return badZoomedRects }
    var node = removeChildrenAndAdd(measure, elt("span", "x"));
    var normal = node.getBoundingClientRect();
    var fromRange = range(node, 0, 1).getBoundingClientRect();
    return badZoomedRects = Math.abs(normal.left - fromRange.left) > 1
  }

  // Known modes, by name and by MIME
  var modes = {}, mimeModes = {};

  // Extra arguments are stored as the mode's dependencies, which is
  // used by (legacy) mechanisms like loadmode.js to automatically
  // load a mode. (Preferred mechanism is the require/define calls.)
  function defineMode(name, mode) {
    if (arguments.length > 2)
      { mode.dependencies = Array.prototype.slice.call(arguments, 2); }
    modes[name] = mode;
  }

  function defineMIME(mime, spec) {
    mimeModes[mime] = spec;
  }

  // Given a MIME type, a {name, ...options} config object, or a name
  // string, return a mode config object.
  function resolveMode(spec) {
    if (typeof spec == "string" && mimeModes.hasOwnProperty(spec)) {
      spec = mimeModes[spec];
    } else if (spec && typeof spec.name == "string" && mimeModes.hasOwnProperty(spec.name)) {
      var found = mimeModes[spec.name];
      if (typeof found == "string") { found = {name: found}; }
      spec = createObj(found, spec);
      spec.name = found.name;
    } else if (typeof spec == "string" && /^[\w\-]+\/[\w\-]+\+xml$/.test(spec)) {
      return resolveMode("application/xml")
    } else if (typeof spec == "string" && /^[\w\-]+\/[\w\-]+\+json$/.test(spec)) {
      return resolveMode("application/json")
    }
    if (typeof spec == "string") { return {name: spec} }
    else { return spec || {name: "null"} }
  }

  // Given a mode spec (anything that resolveMode accepts), find and
  // initialize an actual mode object.
  function getMode(options, spec) {
    spec = resolveMode(spec);
    var mfactory = modes[spec.name];
    if (!mfactory) { return getMode(options, "text/plain") }
    var modeObj = mfactory(options, spec);
    if (modeExtensions.hasOwnProperty(spec.name)) {
      var exts = modeExtensions[spec.name];
      for (var prop in exts) {
        if (!exts.hasOwnProperty(prop)) { continue }
        if (modeObj.hasOwnProperty(prop)) { modeObj["_" + prop] = modeObj[prop]; }
        modeObj[prop] = exts[prop];
      }
    }
    modeObj.name = spec.name;
    if (spec.helperType) { modeObj.helperType = spec.helperType; }
    if (spec.modeProps) { for (var prop$1 in spec.modeProps)
      { modeObj[prop$1] = spec.modeProps[prop$1]; } }

    return modeObj
  }

  // This can be used to attach properties to mode objects from
  // outside the actual mode definition.
  var modeExtensions = {};
  function extendMode(mode, properties) {
    var exts = modeExtensions.hasOwnProperty(mode) ? modeExtensions[mode] : (modeExtensions[mode] = {});
    copyObj(properties, exts);
  }

  function copyState(mode, state) {
    if (state === true) { return state }
    if (mode.copyState) { return mode.copyState(state) }
    var nstate = {};
    for (var n in state) {
      var val = state[n];
      if (val instanceof Array) { val = val.concat([]); }
      nstate[n] = val;
    }
    return nstate
  }

  // Given a mode and a state (for that mode), find the inner mode and
  // state at the position that the state refers to.
  function innerMode(mode, state) {
    var info;
    while (mode.innerMode) {
      info = mode.innerMode(state);
      if (!info || info.mode == mode) { break }
      state = info.state;
      mode = info.mode;
    }
    return info || {mode: mode, state: state}
  }

  function startState(mode, a1, a2) {
    return mode.startState ? mode.startState(a1, a2) : true
  }

  // STRING STREAM

  // Fed to the mode parsers, provides helper functions to make
  // parsers more succinct.

  var StringStream = function(string, tabSize, lineOracle) {
    this.pos = this.start = 0;
    this.string = string;
    this.tabSize = tabSize || 8;
    this.lastColumnPos = this.lastColumnValue = 0;
    this.lineStart = 0;
    this.lineOracle = lineOracle;
  };

  StringStream.prototype.eol = function () {return this.pos >= this.string.length};
  StringStream.prototype.sol = function () {return this.pos == this.lineStart};
  StringStream.prototype.peek = function () {return this.string.charAt(this.pos) || undefined};
  StringStream.prototype.next = function () {
    if (this.pos < this.string.length)
      { return this.string.charAt(this.pos++) }
  };
  StringStream.prototype.eat = function (match) {
    var ch = this.string.charAt(this.pos);
    var ok;
    if (typeof match == "string") { ok = ch == match; }
    else { ok = ch && (match.test ? match.test(ch) : match(ch)); }
    if (ok) {++this.pos; return ch}
  };
  StringStream.prototype.eatWhile = function (match) {
    var start = this.pos;
    while (this.eat(match)){}
    return this.pos > start
  };
  StringStream.prototype.eatSpace = function () {
    var start = this.pos;
    while (/[\s\u00a0]/.test(this.string.charAt(this.pos))) { ++this.pos; }
    return this.pos > start
  };
  StringStream.prototype.skipToEnd = function () {this.pos = this.string.length;};
  StringStream.prototype.skipTo = function (ch) {
    var found = this.string.indexOf(ch, this.pos);
    if (found > -1) {this.pos = found; return true}
  };
  StringStream.prototype.backUp = function (n) {this.pos -= n;};
  StringStream.prototype.column = function () {
    if (this.lastColumnPos < this.start) {
      this.lastColumnValue = countColumn(this.string, this.start, this.tabSize, this.lastColumnPos, this.lastColumnValue);
      this.lastColumnPos = this.start;
    }
    return this.lastColumnValue - (this.lineStart ? countColumn(this.string, this.lineStart, this.tabSize) : 0)
  };
  StringStream.prototype.indentation = function () {
    return countColumn(this.string, null, this.tabSize) -
      (this.lineStart ? countColumn(this.string, this.lineStart, this.tabSize) : 0)
  };
  StringStream.prototype.match = function (pattern, consume, caseInsensitive) {
    if (typeof pattern == "string") {
      var cased = function (str) { return caseInsensitive ? str.toLowerCase() : str; };
      var substr = this.string.substr(this.pos, pattern.length);
      if (cased(substr) == cased(pattern)) {
        if (consume !== false) { this.pos += pattern.length; }
        return true
      }
    } else {
      var match = this.string.slice(this.pos).match(pattern);
      if (match && match.index > 0) { return null }
      if (match && consume !== false) { this.pos += match[0].length; }
      return match
    }
  };
  StringStream.prototype.current = function (){return this.string.slice(this.start, this.pos)};
  StringStream.prototype.hideFirstChars = function (n, inner) {
    this.lineStart += n;
    try { return inner() }
    finally { this.lineStart -= n; }
  };
  StringStream.prototype.lookAhead = function (n) {
    var oracle = this.lineOracle;
    return oracle && oracle.lookAhead(n)
  };
  StringStream.prototype.baseToken = function () {
    var oracle = this.lineOracle;
    return oracle && oracle.baseToken(this.pos)
  };

  // Find the line object corresponding to the given line number.
  function getLine(doc, n) {
    n -= doc.first;
    if (n < 0 || n >= doc.size) { throw new Error("There is no line " + (n + doc.first) + " in the document.") }
    var chunk = doc;
    while (!chunk.lines) {
      for (var i = 0;; ++i) {
        var child = chunk.children[i], sz = child.chunkSize();
        if (n < sz) { chunk = child; break }
        n -= sz;
      }
    }
    return chunk.lines[n]
  }

  // Get the part of a document between two positions, as an array of
  // strings.
  function getBetween(doc, start, end) {
    var out = [], n = start.line;
    doc.iter(start.line, end.line + 1, function (line) {
      var text = line.text;
      if (n == end.line) { text = text.slice(0, end.ch); }
      if (n == start.line) { text = text.slice(start.ch); }
      out.push(text);
      ++n;
    });
    return out
  }
  // Get the lines between from and to, as array of strings.
  function getLines(doc, from, to) {
    var out = [];
    doc.iter(from, to, function (line) { out.push(line.text); }); // iter aborts when callback returns truthy value
    return out
  }

  // Update the height of a line, propagating the height change
  // upwards to parent nodes.
  function updateLineHeight(line, height) {
    var diff = height - line.height;
    if (diff) { for (var n = line; n; n = n.parent) { n.height += diff; } }
  }

  // Given a line object, find its line number by walking up through
  // its parent links.
  function lineNo(line) {
    if (line.parent == null) { return null }
    var cur = line.parent, no = indexOf(cur.lines, line);
    for (var chunk = cur.parent; chunk; cur = chunk, chunk = chunk.parent) {
      for (var i = 0;; ++i) {
        if (chunk.children[i] == cur) { break }
        no += chunk.children[i].chunkSize();
      }
    }
    return no + cur.first
  }

  // Find the line at the given vertical position, using the height
  // information in the document tree.
  function lineAtHeight(chunk, h) {
    var n = chunk.first;
    outer: do {
      for (var i$1 = 0; i$1 < chunk.children.length; ++i$1) {
        var child = chunk.children[i$1], ch = child.height;
        if (h < ch) { chunk = child; continue outer }
        h -= ch;
        n += child.chunkSize();
      }
      return n
    } while (!chunk.lines)
    var i = 0;
    for (; i < chunk.lines.length; ++i) {
      var line = chunk.lines[i], lh = line.height;
      if (h < lh) { break }
      h -= lh;
    }
    return n + i
  }

  function isLine(doc, l) {return l >= doc.first && l < doc.first + doc.size}

  function lineNumberFor(options, i) {
    return String(options.lineNumberFormatter(i + options.firstLineNumber))
  }

  // A Pos instance represents a position within the text.
  function Pos(line, ch, sticky) {
    if ( sticky === void 0 ) sticky = null;

    if (!(this instanceof Pos)) { return new Pos(line, ch, sticky) }
    this.line = line;
    this.ch = ch;
    this.sticky = sticky;
  }

  // Compare two positions, return 0 if they are the same, a negative
  // number when a is less, and a positive number otherwise.
  function cmp(a, b) { return a.line - b.line || a.ch - b.ch }

  function equalCursorPos(a, b) { return a.sticky == b.sticky && cmp(a, b) == 0 }

  function copyPos(x) {return Pos(x.line, x.ch)}
  function maxPos(a, b) { return cmp(a, b) < 0 ? b : a }
  function minPos(a, b) { return cmp(a, b) < 0 ? a : b }

  // Most of the external API clips given positions to make sure they
  // actually exist within the document.
  function clipLine(doc, n) {return Math.max(doc.first, Math.min(n, doc.first + doc.size - 1))}
  function clipPos(doc, pos) {
    if (pos.line < doc.first) { return Pos(doc.first, 0) }
    var last = doc.first + doc.size - 1;
    if (pos.line > last) { return Pos(last, getLine(doc, last).text.length) }
    return clipToLen(pos, getLine(doc, pos.line).text.length)
  }
  function clipToLen(pos, linelen) {
    var ch = pos.ch;
    if (ch == null || ch > linelen) { return Pos(pos.line, linelen) }
    else if (ch < 0) { return Pos(pos.line, 0) }
    else { return pos }
  }
  function clipPosArray(doc, array) {
    var out = [];
    for (var i = 0; i < array.length; i++) { out[i] = clipPos(doc, array[i]); }
    return out
  }

  var SavedContext = function(state, lookAhead) {
    this.state = state;
    this.lookAhead = lookAhead;
  };

  var Context = function(doc, state, line, lookAhead) {
    this.state = state;
    this.doc = doc;
    this.line = line;
    this.maxLookAhead = lookAhead || 0;
    this.baseTokens = null;
    this.baseTokenPos = 1;
  };

  Context.prototype.lookAhead = function (n) {
    var line = this.doc.getLine(this.line + n);
    if (line != null && n > this.maxLookAhead) { this.maxLookAhead = n; }
    return line
  };

  Context.prototype.baseToken = function (n) {
    if (!this.baseTokens) { return null }
    while (this.baseTokens[this.baseTokenPos] <= n)
      { this.baseTokenPos += 2; }
    var type = this.baseTokens[this.baseTokenPos + 1];
    return {type: type && type.replace(/( |^)overlay .*/, ""),
            size: this.baseTokens[this.baseTokenPos] - n}
  };

  Context.prototype.nextLine = function () {
    this.line++;
    if (this.maxLookAhead > 0) { this.maxLookAhead--; }
  };

  Context.fromSaved = function (doc, saved, line) {
    if (saved instanceof SavedContext)
      { return new Context(doc, copyState(doc.mode, saved.state), line, saved.lookAhead) }
    else
      { return new Context(doc, copyState(doc.mode, saved), line) }
  };

  Context.prototype.save = function (copy) {
    var state = copy !== false ? copyState(this.doc.mode, this.state) : this.state;
    return this.maxLookAhead > 0 ? new SavedContext(state, this.maxLookAhead) : state
  };


  // Compute a style array (an array starting with a mode generation
  // -- for invalidation -- followed by pairs of end positions and
  // style strings), which is used to highlight the tokens on the
  // line.
  function highlightLine(cm, line, context, forceToEnd) {
    // A styles array always starts with a number identifying the
    // mode/overlays that it is based on (for easy invalidation).
    var st = [cm.state.modeGen], lineClasses = {};
    // Compute the base array of styles
    runMode(cm, line.text, cm.doc.mode, context, function (end, style) { return st.push(end, style); },
            lineClasses, forceToEnd);
    var state = context.state;

    // Run overlays, adjust style array.
    var loop = function ( o ) {
      context.baseTokens = st;
      var overlay = cm.state.overlays[o], i = 1, at = 0;
      context.state = true;
      runMode(cm, line.text, overlay.mode, context, function (end, style) {
        var start = i;
        // Ensure there's a token end at the current position, and that i points at it
        while (at < end) {
          var i_end = st[i];
          if (i_end > end)
            { st.splice(i, 1, end, st[i+1], i_end); }
          i += 2;
          at = Math.min(end, i_end);
        }
        if (!style) { return }
        if (overlay.opaque) {
          st.splice(start, i - start, end, "overlay " + style);
          i = start + 2;
        } else {
          for (; start < i; start += 2) {
            var cur = st[start+1];
            st[start+1] = (cur ? cur + " " : "") + "overlay " + style;
          }
        }
      }, lineClasses);
      context.state = state;
      context.baseTokens = null;
      context.baseTokenPos = 1;
    };

    for (var o = 0; o < cm.state.overlays.length; ++o) loop( o );

    return {styles: st, classes: lineClasses.bgClass || lineClasses.textClass ? lineClasses : null}
  }

  function getLineStyles(cm, line, updateFrontier) {
    if (!line.styles || line.styles[0] != cm.state.modeGen) {
      var context = getContextBefore(cm, lineNo(line));
      var resetState = line.text.length > cm.options.maxHighlightLength && copyState(cm.doc.mode, context.state);
      var result = highlightLine(cm, line, context);
      if (resetState) { context.state = resetState; }
      line.stateAfter = context.save(!resetState);
      line.styles = result.styles;
      if (result.classes) { line.styleClasses = result.classes; }
      else if (line.styleClasses) { line.styleClasses = null; }
      if (updateFrontier === cm.doc.highlightFrontier)
        { cm.doc.modeFrontier = Math.max(cm.doc.modeFrontier, ++cm.doc.highlightFrontier); }
    }
    return line.styles
  }

  function getContextBefore(cm, n, precise) {
    var doc = cm.doc, display = cm.display;
    if (!doc.mode.startState) { return new Context(doc, true, n) }
    var start = findStartLine(cm, n, precise);
    var saved = start > doc.first && getLine(doc, start - 1).stateAfter;
    var context = saved ? Context.fromSaved(doc, saved, start) : new Context(doc, startState(doc.mode), start);

    doc.iter(start, n, function (line) {
      processLine(cm, line.text, context);
      var pos = context.line;
      line.stateAfter = pos == n - 1 || pos % 5 == 0 || pos >= display.viewFrom && pos < display.viewTo ? context.save() : null;
      context.nextLine();
    });
    if (precise) { doc.modeFrontier = context.line; }
    return context
  }

  // Lightweight form of highlight -- proceed over this line and
  // update state, but don't save a style array. Used for lines that
  // aren't currently visible.
  function processLine(cm, text, context, startAt) {
    var mode = cm.doc.mode;
    var stream = new StringStream(text, cm.options.tabSize, context);
    stream.start = stream.pos = startAt || 0;
    if (text == "") { callBlankLine(mode, context.state); }
    while (!stream.eol()) {
      readToken(mode, stream, context.state);
      stream.start = stream.pos;
    }
  }

  function callBlankLine(mode, state) {
    if (mode.blankLine) { return mode.blankLine(state) }
    if (!mode.innerMode) { return }
    var inner = innerMode(mode, state);
    if (inner.mode.blankLine) { return inner.mode.blankLine(inner.state) }
  }

  function readToken(mode, stream, state, inner) {
    for (var i = 0; i < 10; i++) {
      if (inner) { inner[0] = innerMode(mode, state).mode; }
      var style = mode.token(stream, state);
      if (stream.pos > stream.start) { return style }
    }
    throw new Error("Mode " + mode.name + " failed to advance stream.")
  }

  var Token = function(stream, type, state) {
    this.start = stream.start; this.end = stream.pos;
    this.string = stream.current();
    this.type = type || null;
    this.state = state;
  };

  // Utility for getTokenAt and getLineTokens
  function takeToken(cm, pos, precise, asArray) {
    var doc = cm.doc, mode = doc.mode, style;
    pos = clipPos(doc, pos);
    var line = getLine(doc, pos.line), context = getContextBefore(cm, pos.line, precise);
    var stream = new StringStream(line.text, cm.options.tabSize, context), tokens;
    if (asArray) { tokens = []; }
    while ((asArray || stream.pos < pos.ch) && !stream.eol()) {
      stream.start = stream.pos;
      style = readToken(mode, stream, context.state);
      if (asArray) { tokens.push(new Token(stream, style, copyState(doc.mode, context.state))); }
    }
    return asArray ? tokens : new Token(stream, style, context.state)
  }

  function extractLineClasses(type, output) {
    if (type) { for (;;) {
      var lineClass = type.match(/(?:^|\s+)line-(background-)?(\S+)/);
      if (!lineClass) { break }
      type = type.slice(0, lineClass.index) + type.slice(lineClass.index + lineClass[0].length);
      var prop = lineClass[1] ? "bgClass" : "textClass";
      if (output[prop] == null)
        { output[prop] = lineClass[2]; }
      else if (!(new RegExp("(?:^|\\s)" + lineClass[2] + "(?:$|\\s)")).test(output[prop]))
        { output[prop] += " " + lineClass[2]; }
    } }
    return type
  }

  // Run the given mode's parser over a line, calling f for each token.
  function runMode(cm, text, mode, context, f, lineClasses, forceToEnd) {
    var flattenSpans = mode.flattenSpans;
    if (flattenSpans == null) { flattenSpans = cm.options.flattenSpans; }
    var curStart = 0, curStyle = null;
    var stream = new StringStream(text, cm.options.tabSize, context), style;
    var inner = cm.options.addModeClass && [null];
    if (text == "") { extractLineClasses(callBlankLine(mode, context.state), lineClasses); }
    while (!stream.eol()) {
      if (stream.pos > cm.options.maxHighlightLength) {
        flattenSpans = false;
        if (forceToEnd) { processLine(cm, text, context, stream.pos); }
        stream.pos = text.length;
        style = null;
      } else {
        style = extractLineClasses(readToken(mode, stream, context.state, inner), lineClasses);
      }
      if (inner) {
        var mName = inner[0].name;
        if (mName) { style = "m-" + (style ? mName + " " + style : mName); }
      }
      if (!flattenSpans || curStyle != style) {
        while (curStart < stream.start) {
          curStart = Math.min(stream.start, curStart + 5000);
          f(curStart, curStyle);
        }
        curStyle = style;
      }
      stream.start = stream.pos;
    }
    while (curStart < stream.pos) {
      // Webkit seems to refuse to render text nodes longer than 57444
      // characters, and returns inaccurate measurements in nodes
      // starting around 5000 chars.
      var pos = Math.min(stream.pos, curStart + 5000);
      f(pos, curStyle);
      curStart = pos;
    }
  }

  // Finds the line to start with when starting a parse. Tries to
  // find a line with a stateAfter, so that it can start with a
  // valid state. If that fails, it returns the line with the
  // smallest indentation, which tends to need the least context to
  // parse correctly.
  function findStartLine(cm, n, precise) {
    var minindent, minline, doc = cm.doc;
    var lim = precise ? -1 : n - (cm.doc.mode.innerMode ? 1000 : 100);
    for (var search = n; search > lim; --search) {
      if (search <= doc.first) { return doc.first }
      var line = getLine(doc, search - 1), after = line.stateAfter;
      if (after && (!precise || search + (after instanceof SavedContext ? after.lookAhead : 0) <= doc.modeFrontier))
        { return search }
      var indented = countColumn(line.text, null, cm.options.tabSize);
      if (minline == null || minindent > indented) {
        minline = search - 1;
        minindent = indented;
      }
    }
    return minline
  }

  function retreatFrontier(doc, n) {
    doc.modeFrontier = Math.min(doc.modeFrontier, n);
    if (doc.highlightFrontier < n - 10) { return }
    var start = doc.first;
    for (var line = n - 1; line > start; line--) {
      var saved = getLine(doc, line).stateAfter;
      // change is on 3
      // state on line 1 looked ahead 2 -- so saw 3
      // test 1 + 2 < 3 should cover this
      if (saved && (!(saved instanceof SavedContext) || line + saved.lookAhead < n)) {
        start = line + 1;
        break
      }
    }
    doc.highlightFrontier = Math.min(doc.highlightFrontier, start);
  }

  // Optimize some code when these features are not used.
  var sawReadOnlySpans = false, sawCollapsedSpans = false;

  function seeReadOnlySpans() {
    sawReadOnlySpans = true;
  }

  function seeCollapsedSpans() {
    sawCollapsedSpans = true;
  }

  // TEXTMARKER SPANS

  function MarkedSpan(marker, from, to) {
    this.marker = marker;
    this.from = from; this.to = to;
  }

  // Search an array of spans for a span matching the given marker.
  function getMarkedSpanFor(spans, marker) {
    if (spans) { for (var i = 0; i < spans.length; ++i) {
      var span = spans[i];
      if (span.marker == marker) { return span }
    } }
  }

  // Remove a span from an array, returning undefined if no spans are
  // left (we don't store arrays for lines without spans).
  function removeMarkedSpan(spans, span) {
    var r;
    for (var i = 0; i < spans.length; ++i)
      { if (spans[i] != span) { (r || (r = [])).push(spans[i]); } }
    return r
  }

  // Add a span to a line.
  function addMarkedSpan(line, span, op) {
    var inThisOp = op && window.WeakSet && (op.markedSpans || (op.markedSpans = new WeakSet));
    if (inThisOp && line.markedSpans && inThisOp.has(line.markedSpans)) {
      line.markedSpans.push(span);
    } else {
      line.markedSpans = line.markedSpans ? line.markedSpans.concat([span]) : [span];
      if (inThisOp) { inThisOp.add(line.markedSpans); }
    }
    span.marker.attachLine(line);
  }

  // Used for the algorithm that adjusts markers for a change in the
  // document. These functions cut an array of spans at a given
  // character position, returning an array of remaining chunks (or
  // undefined if nothing remains).
  function markedSpansBefore(old, startCh, isInsert) {
    var nw;
    if (old) { for (var i = 0; i < old.length; ++i) {
      var span = old[i], marker = span.marker;
      var startsBefore = span.from == null || (marker.inclusiveLeft ? span.from <= startCh : span.from < startCh);
      if (startsBefore || span.from == startCh && marker.type == "bookmark" && (!isInsert || !span.marker.insertLeft)) {
        var endsAfter = span.to == null || (marker.inclusiveRight ? span.to >= startCh : span.to > startCh)
        ;(nw || (nw = [])).push(new MarkedSpan(marker, span.from, endsAfter ? null : span.to));
      }
    } }
    return nw
  }
  function markedSpansAfter(old, endCh, isInsert) {
    var nw;
    if (old) { for (var i = 0; i < old.length; ++i) {
      var span = old[i], marker = span.marker;
      var endsAfter = span.to == null || (marker.inclusiveRight ? span.to >= endCh : span.to > endCh);
      if (endsAfter || span.from == endCh && marker.type == "bookmark" && (!isInsert || span.marker.insertLeft)) {
        var startsBefore = span.from == null || (marker.inclusiveLeft ? span.from <= endCh : span.from < endCh)
        ;(nw || (nw = [])).push(new MarkedSpan(marker, startsBefore ? null : span.from - endCh,
                                              span.to == null ? null : span.to - endCh));
      }
    } }
    return nw
  }

  // Given a change object, compute the new set of marker spans that
  // cover the line in which the change took place. Removes spans
  // entirely within the change, reconnects spans belonging to the
  // same marker that appear on both sides of the change, and cuts off
  // spans partially within the change. Returns an array of span
  // arrays with one element for each line in (after) the change.
  function stretchSpansOverChange(doc, change) {
    if (change.full) { return null }
    var oldFirst = isLine(doc, change.from.line) && getLine(doc, change.from.line).markedSpans;
    var oldLast = isLine(doc, change.to.line) && getLine(doc, change.to.line).markedSpans;
    if (!oldFirst && !oldLast) { return null }

    var startCh = change.from.ch, endCh = change.to.ch, isInsert = cmp(change.from, change.to) == 0;
    // Get the spans that 'stick out' on both sides
    var first = markedSpansBefore(oldFirst, startCh, isInsert);
    var last = markedSpansAfter(oldLast, endCh, isInsert);

    // Next, merge those two ends
    var sameLine = change.text.length == 1, offset = lst(change.text).length + (sameLine ? startCh : 0);
    if (first) {
      // Fix up .to properties of first
      for (var i = 0; i < first.length; ++i) {
        var span = first[i];
        if (span.to == null) {
          var found = getMarkedSpanFor(last, span.marker);
          if (!found) { span.to = startCh; }
          else if (sameLine) { span.to = found.to == null ? null : found.to + offset; }
        }
      }
    }
    if (last) {
      // Fix up .from in last (or move them into first in case of sameLine)
      for (var i$1 = 0; i$1 < last.length; ++i$1) {
        var span$1 = last[i$1];
        if (span$1.to != null) { span$1.to += offset; }
        if (span$1.from == null) {
          var found$1 = getMarkedSpanFor(first, span$1.marker);
          if (!found$1) {
            span$1.from = offset;
            if (sameLine) { (first || (first = [])).push(span$1); }
          }
        } else {
          span$1.from += offset;
          if (sameLine) { (first || (first = [])).push(span$1); }
        }
      }
    }
    // Make sure we didn't create any zero-length spans
    if (first) { first = clearEmptySpans(first); }
    if (last && last != first) { last = clearEmptySpans(last); }

    var newMarkers = [first];
    if (!sameLine) {
      // Fill gap with whole-line-spans
      var gap = change.text.length - 2, gapMarkers;
      if (gap > 0 && first)
        { for (var i$2 = 0; i$2 < first.length; ++i$2)
          { if (first[i$2].to == null)
            { (gapMarkers || (gapMarkers = [])).push(new MarkedSpan(first[i$2].marker, null, null)); } } }
      for (var i$3 = 0; i$3 < gap; ++i$3)
        { newMarkers.push(gapMarkers); }
      newMarkers.push(last);
    }
    return newMarkers
  }

  // Remove spans that are empty and don't have a clearWhenEmpty
  // option of false.
  function clearEmptySpans(spans) {
    for (var i = 0; i < spans.length; ++i) {
      var span = spans[i];
      if (span.from != null && span.from == span.to && span.marker.clearWhenEmpty !== false)
        { spans.splice(i--, 1); }
    }
    if (!spans.length) { return null }
    return spans
  }

  // Used to 'clip' out readOnly ranges when making a change.
  function removeReadOnlyRanges(doc, from, to) {
    var markers = null;
    doc.iter(from.line, to.line + 1, function (line) {
      if (line.markedSpans) { for (var i = 0; i < line.markedSpans.length; ++i) {
        var mark = line.markedSpans[i].marker;
        if (mark.readOnly && (!markers || indexOf(markers, mark) == -1))
          { (markers || (markers = [])).push(mark); }
      } }
    });
    if (!markers) { return null }
    var parts = [{from: from, to: to}];
    for (var i = 0; i < markers.length; ++i) {
      var mk = markers[i], m = mk.find(0);
      for (var j = 0; j < parts.length; ++j) {
        var p = parts[j];
        if (cmp(p.to, m.from) < 0 || cmp(p.from, m.to) > 0) { continue }
        var newParts = [j, 1], dfrom = cmp(p.from, m.from), dto = cmp(p.to, m.to);
        if (dfrom < 0 || !mk.inclusiveLeft && !dfrom)
          { newParts.push({from: p.from, to: m.from}); }
        if (dto > 0 || !mk.inclusiveRight && !dto)
          { newParts.push({from: m.to, to: p.to}); }
        parts.splice.apply(parts, newParts);
        j += newParts.length - 3;
      }
    }
    return parts
  }

  // Connect or disconnect spans from a line.
  function detachMarkedSpans(line) {
    var spans = line.markedSpans;
    if (!spans) { return }
    for (var i = 0; i < spans.length; ++i)
      { spans[i].marker.detachLine(line); }
    line.markedSpans = null;
  }
  function attachMarkedSpans(line, spans) {
    if (!spans) { return }
    for (var i = 0; i < spans.length; ++i)
      { spans[i].marker.attachLine(line); }
    line.markedSpans = spans;
  }

  // Helpers used when computing which overlapping collapsed span
  // counts as the larger one.
  function extraLeft(marker) { return marker.inclusiveLeft ? -1 : 0 }
  function extraRight(marker) { return marker.inclusiveRight ? 1 : 0 }

  // Returns a number indicating which of two overlapping collapsed
  // spans is larger (and thus includes the other). Falls back to
  // comparing ids when the spans cover exactly the same range.
  function compareCollapsedMarkers(a, b) {
    var lenDiff = a.lines.length - b.lines.length;
    if (lenDiff != 0) { return lenDiff }
    var aPos = a.find(), bPos = b.find();
    var fromCmp = cmp(aPos.from, bPos.from) || extraLeft(a) - extraLeft(b);
    if (fromCmp) { return -fromCmp }
    var toCmp = cmp(aPos.to, bPos.to) || extraRight(a) - extraRight(b);
    if (toCmp) { return toCmp }
    return b.id - a.id
  }

  // Find out whether a line ends or starts in a collapsed span. If
  // so, return the marker for that span.
  function collapsedSpanAtSide(line, start) {
    var sps = sawCollapsedSpans && line.markedSpans, found;
    if (sps) { for (var sp = (void 0), i = 0; i < sps.length; ++i) {
      sp = sps[i];
      if (sp.marker.collapsed && (start ? sp.from : sp.to) == null &&
          (!found || compareCollapsedMarkers(found, sp.marker) < 0))
        { found = sp.marker; }
    } }
    return found
  }
  function collapsedSpanAtStart(line) { return collapsedSpanAtSide(line, true) }
  function collapsedSpanAtEnd(line) { return collapsedSpanAtSide(line, false) }

  function collapsedSpanAround(line, ch) {
    var sps = sawCollapsedSpans && line.markedSpans, found;
    if (sps) { for (var i = 0; i < sps.length; ++i) {
      var sp = sps[i];
      if (sp.marker.collapsed && (sp.from == null || sp.from < ch) && (sp.to == null || sp.to > ch) &&
          (!found || compareCollapsedMarkers(found, sp.marker) < 0)) { found = sp.marker; }
    } }
    return found
  }

  // Test whether there exists a collapsed span that partially
  // overlaps (covers the start or end, but not both) of a new span.
  // Such overlap is not allowed.
  function conflictingCollapsedRange(doc, lineNo, from, to, marker) {
    var line = getLine(doc, lineNo);
    var sps = sawCollapsedSpans && line.markedSpans;
    if (sps) { for (var i = 0; i < sps.length; ++i) {
      var sp = sps[i];
      if (!sp.marker.collapsed) { continue }
      var found = sp.marker.find(0);
      var fromCmp = cmp(found.from, from) || extraLeft(sp.marker) - extraLeft(marker);
      var toCmp = cmp(found.to, to) || extraRight(sp.marker) - extraRight(marker);
      if (fromCmp >= 0 && toCmp <= 0 || fromCmp <= 0 && toCmp >= 0) { continue }
      if (fromCmp <= 0 && (sp.marker.inclusiveRight && marker.inclusiveLeft ? cmp(found.to, from) >= 0 : cmp(found.to, from) > 0) ||
          fromCmp >= 0 && (sp.marker.inclusiveRight && marker.inclusiveLeft ? cmp(found.from, to) <= 0 : cmp(found.from, to) < 0))
        { return true }
    } }
  }

  // A visual line is a line as drawn on the screen. Folding, for
  // example, can cause multiple logical lines to appear on the same
  // visual line. This finds the start of the visual line that the
  // given line is part of (usually that is the line itself).
  function visualLine(line) {
    var merged;
    while (merged = collapsedSpanAtStart(line))
      { line = merged.find(-1, true).line; }
    return line
  }

  function visualLineEnd(line) {
    var merged;
    while (merged = collapsedSpanAtEnd(line))
      { line = merged.find(1, true).line; }
    return line
  }

  // Returns an array of logical lines that continue the visual line
  // started by the argument, or undefined if there are no such lines.
  function visualLineContinued(line) {
    var merged, lines;
    while (merged = collapsedSpanAtEnd(line)) {
      line = merged.find(1, true).line
      ;(lines || (lines = [])).push(line);
    }
    return lines
  }

  // Get the line number of the start of the visual line that the
  // given line number is part of.
  function visualLineNo(doc, lineN) {
    var line = getLine(doc, lineN), vis = visualLine(line);
    if (line == vis) { return lineN }
    return lineNo(vis)
  }

  // Get the line number of the start of the next visual line after
  // the given line.
  function visualLineEndNo(doc, lineN) {
    if (lineN > doc.lastLine()) { return lineN }
    var line = getLine(doc, lineN), merged;
    if (!lineIsHidden(doc, line)) { return lineN }
    while (merged = collapsedSpanAtEnd(line))
      { line = merged.find(1, true).line; }
    return lineNo(line) + 1
  }

  // Compute whether a line is hidden. Lines count as hidden when they
  // are part of a visual line that starts with another line, or when
  // they are entirely covered by collapsed, non-widget span.
  function lineIsHidden(doc, line) {
    var sps = sawCollapsedSpans && line.markedSpans;
    if (sps) { for (var sp = (void 0), i = 0; i < sps.length; ++i) {
      sp = sps[i];
      if (!sp.marker.collapsed) { continue }
      if (sp.from == null) { return true }
      if (sp.marker.widgetNode) { continue }
      if (sp.from == 0 && sp.marker.inclusiveLeft && lineIsHiddenInner(doc, line, sp))
        { return true }
    } }
  }
  function lineIsHiddenInner(doc, line, span) {
    if (span.to == null) {
      var end = span.marker.find(1, true);
      return lineIsHiddenInner(doc, end.line, getMarkedSpanFor(end.line.markedSpans, span.marker))
    }
    if (span.marker.inclusiveRight && span.to == line.text.length)
      { return true }
    for (var sp = (void 0), i = 0; i < line.markedSpans.length; ++i) {
      sp = line.markedSpans[i];
      if (sp.marker.collapsed && !sp.marker.widgetNode && sp.from == span.to &&
          (sp.to == null || sp.to != span.from) &&
          (sp.marker.inclusiveLeft || span.marker.inclusiveRight) &&
          lineIsHiddenInner(doc, line, sp)) { return true }
    }
  }

  // Find the height above the given line.
  function heightAtLine(lineObj) {
    lineObj = visualLine(lineObj);

    var h = 0, chunk = lineObj.parent;
    for (var i = 0; i < chunk.lines.length; ++i) {
      var line = chunk.lines[i];
      if (line == lineObj) { break }
      else { h += line.height; }
    }
    for (var p = chunk.parent; p; chunk = p, p = chunk.parent) {
      for (var i$1 = 0; i$1 < p.children.length; ++i$1) {
        var cur = p.children[i$1];
        if (cur == chunk) { break }
        else { h += cur.height; }
      }
    }
    return h
  }

  // Compute the character length of a line, taking into account
  // collapsed ranges (see markText) that might hide parts, and join
  // other lines onto it.
  function lineLength(line) {
    if (line.height == 0) { return 0 }
    var len = line.text.length, merged, cur = line;
    while (merged = collapsedSpanAtStart(cur)) {
      var found = merged.find(0, true);
      cur = found.from.line;
      len += found.from.ch - found.to.ch;
    }
    cur = line;
    while (merged = collapsedSpanAtEnd(cur)) {
      var found$1 = merged.find(0, true);
      len -= cur.text.length - found$1.from.ch;
      cur = found$1.to.line;
      len += cur.text.length - found$1.to.ch;
    }
    return len
  }

  // Find the longest line in the document.
  function findMaxLine(cm) {
    var d = cm.display, doc = cm.doc;
    d.maxLine = getLine(doc, doc.first);
    d.maxLineLength = lineLength(d.maxLine);
    d.maxLineChanged = true;
    doc.iter(function (line) {
      var len = lineLength(line);
      if (len > d.maxLineLength) {
        d.maxLineLength = len;
        d.maxLine = line;
      }
    });
  }

  // LINE DATA STRUCTURE

  // Line objects. These hold state related to a line, including
  // highlighting info (the styles array).
  var Line = function(text, markedSpans, estimateHeight) {
    this.text = text;
    attachMarkedSpans(this, markedSpans);
    this.height = estimateHeight ? estimateHeight(this) : 1;
  };

  Line.prototype.lineNo = function () { return lineNo(this) };
  eventMixin(Line);

  // Change the content (text, markers) of a line. Automatically
  // invalidates cached information and tries to re-estimate the
  // line's height.
  function updateLine(line, text, markedSpans, estimateHeight) {
    line.text = text;
    if (line.stateAfter) { line.stateAfter = null; }
    if (line.styles) { line.styles = null; }
    if (line.order != null) { line.order = null; }
    detachMarkedSpans(line);
    attachMarkedSpans(line, markedSpans);
    var estHeight = estimateHeight ? estimateHeight(line) : 1;
    if (estHeight != line.height) { updateLineHeight(line, estHeight); }
  }

  // Detach a line from the document tree and its markers.
  function cleanUpLine(line) {
    line.parent = null;
    detachMarkedSpans(line);
  }

  // Convert a style as returned by a mode (either null, or a string
  // containing one or more styles) to a CSS style. This is cached,
  // and also looks for line-wide styles.
  var styleToClassCache = {}, styleToClassCacheWithMode = {};
  function interpretTokenStyle(style, options) {
    if (!style || /^\s*$/.test(style)) { return null }
    var cache = options.addModeClass ? styleToClassCacheWithMode : styleToClassCache;
    return cache[style] ||
      (cache[style] = style.replace(/\S+/g, "cm-$&"))
  }

  // Render the DOM representation of the text of a line. Also builds
  // up a 'line map', which points at the DOM nodes that represent
  // specific stretches of text, and is used by the measuring code.
  // The returned object contains the DOM node, this map, and
  // information about line-wide styles that were set by the mode.
  function buildLineContent(cm, lineView) {
    // The padding-right forces the element to have a 'border', which
    // is needed on Webkit to be able to get line-level bounding
    // rectangles for it (in measureChar).
    var content = eltP("span", null, null, webkit ? "padding-right: .1px" : null);
    var builder = {pre: eltP("pre", [content], "CodeMirror-line"), content: content,
                   col: 0, pos: 0, cm: cm,
                   trailingSpace: false,
                   splitSpaces: cm.getOption("lineWrapping")};
    lineView.measure = {};

    // Iterate over the logical lines that make up this visual line.
    for (var i = 0; i <= (lineView.rest ? lineView.rest.length : 0); i++) {
      var line = i ? lineView.rest[i - 1] : lineView.line, order = (void 0);
      builder.pos = 0;
      builder.addToken = buildToken;
      // Optionally wire in some hacks into the token-rendering
      // algorithm, to deal with browser quirks.
      if (hasBadBidiRects(cm.display.measure) && (order = getOrder(line, cm.doc.direction)))
        { builder.addToken = buildTokenBadBidi(builder.addToken, order); }
      builder.map = [];
      var allowFrontierUpdate = lineView != cm.display.externalMeasured && lineNo(line);
      insertLineContent(line, builder, getLineStyles(cm, line, allowFrontierUpdate));
      if (line.styleClasses) {
        if (line.styleClasses.bgClass)
          { builder.bgClass = joinClasses(line.styleClasses.bgClass, builder.bgClass || ""); }
        if (line.styleClasses.textClass)
          { builder.textClass = joinClasses(line.styleClasses.textClass, builder.textClass || ""); }
      }

      // Ensure at least a single node is present, for measuring.
      if (builder.map.length == 0)
        { builder.map.push(0, 0, builder.content.appendChild(zeroWidthElement(cm.display.measure))); }

      // Store the map and a cache object for the current logical line
      if (i == 0) {
        lineView.measure.map = builder.map;
        lineView.measure.cache = {};
      } else {
  (lineView.measure.maps || (lineView.measure.maps = [])).push(builder.map)
        ;(lineView.measure.caches || (lineView.measure.caches = [])).push({});
      }
    }

    // See issue #2901
    if (webkit) {
      var last = builder.content.lastChild;
      if (/\bcm-tab\b/.test(last.className) || (last.querySelector && last.querySelector(".cm-tab")))
        { builder.content.className = "cm-tab-wrap-hack"; }
    }

    signal(cm, "renderLine", cm, lineView.line, builder.pre);
    if (builder.pre.className)
      { builder.textClass = joinClasses(builder.pre.className, builder.textClass || ""); }

    return builder
  }

  function defaultSpecialCharPlaceholder(ch) {
    var token = elt("span", "\u2022", "cm-invalidchar");
    token.title = "\\u" + ch.charCodeAt(0).toString(16);
    token.setAttribute("aria-label", token.title);
    return token
  }

  // Build up the DOM representation for a single token, and add it to
  // the line map. Takes care to render special characters separately.
  function buildToken(builder, text, style, startStyle, endStyle, css, attributes) {
    if (!text) { return }
    var displayText = builder.splitSpaces ? splitSpaces(text, builder.trailingSpace) : text;
    var special = builder.cm.state.specialChars, mustWrap = false;
    var content;
    if (!special.test(text)) {
      builder.col += text.length;
      content = document.createTextNode(displayText);
      builder.map.push(builder.pos, builder.pos + text.length, content);
      if (ie && ie_version < 9) { mustWrap = true; }
      builder.pos += text.length;
    } else {
      content = document.createDocumentFragment();
      var pos = 0;
      while (true) {
        special.lastIndex = pos;
        var m = special.exec(text);
        var skipped = m ? m.index - pos : text.length - pos;
        if (skipped) {
          var txt = document.createTextNode(displayText.slice(pos, pos + skipped));
          if (ie && ie_version < 9) { content.appendChild(elt("span", [txt])); }
          else { content.appendChild(txt); }
          builder.map.push(builder.pos, builder.pos + skipped, txt);
          builder.col += skipped;
          builder.pos += skipped;
        }
        if (!m) { break }
        pos += skipped + 1;
        var txt$1 = (void 0);
        if (m[0] == "\t") {
          var tabSize = builder.cm.options.tabSize, tabWidth = tabSize - builder.col % tabSize;
          txt$1 = content.appendChild(elt("span", spaceStr(tabWidth), "cm-tab"));
          txt$1.setAttribute("role", "presentation");
          txt$1.setAttribute("cm-text", "\t");
          builder.col += tabWidth;
        } else if (m[0] == "\r" || m[0] == "\n") {
          txt$1 = content.appendChild(elt("span", m[0] == "\r" ? "\u240d" : "\u2424", "cm-invalidchar"));
          txt$1.setAttribute("cm-text", m[0]);
          builder.col += 1;
        } else {
          txt$1 = builder.cm.options.specialCharPlaceholder(m[0]);
          txt$1.setAttribute("cm-text", m[0]);
          if (ie && ie_version < 9) { content.appendChild(elt("span", [txt$1])); }
          else { content.appendChild(txt$1); }
          builder.col += 1;
        }
        builder.map.push(builder.pos, builder.pos + 1, txt$1);
        builder.pos++;
      }
    }
    builder.trailingSpace = displayText.charCodeAt(text.length - 1) == 32;
    if (style || startStyle || endStyle || mustWrap || css || attributes) {
      var fullStyle = style || "";
      if (startStyle) { fullStyle += startStyle; }
      if (endStyle) { fullStyle += endStyle; }
      var token = elt("span", [content], fullStyle, css);
      if (attributes) {
        for (var attr in attributes) { if (attributes.hasOwnProperty(attr) && attr != "style" && attr != "class")
          { token.setAttribute(attr, attributes[attr]); } }
      }
      return builder.content.appendChild(token)
    }
    builder.content.appendChild(content);
  }

  // Change some spaces to NBSP to prevent the browser from collapsing
  // trailing spaces at the end of a line when rendering text (issue #1362).
  function splitSpaces(text, trailingBefore) {
    if (text.length > 1 && !/  /.test(text)) { return text }
    var spaceBefore = trailingBefore, result = "";
    for (var i = 0; i < text.length; i++) {
      var ch = text.charAt(i);
      if (ch == " " && spaceBefore && (i == text.length - 1 || text.charCodeAt(i + 1) == 32))
        { ch = "\u00a0"; }
      result += ch;
      spaceBefore = ch == " ";
    }
    return result
  }

  // Work around nonsense dimensions being reported for stretches of
  // right-to-left text.
  function buildTokenBadBidi(inner, order) {
    return function (builder, text, style, startStyle, endStyle, css, attributes) {
      style = style ? style + " cm-force-border" : "cm-force-border";
      var start = builder.pos, end = start + text.length;
      for (;;) {
        // Find the part that overlaps with the start of this text
        var part = (void 0);
        for (var i = 0; i < order.length; i++) {
          part = order[i];
          if (part.to > start && part.from <= start) { break }
        }
        if (part.to >= end) { return inner(builder, text, style, startStyle, endStyle, css, attributes) }
        inner(builder, text.slice(0, part.to - start), style, startStyle, null, css, attributes);
        startStyle = null;
        text = text.slice(part.to - start);
        start = part.to;
      }
    }
  }

  function buildCollapsedSpan(builder, size, marker, ignoreWidget) {
    var widget = !ignoreWidget && marker.widgetNode;
    if (widget) { builder.map.push(builder.pos, builder.pos + size, widget); }
    if (!ignoreWidget && builder.cm.display.input.needsContentAttribute) {
      if (!widget)
        { widget = builder.content.appendChild(document.createElement("span")); }
      widget.setAttribute("cm-marker", marker.id);
    }
    if (widget) {
      builder.cm.display.input.setUneditable(widget);
      builder.content.appendChild(widget);
    }
    builder.pos += size;
    builder.trailingSpace = false;
  }

  // Outputs a number of spans to make up a line, taking highlighting
  // and marked text into account.
  function insertLineContent(line, builder, styles) {
    var spans = line.markedSpans, allText = line.text, at = 0;
    if (!spans) {
      for (var i$1 = 1; i$1 < styles.length; i$1+=2)
        { builder.addToken(builder, allText.slice(at, at = styles[i$1]), interpretTokenStyle(styles[i$1+1], builder.cm.options)); }
      return
    }

    var len = allText.length, pos = 0, i = 1, text = "", style, css;
    var nextChange = 0, spanStyle, spanEndStyle, spanStartStyle, collapsed, attributes;
    for (;;) {
      if (nextChange == pos) { // Update current marker set
        spanStyle = spanEndStyle = spanStartStyle = css = "";
        attributes = null;
        collapsed = null; nextChange = Infinity;
        var foundBookmarks = [], endStyles = (void 0);
        for (var j = 0; j < spans.length; ++j) {
          var sp = spans[j], m = sp.marker;
          if (m.type == "bookmark" && sp.from == pos && m.widgetNode) {
            foundBookmarks.push(m);
          } else if (sp.from <= pos && (sp.to == null || sp.to > pos || m.collapsed && sp.to == pos && sp.from == pos)) {
            if (sp.to != null && sp.to != pos && nextChange > sp.to) {
              nextChange = sp.to;
              spanEndStyle = "";
            }
            if (m.className) { spanStyle += " " + m.className; }
            if (m.css) { css = (css ? css + ";" : "") + m.css; }
            if (m.startStyle && sp.from == pos) { spanStartStyle += " " + m.startStyle; }
            if (m.endStyle && sp.to == nextChange) { (endStyles || (endStyles = [])).push(m.endStyle, sp.to); }
            // support for the old title property
            // https://github.com/codemirror/CodeMirror/pull/5673
            if (m.title) { (attributes || (attributes = {})).title = m.title; }
            if (m.attributes) {
              for (var attr in m.attributes)
                { (attributes || (attributes = {}))[attr] = m.attributes[attr]; }
            }
            if (m.collapsed && (!collapsed || compareCollapsedMarkers(collapsed.marker, m) < 0))
              { collapsed = sp; }
          } else if (sp.from > pos && nextChange > sp.from) {
            nextChange = sp.from;
          }
        }
        if (endStyles) { for (var j$1 = 0; j$1 < endStyles.length; j$1 += 2)
          { if (endStyles[j$1 + 1] == nextChange) { spanEndStyle += " " + endStyles[j$1]; } } }

        if (!collapsed || collapsed.from == pos) { for (var j$2 = 0; j$2 < foundBookmarks.length; ++j$2)
          { buildCollapsedSpan(builder, 0, foundBookmarks[j$2]); } }
        if (collapsed && (collapsed.from || 0) == pos) {
          buildCollapsedSpan(builder, (collapsed.to == null ? len + 1 : collapsed.to) - pos,
                             collapsed.marker, collapsed.from == null);
          if (collapsed.to == null) { return }
          if (collapsed.to == pos) { collapsed = false; }
        }
      }
      if (pos >= len) { break }

      var upto = Math.min(len, nextChange);
      while (true) {
        if (text) {
          var end = pos + text.length;
          if (!collapsed) {
            var tokenText = end > upto ? text.slice(0, upto - pos) : text;
            builder.addToken(builder, tokenText, style ? style + spanStyle : spanStyle,
                             spanStartStyle, pos + tokenText.length == nextChange ? spanEndStyle : "", css, attributes);
          }
          if (end >= upto) {text = text.slice(upto - pos); pos = upto; break}
          pos = end;
          spanStartStyle = "";
        }
        text = allText.slice(at, at = styles[i++]);
        style = interpretTokenStyle(styles[i++], builder.cm.options);
      }
    }
  }


  // These objects are used to represent the visible (currently drawn)
  // part of the document. A LineView may correspond to multiple
  // logical lines, if those are connected by collapsed ranges.
  function LineView(doc, line, lineN) {
    // The starting line
    this.line = line;
    // Continuing lines, if any
    this.rest = visualLineContinued(line);
    // Number of logical lines in this visual line
    this.size = this.rest ? lineNo(lst(this.rest)) - lineN + 1 : 1;
    this.node = this.text = null;
    this.hidden = lineIsHidden(doc, line);
  }

  // Create a range of LineView objects for the given lines.
  function buildViewArray(cm, from, to) {
    var array = [], nextPos;
    for (var pos = from; pos < to; pos = nextPos) {
      var view = new LineView(cm.doc, getLine(cm.doc, pos), pos);
      nextPos = pos + view.size;
      array.push(view);
    }
    return array
  }

  var operationGroup = null;

  function pushOperation(op) {
    if (operationGroup) {
      operationGroup.ops.push(op);
    } else {
      op.ownsGroup = operationGroup = {
        ops: [op],
        delayedCallbacks: []
      };
    }
  }

  function fireCallbacksForOps(group) {
    // Calls delayed callbacks and cursorActivity handlers until no
    // new ones appear
    var callbacks = group.delayedCallbacks, i = 0;
    do {
      for (; i < callbacks.length; i++)
        { callbacks[i].call(null); }
      for (var j = 0; j < group.ops.length; j++) {
        var op = group.ops[j];
        if (op.cursorActivityHandlers)
          { while (op.cursorActivityCalled < op.cursorActivityHandlers.length)
            { op.cursorActivityHandlers[op.cursorActivityCalled++].call(null, op.cm); } }
      }
    } while (i < callbacks.length)
  }

  function finishOperation(op, endCb) {
    var group = op.ownsGroup;
    if (!group) { return }

    try { fireCallbacksForOps(group); }
    finally {
      operationGroup = null;
      endCb(group);
    }
  }

  var orphanDelayedCallbacks = null;

  // Often, we want to signal events at a point where we are in the
  // middle of some work, but don't want the handler to start calling
  // other methods on the editor, which might be in an inconsistent
  // state or simply not expect any other events to happen.
  // signalLater looks whether there are any handlers, and schedules
  // them to be executed when the last operation ends, or, if no
  // operation is active, when a timeout fires.
  function signalLater(emitter, type /*, values...*/) {
    var arr = getHandlers(emitter, type);
    if (!arr.length) { return }
    var args = Array.prototype.slice.call(arguments, 2), list;
    if (operationGroup) {
      list = operationGroup.delayedCallbacks;
    } else if (orphanDelayedCallbacks) {
      list = orphanDelayedCallbacks;
    } else {
      list = orphanDelayedCallbacks = [];
      setTimeout(fireOrphanDelayed, 0);
    }
    var loop = function ( i ) {
      list.push(function () { return arr[i].apply(null, args); });
    };

    for (var i = 0; i < arr.length; ++i)
      loop( i );
  }

  function fireOrphanDelayed() {
    var delayed = orphanDelayedCallbacks;
    orphanDelayedCallbacks = null;
    for (var i = 0; i < delayed.length; ++i) { delayed[i](); }
  }

  // When an aspect of a line changes, a string is added to
  // lineView.changes. This updates the relevant part of the line's
  // DOM structure.
  function updateLineForChanges(cm, lineView, lineN, dims) {
    for (var j = 0; j < lineView.changes.length; j++) {
      var type = lineView.changes[j];
      if (type == "text") { updateLineText(cm, lineView); }
      else if (type == "gutter") { updateLineGutter(cm, lineView, lineN, dims); }
      else if (type == "class") { updateLineClasses(cm, lineView); }
      else if (type == "widget") { updateLineWidgets(cm, lineView, dims); }
    }
    lineView.changes = null;
  }

  // Lines with gutter elements, widgets or a background class need to
  // be wrapped, and have the extra elements added to the wrapper div
  function ensureLineWrapped(lineView) {
    if (lineView.node == lineView.text) {
      lineView.node = elt("div", null, null, "position: relative");
      if (lineView.text.parentNode)
        { lineView.text.parentNode.replaceChild(lineView.node, lineView.text); }
      lineView.node.appendChild(lineView.text);
      if (ie && ie_version < 8) { lineView.node.style.zIndex = 2; }
    }
    return lineView.node
  }

  function updateLineBackground(cm, lineView) {
    var cls = lineView.bgClass ? lineView.bgClass + " " + (lineView.line.bgClass || "") : lineView.line.bgClass;
    if (cls) { cls += " CodeMirror-linebackground"; }
    if (lineView.background) {
      if (cls) { lineView.background.className = cls; }
      else { lineView.background.parentNode.removeChild(lineView.background); lineView.background = null; }
    } else if (cls) {
      var wrap = ensureLineWrapped(lineView);
      lineView.background = wrap.insertBefore(elt("div", null, cls), wrap.firstChild);
      cm.display.input.setUneditable(lineView.background);
    }
  }

  // Wrapper around buildLineContent which will reuse the structure
  // in display.externalMeasured when possible.
  function getLineContent(cm, lineView) {
    var ext = cm.display.externalMeasured;
    if (ext && ext.line == lineView.line) {
      cm.display.externalMeasured = null;
      lineView.measure = ext.measure;
      return ext.built
    }
    return buildLineContent(cm, lineView)
  }

  // Redraw the line's text. Interacts with the background and text
  // classes because the mode may output tokens that influence these
  // classes.
  function updateLineText(cm, lineView) {
    var cls = lineView.text.className;
    var built = getLineContent(cm, lineView);
    if (lineView.text == lineView.node) { lineView.node = built.pre; }
    lineView.text.parentNode.replaceChild(built.pre, lineView.text);
    lineView.text = built.pre;
    if (built.bgClass != lineView.bgClass || built.textClass != lineView.textClass) {
      lineView.bgClass = built.bgClass;
      lineView.textClass = built.textClass;
      updateLineClasses(cm, lineView);
    } else if (cls) {
      lineView.text.className = cls;
    }
  }

  function updateLineClasses(cm, lineView) {
    updateLineBackground(cm, lineView);
    if (lineView.line.wrapClass)
      { ensureLineWrapped(lineView).className = lineView.line.wrapClass; }
    else if (lineView.node != lineView.text)
      { lineView.node.className = ""; }
    var textClass = lineView.textClass ? lineView.textClass + " " + (lineView.line.textClass || "") : lineView.line.textClass;
    lineView.text.className = textClass || "";
  }

  function updateLineGutter(cm, lineView, lineN, dims) {
    if (lineView.gutter) {
      lineView.node.removeChild(lineView.gutter);
      lineView.gutter = null;
    }
    if (lineView.gutterBackground) {
      lineView.node.removeChild(lineView.gutterBackground);
      lineView.gutterBackground = null;
    }
    if (lineView.line.gutterClass) {
      var wrap = ensureLineWrapped(lineView);
      lineView.gutterBackground = elt("div", null, "CodeMirror-gutter-background " + lineView.line.gutterClass,
                                      ("left: " + (cm.options.fixedGutter ? dims.fixedPos : -dims.gutterTotalWidth) + "px; width: " + (dims.gutterTotalWidth) + "px"));
      cm.display.input.setUneditable(lineView.gutterBackground);
      wrap.insertBefore(lineView.gutterBackground, lineView.text);
    }
    var markers = lineView.line.gutterMarkers;
    if (cm.options.lineNumbers || markers) {
      var wrap$1 = ensureLineWrapped(lineView);
      var gutterWrap = lineView.gutter = elt("div", null, "CodeMirror-gutter-wrapper", ("left: " + (cm.options.fixedGutter ? dims.fixedPos : -dims.gutterTotalWidth) + "px"));
      gutterWrap.setAttribute("aria-hidden", "true");
      cm.display.input.setUneditable(gutterWrap);
      wrap$1.insertBefore(gutterWrap, lineView.text);
      if (lineView.line.gutterClass)
        { gutterWrap.className += " " + lineView.line.gutterClass; }
      if (cm.options.lineNumbers && (!markers || !markers["CodeMirror-linenumbers"]))
        { lineView.lineNumber = gutterWrap.appendChild(
          elt("div", lineNumberFor(cm.options, lineN),
              "CodeMirror-linenumber CodeMirror-gutter-elt",
              ("left: " + (dims.gutterLeft["CodeMirror-linenumbers"]) + "px; width: " + (cm.display.lineNumInnerWidth) + "px"))); }
      if (markers) { for (var k = 0; k < cm.display.gutterSpecs.length; ++k) {
        var id = cm.display.gutterSpecs[k].className, found = markers.hasOwnProperty(id) && markers[id];
        if (found)
          { gutterWrap.appendChild(elt("div", [found], "CodeMirror-gutter-elt",
                                     ("left: " + (dims.gutterLeft[id]) + "px; width: " + (dims.gutterWidth[id]) + "px"))); }
      } }
    }
  }

  function updateLineWidgets(cm, lineView, dims) {
    if (lineView.alignable) { lineView.alignable = null; }
    var isWidget = classTest("CodeMirror-linewidget");
    for (var node = lineView.node.firstChild, next = (void 0); node; node = next) {
      next = node.nextSibling;
      if (isWidget.test(node.className)) { lineView.node.removeChild(node); }
    }
    insertLineWidgets(cm, lineView, dims);
  }

  // Build a line's DOM representation from scratch
  function buildLineElement(cm, lineView, lineN, dims) {
    var built = getLineContent(cm, lineView);
    lineView.text = lineView.node = built.pre;
    if (built.bgClass) { lineView.bgClass = built.bgClass; }
    if (built.textClass) { lineView.textClass = built.textClass; }

    updateLineClasses(cm, lineView);
    updateLineGutter(cm, lineView, lineN, dims);
    insertLineWidgets(cm, lineView, dims);
    return lineView.node
  }

  // A lineView may contain multiple logical lines (when merged by
  // collapsed spans). The widgets for all of them need to be drawn.
  function insertLineWidgets(cm, lineView, dims) {
    insertLineWidgetsFor(cm, lineView.line, lineView, dims, true);
    if (lineView.rest) { for (var i = 0; i < lineView.rest.length; i++)
      { insertLineWidgetsFor(cm, lineView.rest[i], lineView, dims, false); } }
  }

  function insertLineWidgetsFor(cm, line, lineView, dims, allowAbove) {
    if (!line.widgets) { return }
    var wrap = ensureLineWrapped(lineView);
    for (var i = 0, ws = line.widgets; i < ws.length; ++i) {
      var widget = ws[i], node = elt("div", [widget.node], "CodeMirror-linewidget" + (widget.className ? " " + widget.className : ""));
      if (!widget.handleMouseEvents) { node.setAttribute("cm-ignore-events", "true"); }
      positionLineWidget(widget, node, lineView, dims);
      cm.display.input.setUneditable(node);
      if (allowAbove && widget.above)
        { wrap.insertBefore(node, lineView.gutter || lineView.text); }
      else
        { wrap.appendChild(node); }
      signalLater(widget, "redraw");
    }
  }

  function positionLineWidget(widget, node, lineView, dims) {
    if (widget.noHScroll) {
  (lineView.alignable || (lineView.alignable = [])).push(node);
      var width = dims.wrapperWidth;
      node.style.left = dims.fixedPos + "px";
      if (!widget.coverGutter) {
        width -= dims.gutterTotalWidth;
        node.style.paddingLeft = dims.gutterTotalWidth + "px";
      }
      node.style.width = width + "px";
    }
    if (widget.coverGutter) {
      node.style.zIndex = 5;
      node.style.position = "relative";
      if (!widget.noHScroll) { node.style.marginLeft = -dims.gutterTotalWidth + "px"; }
    }
  }

  function widgetHeight(widget) {
    if (widget.height != null) { return widget.height }
    var cm = widget.doc.cm;
    if (!cm) { return 0 }
    if (!contains(document.body, widget.node)) {
      var parentStyle = "position: relative;";
      if (widget.coverGutter)
        { parentStyle += "margin-left: -" + cm.display.gutters.offsetWidth + "px;"; }
      if (widget.noHScroll)
        { parentStyle += "width: " + cm.display.wrapper.clientWidth + "px;"; }
      removeChildrenAndAdd(cm.display.measure, elt("div", [widget.node], null, parentStyle));
    }
    return widget.height = widget.node.parentNode.offsetHeight
  }

  // Return true when the given mouse event happened in a widget
  function eventInWidget(display, e) {
    for (var n = e_target(e); n != display.wrapper; n = n.parentNode) {
      if (!n || (n.nodeType == 1 && n.getAttribute("cm-ignore-events") == "true") ||
          (n.parentNode == display.sizer && n != display.mover))
        { return true }
    }
  }

  // POSITION MEASUREMENT

  function paddingTop(display) {return display.lineSpace.offsetTop}
  function paddingVert(display) {return display.mover.offsetHeight - display.lineSpace.offsetHeight}
  function paddingH(display) {
    if (display.cachedPaddingH) { return display.cachedPaddingH }
    var e = removeChildrenAndAdd(display.measure, elt("pre", "x", "CodeMirror-line-like"));
    var style = window.getComputedStyle ? window.getComputedStyle(e) : e.currentStyle;
    var data = {left: parseInt(style.paddingLeft), right: parseInt(style.paddingRight)};
    if (!isNaN(data.left) && !isNaN(data.right)) { display.cachedPaddingH = data; }
    return data
  }

  function scrollGap(cm) { return scrollerGap - cm.display.nativeBarWidth }
  function displayWidth(cm) {
    return cm.display.scroller.clientWidth - scrollGap(cm) - cm.display.barWidth
  }
  function displayHeight(cm) {
    return cm.display.scroller.clientHeight - scrollGap(cm) - cm.display.barHeight
  }

  // Ensure the lineView.wrapping.heights array is populated. This is
  // an array of bottom offsets for the lines that make up a drawn
  // line. When lineWrapping is on, there might be more than one
  // height.
  function ensureLineHeights(cm, lineView, rect) {
    var wrapping = cm.options.lineWrapping;
    var curWidth = wrapping && displayWidth(cm);
    if (!lineView.measure.heights || wrapping && lineView.measure.width != curWidth) {
      var heights = lineView.measure.heights = [];
      if (wrapping) {
        lineView.measure.width = curWidth;
        var rects = lineView.text.firstChild.getClientRects();
        for (var i = 0; i < rects.length - 1; i++) {
          var cur = rects[i], next = rects[i + 1];
          if (Math.abs(cur.bottom - next.bottom) > 2)
            { heights.push((cur.bottom + next.top) / 2 - rect.top); }
        }
      }
      heights.push(rect.bottom - rect.top);
    }
  }

  // Find a line map (mapping character offsets to text nodes) and a
  // measurement cache for the given line number. (A line view might
  // contain multiple lines when collapsed ranges are present.)
  function mapFromLineView(lineView, line, lineN) {
    if (lineView.line == line)
      { return {map: lineView.measure.map, cache: lineView.measure.cache} }
    if (lineView.rest) {
      for (var i = 0; i < lineView.rest.length; i++)
        { if (lineView.rest[i] == line)
          { return {map: lineView.measure.maps[i], cache: lineView.measure.caches[i]} } }
      for (var i$1 = 0; i$1 < lineView.rest.length; i$1++)
        { if (lineNo(lineView.rest[i$1]) > lineN)
          { return {map: lineView.measure.maps[i$1], cache: lineView.measure.caches[i$1], before: true} } }
    }
  }

  // Render a line into the hidden node display.externalMeasured. Used
  // when measurement is needed for a line that's not in the viewport.
  function updateExternalMeasurement(cm, line) {
    line = visualLine(line);
    var lineN = lineNo(line);
    var view = cm.display.externalMeasured = new LineView(cm.doc, line, lineN);
    view.lineN = lineN;
    var built = view.built = buildLineContent(cm, view);
    view.text = built.pre;
    removeChildrenAndAdd(cm.display.lineMeasure, built.pre);
    return view
  }

  // Get a {top, bottom, left, right} box (in line-local coordinates)
  // for a given character.
  function measureChar(cm, line, ch, bias) {
    return measureCharPrepared(cm, prepareMeasureForLine(cm, line), ch, bias)
  }

  // Find a line view that corresponds to the given line number.
  function findViewForLine(cm, lineN) {
    if (lineN >= cm.display.viewFrom && lineN < cm.display.viewTo)
      { return cm.display.view[findViewIndex(cm, lineN)] }
    var ext = cm.display.externalMeasured;
    if (ext && lineN >= ext.lineN && lineN < ext.lineN + ext.size)
      { return ext }
  }

  // Measurement can be split in two steps, the set-up work that
  // applies to the whole line, and the measurement of the actual
  // character. Functions like coordsChar, that need to do a lot of
  // measurements in a row, can thus ensure that the set-up work is
  // only done once.
  function prepareMeasureForLine(cm, line) {
    var lineN = lineNo(line);
    var view = findViewForLine(cm, lineN);
    if (view && !view.text) {
      view = null;
    } else if (view && view.changes) {
      updateLineForChanges(cm, view, lineN, getDimensions(cm));
      cm.curOp.forceUpdate = true;
    }
    if (!view)
      { view = updateExternalMeasurement(cm, line); }

    var info = mapFromLineView(view, line, lineN);
    return {
      line: line, view: view, rect: null,
      map: info.map, cache: info.cache, before: info.before,
      hasHeights: false
    }
  }

  // Given a prepared measurement object, measures the position of an
  // actual character (or fetches it from the cache).
  function measureCharPrepared(cm, prepared, ch, bias, varHeight) {
    if (prepared.before) { ch = -1; }
    var key = ch + (bias || ""), found;
    if (prepared.cache.hasOwnProperty(key)) {
      found = prepared.cache[key];
    } else {
      if (!prepared.rect)
        { prepared.rect = prepared.view.text.getBoundingClientRect(); }
      if (!prepared.hasHeights) {
        ensureLineHeights(cm, prepared.view, prepared.rect);
        prepared.hasHeights = true;
      }
      found = measureCharInner(cm, prepared, ch, bias);
      if (!found.bogus) { prepared.cache[key] = found; }
    }
    return {left: found.left, right: found.right,
            top: varHeight ? found.rtop : found.top,
            bottom: varHeight ? found.rbottom : found.bottom}
  }

  var nullRect = {left: 0, right: 0, top: 0, bottom: 0};

  function nodeAndOffsetInLineMap(map, ch, bias) {
    var node, start, end, collapse, mStart, mEnd;
    // First, search the line map for the text node corresponding to,
    // or closest to, the target character.
    for (var i = 0; i < map.length; i += 3) {
      mStart = map[i];
      mEnd = map[i + 1];
      if (ch < mStart) {
        start = 0; end = 1;
        collapse = "left";
      } else if (ch < mEnd) {
        start = ch - mStart;
        end = start + 1;
      } else if (i == map.length - 3 || ch == mEnd && map[i + 3] > ch) {
        end = mEnd - mStart;
        start = end - 1;
        if (ch >= mEnd) { collapse = "right"; }
      }
      if (start != null) {
        node = map[i + 2];
        if (mStart == mEnd && bias == (node.insertLeft ? "left" : "right"))
          { collapse = bias; }
        if (bias == "left" && start == 0)
          { while (i && map[i - 2] == map[i - 3] && map[i - 1].insertLeft) {
            node = map[(i -= 3) + 2];
            collapse = "left";
          } }
        if (bias == "right" && start == mEnd - mStart)
          { while (i < map.length - 3 && map[i + 3] == map[i + 4] && !map[i + 5].insertLeft) {
            node = map[(i += 3) + 2];
            collapse = "right";
          } }
        break
      }
    }
    return {node: node, start: start, end: end, collapse: collapse, coverStart: mStart, coverEnd: mEnd}
  }

  function getUsefulRect(rects, bias) {
    var rect = nullRect;
    if (bias == "left") { for (var i = 0; i < rects.length; i++) {
      if ((rect = rects[i]).left != rect.right) { break }
    } } else { for (var i$1 = rects.length - 1; i$1 >= 0; i$1--) {
      if ((rect = rects[i$1]).left != rect.right) { break }
    } }
    return rect
  }

  function measureCharInner(cm, prepared, ch, bias) {
    var place = nodeAndOffsetInLineMap(prepared.map, ch, bias);
    var node = place.node, start = place.start, end = place.end, collapse = place.collapse;

    var rect;
    if (node.nodeType == 3) { // If it is a text node, use a range to retrieve the coordinates.
      for (var i$1 = 0; i$1 < 4; i$1++) { // Retry a maximum of 4 times when nonsense rectangles are returned
        while (start && isExtendingChar(prepared.line.text.charAt(place.coverStart + start))) { --start; }
        while (place.coverStart + end < place.coverEnd && isExtendingChar(prepared.line.text.charAt(place.coverStart + end))) { ++end; }
        if (ie && ie_version < 9 && start == 0 && end == place.coverEnd - place.coverStart)
          { rect = node.parentNode.getBoundingClientRect(); }
        else
          { rect = getUsefulRect(range(node, start, end).getClientRects(), bias); }
        if (rect.left || rect.right || start == 0) { break }
        end = start;
        start = start - 1;
        collapse = "right";
      }
      if (ie && ie_version < 11) { rect = maybeUpdateRectForZooming(cm.display.measure, rect); }
    } else { // If it is a widget, simply get the box for the whole widget.
      if (start > 0) { collapse = bias = "right"; }
      var rects;
      if (cm.options.lineWrapping && (rects = node.getClientRects()).length > 1)
        { rect = rects[bias == "right" ? rects.length - 1 : 0]; }
      else
        { rect = node.getBoundingClientRect(); }
    }
    if (ie && ie_version < 9 && !start && (!rect || !rect.left && !rect.right)) {
      var rSpan = node.parentNode.getClientRects()[0];
      if (rSpan)
        { rect = {left: rSpan.left, right: rSpan.left + charWidth(cm.display), top: rSpan.top, bottom: rSpan.bottom}; }
      else
        { rect = nullRect; }
    }

    var rtop = rect.top - prepared.rect.top, rbot = rect.bottom - prepared.rect.top;
    var mid = (rtop + rbot) / 2;
    var heights = prepared.view.measure.heights;
    var i = 0;
    for (; i < heights.length - 1; i++)
      { if (mid < heights[i]) { break } }
    var top = i ? heights[i - 1] : 0, bot = heights[i];
    var result = {left: (collapse == "right" ? rect.right : rect.left) - prepared.rect.left,
                  right: (collapse == "left" ? rect.left : rect.right) - prepared.rect.left,
                  top: top, bottom: bot};
    if (!rect.left && !rect.right) { result.bogus = true; }
    if (!cm.options.singleCursorHeightPerLine) { result.rtop = rtop; result.rbottom = rbot; }

    return result
  }

  // Work around problem with bounding client rects on ranges being
  // returned incorrectly when zoomed on IE10 and below.
  function maybeUpdateRectForZooming(measure, rect) {
    if (!window.screen || screen.logicalXDPI == null ||
        screen.logicalXDPI == screen.deviceXDPI || !hasBadZoomedRects(measure))
      { return rect }
    var scaleX = screen.logicalXDPI / screen.deviceXDPI;
    var scaleY = screen.logicalYDPI / screen.deviceYDPI;
    return {left: rect.left * scaleX, right: rect.right * scaleX,
            top: rect.top * scaleY, bottom: rect.bottom * scaleY}
  }

  function clearLineMeasurementCacheFor(lineView) {
    if (lineView.measure) {
      lineView.measure.cache = {};
      lineView.measure.heights = null;
      if (lineView.rest) { for (var i = 0; i < lineView.rest.length; i++)
        { lineView.measure.caches[i] = {}; } }
    }
  }

  function clearLineMeasurementCache(cm) {
    cm.display.externalMeasure = null;
    removeChildren(cm.display.lineMeasure);
    for (var i = 0; i < cm.display.view.length; i++)
      { clearLineMeasurementCacheFor(cm.display.view[i]); }
  }

  function clearCaches(cm) {
    clearLineMeasurementCache(cm);
    cm.display.cachedCharWidth = cm.display.cachedTextHeight = cm.display.cachedPaddingH = null;
    if (!cm.options.lineWrapping) { cm.display.maxLineChanged = true; }
    cm.display.lineNumChars = null;
  }

  function pageScrollX() {
    // Work around https://bugs.chromium.org/p/chromium/issues/detail?id=489206
    // which causes page_Offset and bounding client rects to use
    // different reference viewports and invalidate our calculations.
    if (chrome && android) { return -(document.body.getBoundingClientRect().left - parseInt(getComputedStyle(document.body).marginLeft)) }
    return window.pageXOffset || (document.documentElement || document.body).scrollLeft
  }
  function pageScrollY() {
    if (chrome && android) { return -(document.body.getBoundingClientRect().top - parseInt(getComputedStyle(document.body).marginTop)) }
    return window.pageYOffset || (document.documentElement || document.body).scrollTop
  }

  function widgetTopHeight(lineObj) {
    var ref = visualLine(lineObj);
    var widgets = ref.widgets;
    var height = 0;
    if (widgets) { for (var i = 0; i < widgets.length; ++i) { if (widgets[i].above)
      { height += widgetHeight(widgets[i]); } } }
    return height
  }

  // Converts a {top, bottom, left, right} box from line-local
  // coordinates into another coordinate system. Context may be one of
  // "line", "div" (display.lineDiv), "local"./null (editor), "window",
  // or "page".
  function intoCoordSystem(cm, lineObj, rect, context, includeWidgets) {
    if (!includeWidgets) {
      var height = widgetTopHeight(lineObj);
      rect.top += height; rect.bottom += height;
    }
    if (context == "line") { return rect }
    if (!context) { context = "local"; }
    var yOff = heightAtLine(lineObj);
    if (context == "local") { yOff += paddingTop(cm.display); }
    else { yOff -= cm.display.viewOffset; }
    if (context == "page" || context == "window") {
      var lOff = cm.display.lineSpace.getBoundingClientRect();
      yOff += lOff.top + (context == "window" ? 0 : pageScrollY());
      var xOff = lOff.left + (context == "window" ? 0 : pageScrollX());
      rect.left += xOff; rect.right += xOff;
    }
    rect.top += yOff; rect.bottom += yOff;
    return rect
  }

  // Coverts a box from "div" coords to another coordinate system.
  // Context may be "window", "page", "div", or "local"./null.
  function fromCoordSystem(cm, coords, context) {
    if (context == "div") { return coords }
    var left = coords.left, top = coords.top;
    // First move into "page" coordinate system
    if (context == "page") {
      left -= pageScrollX();
      top -= pageScrollY();
    } else if (context == "local" || !context) {
      var localBox = cm.display.sizer.getBoundingClientRect();
      left += localBox.left;
      top += localBox.top;
    }

    var lineSpaceBox = cm.display.lineSpace.getBoundingClientRect();
    return {left: left - lineSpaceBox.left, top: top - lineSpaceBox.top}
  }

  function charCoords(cm, pos, context, lineObj, bias) {
    if (!lineObj) { lineObj = getLine(cm.doc, pos.line); }
    return intoCoordSystem(cm, lineObj, measureChar(cm, lineObj, pos.ch, bias), context)
  }

  // Returns a box for a given cursor position, which may have an
  // 'other' property containing the position of the secondary cursor
  // on a bidi boundary.
  // A cursor Pos(line, char, "before") is on the same visual line as `char - 1`
  // and after `char - 1` in writing order of `char - 1`
  // A cursor Pos(line, char, "after") is on the same visual line as `char`
  // and before `char` in writing order of `char`
  // Examples (upper-case letters are RTL, lower-case are LTR):
  //     Pos(0, 1, ...)
  //     before   after
  // ab     a|b     a|b
  // aB     a|B     aB|
  // Ab     |Ab     A|b
  // AB     B|A     B|A
  // Every position after the last character on a line is considered to stick
  // to the last character on the line.
  function cursorCoords(cm, pos, context, lineObj, preparedMeasure, varHeight) {
    lineObj = lineObj || getLine(cm.doc, pos.line);
    if (!preparedMeasure) { preparedMeasure = prepareMeasureForLine(cm, lineObj); }
    function get(ch, right) {
      var m = measureCharPrepared(cm, preparedMeasure, ch, right ? "right" : "left", varHeight);
      if (right) { m.left = m.right; } else { m.right = m.left; }
      return intoCoordSystem(cm, lineObj, m, context)
    }
    var order = getOrder(lineObj, cm.doc.direction), ch = pos.ch, sticky = pos.sticky;
    if (ch >= lineObj.text.length) {
      ch = lineObj.text.length;
      sticky = "before";
    } else if (ch <= 0) {
      ch = 0;
      sticky = "after";
    }
    if (!order) { return get(sticky == "before" ? ch - 1 : ch, sticky == "before") }

    function getBidi(ch, partPos, invert) {
      var part = order[partPos], right = part.level == 1;
      return get(invert ? ch - 1 : ch, right != invert)
    }
    var partPos = getBidiPartAt(order, ch, sticky);
    var other = bidiOther;
    var val = getBidi(ch, partPos, sticky == "before");
    if (other != null) { val.other = getBidi(ch, other, sticky != "before"); }
    return val
  }

  // Used to cheaply estimate the coordinates for a position. Used for
  // intermediate scroll updates.
  function estimateCoords(cm, pos) {
    var left = 0;
    pos = clipPos(cm.doc, pos);
    if (!cm.options.lineWrapping) { left = charWidth(cm.display) * pos.ch; }
    var lineObj = getLine(cm.doc, pos.line);
    var top = heightAtLine(lineObj) + paddingTop(cm.display);
    return {left: left, right: left, top: top, bottom: top + lineObj.height}
  }

  // Positions returned by coordsChar contain some extra information.
  // xRel is the relative x position of the input coordinates compared
  // to the found position (so xRel > 0 means the coordinates are to
  // the right of the character position, for example). When outside
  // is true, that means the coordinates lie outside the line's
  // vertical range.
  function PosWithInfo(line, ch, sticky, outside, xRel) {
    var pos = Pos(line, ch, sticky);
    pos.xRel = xRel;
    if (outside) { pos.outside = outside; }
    return pos
  }

  // Compute the character position closest to the given coordinates.
  // Input must be lineSpace-local ("div" coordinate system).
  function coordsChar(cm, x, y) {
    var doc = cm.doc;
    y += cm.display.viewOffset;
    if (y < 0) { return PosWithInfo(doc.first, 0, null, -1, -1) }
    var lineN = lineAtHeight(doc, y), last = doc.first + doc.size - 1;
    if (lineN > last)
      { return PosWithInfo(doc.first + doc.size - 1, getLine(doc, last).text.length, null, 1, 1) }
    if (x < 0) { x = 0; }

    var lineObj = getLine(doc, lineN);
    for (;;) {
      var found = coordsCharInner(cm, lineObj, lineN, x, y);
      var collapsed = collapsedSpanAround(lineObj, found.ch + (found.xRel > 0 || found.outside > 0 ? 1 : 0));
      if (!collapsed) { return found }
      var rangeEnd = collapsed.find(1);
      if (rangeEnd.line == lineN) { return rangeEnd }
      lineObj = getLine(doc, lineN = rangeEnd.line);
    }
  }

  function wrappedLineExtent(cm, lineObj, preparedMeasure, y) {
    y -= widgetTopHeight(lineObj);
    var end = lineObj.text.length;
    var begin = findFirst(function (ch) { return measureCharPrepared(cm, preparedMeasure, ch - 1).bottom <= y; }, end, 0);
    end = findFirst(function (ch) { return measureCharPrepared(cm, preparedMeasure, ch).top > y; }, begin, end);
    return {begin: begin, end: end}
  }

  function wrappedLineExtentChar(cm, lineObj, preparedMeasure, target) {
    if (!preparedMeasure) { preparedMeasure = prepareMeasureForLine(cm, lineObj); }
    var targetTop = intoCoordSystem(cm, lineObj, measureCharPrepared(cm, preparedMeasure, target), "line").top;
    return wrappedLineExtent(cm, lineObj, preparedMeasure, targetTop)
  }

  // Returns true if the given side of a box is after the given
  // coordinates, in top-to-bottom, left-to-right order.
  function boxIsAfter(box, x, y, left) {
    return box.bottom <= y ? false : box.top > y ? true : (left ? box.left : box.right) > x
  }

  function coordsCharInner(cm, lineObj, lineNo, x, y) {
    // Move y into line-local coordinate space
    y -= heightAtLine(lineObj);
    var preparedMeasure = prepareMeasureForLine(cm, lineObj);
    // When directly calling `measureCharPrepared`, we have to adjust
    // for the widgets at this line.
    var widgetHeight = widgetTopHeight(lineObj);
    var begin = 0, end = lineObj.text.length, ltr = true;

    var order = getOrder(lineObj, cm.doc.direction);
    // If the line isn't plain left-to-right text, first figure out
    // which bidi section the coordinates fall into.
    if (order) {
      var part = (cm.options.lineWrapping ? coordsBidiPartWrapped : coordsBidiPart)
                   (cm, lineObj, lineNo, preparedMeasure, order, x, y);
      ltr = part.level != 1;
      // The awkward -1 offsets are needed because findFirst (called
      // on these below) will treat its first bound as inclusive,
      // second as exclusive, but we want to actually address the
      // characters in the part's range
      begin = ltr ? part.from : part.to - 1;
      end = ltr ? part.to : part.from - 1;
    }

    // A binary search to find the first character whose bounding box
    // starts after the coordinates. If we run across any whose box wrap
    // the coordinates, store that.
    var chAround = null, boxAround = null;
    var ch = findFirst(function (ch) {
      var box = measureCharPrepared(cm, preparedMeasure, ch);
      box.top += widgetHeight; box.bottom += widgetHeight;
      if (!boxIsAfter(box, x, y, false)) { return false }
      if (box.top <= y && box.left <= x) {
        chAround = ch;
        boxAround = box;
      }
      return true
    }, begin, end);

    var baseX, sticky, outside = false;
    // If a box around the coordinates was found, use that
    if (boxAround) {
      // Distinguish coordinates nearer to the left or right side of the box
      var atLeft = x - boxAround.left < boxAround.right - x, atStart = atLeft == ltr;
      ch = chAround + (atStart ? 0 : 1);
      sticky = atStart ? "after" : "before";
      baseX = atLeft ? boxAround.left : boxAround.right;
    } else {
      // (Adjust for extended bound, if necessary.)
      if (!ltr && (ch == end || ch == begin)) { ch++; }
      // To determine which side to associate with, get the box to the
      // left of the character and compare it's vertical position to the
      // coordinates
      sticky = ch == 0 ? "after" : ch == lineObj.text.length ? "before" :
        (measureCharPrepared(cm, preparedMeasure, ch - (ltr ? 1 : 0)).bottom + widgetHeight <= y) == ltr ?
        "after" : "before";
      // Now get accurate coordinates for this place, in order to get a
      // base X position
      var coords = cursorCoords(cm, Pos(lineNo, ch, sticky), "line", lineObj, preparedMeasure);
      baseX = coords.left;
      outside = y < coords.top ? -1 : y >= coords.bottom ? 1 : 0;
    }

    ch = skipExtendingChars(lineObj.text, ch, 1);
    return PosWithInfo(lineNo, ch, sticky, outside, x - baseX)
  }

  function coordsBidiPart(cm, lineObj, lineNo, preparedMeasure, order, x, y) {
    // Bidi parts are sorted left-to-right, and in a non-line-wrapping
    // situation, we can take this ordering to correspond to the visual
    // ordering. This finds the first part whose end is after the given
    // coordinates.
    var index = findFirst(function (i) {
      var part = order[i], ltr = part.level != 1;
      return boxIsAfter(cursorCoords(cm, Pos(lineNo, ltr ? part.to : part.from, ltr ? "before" : "after"),
                                     "line", lineObj, preparedMeasure), x, y, true)
    }, 0, order.length - 1);
    var part = order[index];
    // If this isn't the first part, the part's start is also after
    // the coordinates, and the coordinates aren't on the same line as
    // that start, move one part back.
    if (index > 0) {
      var ltr = part.level != 1;
      var start = cursorCoords(cm, Pos(lineNo, ltr ? part.from : part.to, ltr ? "after" : "before"),
                               "line", lineObj, preparedMeasure);
      if (boxIsAfter(start, x, y, true) && start.top > y)
        { part = order[index - 1]; }
    }
    return part
  }

  function coordsBidiPartWrapped(cm, lineObj, _lineNo, preparedMeasure, order, x, y) {
    // In a wrapped line, rtl text on wrapping boundaries can do things
    // that don't correspond to the ordering in our `order` array at
    // all, so a binary search doesn't work, and we want to return a
    // part that only spans one line so that the binary search in
    // coordsCharInner is safe. As such, we first find the extent of the
    // wrapped line, and then do a flat search in which we discard any
    // spans that aren't on the line.
    var ref = wrappedLineExtent(cm, lineObj, preparedMeasure, y);
    var begin = ref.begin;
    var end = ref.end;
    if (/\s/.test(lineObj.text.charAt(end - 1))) { end--; }
    var part = null, closestDist = null;
    for (var i = 0; i < order.length; i++) {
      var p = order[i];
      if (p.from >= end || p.to <= begin) { continue }
      var ltr = p.level != 1;
      var endX = measureCharPrepared(cm, preparedMeasure, ltr ? Math.min(end, p.to) - 1 : Math.max(begin, p.from)).right;
      // Weigh against spans ending before this, so that they are only
      // picked if nothing ends after
      var dist = endX < x ? x - endX + 1e9 : endX - x;
      if (!part || closestDist > dist) {
        part = p;
        closestDist = dist;
      }
    }
    if (!part) { part = order[order.length - 1]; }
    // Clip the part to the wrapped line.
    if (part.from < begin) { part = {from: begin, to: part.to, level: part.level}; }
    if (part.to > end) { part = {from: part.from, to: end, level: part.level}; }
    return part
  }

  var measureText;
  // Compute the default text height.
  function textHeight(display) {
    if (display.cachedTextHeight != null) { return display.cachedTextHeight }
    if (measureText == null) {
      measureText = elt("pre", null, "CodeMirror-line-like");
      // Measure a bunch of lines, for browsers that compute
      // fractional heights.
      for (var i = 0; i < 49; ++i) {
        measureText.appendChild(document.createTextNode("x"));
        measureText.appendChild(elt("br"));
      }
      measureText.appendChild(document.createTextNode("x"));
    }
    removeChildrenAndAdd(display.measure, measureText);
    var height = measureText.offsetHeight / 50;
    if (height > 3) { display.cachedTextHeight = height; }
    removeChildren(display.measure);
    return height || 1
  }

  // Compute the default character width.
  function charWidth(display) {
    if (display.cachedCharWidth != null) { return display.cachedCharWidth }
    var anchor = elt("span", "xxxxxxxxxx");
    var pre = elt("pre", [anchor], "CodeMirror-line-like");
    removeChildrenAndAdd(display.measure, pre);
    var rect = anchor.getBoundingClientRect(), width = (rect.right - rect.left) / 10;
    if (width > 2) { display.cachedCharWidth = width; }
    return width || 10
  }

  // Do a bulk-read of the DOM positions and sizes needed to draw the
  // view, so that we don't interleave reading and writing to the DOM.
  function getDimensions(cm) {
    var d = cm.display, left = {}, width = {};
    var gutterLeft = d.gutters.clientLeft;
    for (var n = d.gutters.firstChild, i = 0; n; n = n.nextSibling, ++i) {
      var id = cm.display.gutterSpecs[i].className;
      left[id] = n.offsetLeft + n.clientLeft + gutterLeft;
      width[id] = n.clientWidth;
    }
    return {fixedPos: compensateForHScroll(d),
            gutterTotalWidth: d.gutters.offsetWidth,
            gutterLeft: left,
            gutterWidth: width,
            wrapperWidth: d.wrapper.clientWidth}
  }

  // Computes display.scroller.scrollLeft + display.gutters.offsetWidth,
  // but using getBoundingClientRect to get a sub-pixel-accurate
  // result.
  function compensateForHScroll(display) {
    return display.scroller.getBoundingClientRect().left - display.sizer.getBoundingClientRect().left
  }

  // Returns a function that estimates the height of a line, to use as
  // first approximation until the line becomes visible (and is thus
  // properly measurable).
  function estimateHeight(cm) {
    var th = textHeight(cm.display), wrapping = cm.options.lineWrapping;
    var perLine = wrapping && Math.max(5, cm.display.scroller.clientWidth / charWidth(cm.display) - 3);
    return function (line) {
      if (lineIsHidden(cm.doc, line)) { return 0 }

      var widgetsHeight = 0;
      if (line.widgets) { for (var i = 0; i < line.widgets.length; i++) {
        if (line.widgets[i].height) { widgetsHeight += line.widgets[i].height; }
      } }

      if (wrapping)
        { return widgetsHeight + (Math.ceil(line.text.length / perLine) || 1) * th }
      else
        { return widgetsHeight + th }
    }
  }

  function estimateLineHeights(cm) {
    var doc = cm.doc, est = estimateHeight(cm);
    doc.iter(function (line) {
      var estHeight = est(line);
      if (estHeight != line.height) { updateLineHeight(line, estHeight); }
    });
  }

  // Given a mouse event, find the corresponding position. If liberal
  // is false, it checks whether a gutter or scrollbar was clicked,
  // and returns null if it was. forRect is used by rectangular
  // selections, and tries to estimate a character position even for
  // coordinates beyond the right of the text.
  function posFromMouse(cm, e, liberal, forRect) {
    var display = cm.display;
    if (!liberal && e_target(e).getAttribute("cm-not-content") == "true") { return null }

    var x, y, space = display.lineSpace.getBoundingClientRect();
    // Fails unpredictably on IE[67] when mouse is dragged around quickly.
    try { x = e.clientX - space.left; y = e.clientY - space.top; }
    catch (e$1) { return null }
    var coords = coordsChar(cm, x, y), line;
    if (forRect && coords.xRel > 0 && (line = getLine(cm.doc, coords.line).text).length == coords.ch) {
      var colDiff = countColumn(line, line.length, cm.options.tabSize) - line.length;
      coords = Pos(coords.line, Math.max(0, Math.round((x - paddingH(cm.display).left) / charWidth(cm.display)) - colDiff));
    }
    return coords
  }

  // Find the view element corresponding to a given line. Return null
  // when the line isn't visible.
  function findViewIndex(cm, n) {
    if (n >= cm.display.viewTo) { return null }
    n -= cm.display.viewFrom;
    if (n < 0) { return null }
    var view = cm.display.view;
    for (var i = 0; i < view.length; i++) {
      n -= view[i].size;
      if (n < 0) { return i }
    }
  }

  // Updates the display.view data structure for a given change to the
  // document. From and to are in pre-change coordinates. Lendiff is
  // the amount of lines added or subtracted by the change. This is
  // used for changes that span multiple lines, or change the way
  // lines are divided into visual lines. regLineChange (below)
  // registers single-line changes.
  function regChange(cm, from, to, lendiff) {
    if (from == null) { from = cm.doc.first; }
    if (to == null) { to = cm.doc.first + cm.doc.size; }
    if (!lendiff) { lendiff = 0; }

    var display = cm.display;
    if (lendiff && to < display.viewTo &&
        (display.updateLineNumbers == null || display.updateLineNumbers > from))
      { display.updateLineNumbers = from; }

    cm.curOp.viewChanged = true;

    if (from >= display.viewTo) { // Change after
      if (sawCollapsedSpans && visualLineNo(cm.doc, from) < display.viewTo)
        { resetView(cm); }
    } else if (to <= display.viewFrom) { // Change before
      if (sawCollapsedSpans && visualLineEndNo(cm.doc, to + lendiff) > display.viewFrom) {
        resetView(cm);
      } else {
        display.viewFrom += lendiff;
        display.viewTo += lendiff;
      }
    } else if (from <= display.viewFrom && to >= display.viewTo) { // Full overlap
      resetView(cm);
    } else if (from <= display.viewFrom) { // Top overlap
      var cut = viewCuttingPoint(cm, to, to + lendiff, 1);
      if (cut) {
        display.view = display.view.slice(cut.index);
        display.viewFrom = cut.lineN;
        display.viewTo += lendiff;
      } else {
        resetView(cm);
      }
    } else if (to >= display.viewTo) { // Bottom overlap
      var cut$1 = viewCuttingPoint(cm, from, from, -1);
      if (cut$1) {
        display.view = display.view.slice(0, cut$1.index);
        display.viewTo = cut$1.lineN;
      } else {
        resetView(cm);
      }
    } else { // Gap in the middle
      var cutTop = viewCuttingPoint(cm, from, from, -1);
      var cutBot = viewCuttingPoint(cm, to, to + lendiff, 1);
      if (cutTop && cutBot) {
        display.view = display.view.slice(0, cutTop.index)
          .concat(buildViewArray(cm, cutTop.lineN, cutBot.lineN))
          .concat(display.view.slice(cutBot.index));
        display.viewTo += lendiff;
      } else {
        resetView(cm);
      }
    }

    var ext = display.externalMeasured;
    if (ext) {
      if (to < ext.lineN)
        { ext.lineN += lendiff; }
      else if (from < ext.lineN + ext.size)
        { display.externalMeasured = null; }
    }
  }

  // Register a change to a single line. Type must be one of "text",
  // "gutter", "class", "widget"
  function regLineChange(cm, line, type) {
    cm.curOp.viewChanged = true;
    var display = cm.display, ext = cm.display.externalMeasured;
    if (ext && line >= ext.lineN && line < ext.lineN + ext.size)
      { display.externalMeasured = null; }

    if (line < display.viewFrom || line >= display.viewTo) { return }
    var lineView = display.view[findViewIndex(cm, line)];
    if (lineView.node == null) { return }
    var arr = lineView.changes || (lineView.changes = []);
    if (indexOf(arr, type) == -1) { arr.push(type); }
  }

  // Clear the view.
  function resetView(cm) {
    cm.display.viewFrom = cm.display.viewTo = cm.doc.first;
    cm.display.view = [];
    cm.display.viewOffset = 0;
  }

  function viewCuttingPoint(cm, oldN, newN, dir) {
    var index = findViewIndex(cm, oldN), diff, view = cm.display.view;
    if (!sawCollapsedSpans || newN == cm.doc.first + cm.doc.size)
      { return {index: index, lineN: newN} }
    var n = cm.display.viewFrom;
    for (var i = 0; i < index; i++)
      { n += view[i].size; }
    if (n != oldN) {
      if (dir > 0) {
        if (index == view.length - 1) { return null }
        diff = (n + view[index].size) - oldN;
        index++;
      } else {
        diff = n - oldN;
      }
      oldN += diff; newN += diff;
    }
    while (visualLineNo(cm.doc, newN) != newN) {
      if (index == (dir < 0 ? 0 : view.length - 1)) { return null }
      newN += dir * view[index - (dir < 0 ? 1 : 0)].size;
      index += dir;
    }
    return {index: index, lineN: newN}
  }

  // Force the view to cover a given range, adding empty view element
  // or clipping off existing ones as needed.
  function adjustView(cm, from, to) {
    var display = cm.display, view = display.view;
    if (view.length == 0 || from >= display.viewTo || to <= display.viewFrom) {
      display.view = buildViewArray(cm, from, to);
      display.viewFrom = from;
    } else {
      if (display.viewFrom > from)
        { display.view = buildViewArray(cm, from, display.viewFrom).concat(display.view); }
      else if (display.viewFrom < from)
        { display.view = display.view.slice(findViewIndex(cm, from)); }
      display.viewFrom = from;
      if (display.viewTo < to)
        { display.view = display.view.concat(buildViewArray(cm, display.viewTo, to)); }
      else if (display.viewTo > to)
        { display.view = display.view.slice(0, findViewIndex(cm, to)); }
    }
    display.viewTo = to;
  }

  // Count the number of lines in the view whose DOM representation is
  // out of date (or nonexistent).
  function countDirtyView(cm) {
    var view = cm.display.view, dirty = 0;
    for (var i = 0; i < view.length; i++) {
      var lineView = view[i];
      if (!lineView.hidden && (!lineView.node || lineView.changes)) { ++dirty; }
    }
    return dirty
  }

  function updateSelection(cm) {
    cm.display.input.showSelection(cm.display.input.prepareSelection());
  }

  function prepareSelection(cm, primary) {
    if ( primary === void 0 ) primary = true;

    var doc = cm.doc, result = {};
    var curFragment = result.cursors = document.createDocumentFragment();
    var selFragment = result.selection = document.createDocumentFragment();

    var customCursor = cm.options.$customCursor;
    if (customCursor) { primary = true; }
    for (var i = 0; i < doc.sel.ranges.length; i++) {
      if (!primary && i == doc.sel.primIndex) { continue }
      var range = doc.sel.ranges[i];
      if (range.from().line >= cm.display.viewTo || range.to().line < cm.display.viewFrom) { continue }
      var collapsed = range.empty();
      if (customCursor) {
        var head = customCursor(cm, range);
        if (head) { drawSelectionCursor(cm, head, curFragment); }
      } else if (collapsed || cm.options.showCursorWhenSelecting) {
        drawSelectionCursor(cm, range.head, curFragment);
      }
      if (!collapsed)
        { drawSelectionRange(cm, range, selFragment); }
    }
    return result
  }

  // Draws a cursor for the given range
  function drawSelectionCursor(cm, head, output) {
    var pos = cursorCoords(cm, head, "div", null, null, !cm.options.singleCursorHeightPerLine);

    var cursor = output.appendChild(elt("div", "\u00a0", "CodeMirror-cursor"));
    cursor.style.left = pos.left + "px";
    cursor.style.top = pos.top + "px";
    cursor.style.height = Math.max(0, pos.bottom - pos.top) * cm.options.cursorHeight + "px";

    if (/\bcm-fat-cursor\b/.test(cm.getWrapperElement().className)) {
      var charPos = charCoords(cm, head, "div", null, null);
      var width = charPos.right - charPos.left;
      cursor.style.width = (width > 0 ? width : cm.defaultCharWidth()) + "px";
    }

    if (pos.other) {
      // Secondary cursor, shown when on a 'jump' in bi-directional text
      var otherCursor = output.appendChild(elt("div", "\u00a0", "CodeMirror-cursor CodeMirror-secondarycursor"));
      otherCursor.style.display = "";
      otherCursor.style.left = pos.other.left + "px";
      otherCursor.style.top = pos.other.top + "px";
      otherCursor.style.height = (pos.other.bottom - pos.other.top) * .85 + "px";
    }
  }

  function cmpCoords(a, b) { return a.top - b.top || a.left - b.left }

  // Draws the given range as a highlighted selection
  function drawSelectionRange(cm, range, output) {
    var display = cm.display, doc = cm.doc;
    var fragment = document.createDocumentFragment();
    var padding = paddingH(cm.display), leftSide = padding.left;
    var rightSide = Math.max(display.sizerWidth, displayWidth(cm) - display.sizer.offsetLeft) - padding.right;
    var docLTR = doc.direction == "ltr";

    function add(left, top, width, bottom) {
      if (top < 0) { top = 0; }
      top = Math.round(top);
      bottom = Math.round(bottom);
      fragment.appendChild(elt("div", null, "CodeMirror-selected", ("position: absolute; left: " + left + "px;\n                             top: " + top + "px; width: " + (width == null ? rightSide - left : width) + "px;\n                             height: " + (bottom - top) + "px")));
    }

    function drawForLine(line, fromArg, toArg) {
      var lineObj = getLine(doc, line);
      var lineLen = lineObj.text.length;
      var start, end;
      function coords(ch, bias) {
        return charCoords(cm, Pos(line, ch), "div", lineObj, bias)
      }

      function wrapX(pos, dir, side) {
        var extent = wrappedLineExtentChar(cm, lineObj, null, pos);
        var prop = (dir == "ltr") == (side == "after") ? "left" : "right";
        var ch = side == "after" ? extent.begin : extent.end - (/\s/.test(lineObj.text.charAt(extent.end - 1)) ? 2 : 1);
        return coords(ch, prop)[prop]
      }

      var order = getOrder(lineObj, doc.direction);
      iterateBidiSections(order, fromArg || 0, toArg == null ? lineLen : toArg, function (from, to, dir, i) {
        var ltr = dir == "ltr";
        var fromPos = coords(from, ltr ? "left" : "right");
        var toPos = coords(to - 1, ltr ? "right" : "left");

        var openStart = fromArg == null && from == 0, openEnd = toArg == null && to == lineLen;
        var first = i == 0, last = !order || i == order.length - 1;
        if (toPos.top - fromPos.top <= 3) { // Single line
          var openLeft = (docLTR ? openStart : openEnd) && first;
          var openRight = (docLTR ? openEnd : openStart) && last;
          var left = openLeft ? leftSide : (ltr ? fromPos : toPos).left;
          var right = openRight ? rightSide : (ltr ? toPos : fromPos).right;
          add(left, fromPos.top, right - left, fromPos.bottom);
        } else { // Multiple lines
          var topLeft, topRight, botLeft, botRight;
          if (ltr) {
            topLeft = docLTR && openStart && first ? leftSide : fromPos.left;
            topRight = docLTR ? rightSide : wrapX(from, dir, "before");
            botLeft = docLTR ? leftSide : wrapX(to, dir, "after");
            botRight = docLTR && openEnd && last ? rightSide : toPos.right;
          } else {
            topLeft = !docLTR ? leftSide : wrapX(from, dir, "before");
            topRight = !docLTR && openStart && first ? rightSide : fromPos.right;
            botLeft = !docLTR && openEnd && last ? leftSide : toPos.left;
            botRight = !docLTR ? rightSide : wrapX(to, dir, "after");
          }
          add(topLeft, fromPos.top, topRight - topLeft, fromPos.bottom);
          if (fromPos.bottom < toPos.top) { add(leftSide, fromPos.bottom, null, toPos.top); }
          add(botLeft, toPos.top, botRight - botLeft, toPos.bottom);
        }

        if (!start || cmpCoords(fromPos, start) < 0) { start = fromPos; }
        if (cmpCoords(toPos, start) < 0) { start = toPos; }
        if (!end || cmpCoords(fromPos, end) < 0) { end = fromPos; }
        if (cmpCoords(toPos, end) < 0) { end = toPos; }
      });
      return {start: start, end: end}
    }

    var sFrom = range.from(), sTo = range.to();
    if (sFrom.line == sTo.line) {
      drawForLine(sFrom.line, sFrom.ch, sTo.ch);
    } else {
      var fromLine = getLine(doc, sFrom.line), toLine = getLine(doc, sTo.line);
      var singleVLine = visualLine(fromLine) == visualLine(toLine);
      var leftEnd = drawForLine(sFrom.line, sFrom.ch, singleVLine ? fromLine.text.length + 1 : null).end;
      var rightStart = drawForLine(sTo.line, singleVLine ? 0 : null, sTo.ch).start;
      if (singleVLine) {
        if (leftEnd.top < rightStart.top - 2) {
          add(leftEnd.right, leftEnd.top, null, leftEnd.bottom);
          add(leftSide, rightStart.top, rightStart.left, rightStart.bottom);
        } else {
          add(leftEnd.right, leftEnd.top, rightStart.left - leftEnd.right, leftEnd.bottom);
        }
      }
      if (leftEnd.bottom < rightStart.top)
        { add(leftSide, leftEnd.bottom, null, rightStart.top); }
    }

    output.appendChild(fragment);
  }

  // Cursor-blinking
  function restartBlink(cm) {
    if (!cm.state.focused) { return }
    var display = cm.display;
    clearInterval(display.blinker);
    var on = true;
    display.cursorDiv.style.visibility = "";
    if (cm.options.cursorBlinkRate > 0)
      { display.blinker = setInterval(function () {
        if (!cm.hasFocus()) { onBlur(cm); }
        display.cursorDiv.style.visibility = (on = !on) ? "" : "hidden";
      }, cm.options.cursorBlinkRate); }
    else if (cm.options.cursorBlinkRate < 0)
      { display.cursorDiv.style.visibility = "hidden"; }
  }

  function ensureFocus(cm) {
    if (!cm.hasFocus()) {
      cm.display.input.focus();
      if (!cm.state.focused) { onFocus(cm); }
    }
  }

  function delayBlurEvent(cm) {
    cm.state.delayingBlurEvent = true;
    setTimeout(function () { if (cm.state.delayingBlurEvent) {
      cm.state.delayingBlurEvent = false;
      if (cm.state.focused) { onBlur(cm); }
    } }, 100);
  }

  function onFocus(cm, e) {
    if (cm.state.delayingBlurEvent && !cm.state.draggingText) { cm.state.delayingBlurEvent = false; }

    if (cm.options.readOnly == "nocursor") { return }
    if (!cm.state.focused) {
      signal(cm, "focus", cm, e);
      cm.state.focused = true;
      addClass(cm.display.wrapper, "CodeMirror-focused");
      // This test prevents this from firing when a context
      // menu is closed (since the input reset would kill the
      // select-all detection hack)
      if (!cm.curOp && cm.display.selForContextMenu != cm.doc.sel) {
        cm.display.input.reset();
        if (webkit) { setTimeout(function () { return cm.display.input.reset(true); }, 20); } // Issue #1730
      }
      cm.display.input.receivedFocus();
    }
    restartBlink(cm);
  }
  function onBlur(cm, e) {
    if (cm.state.delayingBlurEvent) { return }

    if (cm.state.focused) {
      signal(cm, "blur", cm, e);
      cm.state.focused = false;
      rmClass(cm.display.wrapper, "CodeMirror-focused");
    }
    clearInterval(cm.display.blinker);
    setTimeout(function () { if (!cm.state.focused) { cm.display.shift = false; } }, 150);
  }

  // Read the actual heights of the rendered lines, and update their
  // stored heights to match.
  function updateHeightsInViewport(cm) {
    var display = cm.display;
    var prevBottom = display.lineDiv.offsetTop;
    var viewTop = Math.max(0, display.scroller.getBoundingClientRect().top);
    var oldHeight = display.lineDiv.getBoundingClientRect().top;
    var mustScroll = 0;
    for (var i = 0; i < display.view.length; i++) {
      var cur = display.view[i], wrapping = cm.options.lineWrapping;
      var height = (void 0), width = 0;
      if (cur.hidden) { continue }
      oldHeight += cur.line.height;
      if (ie && ie_version < 8) {
        var bot = cur.node.offsetTop + cur.node.offsetHeight;
        height = bot - prevBottom;
        prevBottom = bot;
      } else {
        var box = cur.node.getBoundingClientRect();
        height = box.bottom - box.top;
        // Check that lines don't extend past the right of the current
        // editor width
        if (!wrapping && cur.text.firstChild)
          { width = cur.text.firstChild.getBoundingClientRect().right - box.left - 1; }
      }
      var diff = cur.line.height - height;
      if (diff > .005 || diff < -.005) {
        if (oldHeight < viewTop) { mustScroll -= diff; }
        updateLineHeight(cur.line, height);
        updateWidgetHeight(cur.line);
        if (cur.rest) { for (var j = 0; j < cur.rest.length; j++)
          { updateWidgetHeight(cur.rest[j]); } }
      }
      if (width > cm.display.sizerWidth) {
        var chWidth = Math.ceil(width / charWidth(cm.display));
        if (chWidth > cm.display.maxLineLength) {
          cm.display.maxLineLength = chWidth;
          cm.display.maxLine = cur.line;
          cm.display.maxLineChanged = true;
        }
      }
    }
    if (Math.abs(mustScroll) > 2) { display.scroller.scrollTop += mustScroll; }
  }

  // Read and store the height of line widgets associated with the
  // given line.
  function updateWidgetHeight(line) {
    if (line.widgets) { for (var i = 0; i < line.widgets.length; ++i) {
      var w = line.widgets[i], parent = w.node.parentNode;
      if (parent) { w.height = parent.offsetHeight; }
    } }
  }

  // Compute the lines that are visible in a given viewport (defaults
  // the the current scroll position). viewport may contain top,
  // height, and ensure (see op.scrollToPos) properties.
  function visibleLines(display, doc, viewport) {
    var top = viewport && viewport.top != null ? Math.max(0, viewport.top) : display.scroller.scrollTop;
    top = Math.floor(top - paddingTop(display));
    var bottom = viewport && viewport.bottom != null ? viewport.bottom : top + display.wrapper.clientHeight;

    var from = lineAtHeight(doc, top), to = lineAtHeight(doc, bottom);
    // Ensure is a {from: {line, ch}, to: {line, ch}} object, and
    // forces those lines into the viewport (if possible).
    if (viewport && viewport.ensure) {
      var ensureFrom = viewport.ensure.from.line, ensureTo = viewport.ensure.to.line;
      if (ensureFrom < from) {
        from = ensureFrom;
        to = lineAtHeight(doc, heightAtLine(getLine(doc, ensureFrom)) + display.wrapper.clientHeight);
      } else if (Math.min(ensureTo, doc.lastLine()) >= to) {
        from = lineAtHeight(doc, heightAtLine(getLine(doc, ensureTo)) - display.wrapper.clientHeight);
        to = ensureTo;
      }
    }
    return {from: from, to: Math.max(to, from + 1)}
  }

  // SCROLLING THINGS INTO VIEW

  // If an editor sits on the top or bottom of the window, partially
  // scrolled out of view, this ensures that the cursor is visible.
  function maybeScrollWindow(cm, rect) {
    if (signalDOMEvent(cm, "scrollCursorIntoView")) { return }

    var display = cm.display, box = display.sizer.getBoundingClientRect(), doScroll = null;
    if (rect.top + box.top < 0) { doScroll = true; }
    else if (rect.bottom + box.top > (window.innerHeight || document.documentElement.clientHeight)) { doScroll = false; }
    if (doScroll != null && !phantom) {
      var scrollNode = elt("div", "\u200b", null, ("position: absolute;\n                         top: " + (rect.top - display.viewOffset - paddingTop(cm.display)) + "px;\n                         height: " + (rect.bottom - rect.top + scrollGap(cm) + display.barHeight) + "px;\n                         left: " + (rect.left) + "px; width: " + (Math.max(2, rect.right - rect.left)) + "px;"));
      cm.display.lineSpace.appendChild(scrollNode);
      scrollNode.scrollIntoView(doScroll);
      cm.display.lineSpace.removeChild(scrollNode);
    }
  }

  // Scroll a given position into view (immediately), verifying that
  // it actually became visible (as line heights are accurately
  // measured, the position of something may 'drift' during drawing).
  function scrollPosIntoView(cm, pos, end, margin) {
    if (margin == null) { margin = 0; }
    var rect;
    if (!cm.options.lineWrapping && pos == end) {
      // Set pos and end to the cursor positions around the character pos sticks to
      // If pos.sticky == "before", that is around pos.ch - 1, otherwise around pos.ch
      // If pos == Pos(_, 0, "before"), pos and end are unchanged
      end = pos.sticky == "before" ? Pos(pos.line, pos.ch + 1, "before") : pos;
      pos = pos.ch ? Pos(pos.line, pos.sticky == "before" ? pos.ch - 1 : pos.ch, "after") : pos;
    }
    for (var limit = 0; limit < 5; limit++) {
      var changed = false;
      var coords = cursorCoords(cm, pos);
      var endCoords = !end || end == pos ? coords : cursorCoords(cm, end);
      rect = {left: Math.min(coords.left, endCoords.left),
              top: Math.min(coords.top, endCoords.top) - margin,
              right: Math.max(coords.left, endCoords.left),
              bottom: Math.max(coords.bottom, endCoords.bottom) + margin};
      var scrollPos = calculateScrollPos(cm, rect);
      var startTop = cm.doc.scrollTop, startLeft = cm.doc.scrollLeft;
      if (scrollPos.scrollTop != null) {
        updateScrollTop(cm, scrollPos.scrollTop);
        if (Math.abs(cm.doc.scrollTop - startTop) > 1) { changed = true; }
      }
      if (scrollPos.scrollLeft != null) {
        setScrollLeft(cm, scrollPos.scrollLeft);
        if (Math.abs(cm.doc.scrollLeft - startLeft) > 1) { changed = true; }
      }
      if (!changed) { break }
    }
    return rect
  }

  // Scroll a given set of coordinates into view (immediately).
  function scrollIntoView(cm, rect) {
    var scrollPos = calculateScrollPos(cm, rect);
    if (scrollPos.scrollTop != null) { updateScrollTop(cm, scrollPos.scrollTop); }
    if (scrollPos.scrollLeft != null) { setScrollLeft(cm, scrollPos.scrollLeft); }
  }

  // Calculate a new scroll position needed to scroll the given
  // rectangle into view. Returns an object with scrollTop and
  // scrollLeft properties. When these are undefined, the
  // vertical/horizontal position does not need to be adjusted.
  function calculateScrollPos(cm, rect) {
    var display = cm.display, snapMargin = textHeight(cm.display);
    if (rect.top < 0) { rect.top = 0; }
    var screentop = cm.curOp && cm.curOp.scrollTop != null ? cm.curOp.scrollTop : display.scroller.scrollTop;
    var screen = displayHeight(cm), result = {};
    if (rect.bottom - rect.top > screen) { rect.bottom = rect.top + screen; }
    var docBottom = cm.doc.height + paddingVert(display);
    var atTop = rect.top < snapMargin, atBottom = rect.bottom > docBottom - snapMargin;
    if (rect.top < screentop) {
      result.scrollTop = atTop ? 0 : rect.top;
    } else if (rect.bottom > screentop + screen) {
      var newTop = Math.min(rect.top, (atBottom ? docBottom : rect.bottom) - screen);
      if (newTop != screentop) { result.scrollTop = newTop; }
    }

    var gutterSpace = cm.options.fixedGutter ? 0 : display.gutters.offsetWidth;
    var screenleft = cm.curOp && cm.curOp.scrollLeft != null ? cm.curOp.scrollLeft : display.scroller.scrollLeft - gutterSpace;
    var screenw = displayWidth(cm) - display.gutters.offsetWidth;
    var tooWide = rect.right - rect.left > screenw;
    if (tooWide) { rect.right = rect.left + screenw; }
    if (rect.left < 10)
      { result.scrollLeft = 0; }
    else if (rect.left < screenleft)
      { result.scrollLeft = Math.max(0, rect.left + gutterSpace - (tooWide ? 0 : 10)); }
    else if (rect.right > screenw + screenleft - 3)
      { result.scrollLeft = rect.right + (tooWide ? 0 : 10) - screenw; }
    return result
  }

  // Store a relative adjustment to the scroll position in the current
  // operation (to be applied when the operation finishes).
  function addToScrollTop(cm, top) {
    if (top == null) { return }
    resolveScrollToPos(cm);
    cm.curOp.scrollTop = (cm.curOp.scrollTop == null ? cm.doc.scrollTop : cm.curOp.scrollTop) + top;
  }

  // Make sure that at the end of the operation the current cursor is
  // shown.
  function ensureCursorVisible(cm) {
    resolveScrollToPos(cm);
    var cur = cm.getCursor();
    cm.curOp.scrollToPos = {from: cur, to: cur, margin: cm.options.cursorScrollMargin};
  }

  function scrollToCoords(cm, x, y) {
    if (x != null || y != null) { resolveScrollToPos(cm); }
    if (x != null) { cm.curOp.scrollLeft = x; }
    if (y != null) { cm.curOp.scrollTop = y; }
  }

  function scrollToRange(cm, range) {
    resolveScrollToPos(cm);
    cm.curOp.scrollToPos = range;
  }

  // When an operation has its scrollToPos property set, and another
  // scroll action is applied before the end of the operation, this
  // 'simulates' scrolling that position into view in a cheap way, so
  // that the effect of intermediate scroll commands is not ignored.
  function resolveScrollToPos(cm) {
    var range = cm.curOp.scrollToPos;
    if (range) {
      cm.curOp.scrollToPos = null;
      var from = estimateCoords(cm, range.from), to = estimateCoords(cm, range.to);
      scrollToCoordsRange(cm, from, to, range.margin);
    }
  }

  function scrollToCoordsRange(cm, from, to, margin) {
    var sPos = calculateScrollPos(cm, {
      left: Math.min(from.left, to.left),
      top: Math.min(from.top, to.top) - margin,
      right: Math.max(from.right, to.right),
      bottom: Math.max(from.bottom, to.bottom) + margin
    });
    scrollToCoords(cm, sPos.scrollLeft, sPos.scrollTop);
  }

  // Sync the scrollable area and scrollbars, ensure the viewport
  // covers the visible area.
  function updateScrollTop(cm, val) {
    if (Math.abs(cm.doc.scrollTop - val) < 2) { return }
    if (!gecko) { updateDisplaySimple(cm, {top: val}); }
    setScrollTop(cm, val, true);
    if (gecko) { updateDisplaySimple(cm); }
    startWorker(cm, 100);
  }

  function setScrollTop(cm, val, forceScroll) {
    val = Math.max(0, Math.min(cm.display.scroller.scrollHeight - cm.display.scroller.clientHeight, val));
    if (cm.display.scroller.scrollTop == val && !forceScroll) { return }
    cm.doc.scrollTop = val;
    cm.display.scrollbars.setScrollTop(val);
    if (cm.display.scroller.scrollTop != val) { cm.display.scroller.scrollTop = val; }
  }

  // Sync scroller and scrollbar, ensure the gutter elements are
  // aligned.
  function setScrollLeft(cm, val, isScroller, forceScroll) {
    val = Math.max(0, Math.min(val, cm.display.scroller.scrollWidth - cm.display.scroller.clientWidth));
    if ((isScroller ? val == cm.doc.scrollLeft : Math.abs(cm.doc.scrollLeft - val) < 2) && !forceScroll) { return }
    cm.doc.scrollLeft = val;
    alignHorizontally(cm);
    if (cm.display.scroller.scrollLeft != val) { cm.display.scroller.scrollLeft = val; }
    cm.display.scrollbars.setScrollLeft(val);
  }

  // SCROLLBARS

  // Prepare DOM reads needed to update the scrollbars. Done in one
  // shot to minimize update/measure roundtrips.
  function measureForScrollbars(cm) {
    var d = cm.display, gutterW = d.gutters.offsetWidth;
    var docH = Math.round(cm.doc.height + paddingVert(cm.display));
    return {
      clientHeight: d.scroller.clientHeight,
      viewHeight: d.wrapper.clientHeight,
      scrollWidth: d.scroller.scrollWidth, clientWidth: d.scroller.clientWidth,
      viewWidth: d.wrapper.clientWidth,
      barLeft: cm.options.fixedGutter ? gutterW : 0,
      docHeight: docH,
      scrollHeight: docH + scrollGap(cm) + d.barHeight,
      nativeBarWidth: d.nativeBarWidth,
      gutterWidth: gutterW
    }
  }

  var NativeScrollbars = function(place, scroll, cm) {
    this.cm = cm;
    var vert = this.vert = elt("div", [elt("div", null, null, "min-width: 1px")], "CodeMirror-vscrollbar");
    var horiz = this.horiz = elt("div", [elt("div", null, null, "height: 100%; min-height: 1px")], "CodeMirror-hscrollbar");
    vert.tabIndex = horiz.tabIndex = -1;
    place(vert); place(horiz);

    on(vert, "scroll", function () {
      if (vert.clientHeight) { scroll(vert.scrollTop, "vertical"); }
    });
    on(horiz, "scroll", function () {
      if (horiz.clientWidth) { scroll(horiz.scrollLeft, "horizontal"); }
    });

    this.checkedZeroWidth = false;
    // Need to set a minimum width to see the scrollbar on IE7 (but must not set it on IE8).
    if (ie && ie_version < 8) { this.horiz.style.minHeight = this.vert.style.minWidth = "18px"; }
  };

  NativeScrollbars.prototype.update = function (measure) {
    var needsH = measure.scrollWidth > measure.clientWidth + 1;
    var needsV = measure.scrollHeight > measure.clientHeight + 1;
    var sWidth = measure.nativeBarWidth;

    if (needsV) {
      this.vert.style.display = "block";
      this.vert.style.bottom = needsH ? sWidth + "px" : "0";
      var totalHeight = measure.viewHeight - (needsH ? sWidth : 0);
      // A bug in IE8 can cause this value to be negative, so guard it.
      this.vert.firstChild.style.height =
        Math.max(0, measure.scrollHeight - measure.clientHeight + totalHeight) + "px";
    } else {
      this.vert.scrollTop = 0;
      this.vert.style.display = "";
      this.vert.firstChild.style.height = "0";
    }

    if (needsH) {
      this.horiz.style.display = "block";
      this.horiz.style.right = needsV ? sWidth + "px" : "0";
      this.horiz.style.left = measure.barLeft + "px";
      var totalWidth = measure.viewWidth - measure.barLeft - (needsV ? sWidth : 0);
      this.horiz.firstChild.style.width =
        Math.max(0, measure.scrollWidth - measure.clientWidth + totalWidth) + "px";
    } else {
      this.horiz.style.display = "";
      this.horiz.firstChild.style.width = "0";
    }

    if (!this.checkedZeroWidth && measure.clientHeight > 0) {
      if (sWidth == 0) { this.zeroWidthHack(); }
      this.checkedZeroWidth = true;
    }

    return {right: needsV ? sWidth : 0, bottom: needsH ? sWidth : 0}
  };

  NativeScrollbars.prototype.setScrollLeft = function (pos) {
    if (this.horiz.scrollLeft != pos) { this.horiz.scrollLeft = pos; }
    if (this.disableHoriz) { this.enableZeroWidthBar(this.horiz, this.disableHoriz, "horiz"); }
  };

  NativeScrollbars.prototype.setScrollTop = function (pos) {
    if (this.vert.scrollTop != pos) { this.vert.scrollTop = pos; }
    if (this.disableVert) { this.enableZeroWidthBar(this.vert, this.disableVert, "vert"); }
  };

  NativeScrollbars.prototype.zeroWidthHack = function () {
    var w = mac && !mac_geMountainLion ? "12px" : "18px";
    this.horiz.style.height = this.vert.style.width = w;
    this.horiz.style.pointerEvents = this.vert.style.pointerEvents = "none";
    this.disableHoriz = new Delayed;
    this.disableVert = new Delayed;
  };

  NativeScrollbars.prototype.enableZeroWidthBar = function (bar, delay, type) {
    bar.style.pointerEvents = "auto";
    function maybeDisable() {
      // To find out whether the scrollbar is still visible, we
      // check whether the element under the pixel in the bottom
      // right corner of the scrollbar box is the scrollbar box
      // itself (when the bar is still visible) or its filler child
      // (when the bar is hidden). If it is still visible, we keep
      // it enabled, if it's hidden, we disable pointer events.
      var box = bar.getBoundingClientRect();
      var elt = type == "vert" ? document.elementFromPoint(box.right - 1, (box.top + box.bottom) / 2)
          : document.elementFromPoint((box.right + box.left) / 2, box.bottom - 1);
      if (elt != bar) { bar.style.pointerEvents = "none"; }
      else { delay.set(1000, maybeDisable); }
    }
    delay.set(1000, maybeDisable);
  };

  NativeScrollbars.prototype.clear = function () {
    var parent = this.horiz.parentNode;
    parent.removeChild(this.horiz);
    parent.removeChild(this.vert);
  };

  var NullScrollbars = function () {};

  NullScrollbars.prototype.update = function () { return {bottom: 0, right: 0} };
  NullScrollbars.prototype.setScrollLeft = function () {};
  NullScrollbars.prototype.setScrollTop = function () {};
  NullScrollbars.prototype.clear = function () {};

  function updateScrollbars(cm, measure) {
    if (!measure) { measure = measureForScrollbars(cm); }
    var startWidth = cm.display.barWidth, startHeight = cm.display.barHeight;
    updateScrollbarsInner(cm, measure);
    for (var i = 0; i < 4 && startWidth != cm.display.barWidth || startHeight != cm.display.barHeight; i++) {
      if (startWidth != cm.display.barWidth && cm.options.lineWrapping)
        { updateHeightsInViewport(cm); }
      updateScrollbarsInner(cm, measureForScrollbars(cm));
      startWidth = cm.display.barWidth; startHeight = cm.display.barHeight;
    }
  }

  // Re-synchronize the fake scrollbars with the actual size of the
  // content.
  function updateScrollbarsInner(cm, measure) {
    var d = cm.display;
    var sizes = d.scrollbars.update(measure);

    d.sizer.style.paddingRight = (d.barWidth = sizes.right) + "px";
    d.sizer.style.paddingBottom = (d.barHeight = sizes.bottom) + "px";
    d.heightForcer.style.borderBottom = sizes.bottom + "px solid transparent";

    if (sizes.right && sizes.bottom) {
      d.scrollbarFiller.style.display = "block";
      d.scrollbarFiller.style.height = sizes.bottom + "px";
      d.scrollbarFiller.style.width = sizes.right + "px";
    } else { d.scrollbarFiller.style.display = ""; }
    if (sizes.bottom && cm.options.coverGutterNextToScrollbar && cm.options.fixedGutter) {
      d.gutterFiller.style.display = "block";
      d.gutterFiller.style.height = sizes.bottom + "px";
      d.gutterFiller.style.width = measure.gutterWidth + "px";
    } else { d.gutterFiller.style.display = ""; }
  }

  var scrollbarModel = {"native": NativeScrollbars, "null": NullScrollbars};

  function initScrollbars(cm) {
    if (cm.display.scrollbars) {
      cm.display.scrollbars.clear();
      if (cm.display.scrollbars.addClass)
        { rmClass(cm.display.wrapper, cm.display.scrollbars.addClass); }
    }

    cm.display.scrollbars = new scrollbarModel[cm.options.scrollbarStyle](function (node) {
      cm.display.wrapper.insertBefore(node, cm.display.scrollbarFiller);
      // Prevent clicks in the scrollbars from killing focus
      on(node, "mousedown", function () {
        if (cm.state.focused) { setTimeout(function () { return cm.display.input.focus(); }, 0); }
      });
      node.setAttribute("cm-not-content", "true");
    }, function (pos, axis) {
      if (axis == "horizontal") { setScrollLeft(cm, pos); }
      else { updateScrollTop(cm, pos); }
    }, cm);
    if (cm.display.scrollbars.addClass)
      { addClass(cm.display.wrapper, cm.display.scrollbars.addClass); }
  }

  // Operations are used to wrap a series of changes to the editor
  // state in such a way that each change won't have to update the
  // cursor and display (which would be awkward, slow, and
  // error-prone). Instead, display updates are batched and then all
  // combined and executed at once.

  var nextOpId = 0;
  // Start a new operation.
  function startOperation(cm) {
    cm.curOp = {
      cm: cm,
      viewChanged: false,      // Flag that indicates that lines might need to be redrawn
      startHeight: cm.doc.height, // Used to detect need to update scrollbar
      forceUpdate: false,      // Used to force a redraw
      updateInput: 0,       // Whether to reset the input textarea
      typing: false,           // Whether this reset should be careful to leave existing text (for compositing)
      changeObjs: null,        // Accumulated changes, for firing change events
      cursorActivityHandlers: null, // Set of handlers to fire cursorActivity on
      cursorActivityCalled: 0, // Tracks which cursorActivity handlers have been called already
      selectionChanged: false, // Whether the selection needs to be redrawn
      updateMaxLine: false,    // Set when the widest line needs to be determined anew
      scrollLeft: null, scrollTop: null, // Intermediate scroll position, not pushed to DOM yet
      scrollToPos: null,       // Used to scroll to a specific position
      focus: false,
      id: ++nextOpId,          // Unique ID
      markArrays: null         // Used by addMarkedSpan
    };
    pushOperation(cm.curOp);
  }

  // Finish an operation, updating the display and signalling delayed events
  function endOperation(cm) {
    var op = cm.curOp;
    if (op) { finishOperation(op, function (group) {
      for (var i = 0; i < group.ops.length; i++)
        { group.ops[i].cm.curOp = null; }
      endOperations(group);
    }); }
  }

  // The DOM updates done when an operation finishes are batched so
  // that the minimum number of relayouts are required.
  function endOperations(group) {
    var ops = group.ops;
    for (var i = 0; i < ops.length; i++) // Read DOM
      { endOperation_R1(ops[i]); }
    for (var i$1 = 0; i$1 < ops.length; i$1++) // Write DOM (maybe)
      { endOperation_W1(ops[i$1]); }
    for (var i$2 = 0; i$2 < ops.length; i$2++) // Read DOM
      { endOperation_R2(ops[i$2]); }
    for (var i$3 = 0; i$3 < ops.length; i$3++) // Write DOM (maybe)
      { endOperation_W2(ops[i$3]); }
    for (var i$4 = 0; i$4 < ops.length; i$4++) // Read DOM
      { endOperation_finish(ops[i$4]); }
  }

  function endOperation_R1(op) {
    var cm = op.cm, display = cm.display;
    maybeClipScrollbars(cm);
    if (op.updateMaxLine) { findMaxLine(cm); }

    op.mustUpdate = op.viewChanged || op.forceUpdate || op.scrollTop != null ||
      op.scrollToPos && (op.scrollToPos.from.line < display.viewFrom ||
                         op.scrollToPos.to.line >= display.viewTo) ||
      display.maxLineChanged && cm.options.lineWrapping;
    op.update = op.mustUpdate &&
      new DisplayUpdate(cm, op.mustUpdate && {top: op.scrollTop, ensure: op.scrollToPos}, op.forceUpdate);
  }

  function endOperation_W1(op) {
    op.updatedDisplay = op.mustUpdate && updateDisplayIfNeeded(op.cm, op.update);
  }

  function endOperation_R2(op) {
    var cm = op.cm, display = cm.display;
    if (op.updatedDisplay) { updateHeightsInViewport(cm); }

    op.barMeasure = measureForScrollbars(cm);

    // If the max line changed since it was last measured, measure it,
    // and ensure the document's width matches it.
    // updateDisplay_W2 will use these properties to do the actual resizing
    if (display.maxLineChanged && !cm.options.lineWrapping) {
      op.adjustWidthTo = measureChar(cm, display.maxLine, display.maxLine.text.length).left + 3;
      cm.display.sizerWidth = op.adjustWidthTo;
      op.barMeasure.scrollWidth =
        Math.max(display.scroller.clientWidth, display.sizer.offsetLeft + op.adjustWidthTo + scrollGap(cm) + cm.display.barWidth);
      op.maxScrollLeft = Math.max(0, display.sizer.offsetLeft + op.adjustWidthTo - displayWidth(cm));
    }

    if (op.updatedDisplay || op.selectionChanged)
      { op.preparedSelection = display.input.prepareSelection(); }
  }

  function endOperation_W2(op) {
    var cm = op.cm;

    if (op.adjustWidthTo != null) {
      cm.display.sizer.style.minWidth = op.adjustWidthTo + "px";
      if (op.maxScrollLeft < cm.doc.scrollLeft)
        { setScrollLeft(cm, Math.min(cm.display.scroller.scrollLeft, op.maxScrollLeft), true); }
      cm.display.maxLineChanged = false;
    }

    var takeFocus = op.focus && op.focus == activeElt();
    if (op.preparedSelection)
      { cm.display.input.showSelection(op.preparedSelection, takeFocus); }
    if (op.updatedDisplay || op.startHeight != cm.doc.height)
      { updateScrollbars(cm, op.barMeasure); }
    if (op.updatedDisplay)
      { setDocumentHeight(cm, op.barMeasure); }

    if (op.selectionChanged) { restartBlink(cm); }

    if (cm.state.focused && op.updateInput)
      { cm.display.input.reset(op.typing); }
    if (takeFocus) { ensureFocus(op.cm); }
  }

  function endOperation_finish(op) {
    var cm = op.cm, display = cm.display, doc = cm.doc;

    if (op.updatedDisplay) { postUpdateDisplay(cm, op.update); }

    // Abort mouse wheel delta measurement, when scrolling explicitly
    if (display.wheelStartX != null && (op.scrollTop != null || op.scrollLeft != null || op.scrollToPos))
      { display.wheelStartX = display.wheelStartY = null; }

    // Propagate the scroll position to the actual DOM scroller
    if (op.scrollTop != null) { setScrollTop(cm, op.scrollTop, op.forceScroll); }

    if (op.scrollLeft != null) { setScrollLeft(cm, op.scrollLeft, true, true); }
    // If we need to scroll a specific position into view, do so.
    if (op.scrollToPos) {
      var rect = scrollPosIntoView(cm, clipPos(doc, op.scrollToPos.from),
                                   clipPos(doc, op.scrollToPos.to), op.scrollToPos.margin);
      maybeScrollWindow(cm, rect);
    }

    // Fire events for markers that are hidden/unidden by editing or
    // undoing
    var hidden = op.maybeHiddenMarkers, unhidden = op.maybeUnhiddenMarkers;
    if (hidden) { for (var i = 0; i < hidden.length; ++i)
      { if (!hidden[i].lines.length) { signal(hidden[i], "hide"); } } }
    if (unhidden) { for (var i$1 = 0; i$1 < unhidden.length; ++i$1)
      { if (unhidden[i$1].lines.length) { signal(unhidden[i$1], "unhide"); } } }

    if (display.wrapper.offsetHeight)
      { doc.scrollTop = cm.display.scroller.scrollTop; }

    // Fire change events, and delayed event handlers
    if (op.changeObjs)
      { signal(cm, "changes", cm, op.changeObjs); }
    if (op.update)
      { op.update.finish(); }
  }

  // Run the given function in an operation
  function runInOp(cm, f) {
    if (cm.curOp) { return f() }
    startOperation(cm);
    try { return f() }
    finally { endOperation(cm); }
  }
  // Wraps a function in an operation. Returns the wrapped function.
  function operation(cm, f) {
    return function() {
      if (cm.curOp) { return f.apply(cm, arguments) }
      startOperation(cm);
      try { return f.apply(cm, arguments) }
      finally { endOperation(cm); }
    }
  }
  // Used to add methods to editor and doc instances, wrapping them in
  // operations.
  function methodOp(f) {
    return function() {
      if (this.curOp) { return f.apply(this, arguments) }
      startOperation(this);
      try { return f.apply(this, arguments) }
      finally { endOperation(this); }
    }
  }
  function docMethodOp(f) {
    return function() {
      var cm = this.cm;
      if (!cm || cm.curOp) { return f.apply(this, arguments) }
      startOperation(cm);
      try { return f.apply(this, arguments) }
      finally { endOperation(cm); }
    }
  }

  // HIGHLIGHT WORKER

  function startWorker(cm, time) {
    if (cm.doc.highlightFrontier < cm.display.viewTo)
      { cm.state.highlight.set(time, bind(highlightWorker, cm)); }
  }

  function highlightWorker(cm) {
    var doc = cm.doc;
    if (doc.highlightFrontier >= cm.display.viewTo) { return }
    var end = +new Date + cm.options.workTime;
    var context = getContextBefore(cm, doc.highlightFrontier);
    var changedLines = [];

    doc.iter(context.line, Math.min(doc.first + doc.size, cm.display.viewTo + 500), function (line) {
      if (context.line >= cm.display.viewFrom) { // Visible
        var oldStyles = line.styles;
        var resetState = line.text.length > cm.options.maxHighlightLength ? copyState(doc.mode, context.state) : null;
        var highlighted = highlightLine(cm, line, context, true);
        if (resetState) { context.state = resetState; }
        line.styles = highlighted.styles;
        var oldCls = line.styleClasses, newCls = highlighted.classes;
        if (newCls) { line.styleClasses = newCls; }
        else if (oldCls) { line.styleClasses = null; }
        var ischange = !oldStyles || oldStyles.length != line.styles.length ||
          oldCls != newCls && (!oldCls || !newCls || oldCls.bgClass != newCls.bgClass || oldCls.textClass != newCls.textClass);
        for (var i = 0; !ischange && i < oldStyles.length; ++i) { ischange = oldStyles[i] != line.styles[i]; }
        if (ischange) { changedLines.push(context.line); }
        line.stateAfter = context.save();
        context.nextLine();
      } else {
        if (line.text.length <= cm.options.maxHighlightLength)
          { processLine(cm, line.text, context); }
        line.stateAfter = context.line % 5 == 0 ? context.save() : null;
        context.nextLine();
      }
      if (+new Date > end) {
        startWorker(cm, cm.options.workDelay);
        return true
      }
    });
    doc.highlightFrontier = context.line;
    doc.modeFrontier = Math.max(doc.modeFrontier, context.line);
    if (changedLines.length) { runInOp(cm, function () {
      for (var i = 0; i < changedLines.length; i++)
        { regLineChange(cm, changedLines[i], "text"); }
    }); }
  }

  // DISPLAY DRAWING

  var DisplayUpdate = function(cm, viewport, force) {
    var display = cm.display;

    this.viewport = viewport;
    // Store some values that we'll need later (but don't want to force a relayout for)
    this.visible = visibleLines(display, cm.doc, viewport);
    this.editorIsHidden = !display.wrapper.offsetWidth;
    this.wrapperHeight = display.wrapper.clientHeight;
    this.wrapperWidth = display.wrapper.clientWidth;
    this.oldDisplayWidth = displayWidth(cm);
    this.force = force;
    this.dims = getDimensions(cm);
    this.events = [];
  };

  DisplayUpdate.prototype.signal = function (emitter, type) {
    if (hasHandler(emitter, type))
      { this.events.push(arguments); }
  };
  DisplayUpdate.prototype.finish = function () {
    for (var i = 0; i < this.events.length; i++)
      { signal.apply(null, this.events[i]); }
  };

  function maybeClipScrollbars(cm) {
    var display = cm.display;
    if (!display.scrollbarsClipped && display.scroller.offsetWidth) {
      display.nativeBarWidth = display.scroller.offsetWidth - display.scroller.clientWidth;
      display.heightForcer.style.height = scrollGap(cm) + "px";
      display.sizer.style.marginBottom = -display.nativeBarWidth + "px";
      display.sizer.style.borderRightWidth = scrollGap(cm) + "px";
      display.scrollbarsClipped = true;
    }
  }

  function selectionSnapshot(cm) {
    if (cm.hasFocus()) { return null }
    var active = activeElt();
    if (!active || !contains(cm.display.lineDiv, active)) { return null }
    var result = {activeElt: active};
    if (window.getSelection) {
      var sel = window.getSelection();
      if (sel.anchorNode && sel.extend && contains(cm.display.lineDiv, sel.anchorNode)) {
        result.anchorNode = sel.anchorNode;
        result.anchorOffset = sel.anchorOffset;
        result.focusNode = sel.focusNode;
        result.focusOffset = sel.focusOffset;
      }
    }
    return result
  }

  function restoreSelection(snapshot) {
    if (!snapshot || !snapshot.activeElt || snapshot.activeElt == activeElt()) { return }
    snapshot.activeElt.focus();
    if (!/^(INPUT|TEXTAREA)$/.test(snapshot.activeElt.nodeName) &&
        snapshot.anchorNode && contains(document.body, snapshot.anchorNode) && contains(document.body, snapshot.focusNode)) {
      var sel = window.getSelection(), range = document.createRange();
      range.setEnd(snapshot.anchorNode, snapshot.anchorOffset);
      range.collapse(false);
      sel.removeAllRanges();
      sel.addRange(range);
      sel.extend(snapshot.focusNode, snapshot.focusOffset);
    }
  }

  // Does the actual updating of the line display. Bails out
  // (returning false) when there is nothing to be done and forced is
  // false.
  function updateDisplayIfNeeded(cm, update) {
    var display = cm.display, doc = cm.doc;

    if (update.editorIsHidden) {
      resetView(cm);
      return false
    }

    // Bail out if the visible area is already rendered and nothing changed.
    if (!update.force &&
        update.visible.from >= display.viewFrom && update.visible.to <= display.viewTo &&
        (display.updateLineNumbers == null || display.updateLineNumbers >= display.viewTo) &&
        display.renderedView == display.view && countDirtyView(cm) == 0)
      { return false }

    if (maybeUpdateLineNumberWidth(cm)) {
      resetView(cm);
      update.dims = getDimensions(cm);
    }

    // Compute a suitable new viewport (from & to)
    var end = doc.first + doc.size;
    var from = Math.max(update.visible.from - cm.options.viewportMargin, doc.first);
    var to = Math.min(end, update.visible.to + cm.options.viewportMargin);
    if (display.viewFrom < from && from - display.viewFrom < 20) { from = Math.max(doc.first, display.viewFrom); }
    if (display.viewTo > to && display.viewTo - to < 20) { to = Math.min(end, display.viewTo); }
    if (sawCollapsedSpans) {
      from = visualLineNo(cm.doc, from);
      to = visualLineEndNo(cm.doc, to);
    }

    var different = from != display.viewFrom || to != display.viewTo ||
      display.lastWrapHeight != update.wrapperHeight || display.lastWrapWidth != update.wrapperWidth;
    adjustView(cm, from, to);

    display.viewOffset = heightAtLine(getLine(cm.doc, display.viewFrom));
    // Position the mover div to align with the current scroll position
    cm.display.mover.style.top = display.viewOffset + "px";

    var toUpdate = countDirtyView(cm);
    if (!different && toUpdate == 0 && !update.force && display.renderedView == display.view &&
        (display.updateLineNumbers == null || display.updateLineNumbers >= display.viewTo))
      { return false }

    // For big changes, we hide the enclosing element during the
    // update, since that speeds up the operations on most browsers.
    var selSnapshot = selectionSnapshot(cm);
    if (toUpdate > 4) { display.lineDiv.style.display = "none"; }
    patchDisplay(cm, display.updateLineNumbers, update.dims);
    if (toUpdate > 4) { display.lineDiv.style.display = ""; }
    display.renderedView = display.view;
    // There might have been a widget with a focused element that got
    // hidden or updated, if so re-focus it.
    restoreSelection(selSnapshot);

    // Prevent selection and cursors from interfering with the scroll
    // width and height.
    removeChildren(display.cursorDiv);
    removeChildren(display.selectionDiv);
    display.gutters.style.height = display.sizer.style.minHeight = 0;

    if (different) {
      display.lastWrapHeight = update.wrapperHeight;
      display.lastWrapWidth = update.wrapperWidth;
      startWorker(cm, 400);
    }

    display.updateLineNumbers = null;

    return true
  }

  function postUpdateDisplay(cm, update) {
    var viewport = update.viewport;

    for (var first = true;; first = false) {
      if (!first || !cm.options.lineWrapping || update.oldDisplayWidth == displayWidth(cm)) {
        // Clip forced viewport to actual scrollable area.
        if (viewport && viewport.top != null)
          { viewport = {top: Math.min(cm.doc.height + paddingVert(cm.display) - displayHeight(cm), viewport.top)}; }
        // Updated line heights might result in the drawn area not
        // actually covering the viewport. Keep looping until it does.
        update.visible = visibleLines(cm.display, cm.doc, viewport);
        if (update.visible.from >= cm.display.viewFrom && update.visible.to <= cm.display.viewTo)
          { break }
      } else if (first) {
        update.visible = visibleLines(cm.display, cm.doc, viewport);
      }
      if (!updateDisplayIfNeeded(cm, update)) { break }
      updateHeightsInViewport(cm);
      var barMeasure = measureForScrollbars(cm);
      updateSelection(cm);
      updateScrollbars(cm, barMeasure);
      setDocumentHeight(cm, barMeasure);
      update.force = false;
    }

    update.signal(cm, "update", cm);
    if (cm.display.viewFrom != cm.display.reportedViewFrom || cm.display.viewTo != cm.display.reportedViewTo) {
      update.signal(cm, "viewportChange", cm, cm.display.viewFrom, cm.display.viewTo);
      cm.display.reportedViewFrom = cm.display.viewFrom; cm.display.reportedViewTo = cm.display.viewTo;
    }
  }

  function updateDisplaySimple(cm, viewport) {
    var update = new DisplayUpdate(cm, viewport);
    if (updateDisplayIfNeeded(cm, update)) {
      updateHeightsInViewport(cm);
      postUpdateDisplay(cm, update);
      var barMeasure = measureForScrollbars(cm);
      updateSelection(cm);
      updateScrollbars(cm, barMeasure);
      setDocumentHeight(cm, barMeasure);
      update.finish();
    }
  }

  // Sync the actual display DOM structure with display.view, removing
  // nodes for lines that are no longer in view, and creating the ones
  // that are not there yet, and updating the ones that are out of
  // date.
  function patchDisplay(cm, updateNumbersFrom, dims) {
    var display = cm.display, lineNumbers = cm.options.lineNumbers;
    var container = display.lineDiv, cur = container.firstChild;

    function rm(node) {
      var next = node.nextSibling;
      // Works around a throw-scroll bug in OS X Webkit
      if (webkit && mac && cm.display.currentWheelTarget == node)
        { node.style.display = "none"; }
      else
        { node.parentNode.removeChild(node); }
      return next
    }

    var view = display.view, lineN = display.viewFrom;
    // Loop over the elements in the view, syncing cur (the DOM nodes
    // in display.lineDiv) with the view as we go.
    for (var i = 0; i < view.length; i++) {
      var lineView = view[i];
      if (lineView.hidden) ; else if (!lineView.node || lineView.node.parentNode != container) { // Not drawn yet
        var node = buildLineElement(cm, lineView, lineN, dims);
        container.insertBefore(node, cur);
      } else { // Already drawn
        while (cur != lineView.node) { cur = rm(cur); }
        var updateNumber = lineNumbers && updateNumbersFrom != null &&
          updateNumbersFrom <= lineN && lineView.lineNumber;
        if (lineView.changes) {
          if (indexOf(lineView.changes, "gutter") > -1) { updateNumber = false; }
          updateLineForChanges(cm, lineView, lineN, dims);
        }
        if (updateNumber) {
          removeChildren(lineView.lineNumber);
          lineView.lineNumber.appendChild(document.createTextNode(lineNumberFor(cm.options, lineN)));
        }
        cur = lineView.node.nextSibling;
      }
      lineN += lineView.size;
    }
    while (cur) { cur = rm(cur); }
  }

  function updateGutterSpace(display) {
    var width = display.gutters.offsetWidth;
    display.sizer.style.marginLeft = width + "px";
    // Send an event to consumers responding to changes in gutter width.
    signalLater(display, "gutterChanged", display);
  }

  function setDocumentHeight(cm, measure) {
    cm.display.sizer.style.minHeight = measure.docHeight + "px";
    cm.display.heightForcer.style.top = measure.docHeight + "px";
    cm.display.gutters.style.height = (measure.docHeight + cm.display.barHeight + scrollGap(cm)) + "px";
  }

  // Re-align line numbers and gutter marks to compensate for
  // horizontal scrolling.
  function alignHorizontally(cm) {
    var display = cm.display, view = display.view;
    if (!display.alignWidgets && (!display.gutters.firstChild || !cm.options.fixedGutter)) { return }
    var comp = compensateForHScroll(display) - display.scroller.scrollLeft + cm.doc.scrollLeft;
    var gutterW = display.gutters.offsetWidth, left = comp + "px";
    for (var i = 0; i < view.length; i++) { if (!view[i].hidden) {
      if (cm.options.fixedGutter) {
        if (view[i].gutter)
          { view[i].gutter.style.left = left; }
        if (view[i].gutterBackground)
          { view[i].gutterBackground.style.left = left; }
      }
      var align = view[i].alignable;
      if (align) { for (var j = 0; j < align.length; j++)
        { align[j].style.left = left; } }
    } }
    if (cm.options.fixedGutter)
      { display.gutters.style.left = (comp + gutterW) + "px"; }
  }

  // Used to ensure that the line number gutter is still the right
  // size for the current document size. Returns true when an update
  // is needed.
  function maybeUpdateLineNumberWidth(cm) {
    if (!cm.options.lineNumbers) { return false }
    var doc = cm.doc, last = lineNumberFor(cm.options, doc.first + doc.size - 1), display = cm.display;
    if (last.length != display.lineNumChars) {
      var test = display.measure.appendChild(elt("div", [elt("div", last)],
                                                 "CodeMirror-linenumber CodeMirror-gutter-elt"));
      var innerW = test.firstChild.offsetWidth, padding = test.offsetWidth - innerW;
      display.lineGutter.style.width = "";
      display.lineNumInnerWidth = Math.max(innerW, display.lineGutter.offsetWidth - padding) + 1;
      display.lineNumWidth = display.lineNumInnerWidth + padding;
      display.lineNumChars = display.lineNumInnerWidth ? last.length : -1;
      display.lineGutter.style.width = display.lineNumWidth + "px";
      updateGutterSpace(cm.display);
      return true
    }
    return false
  }

  function getGutters(gutters, lineNumbers) {
    var result = [], sawLineNumbers = false;
    for (var i = 0; i < gutters.length; i++) {
      var name = gutters[i], style = null;
      if (typeof name != "string") { style = name.style; name = name.className; }
      if (name == "CodeMirror-linenumbers") {
        if (!lineNumbers) { continue }
        else { sawLineNumbers = true; }
      }
      result.push({className: name, style: style});
    }
    if (lineNumbers && !sawLineNumbers) { result.push({className: "CodeMirror-linenumbers", style: null}); }
    return result
  }

  // Rebuild the gutter elements, ensure the margin to the left of the
  // code matches their width.
  function renderGutters(display) {
    var gutters = display.gutters, specs = display.gutterSpecs;
    removeChildren(gutters);
    display.lineGutter = null;
    for (var i = 0; i < specs.length; ++i) {
      var ref = specs[i];
      var className = ref.className;
      var style = ref.style;
      var gElt = gutters.appendChild(elt("div", null, "CodeMirror-gutter " + className));
      if (style) { gElt.style.cssText = style; }
      if (className == "CodeMirror-linenumbers") {
        display.lineGutter = gElt;
        gElt.style.width = (display.lineNumWidth || 1) + "px";
      }
    }
    gutters.style.display = specs.length ? "" : "none";
    updateGutterSpace(display);
  }

  function updateGutters(cm) {
    renderGutters(cm.display);
    regChange(cm);
    alignHorizontally(cm);
  }

  // The display handles the DOM integration, both for input reading
  // and content drawing. It holds references to DOM nodes and
  // display-related state.

  function Display(place, doc, input, options) {
    var d = this;
    this.input = input;

    // Covers bottom-right square when both scrollbars are present.
    d.scrollbarFiller = elt("div", null, "CodeMirror-scrollbar-filler");
    d.scrollbarFiller.setAttribute("cm-not-content", "true");
    // Covers bottom of gutter when coverGutterNextToScrollbar is on
    // and h scrollbar is present.
    d.gutterFiller = elt("div", null, "CodeMirror-gutter-filler");
    d.gutterFiller.setAttribute("cm-not-content", "true");
    // Will contain the actual code, positioned to cover the viewport.
    d.lineDiv = eltP("div", null, "CodeMirror-code");
    // Elements are added to these to represent selection and cursors.
    d.selectionDiv = elt("div", null, null, "position: relative; z-index: 1");
    d.cursorDiv = elt("div", null, "CodeMirror-cursors");
    // A visibility: hidden element used to find the size of things.
    d.measure = elt("div", null, "CodeMirror-measure");
    // When lines outside of the viewport are measured, they are drawn in this.
    d.lineMeasure = elt("div", null, "CodeMirror-measure");
    // Wraps everything that needs to exist inside the vertically-padded coordinate system
    d.lineSpace = eltP("div", [d.measure, d.lineMeasure, d.selectionDiv, d.cursorDiv, d.lineDiv],
                      null, "position: relative; outline: none");
    var lines = eltP("div", [d.lineSpace], "CodeMirror-lines");
    // Moved around its parent to cover visible view.
    d.mover = elt("div", [lines], null, "position: relative");
    // Set to the height of the document, allowing scrolling.
    d.sizer = elt("div", [d.mover], "CodeMirror-sizer");
    d.sizerWidth = null;
    // Behavior of elts with overflow: auto and padding is
    // inconsistent across browsers. This is used to ensure the
    // scrollable area is big enough.
    d.heightForcer = elt("div", null, null, "position: absolute; height: " + scrollerGap + "px; width: 1px;");
    // Will contain the gutters, if any.
    d.gutters = elt("div", null, "CodeMirror-gutters");
    d.lineGutter = null;
    // Actual scrollable element.
    d.scroller = elt("div", [d.sizer, d.heightForcer, d.gutters], "CodeMirror-scroll");
    d.scroller.setAttribute("tabIndex", "-1");
    // The element in which the editor lives.
    d.wrapper = elt("div", [d.scrollbarFiller, d.gutterFiller, d.scroller], "CodeMirror");

    // This attribute is respected by automatic translation systems such as Google Translate,
    // and may also be respected by tools used by human translators.
    d.wrapper.setAttribute('translate', 'no');

    // Work around IE7 z-index bug (not perfect, hence IE7 not really being supported)
    if (ie && ie_version < 8) { d.gutters.style.zIndex = -1; d.scroller.style.paddingRight = 0; }
    if (!webkit && !(gecko && mobile)) { d.scroller.draggable = true; }

    if (place) {
      if (place.appendChild) { place.appendChild(d.wrapper); }
      else { place(d.wrapper); }
    }

    // Current rendered range (may be bigger than the view window).
    d.viewFrom = d.viewTo = doc.first;
    d.reportedViewFrom = d.reportedViewTo = doc.first;
    // Information about the rendered lines.
    d.view = [];
    d.renderedView = null;
    // Holds info about a single rendered line when it was rendered
    // for measurement, while not in view.
    d.externalMeasured = null;
    // Empty space (in pixels) above the view
    d.viewOffset = 0;
    d.lastWrapHeight = d.lastWrapWidth = 0;
    d.updateLineNumbers = null;

    d.nativeBarWidth = d.barHeight = d.barWidth = 0;
    d.scrollbarsClipped = false;

    // Used to only resize the line number gutter when necessary (when
    // the amount of lines crosses a boundary that makes its width change)
    d.lineNumWidth = d.lineNumInnerWidth = d.lineNumChars = null;
    // Set to true when a non-horizontal-scrolling line widget is
    // added. As an optimization, line widget aligning is skipped when
    // this is false.
    d.alignWidgets = false;

    d.cachedCharWidth = d.cachedTextHeight = d.cachedPaddingH = null;

    // Tracks the maximum line length so that the horizontal scrollbar
    // can be kept static when scrolling.
    d.maxLine = null;
    d.maxLineLength = 0;
    d.maxLineChanged = false;

    // Used for measuring wheel scrolling granularity
    d.wheelDX = d.wheelDY = d.wheelStartX = d.wheelStartY = null;

    // True when shift is held down.
    d.shift = false;

    // Used to track whether anything happened since the context menu
    // was opened.
    d.selForContextMenu = null;

    d.activeTouch = null;

    d.gutterSpecs = getGutters(options.gutters, options.lineNumbers);
    renderGutters(d);

    input.init(d);
  }

  // Since the delta values reported on mouse wheel events are
  // unstandardized between browsers and even browser versions, and
  // generally horribly unpredictable, this code starts by measuring
  // the scroll effect that the first few mouse wheel events have,
  // and, from that, detects the way it can convert deltas to pixel
  // offsets afterwards.
  //
  // The reason we want to know the amount a wheel event will scroll
  // is that it gives us a chance to update the display before the
  // actual scrolling happens, reducing flickering.

  var wheelSamples = 0, wheelPixelsPerUnit = null;
  // Fill in a browser-detected starting value on browsers where we
  // know one. These don't have to be accurate -- the result of them
  // being wrong would just be a slight flicker on the first wheel
  // scroll (if it is large enough).
  if (ie) { wheelPixelsPerUnit = -.53; }
  else if (gecko) { wheelPixelsPerUnit = 15; }
  else if (chrome) { wheelPixelsPerUnit = -.7; }
  else if (safari) { wheelPixelsPerUnit = -1/3; }

  function wheelEventDelta(e) {
    var dx = e.wheelDeltaX, dy = e.wheelDeltaY;
    if (dx == null && e.detail && e.axis == e.HORIZONTAL_AXIS) { dx = e.detail; }
    if (dy == null && e.detail && e.axis == e.VERTICAL_AXIS) { dy = e.detail; }
    else if (dy == null) { dy = e.wheelDelta; }
    return {x: dx, y: dy}
  }
  function wheelEventPixels(e) {
    var delta = wheelEventDelta(e);
    delta.x *= wheelPixelsPerUnit;
    delta.y *= wheelPixelsPerUnit;
    return delta
  }

  function onScrollWheel(cm, e) {
    var delta = wheelEventDelta(e), dx = delta.x, dy = delta.y;
    var pixelsPerUnit = wheelPixelsPerUnit;
    if (e.deltaMode === 0) {
      dx = e.deltaX;
      dy = e.deltaY;
      pixelsPerUnit = 1;
    }

    var display = cm.display, scroll = display.scroller;
    // Quit if there's nothing to scroll here
    var canScrollX = scroll.scrollWidth > scroll.clientWidth;
    var canScrollY = scroll.scrollHeight > scroll.clientHeight;
    if (!(dx && canScrollX || dy && canScrollY)) { return }

    // Webkit browsers on OS X abort momentum scrolls when the target
    // of the scroll event is removed from the scrollable element.
    // This hack (see related code in patchDisplay) makes sure the
    // element is kept around.
    if (dy && mac && webkit) {
      outer: for (var cur = e.target, view = display.view; cur != scroll; cur = cur.parentNode) {
        for (var i = 0; i < view.length; i++) {
          if (view[i].node == cur) {
            cm.display.currentWheelTarget = cur;
            break outer
          }
        }
      }
    }

    // On some browsers, horizontal scrolling will cause redraws to
    // happen before the gutter has been realigned, causing it to
    // wriggle around in a most unseemly way. When we have an
    // estimated pixels/delta value, we just handle horizontal
    // scrolling entirely here. It'll be slightly off from native, but
    // better than glitching out.
    if (dx && !gecko && !presto && pixelsPerUnit != null) {
      if (dy && canScrollY)
        { updateScrollTop(cm, Math.max(0, scroll.scrollTop + dy * pixelsPerUnit)); }
      setScrollLeft(cm, Math.max(0, scroll.scrollLeft + dx * pixelsPerUnit));
      // Only prevent default scrolling if vertical scrolling is
      // actually possible. Otherwise, it causes vertical scroll
      // jitter on OSX trackpads when deltaX is small and deltaY
      // is large (issue #3579)
      if (!dy || (dy && canScrollY))
        { e_preventDefault(e); }
      display.wheelStartX = null; // Abort measurement, if in progress
      return
    }

    // 'Project' the visible viewport to cover the area that is being
    // scrolled into view (if we know enough to estimate it).
    if (dy && pixelsPerUnit != null) {
      var pixels = dy * pixelsPerUnit;
      var top = cm.doc.scrollTop, bot = top + display.wrapper.clientHeight;
      if (pixels < 0) { top = Math.max(0, top + pixels - 50); }
      else { bot = Math.min(cm.doc.height, bot + pixels + 50); }
      updateDisplaySimple(cm, {top: top, bottom: bot});
    }

    if (wheelSamples < 20 && e.deltaMode !== 0) {
      if (display.wheelStartX == null) {
        display.wheelStartX = scroll.scrollLeft; display.wheelStartY = scroll.scrollTop;
        display.wheelDX = dx; display.wheelDY = dy;
        setTimeout(function () {
          if (display.wheelStartX == null) { return }
          var movedX = scroll.scrollLeft - display.wheelStartX;
          var movedY = scroll.scrollTop - display.wheelStartY;
          var sample = (movedY && display.wheelDY && movedY / display.wheelDY) ||
            (movedX && display.wheelDX && movedX / display.wheelDX);
          display.wheelStartX = display.wheelStartY = null;
          if (!sample) { return }
          wheelPixelsPerUnit = (wheelPixelsPerUnit * wheelSamples + sample) / (wheelSamples + 1);
          ++wheelSamples;
        }, 200);
      } else {
        display.wheelDX += dx; display.wheelDY += dy;
      }
    }
  }

  // Selection objects are immutable. A new one is created every time
  // the selection changes. A selection is one or more non-overlapping
  // (and non-touching) ranges, sorted, and an integer that indicates
  // which one is the primary selection (the one that's scrolled into
  // view, that getCursor returns, etc).
  var Selection = function(ranges, primIndex) {
    this.ranges = ranges;
    this.primIndex = primIndex;
  };

  Selection.prototype.primary = function () { return this.ranges[this.primIndex] };

  Selection.prototype.equals = function (other) {
    if (other == this) { return true }
    if (other.primIndex != this.primIndex || other.ranges.length != this.ranges.length) { return false }
    for (var i = 0; i < this.ranges.length; i++) {
      var here = this.ranges[i], there = other.ranges[i];
      if (!equalCursorPos(here.anchor, there.anchor) || !equalCursorPos(here.head, there.head)) { return false }
    }
    return true
  };

  Selection.prototype.deepCopy = function () {
    var out = [];
    for (var i = 0; i < this.ranges.length; i++)
      { out[i] = new Range(copyPos(this.ranges[i].anchor), copyPos(this.ranges[i].head)); }
    return new Selection(out, this.primIndex)
  };

  Selection.prototype.somethingSelected = function () {
    for (var i = 0; i < this.ranges.length; i++)
      { if (!this.ranges[i].empty()) { return true } }
    return false
  };

  Selection.prototype.contains = function (pos, end) {
    if (!end) { end = pos; }
    for (var i = 0; i < this.ranges.length; i++) {
      var range = this.ranges[i];
      if (cmp(end, range.from()) >= 0 && cmp(pos, range.to()) <= 0)
        { return i }
    }
    return -1
  };

  var Range = function(anchor, head) {
    this.anchor = anchor; this.head = head;
  };

  Range.prototype.from = function () { return minPos(this.anchor, this.head) };
  Range.prototype.to = function () { return maxPos(this.anchor, this.head) };
  Range.prototype.empty = function () { return this.head.line == this.anchor.line && this.head.ch == this.anchor.ch };

  // Take an unsorted, potentially overlapping set of ranges, and
  // build a selection out of it. 'Consumes' ranges array (modifying
  // it).
  function normalizeSelection(cm, ranges, primIndex) {
    var mayTouch = cm && cm.options.selectionsMayTouch;
    var prim = ranges[primIndex];
    ranges.sort(function (a, b) { return cmp(a.from(), b.from()); });
    primIndex = indexOf(ranges, prim);
    for (var i = 1; i < ranges.length; i++) {
      var cur = ranges[i], prev = ranges[i - 1];
      var diff = cmp(prev.to(), cur.from());
      if (mayTouch && !cur.empty() ? diff > 0 : diff >= 0) {
        var from = minPos(prev.from(), cur.from()), to = maxPos(prev.to(), cur.to());
        var inv = prev.empty() ? cur.from() == cur.head : prev.from() == prev.head;
        if (i <= primIndex) { --primIndex; }
        ranges.splice(--i, 2, new Range(inv ? to : from, inv ? from : to));
      }
    }
    return new Selection(ranges, primIndex)
  }

  function simpleSelection(anchor, head) {
    return new Selection([new Range(anchor, head || anchor)], 0)
  }

  // Compute the position of the end of a change (its 'to' property
  // refers to the pre-change end).
  function changeEnd(change) {
    if (!change.text) { return change.to }
    return Pos(change.from.line + change.text.length - 1,
               lst(change.text).length + (change.text.length == 1 ? change.from.ch : 0))
  }

  // Adjust a position to refer to the post-change position of the
  // same text, or the end of the change if the change covers it.
  function adjustForChange(pos, change) {
    if (cmp(pos, change.from) < 0) { return pos }
    if (cmp(pos, change.to) <= 0) { return changeEnd(change) }

    var line = pos.line + change.text.length - (change.to.line - change.from.line) - 1, ch = pos.ch;
    if (pos.line == change.to.line) { ch += changeEnd(change).ch - change.to.ch; }
    return Pos(line, ch)
  }

  function computeSelAfterChange(doc, change) {
    var out = [];
    for (var i = 0; i < doc.sel.ranges.length; i++) {
      var range = doc.sel.ranges[i];
      out.push(new Range(adjustForChange(range.anchor, change),
                         adjustForChange(range.head, change)));
    }
    return normalizeSelection(doc.cm, out, doc.sel.primIndex)
  }

  function offsetPos(pos, old, nw) {
    if (pos.line == old.line)
      { return Pos(nw.line, pos.ch - old.ch + nw.ch) }
    else
      { return Pos(nw.line + (pos.line - old.line), pos.ch) }
  }

  // Used by replaceSelections to allow moving the selection to the
  // start or around the replaced test. Hint may be "start" or "around".
  function computeReplacedSel(doc, changes, hint) {
    var out = [];
    var oldPrev = Pos(doc.first, 0), newPrev = oldPrev;
    for (var i = 0; i < changes.length; i++) {
      var change = changes[i];
      var from = offsetPos(change.from, oldPrev, newPrev);
      var to = offsetPos(changeEnd(change), oldPrev, newPrev);
      oldPrev = change.to;
      newPrev = to;
      if (hint == "around") {
        var range = doc.sel.ranges[i], inv = cmp(range.head, range.anchor) < 0;
        out[i] = new Range(inv ? to : from, inv ? from : to);
      } else {
        out[i] = new Range(from, from);
      }
    }
    return new Selection(out, doc.sel.primIndex)
  }

  // Used to get the editor into a consistent state again when options change.

  function loadMode(cm) {
    cm.doc.mode = getMode(cm.options, cm.doc.modeOption);
    resetModeState(cm);
  }

  function resetModeState(cm) {
    cm.doc.iter(function (line) {
      if (line.stateAfter) { line.stateAfter = null; }
      if (line.styles) { line.styles = null; }
    });
    cm.doc.modeFrontier = cm.doc.highlightFrontier = cm.doc.first;
    startWorker(cm, 100);
    cm.state.modeGen++;
    if (cm.curOp) { regChange(cm); }
  }

  // DOCUMENT DATA STRUCTURE

  // By default, updates that start and end at the beginning of a line
  // are treated specially, in order to make the association of line
  // widgets and marker elements with the text behave more intuitive.
  function isWholeLineUpdate(doc, change) {
    return change.from.ch == 0 && change.to.ch == 0 && lst(change.text) == "" &&
      (!doc.cm || doc.cm.options.wholeLineUpdateBefore)
  }

  // Perform a change on the document data structure.
  function updateDoc(doc, change, markedSpans, estimateHeight) {
    function spansFor(n) {return markedSpans ? markedSpans[n] : null}
    function update(line, text, spans) {
      updateLine(line, text, spans, estimateHeight);
      signalLater(line, "change", line, change);
    }
    function linesFor(start, end) {
      var result = [];
      for (var i = start; i < end; ++i)
        { result.push(new Line(text[i], spansFor(i), estimateHeight)); }
      return result
    }

    var from = change.from, to = change.to, text = change.text;
    var firstLine = getLine(doc, from.line), lastLine = getLine(doc, to.line);
    var lastText = lst(text), lastSpans = spansFor(text.length - 1), nlines = to.line - from.line;

    // Adjust the line structure
    if (change.full) {
      doc.insert(0, linesFor(0, text.length));
      doc.remove(text.length, doc.size - text.length);
    } else if (isWholeLineUpdate(doc, change)) {
      // This is a whole-line replace. Treated specially to make
      // sure line objects move the way they are supposed to.
      var added = linesFor(0, text.length - 1);
      update(lastLine, lastLine.text, lastSpans);
      if (nlines) { doc.remove(from.line, nlines); }
      if (added.length) { doc.insert(from.line, added); }
    } else if (firstLine == lastLine) {
      if (text.length == 1) {
        update(firstLine, firstLine.text.slice(0, from.ch) + lastText + firstLine.text.slice(to.ch), lastSpans);
      } else {
        var added$1 = linesFor(1, text.length - 1);
        added$1.push(new Line(lastText + firstLine.text.slice(to.ch), lastSpans, estimateHeight));
        update(firstLine, firstLine.text.slice(0, from.ch) + text[0], spansFor(0));
        doc.insert(from.line + 1, added$1);
      }
    } else if (text.length == 1) {
      update(firstLine, firstLine.text.slice(0, from.ch) + text[0] + lastLine.text.slice(to.ch), spansFor(0));
      doc.remove(from.line + 1, nlines);
    } else {
      update(firstLine, firstLine.text.slice(0, from.ch) + text[0], spansFor(0));
      update(lastLine, lastText + lastLine.text.slice(to.ch), lastSpans);
      var added$2 = linesFor(1, text.length - 1);
      if (nlines > 1) { doc.remove(from.line + 1, nlines - 1); }
      doc.insert(from.line + 1, added$2);
    }

    signalLater(doc, "change", doc, change);
  }

  // Call f for all linked documents.
  function linkedDocs(doc, f, sharedHistOnly) {
    function propagate(doc, skip, sharedHist) {
      if (doc.linked) { for (var i = 0; i < doc.linked.length; ++i) {
        var rel = doc.linked[i];
        if (rel.doc == skip) { continue }
        var shared = sharedHist && rel.sharedHist;
        if (sharedHistOnly && !shared) { continue }
        f(rel.doc, shared);
        propagate(rel.doc, doc, shared);
      } }
    }
    propagate(doc, null, true);
  }

  // Attach a document to an editor.
  function attachDoc(cm, doc) {
    if (doc.cm) { throw new Error("This document is already in use.") }
    cm.doc = doc;
    doc.cm = cm;
    estimateLineHeights(cm);
    loadMode(cm);
    setDirectionClass(cm);
    cm.options.direction = doc.direction;
    if (!cm.options.lineWrapping) { findMaxLine(cm); }
    cm.options.mode = doc.modeOption;
    regChange(cm);
  }

  function setDirectionClass(cm) {
  (cm.doc.direction == "rtl" ? addClass : rmClass)(cm.display.lineDiv, "CodeMirror-rtl");
  }

  function directionChanged(cm) {
    runInOp(cm, function () {
      setDirectionClass(cm);
      regChange(cm);
    });
  }

  function History(prev) {
    // Arrays of change events and selections. Doing something adds an
    // event to done and clears undo. Undoing moves events from done
    // to undone, redoing moves them in the other direction.
    this.done = []; this.undone = [];
    this.undoDepth = prev ? prev.undoDepth : Infinity;
    // Used to track when changes can be merged into a single undo
    // event
    this.lastModTime = this.lastSelTime = 0;
    this.lastOp = this.lastSelOp = null;
    this.lastOrigin = this.lastSelOrigin = null;
    // Used by the isClean() method
    this.generation = this.maxGeneration = prev ? prev.maxGeneration : 1;
  }

  // Create a history change event from an updateDoc-style change
  // object.
  function historyChangeFromChange(doc, change) {
    var histChange = {from: copyPos(change.from), to: changeEnd(change), text: getBetween(doc, change.from, change.to)};
    attachLocalSpans(doc, histChange, change.from.line, change.to.line + 1);
    linkedDocs(doc, function (doc) { return attachLocalSpans(doc, histChange, change.from.line, change.to.line + 1); }, true);
    return histChange
  }

  // Pop all selection events off the end of a history array. Stop at
  // a change event.
  function clearSelectionEvents(array) {
    while (array.length) {
      var last = lst(array);
      if (last.ranges) { array.pop(); }
      else { break }
    }
  }

  // Find the top change event in the history. Pop off selection
  // events that are in the way.
  function lastChangeEvent(hist, force) {
    if (force) {
      clearSelectionEvents(hist.done);
      return lst(hist.done)
    } else if (hist.done.length && !lst(hist.done).ranges) {
      return lst(hist.done)
    } else if (hist.done.length > 1 && !hist.done[hist.done.length - 2].ranges) {
      hist.done.pop();
      return lst(hist.done)
    }
  }

  // Register a change in the history. Merges changes that are within
  // a single operation, or are close together with an origin that
  // allows merging (starting with "+") into a single event.
  function addChangeToHistory(doc, change, selAfter, opId) {
    var hist = doc.history;
    hist.undone.length = 0;
    var time = +new Date, cur;
    var last;

    if ((hist.lastOp == opId ||
         hist.lastOrigin == change.origin && change.origin &&
         ((change.origin.charAt(0) == "+" && hist.lastModTime > time - (doc.cm ? doc.cm.options.historyEventDelay : 500)) ||
          change.origin.charAt(0) == "*")) &&
        (cur = lastChangeEvent(hist, hist.lastOp == opId))) {
      // Merge this change into the last event
      last = lst(cur.changes);
      if (cmp(change.from, change.to) == 0 && cmp(change.from, last.to) == 0) {
        // Optimized case for simple insertion -- don't want to add
        // new changesets for every character typed
        last.to = changeEnd(change);
      } else {
        // Add new sub-event
        cur.changes.push(historyChangeFromChange(doc, change));
      }
    } else {
      // Can not be merged, start a new event.
      var before = lst(hist.done);
      if (!before || !before.ranges)
        { pushSelectionToHistory(doc.sel, hist.done); }
      cur = {changes: [historyChangeFromChange(doc, change)],
             generation: hist.generation};
      hist.done.push(cur);
      while (hist.done.length > hist.undoDepth) {
        hist.done.shift();
        if (!hist.done[0].ranges) { hist.done.shift(); }
      }
    }
    hist.done.push(selAfter);
    hist.generation = ++hist.maxGeneration;
    hist.lastModTime = hist.lastSelTime = time;
    hist.lastOp = hist.lastSelOp = opId;
    hist.lastOrigin = hist.lastSelOrigin = change.origin;

    if (!last) { signal(doc, "historyAdded"); }
  }

  function selectionEventCanBeMerged(doc, origin, prev, sel) {
    var ch = origin.charAt(0);
    return ch == "*" ||
      ch == "+" &&
      prev.ranges.length == sel.ranges.length &&
      prev.somethingSelected() == sel.somethingSelected() &&
      new Date - doc.history.lastSelTime <= (doc.cm ? doc.cm.options.historyEventDelay : 500)
  }

  // Called whenever the selection changes, sets the new selection as
  // the pending selection in the history, and pushes the old pending
  // selection into the 'done' array when it was significantly
  // different (in number of selected ranges, emptiness, or time).
  function addSelectionToHistory(doc, sel, opId, options) {
    var hist = doc.history, origin = options && options.origin;

    // A new event is started when the previous origin does not match
    // the current, or the origins don't allow matching. Origins
    // starting with * are always merged, those starting with + are
    // merged when similar and close together in time.
    if (opId == hist.lastSelOp ||
        (origin && hist.lastSelOrigin == origin &&
         (hist.lastModTime == hist.lastSelTime && hist.lastOrigin == origin ||
          selectionEventCanBeMerged(doc, origin, lst(hist.done), sel))))
      { hist.done[hist.done.length - 1] = sel; }
    else
      { pushSelectionToHistory(sel, hist.done); }

    hist.lastSelTime = +new Date;
    hist.lastSelOrigin = origin;
    hist.lastSelOp = opId;
    if (options && options.clearRedo !== false)
      { clearSelectionEvents(hist.undone); }
  }

  function pushSelectionToHistory(sel, dest) {
    var top = lst(dest);
    if (!(top && top.ranges && top.equals(sel)))
      { dest.push(sel); }
  }

  // Used to store marked span information in the history.
  function attachLocalSpans(doc, change, from, to) {
    var existing = change["spans_" + doc.id], n = 0;
    doc.iter(Math.max(doc.first, from), Math.min(doc.first + doc.size, to), function (line) {
      if (line.markedSpans)
        { (existing || (existing = change["spans_" + doc.id] = {}))[n] = line.markedSpans; }
      ++n;
    });
  }

  // When un/re-doing restores text containing marked spans, those
  // that have been explicitly cleared should not be restored.
  function removeClearedSpans(spans) {
    if (!spans) { return null }
    var out;
    for (var i = 0; i < spans.length; ++i) {
      if (spans[i].marker.explicitlyCleared) { if (!out) { out = spans.slice(0, i); } }
      else if (out) { out.push(spans[i]); }
    }
    return !out ? spans : out.length ? out : null
  }

  // Retrieve and filter the old marked spans stored in a change event.
  function getOldSpans(doc, change) {
    var found = change["spans_" + doc.id];
    if (!found) { return null }
    var nw = [];
    for (var i = 0; i < change.text.length; ++i)
      { nw.push(removeClearedSpans(found[i])); }
    return nw
  }

  // Used for un/re-doing changes from the history. Combines the
  // result of computing the existing spans with the set of spans that
  // existed in the history (so that deleting around a span and then
  // undoing brings back the span).
  function mergeOldSpans(doc, change) {
    var old = getOldSpans(doc, change);
    var stretched = stretchSpansOverChange(doc, change);
    if (!old) { return stretched }
    if (!stretched) { return old }

    for (var i = 0; i < old.length; ++i) {
      var oldCur = old[i], stretchCur = stretched[i];
      if (oldCur && stretchCur) {
        spans: for (var j = 0; j < stretchCur.length; ++j) {
          var span = stretchCur[j];
          for (var k = 0; k < oldCur.length; ++k)
            { if (oldCur[k].marker == span.marker) { continue spans } }
          oldCur.push(span);
        }
      } else if (stretchCur) {
        old[i] = stretchCur;
      }
    }
    return old
  }

  // Used both to provide a JSON-safe object in .getHistory, and, when
  // detaching a document, to split the history in two
  function copyHistoryArray(events, newGroup, instantiateSel) {
    var copy = [];
    for (var i = 0; i < events.length; ++i) {
      var event = events[i];
      if (event.ranges) {
        copy.push(instantiateSel ? Selection.prototype.deepCopy.call(event) : event);
        continue
      }
      var changes = event.changes, newChanges = [];
      copy.push({changes: newChanges});
      for (var j = 0; j < changes.length; ++j) {
        var change = changes[j], m = (void 0);
        newChanges.push({from: change.from, to: change.to, text: change.text});
        if (newGroup) { for (var prop in change) { if (m = prop.match(/^spans_(\d+)$/)) {
          if (indexOf(newGroup, Number(m[1])) > -1) {
            lst(newChanges)[prop] = change[prop];
            delete change[prop];
          }
        } } }
      }
    }
    return copy
  }

  // The 'scroll' parameter given to many of these indicated whether
  // the new cursor position should be scrolled into view after
  // modifying the selection.

  // If shift is held or the extend flag is set, extends a range to
  // include a given position (and optionally a second position).
  // Otherwise, simply returns the range between the given positions.
  // Used for cursor motion and such.
  function extendRange(range, head, other, extend) {
    if (extend) {
      var anchor = range.anchor;
      if (other) {
        var posBefore = cmp(head, anchor) < 0;
        if (posBefore != (cmp(other, anchor) < 0)) {
          anchor = head;
          head = other;
        } else if (posBefore != (cmp(head, other) < 0)) {
          head = other;
        }
      }
      return new Range(anchor, head)
    } else {
      return new Range(other || head, head)
    }
  }

  // Extend the primary selection range, discard the rest.
  function extendSelection(doc, head, other, options, extend) {
    if (extend == null) { extend = doc.cm && (doc.cm.display.shift || doc.extend); }
    setSelection(doc, new Selection([extendRange(doc.sel.primary(), head, other, extend)], 0), options);
  }

  // Extend all selections (pos is an array of selections with length
  // equal the number of selections)
  function extendSelections(doc, heads, options) {
    var out = [];
    var extend = doc.cm && (doc.cm.display.shift || doc.extend);
    for (var i = 0; i < doc.sel.ranges.length; i++)
      { out[i] = extendRange(doc.sel.ranges[i], heads[i], null, extend); }
    var newSel = normalizeSelection(doc.cm, out, doc.sel.primIndex);
    setSelection(doc, newSel, options);
  }

  // Updates a single range in the selection.
  function replaceOneSelection(doc, i, range, options) {
    var ranges = doc.sel.ranges.slice(0);
    ranges[i] = range;
    setSelection(doc, normalizeSelection(doc.cm, ranges, doc.sel.primIndex), options);
  }

  // Reset the selection to a single range.
  function setSimpleSelection(doc, anchor, head, options) {
    setSelection(doc, simpleSelection(anchor, head), options);
  }

  // Give beforeSelectionChange handlers a change to influence a
  // selection update.
  function filterSelectionChange(doc, sel, options) {
    var obj = {
      ranges: sel.ranges,
      update: function(ranges) {
        this.ranges = [];
        for (var i = 0; i < ranges.length; i++)
          { this.ranges[i] = new Range(clipPos(doc, ranges[i].anchor),
                                     clipPos(doc, ranges[i].head)); }
      },
      origin: options && options.origin
    };
    signal(doc, "beforeSelectionChange", doc, obj);
    if (doc.cm) { signal(doc.cm, "beforeSelectionChange", doc.cm, obj); }
    if (obj.ranges != sel.ranges) { return normalizeSelection(doc.cm, obj.ranges, obj.ranges.length - 1) }
    else { return sel }
  }

  function setSelectionReplaceHistory(doc, sel, options) {
    var done = doc.history.done, last = lst(done);
    if (last && last.ranges) {
      done[done.length - 1] = sel;
      setSelectionNoUndo(doc, sel, options);
    } else {
      setSelection(doc, sel, options);
    }
  }

  // Set a new selection.
  function setSelection(doc, sel, options) {
    setSelectionNoUndo(doc, sel, options);
    addSelectionToHistory(doc, doc.sel, doc.cm ? doc.cm.curOp.id : NaN, options);
  }

  function setSelectionNoUndo(doc, sel, options) {
    if (hasHandler(doc, "beforeSelectionChange") || doc.cm && hasHandler(doc.cm, "beforeSelectionChange"))
      { sel = filterSelectionChange(doc, sel, options); }

    var bias = options && options.bias ||
      (cmp(sel.primary().head, doc.sel.primary().head) < 0 ? -1 : 1);
    setSelectionInner(doc, skipAtomicInSelection(doc, sel, bias, true));

    if (!(options && options.scroll === false) && doc.cm && doc.cm.getOption("readOnly") != "nocursor")
      { ensureCursorVisible(doc.cm); }
  }

  function setSelectionInner(doc, sel) {
    if (sel.equals(doc.sel)) { return }

    doc.sel = sel;

    if (doc.cm) {
      doc.cm.curOp.updateInput = 1;
      doc.cm.curOp.selectionChanged = true;
      signalCursorActivity(doc.cm);
    }
    signalLater(doc, "cursorActivity", doc);
  }

  // Verify that the selection does not partially select any atomic
  // marked ranges.
  function reCheckSelection(doc) {
    setSelectionInner(doc, skipAtomicInSelection(doc, doc.sel, null, false));
  }

  // Return a selection that does not partially select any atomic
  // ranges.
  function skipAtomicInSelection(doc, sel, bias, mayClear) {
    var out;
    for (var i = 0; i < sel.ranges.length; i++) {
      var range = sel.ranges[i];
      var old = sel.ranges.length == doc.sel.ranges.length && doc.sel.ranges[i];
      var newAnchor = skipAtomic(doc, range.anchor, old && old.anchor, bias, mayClear);
      var newHead = skipAtomic(doc, range.head, old && old.head, bias, mayClear);
      if (out || newAnchor != range.anchor || newHead != range.head) {
        if (!out) { out = sel.ranges.slice(0, i); }
        out[i] = new Range(newAnchor, newHead);
      }
    }
    return out ? normalizeSelection(doc.cm, out, sel.primIndex) : sel
  }

  function skipAtomicInner(doc, pos, oldPos, dir, mayClear) {
    var line = getLine(doc, pos.line);
    if (line.markedSpans) { for (var i = 0; i < line.markedSpans.length; ++i) {
      var sp = line.markedSpans[i], m = sp.marker;

      // Determine if we should prevent the cursor being placed to the left/right of an atomic marker
      // Historically this was determined using the inclusiveLeft/Right option, but the new way to control it
      // is with selectLeft/Right
      var preventCursorLeft = ("selectLeft" in m) ? !m.selectLeft : m.inclusiveLeft;
      var preventCursorRight = ("selectRight" in m) ? !m.selectRight : m.inclusiveRight;

      if ((sp.from == null || (preventCursorLeft ? sp.from <= pos.ch : sp.from < pos.ch)) &&
          (sp.to == null || (preventCursorRight ? sp.to >= pos.ch : sp.to > pos.ch))) {
        if (mayClear) {
          signal(m, "beforeCursorEnter");
          if (m.explicitlyCleared) {
            if (!line.markedSpans) { break }
            else {--i; continue}
          }
        }
        if (!m.atomic) { continue }

        if (oldPos) {
          var near = m.find(dir < 0 ? 1 : -1), diff = (void 0);
          if (dir < 0 ? preventCursorRight : preventCursorLeft)
            { near = movePos(doc, near, -dir, near && near.line == pos.line ? line : null); }
          if (near && near.line == pos.line && (diff = cmp(near, oldPos)) && (dir < 0 ? diff < 0 : diff > 0))
            { return skipAtomicInner(doc, near, pos, dir, mayClear) }
        }

        var far = m.find(dir < 0 ? -1 : 1);
        if (dir < 0 ? preventCursorLeft : preventCursorRight)
          { far = movePos(doc, far, dir, far.line == pos.line ? line : null); }
        return far ? skipAtomicInner(doc, far, pos, dir, mayClear) : null
      }
    } }
    return pos
  }

  // Ensure a given position is not inside an atomic range.
  function skipAtomic(doc, pos, oldPos, bias, mayClear) {
    var dir = bias || 1;
    var found = skipAtomicInner(doc, pos, oldPos, dir, mayClear) ||
        (!mayClear && skipAtomicInner(doc, pos, oldPos, dir, true)) ||
        skipAtomicInner(doc, pos, oldPos, -dir, mayClear) ||
        (!mayClear && skipAtomicInner(doc, pos, oldPos, -dir, true));
    if (!found) {
      doc.cantEdit = true;
      return Pos(doc.first, 0)
    }
    return found
  }

  function movePos(doc, pos, dir, line) {
    if (dir < 0 && pos.ch == 0) {
      if (pos.line > doc.first) { return clipPos(doc, Pos(pos.line - 1)) }
      else { return null }
    } else if (dir > 0 && pos.ch == (line || getLine(doc, pos.line)).text.length) {
      if (pos.line < doc.first + doc.size - 1) { return Pos(pos.line + 1, 0) }
      else { return null }
    } else {
      return new Pos(pos.line, pos.ch + dir)
    }
  }

  function selectAll(cm) {
    cm.setSelection(Pos(cm.firstLine(), 0), Pos(cm.lastLine()), sel_dontScroll);
  }

  // UPDATING

  // Allow "beforeChange" event handlers to influence a change
  function filterChange(doc, change, update) {
    var obj = {
      canceled: false,
      from: change.from,
      to: change.to,
      text: change.text,
      origin: change.origin,
      cancel: function () { return obj.canceled = true; }
    };
    if (update) { obj.update = function (from, to, text, origin) {
      if (from) { obj.from = clipPos(doc, from); }
      if (to) { obj.to = clipPos(doc, to); }
      if (text) { obj.text = text; }
      if (origin !== undefined) { obj.origin = origin; }
    }; }
    signal(doc, "beforeChange", doc, obj);
    if (doc.cm) { signal(doc.cm, "beforeChange", doc.cm, obj); }

    if (obj.canceled) {
      if (doc.cm) { doc.cm.curOp.updateInput = 2; }
      return null
    }
    return {from: obj.from, to: obj.to, text: obj.text, origin: obj.origin}
  }

  // Apply a change to a document, and add it to the document's
  // history, and propagating it to all linked documents.
  function makeChange(doc, change, ignoreReadOnly) {
    if (doc.cm) {
      if (!doc.cm.curOp) { return operation(doc.cm, makeChange)(doc, change, ignoreReadOnly) }
      if (doc.cm.state.suppressEdits) { return }
    }

    if (hasHandler(doc, "beforeChange") || doc.cm && hasHandler(doc.cm, "beforeChange")) {
      change = filterChange(doc, change, true);
      if (!change) { return }
    }

    // Possibly split or suppress the update based on the presence
    // of read-only spans in its range.
    var split = sawReadOnlySpans && !ignoreReadOnly && removeReadOnlyRanges(doc, change.from, change.to);
    if (split) {
      for (var i = split.length - 1; i >= 0; --i)
        { makeChangeInner(doc, {from: split[i].from, to: split[i].to, text: i ? [""] : change.text, origin: change.origin}); }
    } else {
      makeChangeInner(doc, change);
    }
  }

  function makeChangeInner(doc, change) {
    if (change.text.length == 1 && change.text[0] == "" && cmp(change.from, change.to) == 0) { return }
    var selAfter = computeSelAfterChange(doc, change);
    addChangeToHistory(doc, change, selAfter, doc.cm ? doc.cm.curOp.id : NaN);

    makeChangeSingleDoc(doc, change, selAfter, stretchSpansOverChange(doc, change));
    var rebased = [];

    linkedDocs(doc, function (doc, sharedHist) {
      if (!sharedHist && indexOf(rebased, doc.history) == -1) {
        rebaseHist(doc.history, change);
        rebased.push(doc.history);
      }
      makeChangeSingleDoc(doc, change, null, stretchSpansOverChange(doc, change));
    });
  }

  // Revert a change stored in a document's history.
  function makeChangeFromHistory(doc, type, allowSelectionOnly) {
    var suppress = doc.cm && doc.cm.state.suppressEdits;
    if (suppress && !allowSelectionOnly) { return }

    var hist = doc.history, event, selAfter = doc.sel;
    var source = type == "undo" ? hist.done : hist.undone, dest = type == "undo" ? hist.undone : hist.done;

    // Verify that there is a useable event (so that ctrl-z won't
    // needlessly clear selection events)
    var i = 0;
    for (; i < source.length; i++) {
      event = source[i];
      if (allowSelectionOnly ? event.ranges && !event.equals(doc.sel) : !event.ranges)
        { break }
    }
    if (i == source.length) { return }
    hist.lastOrigin = hist.lastSelOrigin = null;

    for (;;) {
      event = source.pop();
      if (event.ranges) {
        pushSelectionToHistory(event, dest);
        if (allowSelectionOnly && !event.equals(doc.sel)) {
          setSelection(doc, event, {clearRedo: false});
          return
        }
        selAfter = event;
      } else if (suppress) {
        source.push(event);
        return
      } else { break }
    }

    // Build up a reverse change object to add to the opposite history
    // stack (redo when undoing, and vice versa).
    var antiChanges = [];
    pushSelectionToHistory(selAfter, dest);
    dest.push({changes: antiChanges, generation: hist.generation});
    hist.generation = event.generation || ++hist.maxGeneration;

    var filter = hasHandler(doc, "beforeChange") || doc.cm && hasHandler(doc.cm, "beforeChange");

    var loop = function ( i ) {
      var change = event.changes[i];
      change.origin = type;
      if (filter && !filterChange(doc, change, false)) {
        source.length = 0;
        return {}
      }

      antiChanges.push(historyChangeFromChange(doc, change));

      var after = i ? computeSelAfterChange(doc, change) : lst(source);
      makeChangeSingleDoc(doc, change, after, mergeOldSpans(doc, change));
      if (!i && doc.cm) { doc.cm.scrollIntoView({from: change.from, to: changeEnd(change)}); }
      var rebased = [];

      // Propagate to the linked documents
      linkedDocs(doc, function (doc, sharedHist) {
        if (!sharedHist && indexOf(rebased, doc.history) == -1) {
          rebaseHist(doc.history, change);
          rebased.push(doc.history);
        }
        makeChangeSingleDoc(doc, change, null, mergeOldSpans(doc, change));
      });
    };

    for (var i$1 = event.changes.length - 1; i$1 >= 0; --i$1) {
      var returned = loop( i$1 );

      if ( returned ) return returned.v;
    }
  }

  // Sub-views need their line numbers shifted when text is added
  // above or below them in the parent document.
  function shiftDoc(doc, distance) {
    if (distance == 0) { return }
    doc.first += distance;
    doc.sel = new Selection(map(doc.sel.ranges, function (range) { return new Range(
      Pos(range.anchor.line + distance, range.anchor.ch),
      Pos(range.head.line + distance, range.head.ch)
    ); }), doc.sel.primIndex);
    if (doc.cm) {
      regChange(doc.cm, doc.first, doc.first - distance, distance);
      for (var d = doc.cm.display, l = d.viewFrom; l < d.viewTo; l++)
        { regLineChange(doc.cm, l, "gutter"); }
    }
  }

  // More lower-level change function, handling only a single document
  // (not linked ones).
  function makeChangeSingleDoc(doc, change, selAfter, spans) {
    if (doc.cm && !doc.cm.curOp)
      { return operation(doc.cm, makeChangeSingleDoc)(doc, change, selAfter, spans) }

    if (change.to.line < doc.first) {
      shiftDoc(doc, change.text.length - 1 - (change.to.line - change.from.line));
      return
    }
    if (change.from.line > doc.lastLine()) { return }

    // Clip the change to the size of this doc
    if (change.from.line < doc.first) {
      var shift = change.text.length - 1 - (doc.first - change.from.line);
      shiftDoc(doc, shift);
      change = {from: Pos(doc.first, 0), to: Pos(change.to.line + shift, change.to.ch),
                text: [lst(change.text)], origin: change.origin};
    }
    var last = doc.lastLine();
    if (change.to.line > last) {
      change = {from: change.from, to: Pos(last, getLine(doc, last).text.length),
                text: [change.text[0]], origin: change.origin};
    }

    change.removed = getBetween(doc, change.from, change.to);

    if (!selAfter) { selAfter = computeSelAfterChange(doc, change); }
    if (doc.cm) { makeChangeSingleDocInEditor(doc.cm, change, spans); }
    else { updateDoc(doc, change, spans); }
    setSelectionNoUndo(doc, selAfter, sel_dontScroll);

    if (doc.cantEdit && skipAtomic(doc, Pos(doc.firstLine(), 0)))
      { doc.cantEdit = false; }
  }

  // Handle the interaction of a change to a document with the editor
  // that this document is part of.
  function makeChangeSingleDocInEditor(cm, change, spans) {
    var doc = cm.doc, display = cm.display, from = change.from, to = change.to;

    var recomputeMaxLength = false, checkWidthStart = from.line;
    if (!cm.options.lineWrapping) {
      checkWidthStart = lineNo(visualLine(getLine(doc, from.line)));
      doc.iter(checkWidthStart, to.line + 1, function (line) {
        if (line == display.maxLine) {
          recomputeMaxLength = true;
          return true
        }
      });
    }

    if (doc.sel.contains(change.from, change.to) > -1)
      { signalCursorActivity(cm); }

    updateDoc(doc, change, spans, estimateHeight(cm));

    if (!cm.options.lineWrapping) {
      doc.iter(checkWidthStart, from.line + change.text.length, function (line) {
        var len = lineLength(line);
        if (len > display.maxLineLength) {
          display.maxLine = line;
          display.maxLineLength = len;
          display.maxLineChanged = true;
          recomputeMaxLength = false;
        }
      });
      if (recomputeMaxLength) { cm.curOp.updateMaxLine = true; }
    }

    retreatFrontier(doc, from.line);
    startWorker(cm, 400);

    var lendiff = change.text.length - (to.line - from.line) - 1;
    // Remember that these lines changed, for updating the display
    if (change.full)
      { regChange(cm); }
    else if (from.line == to.line && change.text.length == 1 && !isWholeLineUpdate(cm.doc, change))
      { regLineChange(cm, from.line, "text"); }
    else
      { regChange(cm, from.line, to.line + 1, lendiff); }

    var changesHandler = hasHandler(cm, "changes"), changeHandler = hasHandler(cm, "change");
    if (changeHandler || changesHandler) {
      var obj = {
        from: from, to: to,
        text: change.text,
        removed: change.removed,
        origin: change.origin
      };
      if (changeHandler) { signalLater(cm, "change", cm, obj); }
      if (changesHandler) { (cm.curOp.changeObjs || (cm.curOp.changeObjs = [])).push(obj); }
    }
    cm.display.selForContextMenu = null;
  }

  function replaceRange(doc, code, from, to, origin) {
    var assign;

    if (!to) { to = from; }
    if (cmp(to, from) < 0) { (assign = [to, from], from = assign[0], to = assign[1]); }
    if (typeof code == "string") { code = doc.splitLines(code); }
    makeChange(doc, {from: from, to: to, text: code, origin: origin});
  }

  // Rebasing/resetting history to deal with externally-sourced changes

  function rebaseHistSelSingle(pos, from, to, diff) {
    if (to < pos.line) {
      pos.line += diff;
    } else if (from < pos.line) {
      pos.line = from;
      pos.ch = 0;
    }
  }

  // Tries to rebase an array of history events given a change in the
  // document. If the change touches the same lines as the event, the
  // event, and everything 'behind' it, is discarded. If the change is
  // before the event, the event's positions are updated. Uses a
  // copy-on-write scheme for the positions, to avoid having to
  // reallocate them all on every rebase, but also avoid problems with
  // shared position objects being unsafely updated.
  function rebaseHistArray(array, from, to, diff) {
    for (var i = 0; i < array.length; ++i) {
      var sub = array[i], ok = true;
      if (sub.ranges) {
        if (!sub.copied) { sub = array[i] = sub.deepCopy(); sub.copied = true; }
        for (var j = 0; j < sub.ranges.length; j++) {
          rebaseHistSelSingle(sub.ranges[j].anchor, from, to, diff);
          rebaseHistSelSingle(sub.ranges[j].head, from, to, diff);
        }
        continue
      }
      for (var j$1 = 0; j$1 < sub.changes.length; ++j$1) {
        var cur = sub.changes[j$1];
        if (to < cur.from.line) {
          cur.from = Pos(cur.from.line + diff, cur.from.ch);
          cur.to = Pos(cur.to.line + diff, cur.to.ch);
        } else if (from <= cur.to.line) {
          ok = false;
          break
        }
      }
      if (!ok) {
        array.splice(0, i + 1);
        i = 0;
      }
    }
  }

  function rebaseHist(hist, change) {
    var from = change.from.line, to = change.to.line, diff = change.text.length - (to - from) - 1;
    rebaseHistArray(hist.done, from, to, diff);
    rebaseHistArray(hist.undone, from, to, diff);
  }

  // Utility for applying a change to a line by handle or number,
  // returning the number and optionally registering the line as
  // changed.
  function changeLine(doc, handle, changeType, op) {
    var no = handle, line = handle;
    if (typeof handle == "number") { line = getLine(doc, clipLine(doc, handle)); }
    else { no = lineNo(handle); }
    if (no == null) { return null }
    if (op(line, no) && doc.cm) { regLineChange(doc.cm, no, changeType); }
    return line
  }

  // The document is represented as a BTree consisting of leaves, with
  // chunk of lines in them, and branches, with up to ten leaves or
  // other branch nodes below them. The top node is always a branch
  // node, and is the document object itself (meaning it has
  // additional methods and properties).
  //
  // All nodes have parent links. The tree is used both to go from
  // line numbers to line objects, and to go from objects to numbers.
  // It also indexes by height, and is used to convert between height
  // and line object, and to find the total height of the document.
  //
  // See also http://marijnhaverbeke.nl/blog/codemirror-line-tree.html

  function LeafChunk(lines) {
    this.lines = lines;
    this.parent = null;
    var height = 0;
    for (var i = 0; i < lines.length; ++i) {
      lines[i].parent = this;
      height += lines[i].height;
    }
    this.height = height;
  }

  LeafChunk.prototype = {
    chunkSize: function() { return this.lines.length },

    // Remove the n lines at offset 'at'.
    removeInner: function(at, n) {
      for (var i = at, e = at + n; i < e; ++i) {
        var line = this.lines[i];
        this.height -= line.height;
        cleanUpLine(line);
        signalLater(line, "delete");
      }
      this.lines.splice(at, n);
    },

    // Helper used to collapse a small branch into a single leaf.
    collapse: function(lines) {
      lines.push.apply(lines, this.lines);
    },

    // Insert the given array of lines at offset 'at', count them as
    // having the given height.
    insertInner: function(at, lines, height) {
      this.height += height;
      this.lines = this.lines.slice(0, at).concat(lines).concat(this.lines.slice(at));
      for (var i = 0; i < lines.length; ++i) { lines[i].parent = this; }
    },

    // Used to iterate over a part of the tree.
    iterN: function(at, n, op) {
      for (var e = at + n; at < e; ++at)
        { if (op(this.lines[at])) { return true } }
    }
  };

  function BranchChunk(children) {
    this.children = children;
    var size = 0, height = 0;
    for (var i = 0; i < children.length; ++i) {
      var ch = children[i];
      size += ch.chunkSize(); height += ch.height;
      ch.parent = this;
    }
    this.size = size;
    this.height = height;
    this.parent = null;
  }

  BranchChunk.prototype = {
    chunkSize: function() { return this.size },

    removeInner: function(at, n) {
      this.size -= n;
      for (var i = 0; i < this.children.length; ++i) {
        var child = this.children[i], sz = child.chunkSize();
        if (at < sz) {
          var rm = Math.min(n, sz - at), oldHeight = child.height;
          child.removeInner(at, rm);
          this.height -= oldHeight - child.height;
          if (sz == rm) { this.children.splice(i--, 1); child.parent = null; }
          if ((n -= rm) == 0) { break }
          at = 0;
        } else { at -= sz; }
      }
      // If the result is smaller than 25 lines, ensure that it is a
      // single leaf node.
      if (this.size - n < 25 &&
          (this.children.length > 1 || !(this.children[0] instanceof LeafChunk))) {
        var lines = [];
        this.collapse(lines);
        this.children = [new LeafChunk(lines)];
        this.children[0].parent = this;
      }
    },

    collapse: function(lines) {
      for (var i = 0; i < this.children.length; ++i) { this.children[i].collapse(lines); }
    },

    insertInner: function(at, lines, height) {
      this.size += lines.length;
      this.height += height;
      for (var i = 0; i < this.children.length; ++i) {
        var child = this.children[i], sz = child.chunkSize();
        if (at <= sz) {
          child.insertInner(at, lines, height);
          if (child.lines && child.lines.length > 50) {
            // To avoid memory thrashing when child.lines is huge (e.g. first view of a large file), it's never spliced.
            // Instead, small slices are taken. They're taken in order because sequential memory accesses are fastest.
            var remaining = child.lines.length % 25 + 25;
            for (var pos = remaining; pos < child.lines.length;) {
              var leaf = new LeafChunk(child.lines.slice(pos, pos += 25));
              child.height -= leaf.height;
              this.children.splice(++i, 0, leaf);
              leaf.parent = this;
            }
            child.lines = child.lines.slice(0, remaining);
            this.maybeSpill();
          }
          break
        }
        at -= sz;
      }
    },

    // When a node has grown, check whether it should be split.
    maybeSpill: function() {
      if (this.children.length <= 10) { return }
      var me = this;
      do {
        var spilled = me.children.splice(me.children.length - 5, 5);
        var sibling = new BranchChunk(spilled);
        if (!me.parent) { // Become the parent node
          var copy = new BranchChunk(me.children);
          copy.parent = me;
          me.children = [copy, sibling];
          me = copy;
       } else {
          me.size -= sibling.size;
          me.height -= sibling.height;
          var myIndex = indexOf(me.parent.children, me);
          me.parent.children.splice(myIndex + 1, 0, sibling);
        }
        sibling.parent = me.parent;
      } while (me.children.length > 10)
      me.parent.maybeSpill();
    },

    iterN: function(at, n, op) {
      for (var i = 0; i < this.children.length; ++i) {
        var child = this.children[i], sz = child.chunkSize();
        if (at < sz) {
          var used = Math.min(n, sz - at);
          if (child.iterN(at, used, op)) { return true }
          if ((n -= used) == 0) { break }
          at = 0;
        } else { at -= sz; }
      }
    }
  };

  // Line widgets are block elements displayed above or below a line.

  var LineWidget = function(doc, node, options) {
    if (options) { for (var opt in options) { if (options.hasOwnProperty(opt))
      { this[opt] = options[opt]; } } }
    this.doc = doc;
    this.node = node;
  };

  LineWidget.prototype.clear = function () {
    var cm = this.doc.cm, ws = this.line.widgets, line = this.line, no = lineNo(line);
    if (no == null || !ws) { return }
    for (var i = 0; i < ws.length; ++i) { if (ws[i] == this) { ws.splice(i--, 1); } }
    if (!ws.length) { line.widgets = null; }
    var height = widgetHeight(this);
    updateLineHeight(line, Math.max(0, line.height - height));
    if (cm) {
      runInOp(cm, function () {
        adjustScrollWhenAboveVisible(cm, line, -height);
        regLineChange(cm, no, "widget");
      });
      signalLater(cm, "lineWidgetCleared", cm, this, no);
    }
  };

  LineWidget.prototype.changed = function () {
      var this$1 = this;

    var oldH = this.height, cm = this.doc.cm, line = this.line;
    this.height = null;
    var diff = widgetHeight(this) - oldH;
    if (!diff) { return }
    if (!lineIsHidden(this.doc, line)) { updateLineHeight(line, line.height + diff); }
    if (cm) {
      runInOp(cm, function () {
        cm.curOp.forceUpdate = true;
        adjustScrollWhenAboveVisible(cm, line, diff);
        signalLater(cm, "lineWidgetChanged", cm, this$1, lineNo(line));
      });
    }
  };
  eventMixin(LineWidget);

  function adjustScrollWhenAboveVisible(cm, line, diff) {
    if (heightAtLine(line) < ((cm.curOp && cm.curOp.scrollTop) || cm.doc.scrollTop))
      { addToScrollTop(cm, diff); }
  }

  function addLineWidget(doc, handle, node, options) {
    var widget = new LineWidget(doc, node, options);
    var cm = doc.cm;
    if (cm && widget.noHScroll) { cm.display.alignWidgets = true; }
    changeLine(doc, handle, "widget", function (line) {
      var widgets = line.widgets || (line.widgets = []);
      if (widget.insertAt == null) { widgets.push(widget); }
      else { widgets.splice(Math.min(widgets.length, Math.max(0, widget.insertAt)), 0, widget); }
      widget.line = line;
      if (cm && !lineIsHidden(doc, line)) {
        var aboveVisible = heightAtLine(line) < doc.scrollTop;
        updateLineHeight(line, line.height + widgetHeight(widget));
        if (aboveVisible) { addToScrollTop(cm, widget.height); }
        cm.curOp.forceUpdate = true;
      }
      return true
    });
    if (cm) { signalLater(cm, "lineWidgetAdded", cm, widget, typeof handle == "number" ? handle : lineNo(handle)); }
    return widget
  }

  // TEXTMARKERS

  // Created with markText and setBookmark methods. A TextMarker is a
  // handle that can be used to clear or find a marked position in the
  // document. Line objects hold arrays (markedSpans) containing
  // {from, to, marker} object pointing to such marker objects, and
  // indicating that such a marker is present on that line. Multiple
  // lines may point to the same marker when it spans across lines.
  // The spans will have null for their from/to properties when the
  // marker continues beyond the start/end of the line. Markers have
  // links back to the lines they currently touch.

  // Collapsed markers have unique ids, in order to be able to order
  // them, which is needed for uniquely determining an outer marker
  // when they overlap (they may nest, but not partially overlap).
  var nextMarkerId = 0;

  var TextMarker = function(doc, type) {
    this.lines = [];
    this.type = type;
    this.doc = doc;
    this.id = ++nextMarkerId;
  };

  // Clear the marker.
  TextMarker.prototype.clear = function () {
    if (this.explicitlyCleared) { return }
    var cm = this.doc.cm, withOp = cm && !cm.curOp;
    if (withOp) { startOperation(cm); }
    if (hasHandler(this, "clear")) {
      var found = this.find();
      if (found) { signalLater(this, "clear", found.from, found.to); }
    }
    var min = null, max = null;
    for (var i = 0; i < this.lines.length; ++i) {
      var line = this.lines[i];
      var span = getMarkedSpanFor(line.markedSpans, this);
      if (cm && !this.collapsed) { regLineChange(cm, lineNo(line), "text"); }
      else if (cm) {
        if (span.to != null) { max = lineNo(line); }
        if (span.from != null) { min = lineNo(line); }
      }
      line.markedSpans = removeMarkedSpan(line.markedSpans, span);
      if (span.from == null && this.collapsed && !lineIsHidden(this.doc, line) && cm)
        { updateLineHeight(line, textHeight(cm.display)); }
    }
    if (cm && this.collapsed && !cm.options.lineWrapping) { for (var i$1 = 0; i$1 < this.lines.length; ++i$1) {
      var visual = visualLine(this.lines[i$1]), len = lineLength(visual);
      if (len > cm.display.maxLineLength) {
        cm.display.maxLine = visual;
        cm.display.maxLineLength = len;
        cm.display.maxLineChanged = true;
      }
    } }

    if (min != null && cm && this.collapsed) { regChange(cm, min, max + 1); }
    this.lines.length = 0;
    this.explicitlyCleared = true;
    if (this.atomic && this.doc.cantEdit) {
      this.doc.cantEdit = false;
      if (cm) { reCheckSelection(cm.doc); }
    }
    if (cm) { signalLater(cm, "markerCleared", cm, this, min, max); }
    if (withOp) { endOperation(cm); }
    if (this.parent) { this.parent.clear(); }
  };

  // Find the position of the marker in the document. Returns a {from,
  // to} object by default. Side can be passed to get a specific side
  // -- 0 (both), -1 (left), or 1 (right). When lineObj is true, the
  // Pos objects returned contain a line object, rather than a line
  // number (used to prevent looking up the same line twice).
  TextMarker.prototype.find = function (side, lineObj) {
    if (side == null && this.type == "bookmark") { side = 1; }
    var from, to;
    for (var i = 0; i < this.lines.length; ++i) {
      var line = this.lines[i];
      var span = getMarkedSpanFor(line.markedSpans, this);
      if (span.from != null) {
        from = Pos(lineObj ? line : lineNo(line), span.from);
        if (side == -1) { return from }
      }
      if (span.to != null) {
        to = Pos(lineObj ? line : lineNo(line), span.to);
        if (side == 1) { return to }
      }
    }
    return from && {from: from, to: to}
  };

  // Signals that the marker's widget changed, and surrounding layout
  // should be recomputed.
  TextMarker.prototype.changed = function () {
      var this$1 = this;

    var pos = this.find(-1, true), widget = this, cm = this.doc.cm;
    if (!pos || !cm) { return }
    runInOp(cm, function () {
      var line = pos.line, lineN = lineNo(pos.line);
      var view = findViewForLine(cm, lineN);
      if (view) {
        clearLineMeasurementCacheFor(view);
        cm.curOp.selectionChanged = cm.curOp.forceUpdate = true;
      }
      cm.curOp.updateMaxLine = true;
      if (!lineIsHidden(widget.doc, line) && widget.height != null) {
        var oldHeight = widget.height;
        widget.height = null;
        var dHeight = widgetHeight(widget) - oldHeight;
        if (dHeight)
          { updateLineHeight(line, line.height + dHeight); }
      }
      signalLater(cm, "markerChanged", cm, this$1);
    });
  };

  TextMarker.prototype.attachLine = function (line) {
    if (!this.lines.length && this.doc.cm) {
      var op = this.doc.cm.curOp;
      if (!op.maybeHiddenMarkers || indexOf(op.maybeHiddenMarkers, this) == -1)
        { (op.maybeUnhiddenMarkers || (op.maybeUnhiddenMarkers = [])).push(this); }
    }
    this.lines.push(line);
  };

  TextMarker.prototype.detachLine = function (line) {
    this.lines.splice(indexOf(this.lines, line), 1);
    if (!this.lines.length && this.doc.cm) {
      var op = this.doc.cm.curOp
      ;(op.maybeHiddenMarkers || (op.maybeHiddenMarkers = [])).push(this);
    }
  };
  eventMixin(TextMarker);

  // Create a marker, wire it up to the right lines, and
  function markText(doc, from, to, options, type) {
    // Shared markers (across linked documents) are handled separately
    // (markTextShared will call out to this again, once per
    // document).
    if (options && options.shared) { return markTextShared(doc, from, to, options, type) }
    // Ensure we are in an operation.
    if (doc.cm && !doc.cm.curOp) { return operation(doc.cm, markText)(doc, from, to, options, type) }

    var marker = new TextMarker(doc, type), diff = cmp(from, to);
    if (options) { copyObj(options, marker, false); }
    // Don't connect empty markers unless clearWhenEmpty is false
    if (diff > 0 || diff == 0 && marker.clearWhenEmpty !== false)
      { return marker }
    if (marker.replacedWith) {
      // Showing up as a widget implies collapsed (widget replaces text)
      marker.collapsed = true;
      marker.widgetNode = eltP("span", [marker.replacedWith], "CodeMirror-widget");
      if (!options.handleMouseEvents) { marker.widgetNode.setAttribute("cm-ignore-events", "true"); }
      if (options.insertLeft) { marker.widgetNode.insertLeft = true; }
    }
    if (marker.collapsed) {
      if (conflictingCollapsedRange(doc, from.line, from, to, marker) ||
          from.line != to.line && conflictingCollapsedRange(doc, to.line, from, to, marker))
        { throw new Error("Inserting collapsed marker partially overlapping an existing one") }
      seeCollapsedSpans();
    }

    if (marker.addToHistory)
      { addChangeToHistory(doc, {from: from, to: to, origin: "markText"}, doc.sel, NaN); }

    var curLine = from.line, cm = doc.cm, updateMaxLine;
    doc.iter(curLine, to.line + 1, function (line) {
      if (cm && marker.collapsed && !cm.options.lineWrapping && visualLine(line) == cm.display.maxLine)
        { updateMaxLine = true; }
      if (marker.collapsed && curLine != from.line) { updateLineHeight(line, 0); }
      addMarkedSpan(line, new MarkedSpan(marker,
                                         curLine == from.line ? from.ch : null,
                                         curLine == to.line ? to.ch : null), doc.cm && doc.cm.curOp);
      ++curLine;
    });
    // lineIsHidden depends on the presence of the spans, so needs a second pass
    if (marker.collapsed) { doc.iter(from.line, to.line + 1, function (line) {
      if (lineIsHidden(doc, line)) { updateLineHeight(line, 0); }
    }); }

    if (marker.clearOnEnter) { on(marker, "beforeCursorEnter", function () { return marker.clear(); }); }

    if (marker.readOnly) {
      seeReadOnlySpans();
      if (doc.history.done.length || doc.history.undone.length)
        { doc.clearHistory(); }
    }
    if (marker.collapsed) {
      marker.id = ++nextMarkerId;
      marker.atomic = true;
    }
    if (cm) {
      // Sync editor state
      if (updateMaxLine) { cm.curOp.updateMaxLine = true; }
      if (marker.collapsed)
        { regChange(cm, from.line, to.line + 1); }
      else if (marker.className || marker.startStyle || marker.endStyle || marker.css ||
               marker.attributes || marker.title)
        { for (var i = from.line; i <= to.line; i++) { regLineChange(cm, i, "text"); } }
      if (marker.atomic) { reCheckSelection(cm.doc); }
      signalLater(cm, "markerAdded", cm, marker);
    }
    return marker
  }

  // SHARED TEXTMARKERS

  // A shared marker spans multiple linked documents. It is
  // implemented as a meta-marker-object controlling multiple normal
  // markers.
  var SharedTextMarker = function(markers, primary) {
    this.markers = markers;
    this.primary = primary;
    for (var i = 0; i < markers.length; ++i)
      { markers[i].parent = this; }
  };

  SharedTextMarker.prototype.clear = function () {
    if (this.explicitlyCleared) { return }
    this.explicitlyCleared = true;
    for (var i = 0; i < this.markers.length; ++i)
      { this.markers[i].clear(); }
    signalLater(this, "clear");
  };

  SharedTextMarker.prototype.find = function (side, lineObj) {
    return this.primary.find(side, lineObj)
  };
  eventMixin(SharedTextMarker);

  function markTextShared(doc, from, to, options, type) {
    options = copyObj(options);
    options.shared = false;
    var markers = [markText(doc, from, to, options, type)], primary = markers[0];
    var widget = options.widgetNode;
    linkedDocs(doc, function (doc) {
      if (widget) { options.widgetNode = widget.cloneNode(true); }
      markers.push(markText(doc, clipPos(doc, from), clipPos(doc, to), options, type));
      for (var i = 0; i < doc.linked.length; ++i)
        { if (doc.linked[i].isParent) { return } }
      primary = lst(markers);
    });
    return new SharedTextMarker(markers, primary)
  }

  function findSharedMarkers(doc) {
    return doc.findMarks(Pos(doc.first, 0), doc.clipPos(Pos(doc.lastLine())), function (m) { return m.parent; })
  }

  function copySharedMarkers(doc, markers) {
    for (var i = 0; i < markers.length; i++) {
      var marker = markers[i], pos = marker.find();
      var mFrom = doc.clipPos(pos.from), mTo = doc.clipPos(pos.to);
      if (cmp(mFrom, mTo)) {
        var subMark = markText(doc, mFrom, mTo, marker.primary, marker.primary.type);
        marker.markers.push(subMark);
        subMark.parent = marker;
      }
    }
  }

  function detachSharedMarkers(markers) {
    var loop = function ( i ) {
      var marker = markers[i], linked = [marker.primary.doc];
      linkedDocs(marker.primary.doc, function (d) { return linked.push(d); });
      for (var j = 0; j < marker.markers.length; j++) {
        var subMarker = marker.markers[j];
        if (indexOf(linked, subMarker.doc) == -1) {
          subMarker.parent = null;
          marker.markers.splice(j--, 1);
        }
      }
    };

    for (var i = 0; i < markers.length; i++) loop( i );
  }

  var nextDocId = 0;
  var Doc = function(text, mode, firstLine, lineSep, direction) {
    if (!(this instanceof Doc)) { return new Doc(text, mode, firstLine, lineSep, direction) }
    if (firstLine == null) { firstLine = 0; }

    BranchChunk.call(this, [new LeafChunk([new Line("", null)])]);
    this.first = firstLine;
    this.scrollTop = this.scrollLeft = 0;
    this.cantEdit = false;
    this.cleanGeneration = 1;
    this.modeFrontier = this.highlightFrontier = firstLine;
    var start = Pos(firstLine, 0);
    this.sel = simpleSelection(start);
    this.history = new History(null);
    this.id = ++nextDocId;
    this.modeOption = mode;
    this.lineSep = lineSep;
    this.direction = (direction == "rtl") ? "rtl" : "ltr";
    this.extend = false;

    if (typeof text == "string") { text = this.splitLines(text); }
    updateDoc(this, {from: start, to: start, text: text});
    setSelection(this, simpleSelection(start), sel_dontScroll);
  };

  Doc.prototype = createObj(BranchChunk.prototype, {
    constructor: Doc,
    // Iterate over the document. Supports two forms -- with only one
    // argument, it calls that for each line in the document. With
    // three, it iterates over the range given by the first two (with
    // the second being non-inclusive).
    iter: function(from, to, op) {
      if (op) { this.iterN(from - this.first, to - from, op); }
      else { this.iterN(this.first, this.first + this.size, from); }
    },

    // Non-public interface for adding and removing lines.
    insert: function(at, lines) {
      var height = 0;
      for (var i = 0; i < lines.length; ++i) { height += lines[i].height; }
      this.insertInner(at - this.first, lines, height);
    },
    remove: function(at, n) { this.removeInner(at - this.first, n); },

    // From here, the methods are part of the public interface. Most
    // are also available from CodeMirror (editor) instances.

    getValue: function(lineSep) {
      var lines = getLines(this, this.first, this.first + this.size);
      if (lineSep === false) { return lines }
      return lines.join(lineSep || this.lineSeparator())
    },
    setValue: docMethodOp(function(code) {
      var top = Pos(this.first, 0), last = this.first + this.size - 1;
      makeChange(this, {from: top, to: Pos(last, getLine(this, last).text.length),
                        text: this.splitLines(code), origin: "setValue", full: true}, true);
      if (this.cm) { scrollToCoords(this.cm, 0, 0); }
      setSelection(this, simpleSelection(top), sel_dontScroll);
    }),
    replaceRange: function(code, from, to, origin) {
      from = clipPos(this, from);
      to = to ? clipPos(this, to) : from;
      replaceRange(this, code, from, to, origin);
    },
    getRange: function(from, to, lineSep) {
      var lines = getBetween(this, clipPos(this, from), clipPos(this, to));
      if (lineSep === false) { return lines }
      if (lineSep === '') { return lines.join('') }
      return lines.join(lineSep || this.lineSeparator())
    },

    getLine: function(line) {var l = this.getLineHandle(line); return l && l.text},

    getLineHandle: function(line) {if (isLine(this, line)) { return getLine(this, line) }},
    getLineNumber: function(line) {return lineNo(line)},

    getLineHandleVisualStart: function(line) {
      if (typeof line == "number") { line = getLine(this, line); }
      return visualLine(line)
    },

    lineCount: function() {return this.size},
    firstLine: function() {return this.first},
    lastLine: function() {return this.first + this.size - 1},

    clipPos: function(pos) {return clipPos(this, pos)},

    getCursor: function(start) {
      var range = this.sel.primary(), pos;
      if (start == null || start == "head") { pos = range.head; }
      else if (start == "anchor") { pos = range.anchor; }
      else if (start == "end" || start == "to" || start === false) { pos = range.to(); }
      else { pos = range.from(); }
      return pos
    },
    listSelections: function() { return this.sel.ranges },
    somethingSelected: function() {return this.sel.somethingSelected()},

    setCursor: docMethodOp(function(line, ch, options) {
      setSimpleSelection(this, clipPos(this, typeof line == "number" ? Pos(line, ch || 0) : line), null, options);
    }),
    setSelection: docMethodOp(function(anchor, head, options) {
      setSimpleSelection(this, clipPos(this, anchor), clipPos(this, head || anchor), options);
    }),
    extendSelection: docMethodOp(function(head, other, options) {
      extendSelection(this, clipPos(this, head), other && clipPos(this, other), options);
    }),
    extendSelections: docMethodOp(function(heads, options) {
      extendSelections(this, clipPosArray(this, heads), options);
    }),
    extendSelectionsBy: docMethodOp(function(f, options) {
      var heads = map(this.sel.ranges, f);
      extendSelections(this, clipPosArray(this, heads), options);
    }),
    setSelections: docMethodOp(function(ranges, primary, options) {
      if (!ranges.length) { return }
      var out = [];
      for (var i = 0; i < ranges.length; i++)
        { out[i] = new Range(clipPos(this, ranges[i].anchor),
                           clipPos(this, ranges[i].head || ranges[i].anchor)); }
      if (primary == null) { primary = Math.min(ranges.length - 1, this.sel.primIndex); }
      setSelection(this, normalizeSelection(this.cm, out, primary), options);
    }),
    addSelection: docMethodOp(function(anchor, head, options) {
      var ranges = this.sel.ranges.slice(0);
      ranges.push(new Range(clipPos(this, anchor), clipPos(this, head || anchor)));
      setSelection(this, normalizeSelection(this.cm, ranges, ranges.length - 1), options);
    }),

    getSelection: function(lineSep) {
      var ranges = this.sel.ranges, lines;
      for (var i = 0; i < ranges.length; i++) {
        var sel = getBetween(this, ranges[i].from(), ranges[i].to());
        lines = lines ? lines.concat(sel) : sel;
      }
      if (lineSep === false) { return lines }
      else { return lines.join(lineSep || this.lineSeparator()) }
    },
    getSelections: function(lineSep) {
      var parts = [], ranges = this.sel.ranges;
      for (var i = 0; i < ranges.length; i++) {
        var sel = getBetween(this, ranges[i].from(), ranges[i].to());
        if (lineSep !== false) { sel = sel.join(lineSep || this.lineSeparator()); }
        parts[i] = sel;
      }
      return parts
    },
    replaceSelection: function(code, collapse, origin) {
      var dup = [];
      for (var i = 0; i < this.sel.ranges.length; i++)
        { dup[i] = code; }
      this.replaceSelections(dup, collapse, origin || "+input");
    },
    replaceSelections: docMethodOp(function(code, collapse, origin) {
      var changes = [], sel = this.sel;
      for (var i = 0; i < sel.ranges.length; i++) {
        var range = sel.ranges[i];
        changes[i] = {from: range.from(), to: range.to(), text: this.splitLines(code[i]), origin: origin};
      }
      var newSel = collapse && collapse != "end" && computeReplacedSel(this, changes, collapse);
      for (var i$1 = changes.length - 1; i$1 >= 0; i$1--)
        { makeChange(this, changes[i$1]); }
      if (newSel) { setSelectionReplaceHistory(this, newSel); }
      else if (this.cm) { ensureCursorVisible(this.cm); }
    }),
    undo: docMethodOp(function() {makeChangeFromHistory(this, "undo");}),
    redo: docMethodOp(function() {makeChangeFromHistory(this, "redo");}),
    undoSelection: docMethodOp(function() {makeChangeFromHistory(this, "undo", true);}),
    redoSelection: docMethodOp(function() {makeChangeFromHistory(this, "redo", true);}),

    setExtending: function(val) {this.extend = val;},
    getExtending: function() {return this.extend},

    historySize: function() {
      var hist = this.history, done = 0, undone = 0;
      for (var i = 0; i < hist.done.length; i++) { if (!hist.done[i].ranges) { ++done; } }
      for (var i$1 = 0; i$1 < hist.undone.length; i$1++) { if (!hist.undone[i$1].ranges) { ++undone; } }
      return {undo: done, redo: undone}
    },
    clearHistory: function() {
      var this$1 = this;

      this.history = new History(this.history);
      linkedDocs(this, function (doc) { return doc.history = this$1.history; }, true);
    },

    markClean: function() {
      this.cleanGeneration = this.changeGeneration(true);
    },
    changeGeneration: function(forceSplit) {
      if (forceSplit)
        { this.history.lastOp = this.history.lastSelOp = this.history.lastOrigin = null; }
      return this.history.generation
    },
    isClean: function (gen) {
      return this.history.generation == (gen || this.cleanGeneration)
    },

    getHistory: function() {
      return {done: copyHistoryArray(this.history.done),
              undone: copyHistoryArray(this.history.undone)}
    },
    setHistory: function(histData) {
      var hist = this.history = new History(this.history);
      hist.done = copyHistoryArray(histData.done.slice(0), null, true);
      hist.undone = copyHistoryArray(histData.undone.slice(0), null, true);
    },

    setGutterMarker: docMethodOp(function(line, gutterID, value) {
      return changeLine(this, line, "gutter", function (line) {
        var markers = line.gutterMarkers || (line.gutterMarkers = {});
        markers[gutterID] = value;
        if (!value && isEmpty(markers)) { line.gutterMarkers = null; }
        return true
      })
    }),

    clearGutter: docMethodOp(function(gutterID) {
      var this$1 = this;

      this.iter(function (line) {
        if (line.gutterMarkers && line.gutterMarkers[gutterID]) {
          changeLine(this$1, line, "gutter", function () {
            line.gutterMarkers[gutterID] = null;
            if (isEmpty(line.gutterMarkers)) { line.gutterMarkers = null; }
            return true
          });
        }
      });
    }),

    lineInfo: function(line) {
      var n;
      if (typeof line == "number") {
        if (!isLine(this, line)) { return null }
        n = line;
        line = getLine(this, line);
        if (!line) { return null }
      } else {
        n = lineNo(line);
        if (n == null) { return null }
      }
      return {line: n, handle: line, text: line.text, gutterMarkers: line.gutterMarkers,
              textClass: line.textClass, bgClass: line.bgClass, wrapClass: line.wrapClass,
              widgets: line.widgets}
    },

    addLineClass: docMethodOp(function(handle, where, cls) {
      return changeLine(this, handle, where == "gutter" ? "gutter" : "class", function (line) {
        var prop = where == "text" ? "textClass"
                 : where == "background" ? "bgClass"
                 : where == "gutter" ? "gutterClass" : "wrapClass";
        if (!line[prop]) { line[prop] = cls; }
        else if (classTest(cls).test(line[prop])) { return false }
        else { line[prop] += " " + cls; }
        return true
      })
    }),
    removeLineClass: docMethodOp(function(handle, where, cls) {
      return changeLine(this, handle, where == "gutter" ? "gutter" : "class", function (line) {
        var prop = where == "text" ? "textClass"
                 : where == "background" ? "bgClass"
                 : where == "gutter" ? "gutterClass" : "wrapClass";
        var cur = line[prop];
        if (!cur) { return false }
        else if (cls == null) { line[prop] = null; }
        else {
          var found = cur.match(classTest(cls));
          if (!found) { return false }
          var end = found.index + found[0].length;
          line[prop] = cur.slice(0, found.index) + (!found.index || end == cur.length ? "" : " ") + cur.slice(end) || null;
        }
        return true
      })
    }),

    addLineWidget: docMethodOp(function(handle, node, options) {
      return addLineWidget(this, handle, node, options)
    }),
    removeLineWidget: function(widget) { widget.clear(); },

    markText: function(from, to, options) {
      return markText(this, clipPos(this, from), clipPos(this, to), options, options && options.type || "range")
    },
    setBookmark: function(pos, options) {
      var realOpts = {replacedWith: options && (options.nodeType == null ? options.widget : options),
                      insertLeft: options && options.insertLeft,
                      clearWhenEmpty: false, shared: options && options.shared,
                      handleMouseEvents: options && options.handleMouseEvents};
      pos = clipPos(this, pos);
      return markText(this, pos, pos, realOpts, "bookmark")
    },
    findMarksAt: function(pos) {
      pos = clipPos(this, pos);
      var markers = [], spans = getLine(this, pos.line).markedSpans;
      if (spans) { for (var i = 0; i < spans.length; ++i) {
        var span = spans[i];
        if ((span.from == null || span.from <= pos.ch) &&
            (span.to == null || span.to >= pos.ch))
          { markers.push(span.marker.parent || span.marker); }
      } }
      return markers
    },
    findMarks: function(from, to, filter) {
      from = clipPos(this, from); to = clipPos(this, to);
      var found = [], lineNo = from.line;
      this.iter(from.line, to.line + 1, function (line) {
        var spans = line.markedSpans;
        if (spans) { for (var i = 0; i < spans.length; i++) {
          var span = spans[i];
          if (!(span.to != null && lineNo == from.line && from.ch >= span.to ||
                span.from == null && lineNo != from.line ||
                span.from != null && lineNo == to.line && span.from >= to.ch) &&
              (!filter || filter(span.marker)))
            { found.push(span.marker.parent || span.marker); }
        } }
        ++lineNo;
      });
      return found
    },
    getAllMarks: function() {
      var markers = [];
      this.iter(function (line) {
        var sps = line.markedSpans;
        if (sps) { for (var i = 0; i < sps.length; ++i)
          { if (sps[i].from != null) { markers.push(sps[i].marker); } } }
      });
      return markers
    },

    posFromIndex: function(off) {
      var ch, lineNo = this.first, sepSize = this.lineSeparator().length;
      this.iter(function (line) {
        var sz = line.text.length + sepSize;
        if (sz > off) { ch = off; return true }
        off -= sz;
        ++lineNo;
      });
      return clipPos(this, Pos(lineNo, ch))
    },
    indexFromPos: function (coords) {
      coords = clipPos(this, coords);
      var index = coords.ch;
      if (coords.line < this.first || coords.ch < 0) { return 0 }
      var sepSize = this.lineSeparator().length;
      this.iter(this.first, coords.line, function (line) { // iter aborts when callback returns a truthy value
        index += line.text.length + sepSize;
      });
      return index
    },

    copy: function(copyHistory) {
      var doc = new Doc(getLines(this, this.first, this.first + this.size),
                        this.modeOption, this.first, this.lineSep, this.direction);
      doc.scrollTop = this.scrollTop; doc.scrollLeft = this.scrollLeft;
      doc.sel = this.sel;
      doc.extend = false;
      if (copyHistory) {
        doc.history.undoDepth = this.history.undoDepth;
        doc.setHistory(this.getHistory());
      }
      return doc
    },

    linkedDoc: function(options) {
      if (!options) { options = {}; }
      var from = this.first, to = this.first + this.size;
      if (options.from != null && options.from > from) { from = options.from; }
      if (options.to != null && options.to < to) { to = options.to; }
      var copy = new Doc(getLines(this, from, to), options.mode || this.modeOption, from, this.lineSep, this.direction);
      if (options.sharedHist) { copy.history = this.history
      ; }(this.linked || (this.linked = [])).push({doc: copy, sharedHist: options.sharedHist});
      copy.linked = [{doc: this, isParent: true, sharedHist: options.sharedHist}];
      copySharedMarkers(copy, findSharedMarkers(this));
      return copy
    },
    unlinkDoc: function(other) {
      if (other instanceof CodeMirror) { other = other.doc; }
      if (this.linked) { for (var i = 0; i < this.linked.length; ++i) {
        var link = this.linked[i];
        if (link.doc != other) { continue }
        this.linked.splice(i, 1);
        other.unlinkDoc(this);
        detachSharedMarkers(findSharedMarkers(this));
        break
      } }
      // If the histories were shared, split them again
      if (other.history == this.history) {
        var splitIds = [other.id];
        linkedDocs(other, function (doc) { return splitIds.push(doc.id); }, true);
        other.history = new History(null);
        other.history.done = copyHistoryArray(this.history.done, splitIds);
        other.history.undone = copyHistoryArray(this.history.undone, splitIds);
      }
    },
    iterLinkedDocs: function(f) {linkedDocs(this, f);},

    getMode: function() {return this.mode},
    getEditor: function() {return this.cm},

    splitLines: function(str) {
      if (this.lineSep) { return str.split(this.lineSep) }
      return splitLinesAuto(str)
    },
    lineSeparator: function() { return this.lineSep || "\n" },

    setDirection: docMethodOp(function (dir) {
      if (dir != "rtl") { dir = "ltr"; }
      if (dir == this.direction) { return }
      this.direction = dir;
      this.iter(function (line) { return line.order = null; });
      if (this.cm) { directionChanged(this.cm); }
    })
  });

  // Public alias.
  Doc.prototype.eachLine = Doc.prototype.iter;

  // Kludge to work around strange IE behavior where it'll sometimes
  // re-fire a series of drag-related events right after the drop (#1551)
  var lastDrop = 0;

  function onDrop(e) {
    var cm = this;
    clearDragCursor(cm);
    if (signalDOMEvent(cm, e) || eventInWidget(cm.display, e))
      { return }
    e_preventDefault(e);
    if (ie) { lastDrop = +new Date; }
    var pos = posFromMouse(cm, e, true), files = e.dataTransfer.files;
    if (!pos || cm.isReadOnly()) { return }
    // Might be a file drop, in which case we simply extract the text
    // and insert it.
    if (files && files.length && window.FileReader && window.File) {
      var n = files.length, text = Array(n), read = 0;
      var markAsReadAndPasteIfAllFilesAreRead = function () {
        if (++read == n) {
          operation(cm, function () {
            pos = clipPos(cm.doc, pos);
            var change = {from: pos, to: pos,
                          text: cm.doc.splitLines(
                              text.filter(function (t) { return t != null; }).join(cm.doc.lineSeparator())),
                          origin: "paste"};
            makeChange(cm.doc, change);
            setSelectionReplaceHistory(cm.doc, simpleSelection(clipPos(cm.doc, pos), clipPos(cm.doc, changeEnd(change))));
          })();
        }
      };
      var readTextFromFile = function (file, i) {
        if (cm.options.allowDropFileTypes &&
            indexOf(cm.options.allowDropFileTypes, file.type) == -1) {
          markAsReadAndPasteIfAllFilesAreRead();
          return
        }
        var reader = new FileReader;
        reader.onerror = function () { return markAsReadAndPasteIfAllFilesAreRead(); };
        reader.onload = function () {
          var content = reader.result;
          if (/[\x00-\x08\x0e-\x1f]{2}/.test(content)) {
            markAsReadAndPasteIfAllFilesAreRead();
            return
          }
          text[i] = content;
          markAsReadAndPasteIfAllFilesAreRead();
        };
        reader.readAsText(file);
      };
      for (var i = 0; i < files.length; i++) { readTextFromFile(files[i], i); }
    } else { // Normal drop
      // Don't do a replace if the drop happened inside of the selected text.
      if (cm.state.draggingText && cm.doc.sel.contains(pos) > -1) {
        cm.state.draggingText(e);
        // Ensure the editor is re-focused
        setTimeout(function () { return cm.display.input.focus(); }, 20);
        return
      }
      try {
        var text$1 = e.dataTransfer.getData("Text");
        if (text$1) {
          var selected;
          if (cm.state.draggingText && !cm.state.draggingText.copy)
            { selected = cm.listSelections(); }
          setSelectionNoUndo(cm.doc, simpleSelection(pos, pos));
          if (selected) { for (var i$1 = 0; i$1 < selected.length; ++i$1)
            { replaceRange(cm.doc, "", selected[i$1].anchor, selected[i$1].head, "drag"); } }
          cm.replaceSelection(text$1, "around", "paste");
          cm.display.input.focus();
        }
      }
      catch(e$1){}
    }
  }

  function onDragStart(cm, e) {
    if (ie && (!cm.state.draggingText || +new Date - lastDrop < 100)) { e_stop(e); return }
    if (signalDOMEvent(cm, e) || eventInWidget(cm.display, e)) { return }

    e.dataTransfer.setData("Text", cm.getSelection());
    e.dataTransfer.effectAllowed = "copyMove";

    // Use dummy image instead of default browsers image.
    // Recent Safari (~6.0.2) have a tendency to segfault when this happens, so we don't do it there.
    if (e.dataTransfer.setDragImage && !safari) {
      var img = elt("img", null, null, "position: fixed; left: 0; top: 0;");
      img.src = "data:image/gif;base64,R0lGODlhAQABAAAAACH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==";
      if (presto) {
        img.width = img.height = 1;
        cm.display.wrapper.appendChild(img);
        // Force a relayout, or Opera won't use our image for some obscure reason
        img._top = img.offsetTop;
      }
      e.dataTransfer.setDragImage(img, 0, 0);
      if (presto) { img.parentNode.removeChild(img); }
    }
  }

  function onDragOver(cm, e) {
    var pos = posFromMouse(cm, e);
    if (!pos) { return }
    var frag = document.createDocumentFragment();
    drawSelectionCursor(cm, pos, frag);
    if (!cm.display.dragCursor) {
      cm.display.dragCursor = elt("div", null, "CodeMirror-cursors CodeMirror-dragcursors");
      cm.display.lineSpace.insertBefore(cm.display.dragCursor, cm.display.cursorDiv);
    }
    removeChildrenAndAdd(cm.display.dragCursor, frag);
  }

  function clearDragCursor(cm) {
    if (cm.display.dragCursor) {
      cm.display.lineSpace.removeChild(cm.display.dragCursor);
      cm.display.dragCursor = null;
    }
  }

  // These must be handled carefully, because naively registering a
  // handler for each editor will cause the editors to never be
  // garbage collected.

  function forEachCodeMirror(f) {
    if (!document.getElementsByClassName) { return }
    var byClass = document.getElementsByClassName("CodeMirror"), editors = [];
    for (var i = 0; i < byClass.length; i++) {
      var cm = byClass[i].CodeMirror;
      if (cm) { editors.push(cm); }
    }
    if (editors.length) { editors[0].operation(function () {
      for (var i = 0; i < editors.length; i++) { f(editors[i]); }
    }); }
  }

  var globalsRegistered = false;
  function ensureGlobalHandlers() {
    if (globalsRegistered) { return }
    registerGlobalHandlers();
    globalsRegistered = true;
  }
  function registerGlobalHandlers() {
    // When the window resizes, we need to refresh active editors.
    var resizeTimer;
    on(window, "resize", function () {
      if (resizeTimer == null) { resizeTimer = setTimeout(function () {
        resizeTimer = null;
        forEachCodeMirror(onResize);
      }, 100); }
    });
    // When the window loses focus, we want to show the editor as blurred
    on(window, "blur", function () { return forEachCodeMirror(onBlur); });
  }
  // Called when the window resizes
  function onResize(cm) {
    var d = cm.display;
    // Might be a text scaling operation, clear size caches.
    d.cachedCharWidth = d.cachedTextHeight = d.cachedPaddingH = null;
    d.scrollbarsClipped = false;
    cm.setSize();
  }

  var keyNames = {
    3: "Pause", 8: "Backspace", 9: "Tab", 13: "Enter", 16: "Shift", 17: "Ctrl", 18: "Alt",
    19: "Pause", 20: "CapsLock", 27: "Esc", 32: "Space", 33: "PageUp", 34: "PageDown", 35: "End",
    36: "Home", 37: "Left", 38: "Up", 39: "Right", 40: "Down", 44: "PrintScrn", 45: "Insert",
    46: "Delete", 59: ";", 61: "=", 91: "Mod", 92: "Mod", 93: "Mod",
    106: "*", 107: "=", 109: "-", 110: ".", 111: "/", 145: "ScrollLock",
    173: "-", 186: ";", 187: "=", 188: ",", 189: "-", 190: ".", 191: "/", 192: "`", 219: "[", 220: "\\",
    221: "]", 222: "'", 224: "Mod", 63232: "Up", 63233: "Down", 63234: "Left", 63235: "Right", 63272: "Delete",
    63273: "Home", 63275: "End", 63276: "PageUp", 63277: "PageDown", 63302: "Insert"
  };

  // Number keys
  for (var i = 0; i < 10; i++) { keyNames[i + 48] = keyNames[i + 96] = String(i); }
  // Alphabetic keys
  for (var i$1 = 65; i$1 <= 90; i$1++) { keyNames[i$1] = String.fromCharCode(i$1); }
  // Function keys
  for (var i$2 = 1; i$2 <= 12; i$2++) { keyNames[i$2 + 111] = keyNames[i$2 + 63235] = "F" + i$2; }

  var keyMap = {};

  keyMap.basic = {
    "Left": "goCharLeft", "Right": "goCharRight", "Up": "goLineUp", "Down": "goLineDown",
    "End": "goLineEnd", "Home": "goLineStartSmart", "PageUp": "goPageUp", "PageDown": "goPageDown",
    "Delete": "delCharAfter", "Backspace": "delCharBefore", "Shift-Backspace": "delCharBefore",
    "Tab": "defaultTab", "Shift-Tab": "indentAuto",
    "Enter": "newlineAndIndent", "Insert": "toggleOverwrite",
    "Esc": "singleSelection"
  };
  // Note that the save and find-related commands aren't defined by
  // default. User code or addons can define them. Unknown commands
  // are simply ignored.
  keyMap.pcDefault = {
    "Ctrl-A": "selectAll", "Ctrl-D": "deleteLine", "Ctrl-Z": "undo", "Shift-Ctrl-Z": "redo", "Ctrl-Y": "redo",
    "Ctrl-Home": "goDocStart", "Ctrl-End": "goDocEnd", "Ctrl-Up": "goLineUp", "Ctrl-Down": "goLineDown",
    "Ctrl-Left": "goGroupLeft", "Ctrl-Right": "goGroupRight", "Alt-Left": "goLineStart", "Alt-Right": "goLineEnd",
    "Ctrl-Backspace": "delGroupBefore", "Ctrl-Delete": "delGroupAfter", "Ctrl-S": "save", "Ctrl-F": "find",
    "Ctrl-G": "findNext", "Shift-Ctrl-G": "findPrev", "Shift-Ctrl-F": "replace", "Shift-Ctrl-R": "replaceAll",
    "Ctrl-[": "indentLess", "Ctrl-]": "indentMore",
    "Ctrl-U": "undoSelection", "Shift-Ctrl-U": "redoSelection", "Alt-U": "redoSelection",
    "fallthrough": "basic"
  };
  // Very basic readline/emacs-style bindings, which are standard on Mac.
  keyMap.emacsy = {
    "Ctrl-F": "goCharRight", "Ctrl-B": "goCharLeft", "Ctrl-P": "goLineUp", "Ctrl-N": "goLineDown",
    "Ctrl-A": "goLineStart", "Ctrl-E": "goLineEnd", "Ctrl-V": "goPageDown", "Shift-Ctrl-V": "goPageUp",
    "Ctrl-D": "delCharAfter", "Ctrl-H": "delCharBefore", "Alt-Backspace": "delWordBefore", "Ctrl-K": "killLine",
    "Ctrl-T": "transposeChars", "Ctrl-O": "openLine"
  };
  keyMap.macDefault = {
    "Cmd-A": "selectAll", "Cmd-D": "deleteLine", "Cmd-Z": "undo", "Shift-Cmd-Z": "redo", "Cmd-Y": "redo",
    "Cmd-Home": "goDocStart", "Cmd-Up": "goDocStart", "Cmd-End": "goDocEnd", "Cmd-Down": "goDocEnd", "Alt-Left": "goGroupLeft",
    "Alt-Right": "goGroupRight", "Cmd-Left": "goLineLeft", "Cmd-Right": "goLineRight", "Alt-Backspace": "delGroupBefore",
    "Ctrl-Alt-Backspace": "delGroupAfter", "Alt-Delete": "delGroupAfter", "Cmd-S": "save", "Cmd-F": "find",
    "Cmd-G": "findNext", "Shift-Cmd-G": "findPrev", "Cmd-Alt-F": "replace", "Shift-Cmd-Alt-F": "replaceAll",
    "Cmd-[": "indentLess", "Cmd-]": "indentMore", "Cmd-Backspace": "delWrappedLineLeft", "Cmd-Delete": "delWrappedLineRight",
    "Cmd-U": "undoSelection", "Shift-Cmd-U": "redoSelection", "Ctrl-Up": "goDocStart", "Ctrl-Down": "goDocEnd",
    "fallthrough": ["basic", "emacsy"]
  };
  keyMap["default"] = mac ? keyMap.macDefault : keyMap.pcDefault;

  // KEYMAP DISPATCH

  function normalizeKeyName(name) {
    var parts = name.split(/-(?!$)/);
    name = parts[parts.length - 1];
    var alt, ctrl, shift, cmd;
    for (var i = 0; i < parts.length - 1; i++) {
      var mod = parts[i];
      if (/^(cmd|meta|m)$/i.test(mod)) { cmd = true; }
      else if (/^a(lt)?$/i.test(mod)) { alt = true; }
      else if (/^(c|ctrl|control)$/i.test(mod)) { ctrl = true; }
      else if (/^s(hift)?$/i.test(mod)) { shift = true; }
      else { throw new Error("Unrecognized modifier name: " + mod) }
    }
    if (alt) { name = "Alt-" + name; }
    if (ctrl) { name = "Ctrl-" + name; }
    if (cmd) { name = "Cmd-" + name; }
    if (shift) { name = "Shift-" + name; }
    return name
  }

  // This is a kludge to keep keymaps mostly working as raw objects
  // (backwards compatibility) while at the same time support features
  // like normalization and multi-stroke key bindings. It compiles a
  // new normalized keymap, and then updates the old object to reflect
  // this.
  function normalizeKeyMap(keymap) {
    var copy = {};
    for (var keyname in keymap) { if (keymap.hasOwnProperty(keyname)) {
      var value = keymap[keyname];
      if (/^(name|fallthrough|(de|at)tach)$/.test(keyname)) { continue }
      if (value == "...") { delete keymap[keyname]; continue }

      var keys = map(keyname.split(" "), normalizeKeyName);
      for (var i = 0; i < keys.length; i++) {
        var val = (void 0), name = (void 0);
        if (i == keys.length - 1) {
          name = keys.join(" ");
          val = value;
        } else {
          name = keys.slice(0, i + 1).join(" ");
          val = "...";
        }
        var prev = copy[name];
        if (!prev) { copy[name] = val; }
        else if (prev != val) { throw new Error("Inconsistent bindings for " + name) }
      }
      delete keymap[keyname];
    } }
    for (var prop in copy) { keymap[prop] = copy[prop]; }
    return keymap
  }

  function lookupKey(key, map, handle, context) {
    map = getKeyMap(map);
    var found = map.call ? map.call(key, context) : map[key];
    if (found === false) { return "nothing" }
    if (found === "...") { return "multi" }
    if (found != null && handle(found)) { return "handled" }

    if (map.fallthrough) {
      if (Object.prototype.toString.call(map.fallthrough) != "[object Array]")
        { return lookupKey(key, map.fallthrough, handle, context) }
      for (var i = 0; i < map.fallthrough.length; i++) {
        var result = lookupKey(key, map.fallthrough[i], handle, context);
        if (result) { return result }
      }
    }
  }

  // Modifier key presses don't count as 'real' key presses for the
  // purpose of keymap fallthrough.
  function isModifierKey(value) {
    var name = typeof value == "string" ? value : keyNames[value.keyCode];
    return name == "Ctrl" || name == "Alt" || name == "Shift" || name == "Mod"
  }

  function addModifierNames(name, event, noShift) {
    var base = name;
    if (event.altKey && base != "Alt") { name = "Alt-" + name; }
    if ((flipCtrlCmd ? event.metaKey : event.ctrlKey) && base != "Ctrl") { name = "Ctrl-" + name; }
    if ((flipCtrlCmd ? event.ctrlKey : event.metaKey) && base != "Mod") { name = "Cmd-" + name; }
    if (!noShift && event.shiftKey && base != "Shift") { name = "Shift-" + name; }
    return name
  }

  // Look up the name of a key as indicated by an event object.
  function keyName(event, noShift) {
    if (presto && event.keyCode == 34 && event["char"]) { return false }
    var name = keyNames[event.keyCode];
    if (name == null || event.altGraphKey) { return false }
    // Ctrl-ScrollLock has keyCode 3, same as Ctrl-Pause,
    // so we'll use event.code when available (Chrome 48+, FF 38+, Safari 10.1+)
    if (event.keyCode == 3 && event.code) { name = event.code; }
    return addModifierNames(name, event, noShift)
  }

  function getKeyMap(val) {
    return typeof val == "string" ? keyMap[val] : val
  }

  // Helper for deleting text near the selection(s), used to implement
  // backspace, delete, and similar functionality.
  function deleteNearSelection(cm, compute) {
    var ranges = cm.doc.sel.ranges, kill = [];
    // Build up a set of ranges to kill first, merging overlapping
    // ranges.
    for (var i = 0; i < ranges.length; i++) {
      var toKill = compute(ranges[i]);
      while (kill.length && cmp(toKill.from, lst(kill).to) <= 0) {
        var replaced = kill.pop();
        if (cmp(replaced.from, toKill.from) < 0) {
          toKill.from = replaced.from;
          break
        }
      }
      kill.push(toKill);
    }
    // Next, remove those actual ranges.
    runInOp(cm, function () {
      for (var i = kill.length - 1; i >= 0; i--)
        { replaceRange(cm.doc, "", kill[i].from, kill[i].to, "+delete"); }
      ensureCursorVisible(cm);
    });
  }

  function moveCharLogically(line, ch, dir) {
    var target = skipExtendingChars(line.text, ch + dir, dir);
    return target < 0 || target > line.text.length ? null : target
  }

  function moveLogically(line, start, dir) {
    var ch = moveCharLogically(line, start.ch, dir);
    return ch == null ? null : new Pos(start.line, ch, dir < 0 ? "after" : "before")
  }

  function endOfLine(visually, cm, lineObj, lineNo, dir) {
    if (visually) {
      if (cm.doc.direction == "rtl") { dir = -dir; }
      var order = getOrder(lineObj, cm.doc.direction);
      if (order) {
        var part = dir < 0 ? lst(order) : order[0];
        var moveInStorageOrder = (dir < 0) == (part.level == 1);
        var sticky = moveInStorageOrder ? "after" : "before";
        var ch;
        // With a wrapped rtl chunk (possibly spanning multiple bidi parts),
        // it could be that the last bidi part is not on the last visual line,
        // since visual lines contain content order-consecutive chunks.
        // Thus, in rtl, we are looking for the first (content-order) character
        // in the rtl chunk that is on the last line (that is, the same line
        // as the last (content-order) character).
        if (part.level > 0 || cm.doc.direction == "rtl") {
          var prep = prepareMeasureForLine(cm, lineObj);
          ch = dir < 0 ? lineObj.text.length - 1 : 0;
          var targetTop = measureCharPrepared(cm, prep, ch).top;
          ch = findFirst(function (ch) { return measureCharPrepared(cm, prep, ch).top == targetTop; }, (dir < 0) == (part.level == 1) ? part.from : part.to - 1, ch);
          if (sticky == "before") { ch = moveCharLogically(lineObj, ch, 1); }
        } else { ch = dir < 0 ? part.to : part.from; }
        return new Pos(lineNo, ch, sticky)
      }
    }
    return new Pos(lineNo, dir < 0 ? lineObj.text.length : 0, dir < 0 ? "before" : "after")
  }

  function moveVisually(cm, line, start, dir) {
    var bidi = getOrder(line, cm.doc.direction);
    if (!bidi) { return moveLogically(line, start, dir) }
    if (start.ch >= line.text.length) {
      start.ch = line.text.length;
      start.sticky = "before";
    } else if (start.ch <= 0) {
      start.ch = 0;
      start.sticky = "after";
    }
    var partPos = getBidiPartAt(bidi, start.ch, start.sticky), part = bidi[partPos];
    if (cm.doc.direction == "ltr" && part.level % 2 == 0 && (dir > 0 ? part.to > start.ch : part.from < start.ch)) {
      // Case 1: We move within an ltr part in an ltr editor. Even with wrapped lines,
      // nothing interesting happens.
      return moveLogically(line, start, dir)
    }

    var mv = function (pos, dir) { return moveCharLogically(line, pos instanceof Pos ? pos.ch : pos, dir); };
    var prep;
    var getWrappedLineExtent = function (ch) {
      if (!cm.options.lineWrapping) { return {begin: 0, end: line.text.length} }
      prep = prep || prepareMeasureForLine(cm, line);
      return wrappedLineExtentChar(cm, line, prep, ch)
    };
    var wrappedLineExtent = getWrappedLineExtent(start.sticky == "before" ? mv(start, -1) : start.ch);

    if (cm.doc.direction == "rtl" || part.level == 1) {
      var moveInStorageOrder = (part.level == 1) == (dir < 0);
      var ch = mv(start, moveInStorageOrder ? 1 : -1);
      if (ch != null && (!moveInStorageOrder ? ch >= part.from && ch >= wrappedLineExtent.begin : ch <= part.to && ch <= wrappedLineExtent.end)) {
        // Case 2: We move within an rtl part or in an rtl editor on the same visual line
        var sticky = moveInStorageOrder ? "before" : "after";
        return new Pos(start.line, ch, sticky)
      }
    }

    // Case 3: Could not move within this bidi part in this visual line, so leave
    // the current bidi part

    var searchInVisualLine = function (partPos, dir, wrappedLineExtent) {
      var getRes = function (ch, moveInStorageOrder) { return moveInStorageOrder
        ? new Pos(start.line, mv(ch, 1), "before")
        : new Pos(start.line, ch, "after"); };

      for (; partPos >= 0 && partPos < bidi.length; partPos += dir) {
        var part = bidi[partPos];
        var moveInStorageOrder = (dir > 0) == (part.level != 1);
        var ch = moveInStorageOrder ? wrappedLineExtent.begin : mv(wrappedLineExtent.end, -1);
        if (part.from <= ch && ch < part.to) { return getRes(ch, moveInStorageOrder) }
        ch = moveInStorageOrder ? part.from : mv(part.to, -1);
        if (wrappedLineExtent.begin <= ch && ch < wrappedLineExtent.end) { return getRes(ch, moveInStorageOrder) }
      }
    };

    // Case 3a: Look for other bidi parts on the same visual line
    var res = searchInVisualLine(partPos + dir, dir, wrappedLineExtent);
    if (res) { return res }

    // Case 3b: Look for other bidi parts on the next visual line
    var nextCh = dir > 0 ? wrappedLineExtent.end : mv(wrappedLineExtent.begin, -1);
    if (nextCh != null && !(dir > 0 && nextCh == line.text.length)) {
      res = searchInVisualLine(dir > 0 ? 0 : bidi.length - 1, dir, getWrappedLineExtent(nextCh));
      if (res) { return res }
    }

    // Case 4: Nowhere to move
    return null
  }

  // Commands are parameter-less actions that can be performed on an
  // editor, mostly used for keybindings.
  var commands = {
    selectAll: selectAll,
    singleSelection: function (cm) { return cm.setSelection(cm.getCursor("anchor"), cm.getCursor("head"), sel_dontScroll); },
    killLine: function (cm) { return deleteNearSelection(cm, function (range) {
      if (range.empty()) {
        var len = getLine(cm.doc, range.head.line).text.length;
        if (range.head.ch == len && range.head.line < cm.lastLine())
          { return {from: range.head, to: Pos(range.head.line + 1, 0)} }
        else
          { return {from: range.head, to: Pos(range.head.line, len)} }
      } else {
        return {from: range.from(), to: range.to()}
      }
    }); },
    deleteLine: function (cm) { return deleteNearSelection(cm, function (range) { return ({
      from: Pos(range.from().line, 0),
      to: clipPos(cm.doc, Pos(range.to().line + 1, 0))
    }); }); },
    delLineLeft: function (cm) { return deleteNearSelection(cm, function (range) { return ({
      from: Pos(range.from().line, 0), to: range.from()
    }); }); },
    delWrappedLineLeft: function (cm) { return deleteNearSelection(cm, function (range) {
      var top = cm.charCoords(range.head, "div").top + 5;
      var leftPos = cm.coordsChar({left: 0, top: top}, "div");
      return {from: leftPos, to: range.from()}
    }); },
    delWrappedLineRight: function (cm) { return deleteNearSelection(cm, function (range) {
      var top = cm.charCoords(range.head, "div").top + 5;
      var rightPos = cm.coordsChar({left: cm.display.lineDiv.offsetWidth + 100, top: top}, "div");
      return {from: range.from(), to: rightPos }
    }); },
    undo: function (cm) { return cm.undo(); },
    redo: function (cm) { return cm.redo(); },
    undoSelection: function (cm) { return cm.undoSelection(); },
    redoSelection: function (cm) { return cm.redoSelection(); },
    goDocStart: function (cm) { return cm.extendSelection(Pos(cm.firstLine(), 0)); },
    goDocEnd: function (cm) { return cm.extendSelection(Pos(cm.lastLine())); },
    goLineStart: function (cm) { return cm.extendSelectionsBy(function (range) { return lineStart(cm, range.head.line); },
      {origin: "+move", bias: 1}
    ); },
    goLineStartSmart: function (cm) { return cm.extendSelectionsBy(function (range) { return lineStartSmart(cm, range.head); },
      {origin: "+move", bias: 1}
    ); },
    goLineEnd: function (cm) { return cm.extendSelectionsBy(function (range) { return lineEnd(cm, range.head.line); },
      {origin: "+move", bias: -1}
    ); },
    goLineRight: function (cm) { return cm.extendSelectionsBy(function (range) {
      var top = cm.cursorCoords(range.head, "div").top + 5;
      return cm.coordsChar({left: cm.display.lineDiv.offsetWidth + 100, top: top}, "div")
    }, sel_move); },
    goLineLeft: function (cm) { return cm.extendSelectionsBy(function (range) {
      var top = cm.cursorCoords(range.head, "div").top + 5;
      return cm.coordsChar({left: 0, top: top}, "div")
    }, sel_move); },
    goLineLeftSmart: function (cm) { return cm.extendSelectionsBy(function (range) {
      var top = cm.cursorCoords(range.head, "div").top + 5;
      var pos = cm.coordsChar({left: 0, top: top}, "div");
      if (pos.ch < cm.getLine(pos.line).search(/\S/)) { return lineStartSmart(cm, range.head) }
      return pos
    }, sel_move); },
    goLineUp: function (cm) { return cm.moveV(-1, "line"); },
    goLineDown: function (cm) { return cm.moveV(1, "line"); },
    goPageUp: function (cm) { return cm.moveV(-1, "page"); },
    goPageDown: function (cm) { return cm.moveV(1, "page"); },
    goCharLeft: function (cm) { return cm.moveH(-1, "char"); },
    goCharRight: function (cm) { return cm.moveH(1, "char"); },
    goColumnLeft: function (cm) { return cm.moveH(-1, "column"); },
    goColumnRight: function (cm) { return cm.moveH(1, "column"); },
    goWordLeft: function (cm) { return cm.moveH(-1, "word"); },
    goGroupRight: function (cm) { return cm.moveH(1, "group"); },
    goGroupLeft: function (cm) { return cm.moveH(-1, "group"); },
    goWordRight: function (cm) { return cm.moveH(1, "word"); },
    delCharBefore: function (cm) { return cm.deleteH(-1, "codepoint"); },
    delCharAfter: function (cm) { return cm.deleteH(1, "char"); },
    delWordBefore: function (cm) { return cm.deleteH(-1, "word"); },
    delWordAfter: function (cm) { return cm.deleteH(1, "word"); },
    delGroupBefore: function (cm) { return cm.deleteH(-1, "group"); },
    delGroupAfter: function (cm) { return cm.deleteH(1, "group"); },
    indentAuto: function (cm) { return cm.indentSelection("smart"); },
    indentMore: function (cm) { return cm.indentSelection("add"); },
    indentLess: function (cm) { return cm.indentSelection("subtract"); },
    insertTab: function (cm) { return cm.replaceSelection("\t"); },
    insertSoftTab: function (cm) {
      var spaces = [], ranges = cm.listSelections(), tabSize = cm.options.tabSize;
      for (var i = 0; i < ranges.length; i++) {
        var pos = ranges[i].from();
        var col = countColumn(cm.getLine(pos.line), pos.ch, tabSize);
        spaces.push(spaceStr(tabSize - col % tabSize));
      }
      cm.replaceSelections(spaces);
    },
    defaultTab: function (cm) {
      if (cm.somethingSelected()) { cm.indentSelection("add"); }
      else { cm.execCommand("insertTab"); }
    },
    // Swap the two chars left and right of each selection's head.
    // Move cursor behind the two swapped characters afterwards.
    //
    // Doesn't consider line feeds a character.
    // Doesn't scan more than one line above to find a character.
    // Doesn't do anything on an empty line.
    // Doesn't do anything with non-empty selections.
    transposeChars: function (cm) { return runInOp(cm, function () {
      var ranges = cm.listSelections(), newSel = [];
      for (var i = 0; i < ranges.length; i++) {
        if (!ranges[i].empty()) { continue }
        var cur = ranges[i].head, line = getLine(cm.doc, cur.line).text;
        if (line) {
          if (cur.ch == line.length) { cur = new Pos(cur.line, cur.ch - 1); }
          if (cur.ch > 0) {
            cur = new Pos(cur.line, cur.ch + 1);
            cm.replaceRange(line.charAt(cur.ch - 1) + line.charAt(cur.ch - 2),
                            Pos(cur.line, cur.ch - 2), cur, "+transpose");
          } else if (cur.line > cm.doc.first) {
            var prev = getLine(cm.doc, cur.line - 1).text;
            if (prev) {
              cur = new Pos(cur.line, 1);
              cm.replaceRange(line.charAt(0) + cm.doc.lineSeparator() +
                              prev.charAt(prev.length - 1),
                              Pos(cur.line - 1, prev.length - 1), cur, "+transpose");
            }
          }
        }
        newSel.push(new Range(cur, cur));
      }
      cm.setSelections(newSel);
    }); },
    newlineAndIndent: function (cm) { return runInOp(cm, function () {
      var sels = cm.listSelections();
      for (var i = sels.length - 1; i >= 0; i--)
        { cm.replaceRange(cm.doc.lineSeparator(), sels[i].anchor, sels[i].head, "+input"); }
      sels = cm.listSelections();
      for (var i$1 = 0; i$1 < sels.length; i$1++)
        { cm.indentLine(sels[i$1].from().line, null, true); }
      ensureCursorVisible(cm);
    }); },
    openLine: function (cm) { return cm.replaceSelection("\n", "start"); },
    toggleOverwrite: function (cm) { return cm.toggleOverwrite(); }
  };


  function lineStart(cm, lineN) {
    var line = getLine(cm.doc, lineN);
    var visual = visualLine(line);
    if (visual != line) { lineN = lineNo(visual); }
    return endOfLine(true, cm, visual, lineN, 1)
  }
  function lineEnd(cm, lineN) {
    var line = getLine(cm.doc, lineN);
    var visual = visualLineEnd(line);
    if (visual != line) { lineN = lineNo(visual); }
    return endOfLine(true, cm, line, lineN, -1)
  }
  function lineStartSmart(cm, pos) {
    var start = lineStart(cm, pos.line);
    var line = getLine(cm.doc, start.line);
    var order = getOrder(line, cm.doc.direction);
    if (!order || order[0].level == 0) {
      var firstNonWS = Math.max(start.ch, line.text.search(/\S/));
      var inWS = pos.line == start.line && pos.ch <= firstNonWS && pos.ch;
      return Pos(start.line, inWS ? 0 : firstNonWS, start.sticky)
    }
    return start
  }

  // Run a handler that was bound to a key.
  function doHandleBinding(cm, bound, dropShift) {
    if (typeof bound == "string") {
      bound = commands[bound];
      if (!bound) { return false }
    }
    // Ensure previous input has been read, so that the handler sees a
    // consistent view of the document
    cm.display.input.ensurePolled();
    var prevShift = cm.display.shift, done = false;
    try {
      if (cm.isReadOnly()) { cm.state.suppressEdits = true; }
      if (dropShift) { cm.display.shift = false; }
      done = bound(cm) != Pass;
    } finally {
      cm.display.shift = prevShift;
      cm.state.suppressEdits = false;
    }
    return done
  }

  function lookupKeyForEditor(cm, name, handle) {
    for (var i = 0; i < cm.state.keyMaps.length; i++) {
      var result = lookupKey(name, cm.state.keyMaps[i], handle, cm);
      if (result) { return result }
    }
    return (cm.options.extraKeys && lookupKey(name, cm.options.extraKeys, handle, cm))
      || lookupKey(name, cm.options.keyMap, handle, cm)
  }

  // Note that, despite the name, this function is also used to check
  // for bound mouse clicks.

  var stopSeq = new Delayed;

  function dispatchKey(cm, name, e, handle) {
    var seq = cm.state.keySeq;
    if (seq) {
      if (isModifierKey(name)) { return "handled" }
      if (/\'$/.test(name))
        { cm.state.keySeq = null; }
      else
        { stopSeq.set(50, function () {
          if (cm.state.keySeq == seq) {
            cm.state.keySeq = null;
            cm.display.input.reset();
          }
        }); }
      if (dispatchKeyInner(cm, seq + " " + name, e, handle)) { return true }
    }
    return dispatchKeyInner(cm, name, e, handle)
  }

  function dispatchKeyInner(cm, name, e, handle) {
    var result = lookupKeyForEditor(cm, name, handle);

    if (result == "multi")
      { cm.state.keySeq = name; }
    if (result == "handled")
      { signalLater(cm, "keyHandled", cm, name, e); }

    if (result == "handled" || result == "multi") {
      e_preventDefault(e);
      restartBlink(cm);
    }

    return !!result
  }

  // Handle a key from the keydown event.
  function handleKeyBinding(cm, e) {
    var name = keyName(e, true);
    if (!name) { return false }

    if (e.shiftKey && !cm.state.keySeq) {
      // First try to resolve full name (including 'Shift-'). Failing
      // that, see if there is a cursor-motion command (starting with
      // 'go') bound to the keyname without 'Shift-'.
      return dispatchKey(cm, "Shift-" + name, e, function (b) { return doHandleBinding(cm, b, true); })
          || dispatchKey(cm, name, e, function (b) {
               if (typeof b == "string" ? /^go[A-Z]/.test(b) : b.motion)
                 { return doHandleBinding(cm, b) }
             })
    } else {
      return dispatchKey(cm, name, e, function (b) { return doHandleBinding(cm, b); })
    }
  }

  // Handle a key from the keypress event
  function handleCharBinding(cm, e, ch) {
    return dispatchKey(cm, "'" + ch + "'", e, function (b) { return doHandleBinding(cm, b, true); })
  }

  var lastStoppedKey = null;
  function onKeyDown(e) {
    var cm = this;
    if (e.target && e.target != cm.display.input.getField()) { return }
    cm.curOp.focus = activeElt();
    if (signalDOMEvent(cm, e)) { return }
    // IE does strange things with escape.
    if (ie && ie_version < 11 && e.keyCode == 27) { e.returnValue = false; }
    var code = e.keyCode;
    cm.display.shift = code == 16 || e.shiftKey;
    var handled = handleKeyBinding(cm, e);
    if (presto) {
      lastStoppedKey = handled ? code : null;
      // Opera has no cut event... we try to at least catch the key combo
      if (!handled && code == 88 && !hasCopyEvent && (mac ? e.metaKey : e.ctrlKey))
        { cm.replaceSelection("", null, "cut"); }
    }
    if (gecko && !mac && !handled && code == 46 && e.shiftKey && !e.ctrlKey && document.execCommand)
      { document.execCommand("cut"); }

    // Turn mouse into crosshair when Alt is held on Mac.
    if (code == 18 && !/\bCodeMirror-crosshair\b/.test(cm.display.lineDiv.className))
      { showCrossHair(cm); }
  }

  function showCrossHair(cm) {
    var lineDiv = cm.display.lineDiv;
    addClass(lineDiv, "CodeMirror-crosshair");

    function up(e) {
      if (e.keyCode == 18 || !e.altKey) {
        rmClass(lineDiv, "CodeMirror-crosshair");
        off(document, "keyup", up);
        off(document, "mouseover", up);
      }
    }
    on(document, "keyup", up);
    on(document, "mouseover", up);
  }

  function onKeyUp(e) {
    if (e.keyCode == 16) { this.doc.sel.shift = false; }
    signalDOMEvent(this, e);
  }

  function onKeyPress(e) {
    var cm = this;
    if (e.target && e.target != cm.display.input.getField()) { return }
    if (eventInWidget(cm.display, e) || signalDOMEvent(cm, e) || e.ctrlKey && !e.altKey || mac && e.metaKey) { return }
    var keyCode = e.keyCode, charCode = e.charCode;
    if (presto && keyCode == lastStoppedKey) {lastStoppedKey = null; e_preventDefault(e); return}
    if ((presto && (!e.which || e.which < 10)) && handleKeyBinding(cm, e)) { return }
    var ch = String.fromCharCode(charCode == null ? keyCode : charCode);
    // Some browsers fire keypress events for backspace
    if (ch == "\x08") { return }
    if (handleCharBinding(cm, e, ch)) { return }
    cm.display.input.onKeyPress(e);
  }

  var DOUBLECLICK_DELAY = 400;

  var PastClick = function(time, pos, button) {
    this.time = time;
    this.pos = pos;
    this.button = button;
  };

  PastClick.prototype.compare = function (time, pos, button) {
    return this.time + DOUBLECLICK_DELAY > time &&
      cmp(pos, this.pos) == 0 && button == this.button
  };

  var lastClick, lastDoubleClick;
  function clickRepeat(pos, button) {
    var now = +new Date;
    if (lastDoubleClick && lastDoubleClick.compare(now, pos, button)) {
      lastClick = lastDoubleClick = null;
      return "triple"
    } else if (lastClick && lastClick.compare(now, pos, button)) {
      lastDoubleClick = new PastClick(now, pos, button);
      lastClick = null;
      return "double"
    } else {
      lastClick = new PastClick(now, pos, button);
      lastDoubleClick = null;
      return "single"
    }
  }

  // A mouse down can be a single click, double click, triple click,
  // start of selection drag, start of text drag, new cursor
  // (ctrl-click), rectangle drag (alt-drag), or xwin
  // middle-click-paste. Or it might be a click on something we should
  // not interfere with, such as a scrollbar or widget.
  function onMouseDown(e) {
    var cm = this, display = cm.display;
    if (signalDOMEvent(cm, e) || display.activeTouch && display.input.supportsTouch()) { return }
    display.input.ensurePolled();
    display.shift = e.shiftKey;

    if (eventInWidget(display, e)) {
      if (!webkit) {
        // Briefly turn off draggability, to allow widgets to do
        // normal dragging things.
        display.scroller.draggable = false;
        setTimeout(function () { return display.scroller.draggable = true; }, 100);
      }
      return
    }
    if (clickInGutter(cm, e)) { return }
    var pos = posFromMouse(cm, e), button = e_button(e), repeat = pos ? clickRepeat(pos, button) : "single";
    window.focus();

    // #3261: make sure, that we're not starting a second selection
    if (button == 1 && cm.state.selectingText)
      { cm.state.selectingText(e); }

    if (pos && handleMappedButton(cm, button, pos, repeat, e)) { return }

    if (button == 1) {
      if (pos) { leftButtonDown(cm, pos, repeat, e); }
      else if (e_target(e) == display.scroller) { e_preventDefault(e); }
    } else if (button == 2) {
      if (pos) { extendSelection(cm.doc, pos); }
      setTimeout(function () { return display.input.focus(); }, 20);
    } else if (button == 3) {
      if (captureRightClick) { cm.display.input.onContextMenu(e); }
      else { delayBlurEvent(cm); }
    }
  }

  function handleMappedButton(cm, button, pos, repeat, event) {
    var name = "Click";
    if (repeat == "double") { name = "Double" + name; }
    else if (repeat == "triple") { name = "Triple" + name; }
    name = (button == 1 ? "Left" : button == 2 ? "Middle" : "Right") + name;

    return dispatchKey(cm,  addModifierNames(name, event), event, function (bound) {
      if (typeof bound == "string") { bound = commands[bound]; }
      if (!bound) { return false }
      var done = false;
      try {
        if (cm.isReadOnly()) { cm.state.suppressEdits = true; }
        done = bound(cm, pos) != Pass;
      } finally {
        cm.state.suppressEdits = false;
      }
      return done
    })
  }

  function configureMouse(cm, repeat, event) {
    var option = cm.getOption("configureMouse");
    var value = option ? option(cm, repeat, event) : {};
    if (value.unit == null) {
      var rect = chromeOS ? event.shiftKey && event.metaKey : event.altKey;
      value.unit = rect ? "rectangle" : repeat == "single" ? "char" : repeat == "double" ? "word" : "line";
    }
    if (value.extend == null || cm.doc.extend) { value.extend = cm.doc.extend || event.shiftKey; }
    if (value.addNew == null) { value.addNew = mac ? event.metaKey : event.ctrlKey; }
    if (value.moveOnDrag == null) { value.moveOnDrag = !(mac ? event.altKey : event.ctrlKey); }
    return value
  }

  function leftButtonDown(cm, pos, repeat, event) {
    if (ie) { setTimeout(bind(ensureFocus, cm), 0); }
    else { cm.curOp.focus = activeElt(); }

    var behavior = configureMouse(cm, repeat, event);

    var sel = cm.doc.sel, contained;
    if (cm.options.dragDrop && dragAndDrop && !cm.isReadOnly() &&
        repeat == "single" && (contained = sel.contains(pos)) > -1 &&
        (cmp((contained = sel.ranges[contained]).from(), pos) < 0 || pos.xRel > 0) &&
        (cmp(contained.to(), pos) > 0 || pos.xRel < 0))
      { leftButtonStartDrag(cm, event, pos, behavior); }
    else
      { leftButtonSelect(cm, event, pos, behavior); }
  }

  // Start a text drag. When it ends, see if any dragging actually
  // happen, and treat as a click if it didn't.
  function leftButtonStartDrag(cm, event, pos, behavior) {
    var display = cm.display, moved = false;
    var dragEnd = operation(cm, function (e) {
      if (webkit) { display.scroller.draggable = false; }
      cm.state.draggingText = false;
      if (cm.state.delayingBlurEvent) {
        if (cm.hasFocus()) { cm.state.delayingBlurEvent = false; }
        else { delayBlurEvent(cm); }
      }
      off(display.wrapper.ownerDocument, "mouseup", dragEnd);
      off(display.wrapper.ownerDocument, "mousemove", mouseMove);
      off(display.scroller, "dragstart", dragStart);
      off(display.scroller, "drop", dragEnd);
      if (!moved) {
        e_preventDefault(e);
        if (!behavior.addNew)
          { extendSelection(cm.doc, pos, null, null, behavior.extend); }
        // Work around unexplainable focus problem in IE9 (#2127) and Chrome (#3081)
        if ((webkit && !safari) || ie && ie_version == 9)
          { setTimeout(function () {display.wrapper.ownerDocument.body.focus({preventScroll: true}); display.input.focus();}, 20); }
        else
          { display.input.focus(); }
      }
    });
    var mouseMove = function(e2) {
      moved = moved || Math.abs(event.clientX - e2.clientX) + Math.abs(event.clientY - e2.clientY) >= 10;
    };
    var dragStart = function () { return moved = true; };
    // Let the drag handler handle this.
    if (webkit) { display.scroller.draggable = true; }
    cm.state.draggingText = dragEnd;
    dragEnd.copy = !behavior.moveOnDrag;
    on(display.wrapper.ownerDocument, "mouseup", dragEnd);
    on(display.wrapper.ownerDocument, "mousemove", mouseMove);
    on(display.scroller, "dragstart", dragStart);
    on(display.scroller, "drop", dragEnd);

    cm.state.delayingBlurEvent = true;
    setTimeout(function () { return display.input.focus(); }, 20);
    // IE's approach to draggable
    if (display.scroller.dragDrop) { display.scroller.dragDrop(); }
  }

  function rangeForUnit(cm, pos, unit) {
    if (unit == "char") { return new Range(pos, pos) }
    if (unit == "word") { return cm.findWordAt(pos) }
    if (unit == "line") { return new Range(Pos(pos.line, 0), clipPos(cm.doc, Pos(pos.line + 1, 0))) }
    var result = unit(cm, pos);
    return new Range(result.from, result.to)
  }

  // Normal selection, as opposed to text dragging.
  function leftButtonSelect(cm, event, start, behavior) {
    if (ie) { delayBlurEvent(cm); }
    var display = cm.display, doc = cm.doc;
    e_preventDefault(event);

    var ourRange, ourIndex, startSel = doc.sel, ranges = startSel.ranges;
    if (behavior.addNew && !behavior.extend) {
      ourIndex = doc.sel.contains(start);
      if (ourIndex > -1)
        { ourRange = ranges[ourIndex]; }
      else
        { ourRange = new Range(start, start); }
    } else {
      ourRange = doc.sel.primary();
      ourIndex = doc.sel.primIndex;
    }

    if (behavior.unit == "rectangle") {
      if (!behavior.addNew) { ourRange = new Range(start, start); }
      start = posFromMouse(cm, event, true, true);
      ourIndex = -1;
    } else {
      var range = rangeForUnit(cm, start, behavior.unit);
      if (behavior.extend)
        { ourRange = extendRange(ourRange, range.anchor, range.head, behavior.extend); }
      else
        { ourRange = range; }
    }

    if (!behavior.addNew) {
      ourIndex = 0;
      setSelection(doc, new Selection([ourRange], 0), sel_mouse);
      startSel = doc.sel;
    } else if (ourIndex == -1) {
      ourIndex = ranges.length;
      setSelection(doc, normalizeSelection(cm, ranges.concat([ourRange]), ourIndex),
                   {scroll: false, origin: "*mouse"});
    } else if (ranges.length > 1 && ranges[ourIndex].empty() && behavior.unit == "char" && !behavior.extend) {
      setSelection(doc, normalizeSelection(cm, ranges.slice(0, ourIndex).concat(ranges.slice(ourIndex + 1)), 0),
                   {scroll: false, origin: "*mouse"});
      startSel = doc.sel;
    } else {
      replaceOneSelection(doc, ourIndex, ourRange, sel_mouse);
    }

    var lastPos = start;
    function extendTo(pos) {
      if (cmp(lastPos, pos) == 0) { return }
      lastPos = pos;

      if (behavior.unit == "rectangle") {
        var ranges = [], tabSize = cm.options.tabSize;
        var startCol = countColumn(getLine(doc, start.line).text, start.ch, tabSize);
        var posCol = countColumn(getLine(doc, pos.line).text, pos.ch, tabSize);
        var left = Math.min(startCol, posCol), right = Math.max(startCol, posCol);
        for (var line = Math.min(start.line, pos.line), end = Math.min(cm.lastLine(), Math.max(start.line, pos.line));
             line <= end; line++) {
          var text = getLine(doc, line).text, leftPos = findColumn(text, left, tabSize);
          if (left == right)
            { ranges.push(new Range(Pos(line, leftPos), Pos(line, leftPos))); }
          else if (text.length > leftPos)
            { ranges.push(new Range(Pos(line, leftPos), Pos(line, findColumn(text, right, tabSize)))); }
        }
        if (!ranges.length) { ranges.push(new Range(start, start)); }
        setSelection(doc, normalizeSelection(cm, startSel.ranges.slice(0, ourIndex).concat(ranges), ourIndex),
                     {origin: "*mouse", scroll: false});
        cm.scrollIntoView(pos);
      } else {
        var oldRange = ourRange;
        var range = rangeForUnit(cm, pos, behavior.unit);
        var anchor = oldRange.anchor, head;
        if (cmp(range.anchor, anchor) > 0) {
          head = range.head;
          anchor = minPos(oldRange.from(), range.anchor);
        } else {
          head = range.anchor;
          anchor = maxPos(oldRange.to(), range.head);
        }
        var ranges$1 = startSel.ranges.slice(0);
        ranges$1[ourIndex] = bidiSimplify(cm, new Range(clipPos(doc, anchor), head));
        setSelection(doc, normalizeSelection(cm, ranges$1, ourIndex), sel_mouse);
      }
    }

    var editorSize = display.wrapper.getBoundingClientRect();
    // Used to ensure timeout re-tries don't fire when another extend
    // happened in the meantime (clearTimeout isn't reliable -- at
    // least on Chrome, the timeouts still happen even when cleared,
    // if the clear happens after their scheduled firing time).
    var counter = 0;

    function extend(e) {
      var curCount = ++counter;
      var cur = posFromMouse(cm, e, true, behavior.unit == "rectangle");
      if (!cur) { return }
      if (cmp(cur, lastPos) != 0) {
        cm.curOp.focus = activeElt();
        extendTo(cur);
        var visible = visibleLines(display, doc);
        if (cur.line >= visible.to || cur.line < visible.from)
          { setTimeout(operation(cm, function () {if (counter == curCount) { extend(e); }}), 150); }
      } else {
        var outside = e.clientY < editorSize.top ? -20 : e.clientY > editorSize.bottom ? 20 : 0;
        if (outside) { setTimeout(operation(cm, function () {
          if (counter != curCount) { return }
          display.scroller.scrollTop += outside;
          extend(e);
        }), 50); }
      }
    }

    function done(e) {
      cm.state.selectingText = false;
      counter = Infinity;
      // If e is null or undefined we interpret this as someone trying
      // to explicitly cancel the selection rather than the user
      // letting go of the mouse button.
      if (e) {
        e_preventDefault(e);
        display.input.focus();
      }
      off(display.wrapper.ownerDocument, "mousemove", move);
      off(display.wrapper.ownerDocument, "mouseup", up);
      doc.history.lastSelOrigin = null;
    }

    var move = operation(cm, function (e) {
      if (e.buttons === 0 || !e_button(e)) { done(e); }
      else { extend(e); }
    });
    var up = operation(cm, done);
    cm.state.selectingText = up;
    on(display.wrapper.ownerDocument, "mousemove", move);
    on(display.wrapper.ownerDocument, "mouseup", up);
  }

  // Used when mouse-selecting to adjust the anchor to the proper side
  // of a bidi jump depending on the visual position of the head.
  function bidiSimplify(cm, range) {
    var anchor = range.anchor;
    var head = range.head;
    var anchorLine = getLine(cm.doc, anchor.line);
    if (cmp(anchor, head) == 0 && anchor.sticky == head.sticky) { return range }
    var order = getOrder(anchorLine);
    if (!order) { return range }
    var index = getBidiPartAt(order, anchor.ch, anchor.sticky), part = order[index];
    if (part.from != anchor.ch && part.to != anchor.ch) { return range }
    var boundary = index + ((part.from == anchor.ch) == (part.level != 1) ? 0 : 1);
    if (boundary == 0 || boundary == order.length) { return range }

    // Compute the relative visual position of the head compared to the
    // anchor (<0 is to the left, >0 to the right)
    var leftSide;
    if (head.line != anchor.line) {
      leftSide = (head.line - anchor.line) * (cm.doc.direction == "ltr" ? 1 : -1) > 0;
    } else {
      var headIndex = getBidiPartAt(order, head.ch, head.sticky);
      var dir = headIndex - index || (head.ch - anchor.ch) * (part.level == 1 ? -1 : 1);
      if (headIndex == boundary - 1 || headIndex == boundary)
        { leftSide = dir < 0; }
      else
        { leftSide = dir > 0; }
    }

    var usePart = order[boundary + (leftSide ? -1 : 0)];
    var from = leftSide == (usePart.level == 1);
    var ch = from ? usePart.from : usePart.to, sticky = from ? "after" : "before";
    return anchor.ch == ch && anchor.sticky == sticky ? range : new Range(new Pos(anchor.line, ch, sticky), head)
  }


  // Determines whether an event happened in the gutter, and fires the
  // handlers for the corresponding event.
  function gutterEvent(cm, e, type, prevent) {
    var mX, mY;
    if (e.touches) {
      mX = e.touches[0].clientX;
      mY = e.touches[0].clientY;
    } else {
      try { mX = e.clientX; mY = e.clientY; }
      catch(e$1) { return false }
    }
    if (mX >= Math.floor(cm.display.gutters.getBoundingClientRect().right)) { return false }
    if (prevent) { e_preventDefault(e); }

    var display = cm.display;
    var lineBox = display.lineDiv.getBoundingClientRect();

    if (mY > lineBox.bottom || !hasHandler(cm, type)) { return e_defaultPrevented(e) }
    mY -= lineBox.top - display.viewOffset;

    for (var i = 0; i < cm.display.gutterSpecs.length; ++i) {
      var g = display.gutters.childNodes[i];
      if (g && g.getBoundingClientRect().right >= mX) {
        var line = lineAtHeight(cm.doc, mY);
        var gutter = cm.display.gutterSpecs[i];
        signal(cm, type, cm, line, gutter.className, e);
        return e_defaultPrevented(e)
      }
    }
  }

  function clickInGutter(cm, e) {
    return gutterEvent(cm, e, "gutterClick", true)
  }

  // CONTEXT MENU HANDLING

  // To make the context menu work, we need to briefly unhide the
  // textarea (making it as unobtrusive as possible) to let the
  // right-click take effect on it.
  function onContextMenu(cm, e) {
    if (eventInWidget(cm.display, e) || contextMenuInGutter(cm, e)) { return }
    if (signalDOMEvent(cm, e, "contextmenu")) { return }
    if (!captureRightClick) { cm.display.input.onContextMenu(e); }
  }

  function contextMenuInGutter(cm, e) {
    if (!hasHandler(cm, "gutterContextMenu")) { return false }
    return gutterEvent(cm, e, "gutterContextMenu", false)
  }

  function themeChanged(cm) {
    cm.display.wrapper.className = cm.display.wrapper.className.replace(/\s*cm-s-\S+/g, "") +
      cm.options.theme.replace(/(^|\s)\s*/g, " cm-s-");
    clearCaches(cm);
  }

  var Init = {toString: function(){return "CodeMirror.Init"}};

  var defaults = {};
  var optionHandlers = {};

  function defineOptions(CodeMirror) {
    var optionHandlers = CodeMirror.optionHandlers;

    function option(name, deflt, handle, notOnInit) {
      CodeMirror.defaults[name] = deflt;
      if (handle) { optionHandlers[name] =
        notOnInit ? function (cm, val, old) {if (old != Init) { handle(cm, val, old); }} : handle; }
    }

    CodeMirror.defineOption = option;

    // Passed to option handlers when there is no old value.
    CodeMirror.Init = Init;

    // These two are, on init, called from the constructor because they
    // have to be initialized before the editor can start at all.
    option("value", "", function (cm, val) { return cm.setValue(val); }, true);
    option("mode", null, function (cm, val) {
      cm.doc.modeOption = val;
      loadMode(cm);
    }, true);

    option("indentUnit", 2, loadMode, true);
    option("indentWithTabs", false);
    option("smartIndent", true);
    option("tabSize", 4, function (cm) {
      resetModeState(cm);
      clearCaches(cm);
      regChange(cm);
    }, true);

    option("lineSeparator", null, function (cm, val) {
      cm.doc.lineSep = val;
      if (!val) { return }
      var newBreaks = [], lineNo = cm.doc.first;
      cm.doc.iter(function (line) {
        for (var pos = 0;;) {
          var found = line.text.indexOf(val, pos);
          if (found == -1) { break }
          pos = found + val.length;
          newBreaks.push(Pos(lineNo, found));
        }
        lineNo++;
      });
      for (var i = newBreaks.length - 1; i >= 0; i--)
        { replaceRange(cm.doc, val, newBreaks[i], Pos(newBreaks[i].line, newBreaks[i].ch + val.length)); }
    });
    option("specialChars", /[\u0000-\u001f\u007f-\u009f\u00ad\u061c\u200b\u200e\u200f\u2028\u2029\ufeff\ufff9-\ufffc]/g, function (cm, val, old) {
      cm.state.specialChars = new RegExp(val.source + (val.test("\t") ? "" : "|\t"), "g");
      if (old != Init) { cm.refresh(); }
    });
    option("specialCharPlaceholder", defaultSpecialCharPlaceholder, function (cm) { return cm.refresh(); }, true);
    option("electricChars", true);
    option("inputStyle", mobile ? "contenteditable" : "textarea", function () {
      throw new Error("inputStyle can not (yet) be changed in a running editor") // FIXME
    }, true);
    option("spellcheck", false, function (cm, val) { return cm.getInputField().spellcheck = val; }, true);
    option("autocorrect", false, function (cm, val) { return cm.getInputField().autocorrect = val; }, true);
    option("autocapitalize", false, function (cm, val) { return cm.getInputField().autocapitalize = val; }, true);
    option("rtlMoveVisually", !windows);
    option("wholeLineUpdateBefore", true);

    option("theme", "default", function (cm) {
      themeChanged(cm);
      updateGutters(cm);
    }, true);
    option("keyMap", "default", function (cm, val, old) {
      var next = getKeyMap(val);
      var prev = old != Init && getKeyMap(old);
      if (prev && prev.detach) { prev.detach(cm, next); }
      if (next.attach) { next.attach(cm, prev || null); }
    });
    option("extraKeys", null);
    option("configureMouse", null);

    option("lineWrapping", false, wrappingChanged, true);
    option("gutters", [], function (cm, val) {
      cm.display.gutterSpecs = getGutters(val, cm.options.lineNumbers);
      updateGutters(cm);
    }, true);
    option("fixedGutter", true, function (cm, val) {
      cm.display.gutters.style.left = val ? compensateForHScroll(cm.display) + "px" : "0";
      cm.refresh();
    }, true);
    option("coverGutterNextToScrollbar", false, function (cm) { return updateScrollbars(cm); }, true);
    option("scrollbarStyle", "native", function (cm) {
      initScrollbars(cm);
      updateScrollbars(cm);
      cm.display.scrollbars.setScrollTop(cm.doc.scrollTop);
      cm.display.scrollbars.setScrollLeft(cm.doc.scrollLeft);
    }, true);
    option("lineNumbers", false, function (cm, val) {
      cm.display.gutterSpecs = getGutters(cm.options.gutters, val);
      updateGutters(cm);
    }, true);
    option("firstLineNumber", 1, updateGutters, true);
    option("lineNumberFormatter", function (integer) { return integer; }, updateGutters, true);
    option("showCursorWhenSelecting", false, updateSelection, true);

    option("resetSelectionOnContextMenu", true);
    option("lineWiseCopyCut", true);
    option("pasteLinesPerSelection", true);
    option("selectionsMayTouch", false);

    option("readOnly", false, function (cm, val) {
      if (val == "nocursor") {
        onBlur(cm);
        cm.display.input.blur();
      }
      cm.display.input.readOnlyChanged(val);
    });

    option("screenReaderLabel", null, function (cm, val) {
      val = (val === '') ? null : val;
      cm.display.input.screenReaderLabelChanged(val);
    });

    option("disableInput", false, function (cm, val) {if (!val) { cm.display.input.reset(); }}, true);
    option("dragDrop", true, dragDropChanged);
    option("allowDropFileTypes", null);

    option("cursorBlinkRate", 530);
    option("cursorScrollMargin", 0);
    option("cursorHeight", 1, updateSelection, true);
    option("singleCursorHeightPerLine", true, updateSelection, true);
    option("workTime", 100);
    option("workDelay", 100);
    option("flattenSpans", true, resetModeState, true);
    option("addModeClass", false, resetModeState, true);
    option("pollInterval", 100);
    option("undoDepth", 200, function (cm, val) { return cm.doc.history.undoDepth = val; });
    option("historyEventDelay", 1250);
    option("viewportMargin", 10, function (cm) { return cm.refresh(); }, true);
    option("maxHighlightLength", 10000, resetModeState, true);
    option("moveInputWithCursor", true, function (cm, val) {
      if (!val) { cm.display.input.resetPosition(); }
    });

    option("tabindex", null, function (cm, val) { return cm.display.input.getField().tabIndex = val || ""; });
    option("autofocus", null);
    option("direction", "ltr", function (cm, val) { return cm.doc.setDirection(val); }, true);
    option("phrases", null);
  }

  function dragDropChanged(cm, value, old) {
    var wasOn = old && old != Init;
    if (!value != !wasOn) {
      var funcs = cm.display.dragFunctions;
      var toggle = value ? on : off;
      toggle(cm.display.scroller, "dragstart", funcs.start);
      toggle(cm.display.scroller, "dragenter", funcs.enter);
      toggle(cm.display.scroller, "dragover", funcs.over);
      toggle(cm.display.scroller, "dragleave", funcs.leave);
      toggle(cm.display.scroller, "drop", funcs.drop);
    }
  }

  function wrappingChanged(cm) {
    if (cm.options.lineWrapping) {
      addClass(cm.display.wrapper, "CodeMirror-wrap");
      cm.display.sizer.style.minWidth = "";
      cm.display.sizerWidth = null;
    } else {
      rmClass(cm.display.wrapper, "CodeMirror-wrap");
      findMaxLine(cm);
    }
    estimateLineHeights(cm);
    regChange(cm);
    clearCaches(cm);
    setTimeout(function () { return updateScrollbars(cm); }, 100);
  }

  // A CodeMirror instance represents an editor. This is the object
  // that user code is usually dealing with.

  function CodeMirror(place, options) {
    var this$1 = this;

    if (!(this instanceof CodeMirror)) { return new CodeMirror(place, options) }

    this.options = options = options ? copyObj(options) : {};
    // Determine effective options based on given values and defaults.
    copyObj(defaults, options, false);

    var doc = options.value;
    if (typeof doc == "string") { doc = new Doc(doc, options.mode, null, options.lineSeparator, options.direction); }
    else if (options.mode) { doc.modeOption = options.mode; }
    this.doc = doc;

    var input = new CodeMirror.inputStyles[options.inputStyle](this);
    var display = this.display = new Display(place, doc, input, options);
    display.wrapper.CodeMirror = this;
    themeChanged(this);
    if (options.lineWrapping)
      { this.display.wrapper.className += " CodeMirror-wrap"; }
    initScrollbars(this);

    this.state = {
      keyMaps: [],  // stores maps added by addKeyMap
      overlays: [], // highlighting overlays, as added by addOverlay
      modeGen: 0,   // bumped when mode/overlay changes, used to invalidate highlighting info
      overwrite: false,
      delayingBlurEvent: false,
      focused: false,
      suppressEdits: false, // used to disable editing during key handlers when in readOnly mode
      pasteIncoming: -1, cutIncoming: -1, // help recognize paste/cut edits in input.poll
      selectingText: false,
      draggingText: false,
      highlight: new Delayed(), // stores highlight worker timeout
      keySeq: null,  // Unfinished key sequence
      specialChars: null
    };

    if (options.autofocus && !mobile) { display.input.focus(); }

    // Override magic textarea content restore that IE sometimes does
    // on our hidden textarea on reload
    if (ie && ie_version < 11) { setTimeout(function () { return this$1.display.input.reset(true); }, 20); }

    registerEventHandlers(this);
    ensureGlobalHandlers();

    startOperation(this);
    this.curOp.forceUpdate = true;
    attachDoc(this, doc);

    if ((options.autofocus && !mobile) || this.hasFocus())
      { setTimeout(function () {
        if (this$1.hasFocus() && !this$1.state.focused) { onFocus(this$1); }
      }, 20); }
    else
      { onBlur(this); }

    for (var opt in optionHandlers) { if (optionHandlers.hasOwnProperty(opt))
      { optionHandlers[opt](this, options[opt], Init); } }
    maybeUpdateLineNumberWidth(this);
    if (options.finishInit) { options.finishInit(this); }
    for (var i = 0; i < initHooks.length; ++i) { initHooks[i](this); }
    endOperation(this);
    // Suppress optimizelegibility in Webkit, since it breaks text
    // measuring on line wrapping boundaries.
    if (webkit && options.lineWrapping &&
        getComputedStyle(display.lineDiv).textRendering == "optimizelegibility")
      { display.lineDiv.style.textRendering = "auto"; }
  }

  // The default configuration options.
  CodeMirror.defaults = defaults;
  // Functions to run when options are changed.
  CodeMirror.optionHandlers = optionHandlers;

  // Attach the necessary event handlers when initializing the editor
  function registerEventHandlers(cm) {
    var d = cm.display;
    on(d.scroller, "mousedown", operation(cm, onMouseDown));
    // Older IE's will not fire a second mousedown for a double click
    if (ie && ie_version < 11)
      { on(d.scroller, "dblclick", operation(cm, function (e) {
        if (signalDOMEvent(cm, e)) { return }
        var pos = posFromMouse(cm, e);
        if (!pos || clickInGutter(cm, e) || eventInWidget(cm.display, e)) { return }
        e_preventDefault(e);
        var word = cm.findWordAt(pos);
        extendSelection(cm.doc, word.anchor, word.head);
      })); }
    else
      { on(d.scroller, "dblclick", function (e) { return signalDOMEvent(cm, e) || e_preventDefault(e); }); }
    // Some browsers fire contextmenu *after* opening the menu, at
    // which point we can't mess with it anymore. Context menu is
    // handled in onMouseDown for these browsers.
    on(d.scroller, "contextmenu", function (e) { return onContextMenu(cm, e); });
    on(d.input.getField(), "contextmenu", function (e) {
      if (!d.scroller.contains(e.target)) { onContextMenu(cm, e); }
    });

    // Used to suppress mouse event handling when a touch happens
    var touchFinished, prevTouch = {end: 0};
    function finishTouch() {
      if (d.activeTouch) {
        touchFinished = setTimeout(function () { return d.activeTouch = null; }, 1000);
        prevTouch = d.activeTouch;
        prevTouch.end = +new Date;
      }
    }
    function isMouseLikeTouchEvent(e) {
      if (e.touches.length != 1) { return false }
      var touch = e.touches[0];
      return touch.radiusX <= 1 && touch.radiusY <= 1
    }
    function farAway(touch, other) {
      if (other.left == null) { return true }
      var dx = other.left - touch.left, dy = other.top - touch.top;
      return dx * dx + dy * dy > 20 * 20
    }
    on(d.scroller, "touchstart", function (e) {
      if (!signalDOMEvent(cm, e) && !isMouseLikeTouchEvent(e) && !clickInGutter(cm, e)) {
        d.input.ensurePolled();
        clearTimeout(touchFinished);
        var now = +new Date;
        d.activeTouch = {start: now, moved: false,
                         prev: now - prevTouch.end <= 300 ? prevTouch : null};
        if (e.touches.length == 1) {
          d.activeTouch.left = e.touches[0].pageX;
          d.activeTouch.top = e.touches[0].pageY;
        }
      }
    });
    on(d.scroller, "touchmove", function () {
      if (d.activeTouch) { d.activeTouch.moved = true; }
    });
    on(d.scroller, "touchend", function (e) {
      var touch = d.activeTouch;
      if (touch && !eventInWidget(d, e) && touch.left != null &&
          !touch.moved && new Date - touch.start < 300) {
        var pos = cm.coordsChar(d.activeTouch, "page"), range;
        if (!touch.prev || farAway(touch, touch.prev)) // Single tap
          { range = new Range(pos, pos); }
        else if (!touch.prev.prev || farAway(touch, touch.prev.prev)) // Double tap
          { range = cm.findWordAt(pos); }
        else // Triple tap
          { range = new Range(Pos(pos.line, 0), clipPos(cm.doc, Pos(pos.line + 1, 0))); }
        cm.setSelection(range.anchor, range.head);
        cm.focus();
        e_preventDefault(e);
      }
      finishTouch();
    });
    on(d.scroller, "touchcancel", finishTouch);

    // Sync scrolling between fake scrollbars and real scrollable
    // area, ensure viewport is updated when scrolling.
    on(d.scroller, "scroll", function () {
      if (d.scroller.clientHeight) {
        updateScrollTop(cm, d.scroller.scrollTop);
        setScrollLeft(cm, d.scroller.scrollLeft, true);
        signal(cm, "scroll", cm);
      }
    });

    // Listen to wheel events in order to try and update the viewport on time.
    on(d.scroller, "mousewheel", function (e) { return onScrollWheel(cm, e); });
    on(d.scroller, "DOMMouseScroll", function (e) { return onScrollWheel(cm, e); });

    // Prevent wrapper from ever scrolling
    on(d.wrapper, "scroll", function () { return d.wrapper.scrollTop = d.wrapper.scrollLeft = 0; });

    d.dragFunctions = {
      enter: function (e) {if (!signalDOMEvent(cm, e)) { e_stop(e); }},
      over: function (e) {if (!signalDOMEvent(cm, e)) { onDragOver(cm, e); e_stop(e); }},
      start: function (e) { return onDragStart(cm, e); },
      drop: operation(cm, onDrop),
      leave: function (e) {if (!signalDOMEvent(cm, e)) { clearDragCursor(cm); }}
    };

    var inp = d.input.getField();
    on(inp, "keyup", function (e) { return onKeyUp.call(cm, e); });
    on(inp, "keydown", operation(cm, onKeyDown));
    on(inp, "keypress", operation(cm, onKeyPress));
    on(inp, "focus", function (e) { return onFocus(cm, e); });
    on(inp, "blur", function (e) { return onBlur(cm, e); });
  }

  var initHooks = [];
  CodeMirror.defineInitHook = function (f) { return initHooks.push(f); };

  // Indent the given line. The how parameter can be "smart",
  // "add"/null, "subtract", or "prev". When aggressive is false
  // (typically set to true for forced single-line indents), empty
  // lines are not indented, and places where the mode returns Pass
  // are left alone.
  function indentLine(cm, n, how, aggressive) {
    var doc = cm.doc, state;
    if (how == null) { how = "add"; }
    if (how == "smart") {
      // Fall back to "prev" when the mode doesn't have an indentation
      // method.
      if (!doc.mode.indent) { how = "prev"; }
      else { state = getContextBefore(cm, n).state; }
    }

    var tabSize = cm.options.tabSize;
    var line = getLine(doc, n), curSpace = countColumn(line.text, null, tabSize);
    if (line.stateAfter) { line.stateAfter = null; }
    var curSpaceString = line.text.match(/^\s*/)[0], indentation;
    if (!aggressive && !/\S/.test(line.text)) {
      indentation = 0;
      how = "not";
    } else if (how == "smart") {
      indentation = doc.mode.indent(state, line.text.slice(curSpaceString.length), line.text);
      if (indentation == Pass || indentation > 150) {
        if (!aggressive) { return }
        how = "prev";
      }
    }
    if (how == "prev") {
      if (n > doc.first) { indentation = countColumn(getLine(doc, n-1).text, null, tabSize); }
      else { indentation = 0; }
    } else if (how == "add") {
      indentation = curSpace + cm.options.indentUnit;
    } else if (how == "subtract") {
      indentation = curSpace - cm.options.indentUnit;
    } else if (typeof how == "number") {
      indentation = curSpace + how;
    }
    indentation = Math.max(0, indentation);

    var indentString = "", pos = 0;
    if (cm.options.indentWithTabs)
      { for (var i = Math.floor(indentation / tabSize); i; --i) {pos += tabSize; indentString += "\t";} }
    if (pos < indentation) { indentString += spaceStr(indentation - pos); }

    if (indentString != curSpaceString) {
      replaceRange(doc, indentString, Pos(n, 0), Pos(n, curSpaceString.length), "+input");
      line.stateAfter = null;
      return true
    } else {
      // Ensure that, if the cursor was in the whitespace at the start
      // of the line, it is moved to the end of that space.
      for (var i$1 = 0; i$1 < doc.sel.ranges.length; i$1++) {
        var range = doc.sel.ranges[i$1];
        if (range.head.line == n && range.head.ch < curSpaceString.length) {
          var pos$1 = Pos(n, curSpaceString.length);
          replaceOneSelection(doc, i$1, new Range(pos$1, pos$1));
          break
        }
      }
    }
  }

  // This will be set to a {lineWise: bool, text: [string]} object, so
  // that, when pasting, we know what kind of selections the copied
  // text was made out of.
  var lastCopied = null;

  function setLastCopied(newLastCopied) {
    lastCopied = newLastCopied;
  }

  function applyTextInput(cm, inserted, deleted, sel, origin) {
    var doc = cm.doc;
    cm.display.shift = false;
    if (!sel) { sel = doc.sel; }

    var recent = +new Date - 200;
    var paste = origin == "paste" || cm.state.pasteIncoming > recent;
    var textLines = splitLinesAuto(inserted), multiPaste = null;
    // When pasting N lines into N selections, insert one line per selection
    if (paste && sel.ranges.length > 1) {
      if (lastCopied && lastCopied.text.join("\n") == inserted) {
        if (sel.ranges.length % lastCopied.text.length == 0) {
          multiPaste = [];
          for (var i = 0; i < lastCopied.text.length; i++)
            { multiPaste.push(doc.splitLines(lastCopied.text[i])); }
        }
      } else if (textLines.length == sel.ranges.length && cm.options.pasteLinesPerSelection) {
        multiPaste = map(textLines, function (l) { return [l]; });
      }
    }

    var updateInput = cm.curOp.updateInput;
    // Normal behavior is to insert the new text into every selection
    for (var i$1 = sel.ranges.length - 1; i$1 >= 0; i$1--) {
      var range = sel.ranges[i$1];
      var from = range.from(), to = range.to();
      if (range.empty()) {
        if (deleted && deleted > 0) // Handle deletion
          { from = Pos(from.line, from.ch - deleted); }
        else if (cm.state.overwrite && !paste) // Handle overwrite
          { to = Pos(to.line, Math.min(getLine(doc, to.line).text.length, to.ch + lst(textLines).length)); }
        else if (paste && lastCopied && lastCopied.lineWise && lastCopied.text.join("\n") == textLines.join("\n"))
          { from = to = Pos(from.line, 0); }
      }
      var changeEvent = {from: from, to: to, text: multiPaste ? multiPaste[i$1 % multiPaste.length] : textLines,
                         origin: origin || (paste ? "paste" : cm.state.cutIncoming > recent ? "cut" : "+input")};
      makeChange(cm.doc, changeEvent);
      signalLater(cm, "inputRead", cm, changeEvent);
    }
    if (inserted && !paste)
      { triggerElectric(cm, inserted); }

    ensureCursorVisible(cm);
    if (cm.curOp.updateInput < 2) { cm.curOp.updateInput = updateInput; }
    cm.curOp.typing = true;
    cm.state.pasteIncoming = cm.state.cutIncoming = -1;
  }

  function handlePaste(e, cm) {
    var pasted = e.clipboardData && e.clipboardData.getData("Text");
    if (pasted) {
      e.preventDefault();
      if (!cm.isReadOnly() && !cm.options.disableInput && cm.hasFocus())
        { runInOp(cm, function () { return applyTextInput(cm, pasted, 0, null, "paste"); }); }
      return true
    }
  }

  function triggerElectric(cm, inserted) {
    // When an 'electric' character is inserted, immediately trigger a reindent
    if (!cm.options.electricChars || !cm.options.smartIndent) { return }
    var sel = cm.doc.sel;

    for (var i = sel.ranges.length - 1; i >= 0; i--) {
      var range = sel.ranges[i];
      if (range.head.ch > 100 || (i && sel.ranges[i - 1].head.line == range.head.line)) { continue }
      var mode = cm.getModeAt(range.head);
      var indented = false;
      if (mode.electricChars) {
        for (var j = 0; j < mode.electricChars.length; j++)
          { if (inserted.indexOf(mode.electricChars.charAt(j)) > -1) {
            indented = indentLine(cm, range.head.line, "smart");
            break
          } }
      } else if (mode.electricInput) {
        if (mode.electricInput.test(getLine(cm.doc, range.head.line).text.slice(0, range.head.ch)))
          { indented = indentLine(cm, range.head.line, "smart"); }
      }
      if (indented) { signalLater(cm, "electricInput", cm, range.head.line); }
    }
  }

  function copyableRanges(cm) {
    var text = [], ranges = [];
    for (var i = 0; i < cm.doc.sel.ranges.length; i++) {
      var line = cm.doc.sel.ranges[i].head.line;
      var lineRange = {anchor: Pos(line, 0), head: Pos(line + 1, 0)};
      ranges.push(lineRange);
      text.push(cm.getRange(lineRange.anchor, lineRange.head));
    }
    return {text: text, ranges: ranges}
  }

  function disableBrowserMagic(field, spellcheck, autocorrect, autocapitalize) {
    field.setAttribute("autocorrect", autocorrect ? "" : "off");
    field.setAttribute("autocapitalize", autocapitalize ? "" : "off");
    field.setAttribute("spellcheck", !!spellcheck);
  }

  function hiddenTextarea() {
    var te = elt("textarea", null, null, "position: absolute; bottom: -1em; padding: 0; width: 1px; height: 1em; min-height: 1em; outline: none");
    var div = elt("div", [te], null, "overflow: hidden; position: relative; width: 3px; height: 0px;");
    // The textarea is kept positioned near the cursor to prevent the
    // fact that it'll be scrolled into view on input from scrolling
    // our fake cursor out of view. On webkit, when wrap=off, paste is
    // very slow. So make the area wide instead.
    if (webkit) { te.style.width = "1000px"; }
    else { te.setAttribute("wrap", "off"); }
    // If border: 0; -- iOS fails to open keyboard (issue #1287)
    if (ios) { te.style.border = "1px solid black"; }
    disableBrowserMagic(te);
    return div
  }

  // The publicly visible API. Note that methodOp(f) means
  // 'wrap f in an operation, performed on its `this` parameter'.

  // This is not the complete set of editor methods. Most of the
  // methods defined on the Doc type are also injected into
  // CodeMirror.prototype, for backwards compatibility and
  // convenience.

  function addEditorMethods(CodeMirror) {
    var optionHandlers = CodeMirror.optionHandlers;

    var helpers = CodeMirror.helpers = {};

    CodeMirror.prototype = {
      constructor: CodeMirror,
      focus: function(){window.focus(); this.display.input.focus();},

      setOption: function(option, value) {
        var options = this.options, old = options[option];
        if (options[option] == value && option != "mode") { return }
        options[option] = value;
        if (optionHandlers.hasOwnProperty(option))
          { operation(this, optionHandlers[option])(this, value, old); }
        signal(this, "optionChange", this, option);
      },

      getOption: function(option) {return this.options[option]},
      getDoc: function() {return this.doc},

      addKeyMap: function(map, bottom) {
        this.state.keyMaps[bottom ? "push" : "unshift"](getKeyMap(map));
      },
      removeKeyMap: function(map) {
        var maps = this.state.keyMaps;
        for (var i = 0; i < maps.length; ++i)
          { if (maps[i] == map || maps[i].name == map) {
            maps.splice(i, 1);
            return true
          } }
      },

      addOverlay: methodOp(function(spec, options) {
        var mode = spec.token ? spec : CodeMirror.getMode(this.options, spec);
        if (mode.startState) { throw new Error("Overlays may not be stateful.") }
        insertSorted(this.state.overlays,
                     {mode: mode, modeSpec: spec, opaque: options && options.opaque,
                      priority: (options && options.priority) || 0},
                     function (overlay) { return overlay.priority; });
        this.state.modeGen++;
        regChange(this);
      }),
      removeOverlay: methodOp(function(spec) {
        var overlays = this.state.overlays;
        for (var i = 0; i < overlays.length; ++i) {
          var cur = overlays[i].modeSpec;
          if (cur == spec || typeof spec == "string" && cur.name == spec) {
            overlays.splice(i, 1);
            this.state.modeGen++;
            regChange(this);
            return
          }
        }
      }),

      indentLine: methodOp(function(n, dir, aggressive) {
        if (typeof dir != "string" && typeof dir != "number") {
          if (dir == null) { dir = this.options.smartIndent ? "smart" : "prev"; }
          else { dir = dir ? "add" : "subtract"; }
        }
        if (isLine(this.doc, n)) { indentLine(this, n, dir, aggressive); }
      }),
      indentSelection: methodOp(function(how) {
        var ranges = this.doc.sel.ranges, end = -1;
        for (var i = 0; i < ranges.length; i++) {
          var range = ranges[i];
          if (!range.empty()) {
            var from = range.from(), to = range.to();
            var start = Math.max(end, from.line);
            end = Math.min(this.lastLine(), to.line - (to.ch ? 0 : 1)) + 1;
            for (var j = start; j < end; ++j)
              { indentLine(this, j, how); }
            var newRanges = this.doc.sel.ranges;
            if (from.ch == 0 && ranges.length == newRanges.length && newRanges[i].from().ch > 0)
              { replaceOneSelection(this.doc, i, new Range(from, newRanges[i].to()), sel_dontScroll); }
          } else if (range.head.line > end) {
            indentLine(this, range.head.line, how, true);
            end = range.head.line;
            if (i == this.doc.sel.primIndex) { ensureCursorVisible(this); }
          }
        }
      }),

      // Fetch the parser token for a given character. Useful for hacks
      // that want to inspect the mode state (say, for completion).
      getTokenAt: function(pos, precise) {
        return takeToken(this, pos, precise)
      },

      getLineTokens: function(line, precise) {
        return takeToken(this, Pos(line), precise, true)
      },

      getTokenTypeAt: function(pos) {
        pos = clipPos(this.doc, pos);
        var styles = getLineStyles(this, getLine(this.doc, pos.line));
        var before = 0, after = (styles.length - 1) / 2, ch = pos.ch;
        var type;
        if (ch == 0) { type = styles[2]; }
        else { for (;;) {
          var mid = (before + after) >> 1;
          if ((mid ? styles[mid * 2 - 1] : 0) >= ch) { after = mid; }
          else if (styles[mid * 2 + 1] < ch) { before = mid + 1; }
          else { type = styles[mid * 2 + 2]; break }
        } }
        var cut = type ? type.indexOf("overlay ") : -1;
        return cut < 0 ? type : cut == 0 ? null : type.slice(0, cut - 1)
      },

      getModeAt: function(pos) {
        var mode = this.doc.mode;
        if (!mode.innerMode) { return mode }
        return CodeMirror.innerMode(mode, this.getTokenAt(pos).state).mode
      },

      getHelper: function(pos, type) {
        return this.getHelpers(pos, type)[0]
      },

      getHelpers: function(pos, type) {
        var found = [];
        if (!helpers.hasOwnProperty(type)) { return found }
        var help = helpers[type], mode = this.getModeAt(pos);
        if (typeof mode[type] == "string") {
          if (help[mode[type]]) { found.push(help[mode[type]]); }
        } else if (mode[type]) {
          for (var i = 0; i < mode[type].length; i++) {
            var val = help[mode[type][i]];
            if (val) { found.push(val); }
          }
        } else if (mode.helperType && help[mode.helperType]) {
          found.push(help[mode.helperType]);
        } else if (help[mode.name]) {
          found.push(help[mode.name]);
        }
        for (var i$1 = 0; i$1 < help._global.length; i$1++) {
          var cur = help._global[i$1];
          if (cur.pred(mode, this) && indexOf(found, cur.val) == -1)
            { found.push(cur.val); }
        }
        return found
      },

      getStateAfter: function(line, precise) {
        var doc = this.doc;
        line = clipLine(doc, line == null ? doc.first + doc.size - 1: line);
        return getContextBefore(this, line + 1, precise).state
      },

      cursorCoords: function(start, mode) {
        var pos, range = this.doc.sel.primary();
        if (start == null) { pos = range.head; }
        else if (typeof start == "object") { pos = clipPos(this.doc, start); }
        else { pos = start ? range.from() : range.to(); }
        return cursorCoords(this, pos, mode || "page")
      },

      charCoords: function(pos, mode) {
        return charCoords(this, clipPos(this.doc, pos), mode || "page")
      },

      coordsChar: function(coords, mode) {
        coords = fromCoordSystem(this, coords, mode || "page");
        return coordsChar(this, coords.left, coords.top)
      },

      lineAtHeight: function(height, mode) {
        height = fromCoordSystem(this, {top: height, left: 0}, mode || "page").top;
        return lineAtHeight(this.doc, height + this.display.viewOffset)
      },
      heightAtLine: function(line, mode, includeWidgets) {
        var end = false, lineObj;
        if (typeof line == "number") {
          var last = this.doc.first + this.doc.size - 1;
          if (line < this.doc.first) { line = this.doc.first; }
          else if (line > last) { line = last; end = true; }
          lineObj = getLine(this.doc, line);
        } else {
          lineObj = line;
        }
        return intoCoordSystem(this, lineObj, {top: 0, left: 0}, mode || "page", includeWidgets || end).top +
          (end ? this.doc.height - heightAtLine(lineObj) : 0)
      },

      defaultTextHeight: function() { return textHeight(this.display) },
      defaultCharWidth: function() { return charWidth(this.display) },

      getViewport: function() { return {from: this.display.viewFrom, to: this.display.viewTo}},

      addWidget: function(pos, node, scroll, vert, horiz) {
        var display = this.display;
        pos = cursorCoords(this, clipPos(this.doc, pos));
        var top = pos.bottom, left = pos.left;
        node.style.position = "absolute";
        node.setAttribute("cm-ignore-events", "true");
        this.display.input.setUneditable(node);
        display.sizer.appendChild(node);
        if (vert == "over") {
          top = pos.top;
        } else if (vert == "above" || vert == "near") {
          var vspace = Math.max(display.wrapper.clientHeight, this.doc.height),
          hspace = Math.max(display.sizer.clientWidth, display.lineSpace.clientWidth);
          // Default to positioning above (if specified and possible); otherwise default to positioning below
          if ((vert == 'above' || pos.bottom + node.offsetHeight > vspace) && pos.top > node.offsetHeight)
            { top = pos.top - node.offsetHeight; }
          else if (pos.bottom + node.offsetHeight <= vspace)
            { top = pos.bottom; }
          if (left + node.offsetWidth > hspace)
            { left = hspace - node.offsetWidth; }
        }
        node.style.top = top + "px";
        node.style.left = node.style.right = "";
        if (horiz == "right") {
          left = display.sizer.clientWidth - node.offsetWidth;
          node.style.right = "0px";
        } else {
          if (horiz == "left") { left = 0; }
          else if (horiz == "middle") { left = (display.sizer.clientWidth - node.offsetWidth) / 2; }
          node.style.left = left + "px";
        }
        if (scroll)
          { scrollIntoView(this, {left: left, top: top, right: left + node.offsetWidth, bottom: top + node.offsetHeight}); }
      },

      triggerOnKeyDown: methodOp(onKeyDown),
      triggerOnKeyPress: methodOp(onKeyPress),
      triggerOnKeyUp: onKeyUp,
      triggerOnMouseDown: methodOp(onMouseDown),

      execCommand: function(cmd) {
        if (commands.hasOwnProperty(cmd))
          { return commands[cmd].call(null, this) }
      },

      triggerElectric: methodOp(function(text) { triggerElectric(this, text); }),

      findPosH: function(from, amount, unit, visually) {
        var dir = 1;
        if (amount < 0) { dir = -1; amount = -amount; }
        var cur = clipPos(this.doc, from);
        for (var i = 0; i < amount; ++i) {
          cur = findPosH(this.doc, cur, dir, unit, visually);
          if (cur.hitSide) { break }
        }
        return cur
      },

      moveH: methodOp(function(dir, unit) {
        var this$1 = this;

        this.extendSelectionsBy(function (range) {
          if (this$1.display.shift || this$1.doc.extend || range.empty())
            { return findPosH(this$1.doc, range.head, dir, unit, this$1.options.rtlMoveVisually) }
          else
            { return dir < 0 ? range.from() : range.to() }
        }, sel_move);
      }),

      deleteH: methodOp(function(dir, unit) {
        var sel = this.doc.sel, doc = this.doc;
        if (sel.somethingSelected())
          { doc.replaceSelection("", null, "+delete"); }
        else
          { deleteNearSelection(this, function (range) {
            var other = findPosH(doc, range.head, dir, unit, false);
            return dir < 0 ? {from: other, to: range.head} : {from: range.head, to: other}
          }); }
      }),

      findPosV: function(from, amount, unit, goalColumn) {
        var dir = 1, x = goalColumn;
        if (amount < 0) { dir = -1; amount = -amount; }
        var cur = clipPos(this.doc, from);
        for (var i = 0; i < amount; ++i) {
          var coords = cursorCoords(this, cur, "div");
          if (x == null) { x = coords.left; }
          else { coords.left = x; }
          cur = findPosV(this, coords, dir, unit);
          if (cur.hitSide) { break }
        }
        return cur
      },

      moveV: methodOp(function(dir, unit) {
        var this$1 = this;

        var doc = this.doc, goals = [];
        var collapse = !this.display.shift && !doc.extend && doc.sel.somethingSelected();
        doc.extendSelectionsBy(function (range) {
          if (collapse)
            { return dir < 0 ? range.from() : range.to() }
          var headPos = cursorCoords(this$1, range.head, "div");
          if (range.goalColumn != null) { headPos.left = range.goalColumn; }
          goals.push(headPos.left);
          var pos = findPosV(this$1, headPos, dir, unit);
          if (unit == "page" && range == doc.sel.primary())
            { addToScrollTop(this$1, charCoords(this$1, pos, "div").top - headPos.top); }
          return pos
        }, sel_move);
        if (goals.length) { for (var i = 0; i < doc.sel.ranges.length; i++)
          { doc.sel.ranges[i].goalColumn = goals[i]; } }
      }),

      // Find the word at the given position (as returned by coordsChar).
      findWordAt: function(pos) {
        var doc = this.doc, line = getLine(doc, pos.line).text;
        var start = pos.ch, end = pos.ch;
        if (line) {
          var helper = this.getHelper(pos, "wordChars");
          if ((pos.sticky == "before" || end == line.length) && start) { --start; } else { ++end; }
          var startChar = line.charAt(start);
          var check = isWordChar(startChar, helper)
            ? function (ch) { return isWordChar(ch, helper); }
            : /\s/.test(startChar) ? function (ch) { return /\s/.test(ch); }
            : function (ch) { return (!/\s/.test(ch) && !isWordChar(ch)); };
          while (start > 0 && check(line.charAt(start - 1))) { --start; }
          while (end < line.length && check(line.charAt(end))) { ++end; }
        }
        return new Range(Pos(pos.line, start), Pos(pos.line, end))
      },

      toggleOverwrite: function(value) {
        if (value != null && value == this.state.overwrite) { return }
        if (this.state.overwrite = !this.state.overwrite)
          { addClass(this.display.cursorDiv, "CodeMirror-overwrite"); }
        else
          { rmClass(this.display.cursorDiv, "CodeMirror-overwrite"); }

        signal(this, "overwriteToggle", this, this.state.overwrite);
      },
      hasFocus: function() { return this.display.input.getField() == activeElt() },
      isReadOnly: function() { return !!(this.options.readOnly || this.doc.cantEdit) },

      scrollTo: methodOp(function (x, y) { scrollToCoords(this, x, y); }),
      getScrollInfo: function() {
        var scroller = this.display.scroller;
        return {left: scroller.scrollLeft, top: scroller.scrollTop,
                height: scroller.scrollHeight - scrollGap(this) - this.display.barHeight,
                width: scroller.scrollWidth - scrollGap(this) - this.display.barWidth,
                clientHeight: displayHeight(this), clientWidth: displayWidth(this)}
      },

      scrollIntoView: methodOp(function(range, margin) {
        if (range == null) {
          range = {from: this.doc.sel.primary().head, to: null};
          if (margin == null) { margin = this.options.cursorScrollMargin; }
        } else if (typeof range == "number") {
          range = {from: Pos(range, 0), to: null};
        } else if (range.from == null) {
          range = {from: range, to: null};
        }
        if (!range.to) { range.to = range.from; }
        range.margin = margin || 0;

        if (range.from.line != null) {
          scrollToRange(this, range);
        } else {
          scrollToCoordsRange(this, range.from, range.to, range.margin);
        }
      }),

      setSize: methodOp(function(width, height) {
        var this$1 = this;

        var interpret = function (val) { return typeof val == "number" || /^\d+$/.test(String(val)) ? val + "px" : val; };
        if (width != null) { this.display.wrapper.style.width = interpret(width); }
        if (height != null) { this.display.wrapper.style.height = interpret(height); }
        if (this.options.lineWrapping) { clearLineMeasurementCache(this); }
        var lineNo = this.display.viewFrom;
        this.doc.iter(lineNo, this.display.viewTo, function (line) {
          if (line.widgets) { for (var i = 0; i < line.widgets.length; i++)
            { if (line.widgets[i].noHScroll) { regLineChange(this$1, lineNo, "widget"); break } } }
          ++lineNo;
        });
        this.curOp.forceUpdate = true;
        signal(this, "refresh", this);
      }),

      operation: function(f){return runInOp(this, f)},
      startOperation: function(){return startOperation(this)},
      endOperation: function(){return endOperation(this)},

      refresh: methodOp(function() {
        var oldHeight = this.display.cachedTextHeight;
        regChange(this);
        this.curOp.forceUpdate = true;
        clearCaches(this);
        scrollToCoords(this, this.doc.scrollLeft, this.doc.scrollTop);
        updateGutterSpace(this.display);
        if (oldHeight == null || Math.abs(oldHeight - textHeight(this.display)) > .5 || this.options.lineWrapping)
          { estimateLineHeights(this); }
        signal(this, "refresh", this);
      }),

      swapDoc: methodOp(function(doc) {
        var old = this.doc;
        old.cm = null;
        // Cancel the current text selection if any (#5821)
        if (this.state.selectingText) { this.state.selectingText(); }
        attachDoc(this, doc);
        clearCaches(this);
        this.display.input.reset();
        scrollToCoords(this, doc.scrollLeft, doc.scrollTop);
        this.curOp.forceScroll = true;
        signalLater(this, "swapDoc", this, old);
        return old
      }),

      phrase: function(phraseText) {
        var phrases = this.options.phrases;
        return phrases && Object.prototype.hasOwnProperty.call(phrases, phraseText) ? phrases[phraseText] : phraseText
      },

      getInputField: function(){return this.display.input.getField()},
      getWrapperElement: function(){return this.display.wrapper},
      getScrollerElement: function(){return this.display.scroller},
      getGutterElement: function(){return this.display.gutters}
    };
    eventMixin(CodeMirror);

    CodeMirror.registerHelper = function(type, name, value) {
      if (!helpers.hasOwnProperty(type)) { helpers[type] = CodeMirror[type] = {_global: []}; }
      helpers[type][name] = value;
    };
    CodeMirror.registerGlobalHelper = function(type, name, predicate, value) {
      CodeMirror.registerHelper(type, name, value);
      helpers[type]._global.push({pred: predicate, val: value});
    };
  }

  // Used for horizontal relative motion. Dir is -1 or 1 (left or
  // right), unit can be "codepoint", "char", "column" (like char, but
  // doesn't cross line boundaries), "word" (across next word), or
  // "group" (to the start of next group of word or
  // non-word-non-whitespace chars). The visually param controls
  // whether, in right-to-left text, direction 1 means to move towards
  // the next index in the string, or towards the character to the right
  // of the current position. The resulting position will have a
  // hitSide=true property if it reached the end of the document.
  function findPosH(doc, pos, dir, unit, visually) {
    var oldPos = pos;
    var origDir = dir;
    var lineObj = getLine(doc, pos.line);
    var lineDir = visually && doc.direction == "rtl" ? -dir : dir;
    function findNextLine() {
      var l = pos.line + lineDir;
      if (l < doc.first || l >= doc.first + doc.size) { return false }
      pos = new Pos(l, pos.ch, pos.sticky);
      return lineObj = getLine(doc, l)
    }
    function moveOnce(boundToLine) {
      var next;
      if (unit == "codepoint") {
        var ch = lineObj.text.charCodeAt(pos.ch + (dir > 0 ? 0 : -1));
        if (isNaN(ch)) {
          next = null;
        } else {
          var astral = dir > 0 ? ch >= 0xD800 && ch < 0xDC00 : ch >= 0xDC00 && ch < 0xDFFF;
          next = new Pos(pos.line, Math.max(0, Math.min(lineObj.text.length, pos.ch + dir * (astral ? 2 : 1))), -dir);
        }
      } else if (visually) {
        next = moveVisually(doc.cm, lineObj, pos, dir);
      } else {
        next = moveLogically(lineObj, pos, dir);
      }
      if (next == null) {
        if (!boundToLine && findNextLine())
          { pos = endOfLine(visually, doc.cm, lineObj, pos.line, lineDir); }
        else
          { return false }
      } else {
        pos = next;
      }
      return true
    }

    if (unit == "char" || unit == "codepoint") {
      moveOnce();
    } else if (unit == "column") {
      moveOnce(true);
    } else if (unit == "word" || unit == "group") {
      var sawType = null, group = unit == "group";
      var helper = doc.cm && doc.cm.getHelper(pos, "wordChars");
      for (var first = true;; first = false) {
        if (dir < 0 && !moveOnce(!first)) { break }
        var cur = lineObj.text.charAt(pos.ch) || "\n";
        var type = isWordChar(cur, helper) ? "w"
          : group && cur == "\n" ? "n"
          : !group || /\s/.test(cur) ? null
          : "p";
        if (group && !first && !type) { type = "s"; }
        if (sawType && sawType != type) {
          if (dir < 0) {dir = 1; moveOnce(); pos.sticky = "after";}
          break
        }

        if (type) { sawType = type; }
        if (dir > 0 && !moveOnce(!first)) { break }
      }
    }
    var result = skipAtomic(doc, pos, oldPos, origDir, true);
    if (equalCursorPos(oldPos, result)) { result.hitSide = true; }
    return result
  }

  // For relative vertical movement. Dir may be -1 or 1. Unit can be
  // "page" or "line". The resulting position will have a hitSide=true
  // property if it reached the end of the document.
  function findPosV(cm, pos, dir, unit) {
    var doc = cm.doc, x = pos.left, y;
    if (unit == "page") {
      var pageSize = Math.min(cm.display.wrapper.clientHeight, window.innerHeight || document.documentElement.clientHeight);
      var moveAmount = Math.max(pageSize - .5 * textHeight(cm.display), 3);
      y = (dir > 0 ? pos.bottom : pos.top) + dir * moveAmount;

    } else if (unit == "line") {
      y = dir > 0 ? pos.bottom + 3 : pos.top - 3;
    }
    var target;
    for (;;) {
      target = coordsChar(cm, x, y);
      if (!target.outside) { break }
      if (dir < 0 ? y <= 0 : y >= doc.height) { target.hitSide = true; break }
      y += dir * 5;
    }
    return target
  }

  // CONTENTEDITABLE INPUT STYLE

  var ContentEditableInput = function(cm) {
    this.cm = cm;
    this.lastAnchorNode = this.lastAnchorOffset = this.lastFocusNode = this.lastFocusOffset = null;
    this.polling = new Delayed();
    this.composing = null;
    this.gracePeriod = false;
    this.readDOMTimeout = null;
  };

  ContentEditableInput.prototype.init = function (display) {
      var this$1 = this;

    var input = this, cm = input.cm;
    var div = input.div = display.lineDiv;
    div.contentEditable = true;
    disableBrowserMagic(div, cm.options.spellcheck, cm.options.autocorrect, cm.options.autocapitalize);

    function belongsToInput(e) {
      for (var t = e.target; t; t = t.parentNode) {
        if (t == div) { return true }
        if (/\bCodeMirror-(?:line)?widget\b/.test(t.className)) { break }
      }
      return false
    }

    on(div, "paste", function (e) {
      if (!belongsToInput(e) || signalDOMEvent(cm, e) || handlePaste(e, cm)) { return }
      // IE doesn't fire input events, so we schedule a read for the pasted content in this way
      if (ie_version <= 11) { setTimeout(operation(cm, function () { return this$1.updateFromDOM(); }), 20); }
    });

    on(div, "compositionstart", function (e) {
      this$1.composing = {data: e.data, done: false};
    });
    on(div, "compositionupdate", function (e) {
      if (!this$1.composing) { this$1.composing = {data: e.data, done: false}; }
    });
    on(div, "compositionend", function (e) {
      if (this$1.composing) {
        if (e.data != this$1.composing.data) { this$1.readFromDOMSoon(); }
        this$1.composing.done = true;
      }
    });

    on(div, "touchstart", function () { return input.forceCompositionEnd(); });

    on(div, "input", function () {
      if (!this$1.composing) { this$1.readFromDOMSoon(); }
    });

    function onCopyCut(e) {
      if (!belongsToInput(e) || signalDOMEvent(cm, e)) { return }
      if (cm.somethingSelected()) {
        setLastCopied({lineWise: false, text: cm.getSelections()});
        if (e.type == "cut") { cm.replaceSelection("", null, "cut"); }
      } else if (!cm.options.lineWiseCopyCut) {
        return
      } else {
        var ranges = copyableRanges(cm);
        setLastCopied({lineWise: true, text: ranges.text});
        if (e.type == "cut") {
          cm.operation(function () {
            cm.setSelections(ranges.ranges, 0, sel_dontScroll);
            cm.replaceSelection("", null, "cut");
          });
        }
      }
      if (e.clipboardData) {
        e.clipboardData.clearData();
        var content = lastCopied.text.join("\n");
        // iOS exposes the clipboard API, but seems to discard content inserted into it
        e.clipboardData.setData("Text", content);
        if (e.clipboardData.getData("Text") == content) {
          e.preventDefault();
          return
        }
      }
      // Old-fashioned briefly-focus-a-textarea hack
      var kludge = hiddenTextarea(), te = kludge.firstChild;
      cm.display.lineSpace.insertBefore(kludge, cm.display.lineSpace.firstChild);
      te.value = lastCopied.text.join("\n");
      var hadFocus = activeElt();
      selectInput(te);
      setTimeout(function () {
        cm.display.lineSpace.removeChild(kludge);
        hadFocus.focus();
        if (hadFocus == div) { input.showPrimarySelection(); }
      }, 50);
    }
    on(div, "copy", onCopyCut);
    on(div, "cut", onCopyCut);
  };

  ContentEditableInput.prototype.screenReaderLabelChanged = function (label) {
    // Label for screenreaders, accessibility
    if(label) {
      this.div.setAttribute('aria-label', label);
    } else {
      this.div.removeAttribute('aria-label');
    }
  };

  ContentEditableInput.prototype.prepareSelection = function () {
    var result = prepareSelection(this.cm, false);
    result.focus = activeElt() == this.div;
    return result
  };

  ContentEditableInput.prototype.showSelection = function (info, takeFocus) {
    if (!info || !this.cm.display.view.length) { return }
    if (info.focus || takeFocus) { this.showPrimarySelection(); }
    this.showMultipleSelections(info);
  };

  ContentEditableInput.prototype.getSelection = function () {
    return this.cm.display.wrapper.ownerDocument.getSelection()
  };

  ContentEditableInput.prototype.showPrimarySelection = function () {
    var sel = this.getSelection(), cm = this.cm, prim = cm.doc.sel.primary();
    var from = prim.from(), to = prim.to();

    if (cm.display.viewTo == cm.display.viewFrom || from.line >= cm.display.viewTo || to.line < cm.display.viewFrom) {
      sel.removeAllRanges();
      return
    }

    var curAnchor = domToPos(cm, sel.anchorNode, sel.anchorOffset);
    var curFocus = domToPos(cm, sel.focusNode, sel.focusOffset);
    if (curAnchor && !curAnchor.bad && curFocus && !curFocus.bad &&
        cmp(minPos(curAnchor, curFocus), from) == 0 &&
        cmp(maxPos(curAnchor, curFocus), to) == 0)
      { return }

    var view = cm.display.view;
    var start = (from.line >= cm.display.viewFrom && posToDOM(cm, from)) ||
        {node: view[0].measure.map[2], offset: 0};
    var end = to.line < cm.display.viewTo && posToDOM(cm, to);
    if (!end) {
      var measure = view[view.length - 1].measure;
      var map = measure.maps ? measure.maps[measure.maps.length - 1] : measure.map;
      end = {node: map[map.length - 1], offset: map[map.length - 2] - map[map.length - 3]};
    }

    if (!start || !end) {
      sel.removeAllRanges();
      return
    }

    var old = sel.rangeCount && sel.getRangeAt(0), rng;
    try { rng = range(start.node, start.offset, end.offset, end.node); }
    catch(e) {} // Our model of the DOM might be outdated, in which case the range we try to set can be impossible
    if (rng) {
      if (!gecko && cm.state.focused) {
        sel.collapse(start.node, start.offset);
        if (!rng.collapsed) {
          sel.removeAllRanges();
          sel.addRange(rng);
        }
      } else {
        sel.removeAllRanges();
        sel.addRange(rng);
      }
      if (old && sel.anchorNode == null) { sel.addRange(old); }
      else if (gecko) { this.startGracePeriod(); }
    }
    this.rememberSelection();
  };

  ContentEditableInput.prototype.startGracePeriod = function () {
      var this$1 = this;

    clearTimeout(this.gracePeriod);
    this.gracePeriod = setTimeout(function () {
      this$1.gracePeriod = false;
      if (this$1.selectionChanged())
        { this$1.cm.operation(function () { return this$1.cm.curOp.selectionChanged = true; }); }
    }, 20);
  };

  ContentEditableInput.prototype.showMultipleSelections = function (info) {
    removeChildrenAndAdd(this.cm.display.cursorDiv, info.cursors);
    removeChildrenAndAdd(this.cm.display.selectionDiv, info.selection);
  };

  ContentEditableInput.prototype.rememberSelection = function () {
    var sel = this.getSelection();
    this.lastAnchorNode = sel.anchorNode; this.lastAnchorOffset = sel.anchorOffset;
    this.lastFocusNode = sel.focusNode; this.lastFocusOffset = sel.focusOffset;
  };

  ContentEditableInput.prototype.selectionInEditor = function () {
    var sel = this.getSelection();
    if (!sel.rangeCount) { return false }
    var node = sel.getRangeAt(0).commonAncestorContainer;
    return contains(this.div, node)
  };

  ContentEditableInput.prototype.focus = function () {
    if (this.cm.options.readOnly != "nocursor") {
      if (!this.selectionInEditor() || activeElt() != this.div)
        { this.showSelection(this.prepareSelection(), true); }
      this.div.focus();
    }
  };
  ContentEditableInput.prototype.blur = function () { this.div.blur(); };
  ContentEditableInput.prototype.getField = function () { return this.div };

  ContentEditableInput.prototype.supportsTouch = function () { return true };

  ContentEditableInput.prototype.receivedFocus = function () {
      var this$1 = this;

    var input = this;
    if (this.selectionInEditor())
      { setTimeout(function () { return this$1.pollSelection(); }, 20); }
    else
      { runInOp(this.cm, function () { return input.cm.curOp.selectionChanged = true; }); }

    function poll() {
      if (input.cm.state.focused) {
        input.pollSelection();
        input.polling.set(input.cm.options.pollInterval, poll);
      }
    }
    this.polling.set(this.cm.options.pollInterval, poll);
  };

  ContentEditableInput.prototype.selectionChanged = function () {
    var sel = this.getSelection();
    return sel.anchorNode != this.lastAnchorNode || sel.anchorOffset != this.lastAnchorOffset ||
      sel.focusNode != this.lastFocusNode || sel.focusOffset != this.lastFocusOffset
  };

  ContentEditableInput.prototype.pollSelection = function () {
    if (this.readDOMTimeout != null || this.gracePeriod || !this.selectionChanged()) { return }
    var sel = this.getSelection(), cm = this.cm;
    // On Android Chrome (version 56, at least), backspacing into an
    // uneditable block element will put the cursor in that element,
    // and then, because it's not editable, hide the virtual keyboard.
    // Because Android doesn't allow us to actually detect backspace
    // presses in a sane way, this code checks for when that happens
    // and simulates a backspace press in this case.
    if (android && chrome && this.cm.display.gutterSpecs.length && isInGutter(sel.anchorNode)) {
      this.cm.triggerOnKeyDown({type: "keydown", keyCode: 8, preventDefault: Math.abs});
      this.blur();
      this.focus();
      return
    }
    if (this.composing) { return }
    this.rememberSelection();
    var anchor = domToPos(cm, sel.anchorNode, sel.anchorOffset);
    var head = domToPos(cm, sel.focusNode, sel.focusOffset);
    if (anchor && head) { runInOp(cm, function () {
      setSelection(cm.doc, simpleSelection(anchor, head), sel_dontScroll);
      if (anchor.bad || head.bad) { cm.curOp.selectionChanged = true; }
    }); }
  };

  ContentEditableInput.prototype.pollContent = function () {
    if (this.readDOMTimeout != null) {
      clearTimeout(this.readDOMTimeout);
      this.readDOMTimeout = null;
    }

    var cm = this.cm, display = cm.display, sel = cm.doc.sel.primary();
    var from = sel.from(), to = sel.to();
    if (from.ch == 0 && from.line > cm.firstLine())
      { from = Pos(from.line - 1, getLine(cm.doc, from.line - 1).length); }
    if (to.ch == getLine(cm.doc, to.line).text.length && to.line < cm.lastLine())
      { to = Pos(to.line + 1, 0); }
    if (from.line < display.viewFrom || to.line > display.viewTo - 1) { return false }

    var fromIndex, fromLine, fromNode;
    if (from.line == display.viewFrom || (fromIndex = findViewIndex(cm, from.line)) == 0) {
      fromLine = lineNo(display.view[0].line);
      fromNode = display.view[0].node;
    } else {
      fromLine = lineNo(display.view[fromIndex].line);
      fromNode = display.view[fromIndex - 1].node.nextSibling;
    }
    var toIndex = findViewIndex(cm, to.line);
    var toLine, toNode;
    if (toIndex == display.view.length - 1) {
      toLine = display.viewTo - 1;
      toNode = display.lineDiv.lastChild;
    } else {
      toLine = lineNo(display.view[toIndex + 1].line) - 1;
      toNode = display.view[toIndex + 1].node.previousSibling;
    }

    if (!fromNode) { return false }
    var newText = cm.doc.splitLines(domTextBetween(cm, fromNode, toNode, fromLine, toLine));
    var oldText = getBetween(cm.doc, Pos(fromLine, 0), Pos(toLine, getLine(cm.doc, toLine).text.length));
    while (newText.length > 1 && oldText.length > 1) {
      if (lst(newText) == lst(oldText)) { newText.pop(); oldText.pop(); toLine--; }
      else if (newText[0] == oldText[0]) { newText.shift(); oldText.shift(); fromLine++; }
      else { break }
    }

    var cutFront = 0, cutEnd = 0;
    var newTop = newText[0], oldTop = oldText[0], maxCutFront = Math.min(newTop.length, oldTop.length);
    while (cutFront < maxCutFront && newTop.charCodeAt(cutFront) == oldTop.charCodeAt(cutFront))
      { ++cutFront; }
    var newBot = lst(newText), oldBot = lst(oldText);
    var maxCutEnd = Math.min(newBot.length - (newText.length == 1 ? cutFront : 0),
                             oldBot.length - (oldText.length == 1 ? cutFront : 0));
    while (cutEnd < maxCutEnd &&
           newBot.charCodeAt(newBot.length - cutEnd - 1) == oldBot.charCodeAt(oldBot.length - cutEnd - 1))
      { ++cutEnd; }
    // Try to move start of change to start of selection if ambiguous
    if (newText.length == 1 && oldText.length == 1 && fromLine == from.line) {
      while (cutFront && cutFront > from.ch &&
             newBot.charCodeAt(newBot.length - cutEnd - 1) == oldBot.charCodeAt(oldBot.length - cutEnd - 1)) {
        cutFront--;
        cutEnd++;
      }
    }

    newText[newText.length - 1] = newBot.slice(0, newBot.length - cutEnd).replace(/^\u200b+/, "");
    newText[0] = newText[0].slice(cutFront).replace(/\u200b+$/, "");

    var chFrom = Pos(fromLine, cutFront);
    var chTo = Pos(toLine, oldText.length ? lst(oldText).length - cutEnd : 0);
    if (newText.length > 1 || newText[0] || cmp(chFrom, chTo)) {
      replaceRange(cm.doc, newText, chFrom, chTo, "+input");
      return true
    }
  };

  ContentEditableInput.prototype.ensurePolled = function () {
    this.forceCompositionEnd();
  };
  ContentEditableInput.prototype.reset = function () {
    this.forceCompositionEnd();
  };
  ContentEditableInput.prototype.forceCompositionEnd = function () {
    if (!this.composing) { return }
    clearTimeout(this.readDOMTimeout);
    this.composing = null;
    this.updateFromDOM();
    this.div.blur();
    this.div.focus();
  };
  ContentEditableInput.prototype.readFromDOMSoon = function () {
      var this$1 = this;

    if (this.readDOMTimeout != null) { return }
    this.readDOMTimeout = setTimeout(function () {
      this$1.readDOMTimeout = null;
      if (this$1.composing) {
        if (this$1.composing.done) { this$1.composing = null; }
        else { return }
      }
      this$1.updateFromDOM();
    }, 80);
  };

  ContentEditableInput.prototype.updateFromDOM = function () {
      var this$1 = this;

    if (this.cm.isReadOnly() || !this.pollContent())
      { runInOp(this.cm, function () { return regChange(this$1.cm); }); }
  };

  ContentEditableInput.prototype.setUneditable = function (node) {
    node.contentEditable = "false";
  };

  ContentEditableInput.prototype.onKeyPress = function (e) {
    if (e.charCode == 0 || this.composing) { return }
    e.preventDefault();
    if (!this.cm.isReadOnly())
      { operation(this.cm, applyTextInput)(this.cm, String.fromCharCode(e.charCode == null ? e.keyCode : e.charCode), 0); }
  };

  ContentEditableInput.prototype.readOnlyChanged = function (val) {
    this.div.contentEditable = String(val != "nocursor");
  };

  ContentEditableInput.prototype.onContextMenu = function () {};
  ContentEditableInput.prototype.resetPosition = function () {};

  ContentEditableInput.prototype.needsContentAttribute = true;

  function posToDOM(cm, pos) {
    var view = findViewForLine(cm, pos.line);
    if (!view || view.hidden) { return null }
    var line = getLine(cm.doc, pos.line);
    var info = mapFromLineView(view, line, pos.line);

    var order = getOrder(line, cm.doc.direction), side = "left";
    if (order) {
      var partPos = getBidiPartAt(order, pos.ch);
      side = partPos % 2 ? "right" : "left";
    }
    var result = nodeAndOffsetInLineMap(info.map, pos.ch, side);
    result.offset = result.collapse == "right" ? result.end : result.start;
    return result
  }

  function isInGutter(node) {
    for (var scan = node; scan; scan = scan.parentNode)
      { if (/CodeMirror-gutter-wrapper/.test(scan.className)) { return true } }
    return false
  }

  function badPos(pos, bad) { if (bad) { pos.bad = true; } return pos }

  function domTextBetween(cm, from, to, fromLine, toLine) {
    var text = "", closing = false, lineSep = cm.doc.lineSeparator(), extraLinebreak = false;
    function recognizeMarker(id) { return function (marker) { return marker.id == id; } }
    function close() {
      if (closing) {
        text += lineSep;
        if (extraLinebreak) { text += lineSep; }
        closing = extraLinebreak = false;
      }
    }
    function addText(str) {
      if (str) {
        close();
        text += str;
      }
    }
    function walk(node) {
      if (node.nodeType == 1) {
        var cmText = node.getAttribute("cm-text");
        if (cmText) {
          addText(cmText);
          return
        }
        var markerID = node.getAttribute("cm-marker"), range;
        if (markerID) {
          var found = cm.findMarks(Pos(fromLine, 0), Pos(toLine + 1, 0), recognizeMarker(+markerID));
          if (found.length && (range = found[0].find(0)))
            { addText(getBetween(cm.doc, range.from, range.to).join(lineSep)); }
          return
        }
        if (node.getAttribute("contenteditable") == "false") { return }
        var isBlock = /^(pre|div|p|li|table|br)$/i.test(node.nodeName);
        if (!/^br$/i.test(node.nodeName) && node.textContent.length == 0) { return }

        if (isBlock) { close(); }
        for (var i = 0; i < node.childNodes.length; i++)
          { walk(node.childNodes[i]); }

        if (/^(pre|p)$/i.test(node.nodeName)) { extraLinebreak = true; }
        if (isBlock) { closing = true; }
      } else if (node.nodeType == 3) {
        addText(node.nodeValue.replace(/\u200b/g, "").replace(/\u00a0/g, " "));
      }
    }
    for (;;) {
      walk(from);
      if (from == to) { break }
      from = from.nextSibling;
      extraLinebreak = false;
    }
    return text
  }

  function domToPos(cm, node, offset) {
    var lineNode;
    if (node == cm.display.lineDiv) {
      lineNode = cm.display.lineDiv.childNodes[offset];
      if (!lineNode) { return badPos(cm.clipPos(Pos(cm.display.viewTo - 1)), true) }
      node = null; offset = 0;
    } else {
      for (lineNode = node;; lineNode = lineNode.parentNode) {
        if (!lineNode || lineNode == cm.display.lineDiv) { return null }
        if (lineNode.parentNode && lineNode.parentNode == cm.display.lineDiv) { break }
      }
    }
    for (var i = 0; i < cm.display.view.length; i++) {
      var lineView = cm.display.view[i];
      if (lineView.node == lineNode)
        { return locateNodeInLineView(lineView, node, offset) }
    }
  }

  function locateNodeInLineView(lineView, node, offset) {
    var wrapper = lineView.text.firstChild, bad = false;
    if (!node || !contains(wrapper, node)) { return badPos(Pos(lineNo(lineView.line), 0), true) }
    if (node == wrapper) {
      bad = true;
      node = wrapper.childNodes[offset];
      offset = 0;
      if (!node) {
        var line = lineView.rest ? lst(lineView.rest) : lineView.line;
        return badPos(Pos(lineNo(line), line.text.length), bad)
      }
    }

    var textNode = node.nodeType == 3 ? node : null, topNode = node;
    if (!textNode && node.childNodes.length == 1 && node.firstChild.nodeType == 3) {
      textNode = node.firstChild;
      if (offset) { offset = textNode.nodeValue.length; }
    }
    while (topNode.parentNode != wrapper) { topNode = topNode.parentNode; }
    var measure = lineView.measure, maps = measure.maps;

    function find(textNode, topNode, offset) {
      for (var i = -1; i < (maps ? maps.length : 0); i++) {
        var map = i < 0 ? measure.map : maps[i];
        for (var j = 0; j < map.length; j += 3) {
          var curNode = map[j + 2];
          if (curNode == textNode || curNode == topNode) {
            var line = lineNo(i < 0 ? lineView.line : lineView.rest[i]);
            var ch = map[j] + offset;
            if (offset < 0 || curNode != textNode) { ch = map[j + (offset ? 1 : 0)]; }
            return Pos(line, ch)
          }
        }
      }
    }
    var found = find(textNode, topNode, offset);
    if (found) { return badPos(found, bad) }

    // FIXME this is all really shaky. might handle the few cases it needs to handle, but likely to cause problems
    for (var after = topNode.nextSibling, dist = textNode ? textNode.nodeValue.length - offset : 0; after; after = after.nextSibling) {
      found = find(after, after.firstChild, 0);
      if (found)
        { return badPos(Pos(found.line, found.ch - dist), bad) }
      else
        { dist += after.textContent.length; }
    }
    for (var before = topNode.previousSibling, dist$1 = offset; before; before = before.previousSibling) {
      found = find(before, before.firstChild, -1);
      if (found)
        { return badPos(Pos(found.line, found.ch + dist$1), bad) }
      else
        { dist$1 += before.textContent.length; }
    }
  }

  // TEXTAREA INPUT STYLE

  var TextareaInput = function(cm) {
    this.cm = cm;
    // See input.poll and input.reset
    this.prevInput = "";

    // Flag that indicates whether we expect input to appear real soon
    // now (after some event like 'keypress' or 'input') and are
    // polling intensively.
    this.pollingFast = false;
    // Self-resetting timeout for the poller
    this.polling = new Delayed();
    // Used to work around IE issue with selection being forgotten when focus moves away from textarea
    this.hasSelection = false;
    this.composing = null;
  };

  TextareaInput.prototype.init = function (display) {
      var this$1 = this;

    var input = this, cm = this.cm;
    this.createField(display);
    var te = this.textarea;

    display.wrapper.insertBefore(this.wrapper, display.wrapper.firstChild);

    // Needed to hide big blue blinking cursor on Mobile Safari (doesn't seem to work in iOS 8 anymore)
    if (ios) { te.style.width = "0px"; }

    on(te, "input", function () {
      if (ie && ie_version >= 9 && this$1.hasSelection) { this$1.hasSelection = null; }
      input.poll();
    });

    on(te, "paste", function (e) {
      if (signalDOMEvent(cm, e) || handlePaste(e, cm)) { return }

      cm.state.pasteIncoming = +new Date;
      input.fastPoll();
    });

    function prepareCopyCut(e) {
      if (signalDOMEvent(cm, e)) { return }
      if (cm.somethingSelected()) {
        setLastCopied({lineWise: false, text: cm.getSelections()});
      } else if (!cm.options.lineWiseCopyCut) {
        return
      } else {
        var ranges = copyableRanges(cm);
        setLastCopied({lineWise: true, text: ranges.text});
        if (e.type == "cut") {
          cm.setSelections(ranges.ranges, null, sel_dontScroll);
        } else {
          input.prevInput = "";
          te.value = ranges.text.join("\n");
          selectInput(te);
        }
      }
      if (e.type == "cut") { cm.state.cutIncoming = +new Date; }
    }
    on(te, "cut", prepareCopyCut);
    on(te, "copy", prepareCopyCut);

    on(display.scroller, "paste", function (e) {
      if (eventInWidget(display, e) || signalDOMEvent(cm, e)) { return }
      if (!te.dispatchEvent) {
        cm.state.pasteIncoming = +new Date;
        input.focus();
        return
      }

      // Pass the `paste` event to the textarea so it's handled by its event listener.
      var event = new Event("paste");
      event.clipboardData = e.clipboardData;
      te.dispatchEvent(event);
    });

    // Prevent normal selection in the editor (we handle our own)
    on(display.lineSpace, "selectstart", function (e) {
      if (!eventInWidget(display, e)) { e_preventDefault(e); }
    });

    on(te, "compositionstart", function () {
      var start = cm.getCursor("from");
      if (input.composing) { input.composing.range.clear(); }
      input.composing = {
        start: start,
        range: cm.markText(start, cm.getCursor("to"), {className: "CodeMirror-composing"})
      };
    });
    on(te, "compositionend", function () {
      if (input.composing) {
        input.poll();
        input.composing.range.clear();
        input.composing = null;
      }
    });
  };

  TextareaInput.prototype.createField = function (_display) {
    // Wraps and hides input textarea
    this.wrapper = hiddenTextarea();
    // The semihidden textarea that is focused when the editor is
    // focused, and receives input.
    this.textarea = this.wrapper.firstChild;
  };

  TextareaInput.prototype.screenReaderLabelChanged = function (label) {
    // Label for screenreaders, accessibility
    if(label) {
      this.textarea.setAttribute('aria-label', label);
    } else {
      this.textarea.removeAttribute('aria-label');
    }
  };

  TextareaInput.prototype.prepareSelection = function () {
    // Redraw the selection and/or cursor
    var cm = this.cm, display = cm.display, doc = cm.doc;
    var result = prepareSelection(cm);

    // Move the hidden textarea near the cursor to prevent scrolling artifacts
    if (cm.options.moveInputWithCursor) {
      var headPos = cursorCoords(cm, doc.sel.primary().head, "div");
      var wrapOff = display.wrapper.getBoundingClientRect(), lineOff = display.lineDiv.getBoundingClientRect();
      result.teTop = Math.max(0, Math.min(display.wrapper.clientHeight - 10,
                                          headPos.top + lineOff.top - wrapOff.top));
      result.teLeft = Math.max(0, Math.min(display.wrapper.clientWidth - 10,
                                           headPos.left + lineOff.left - wrapOff.left));
    }

    return result
  };

  TextareaInput.prototype.showSelection = function (drawn) {
    var cm = this.cm, display = cm.display;
    removeChildrenAndAdd(display.cursorDiv, drawn.cursors);
    removeChildrenAndAdd(display.selectionDiv, drawn.selection);
    if (drawn.teTop != null) {
      this.wrapper.style.top = drawn.teTop + "px";
      this.wrapper.style.left = drawn.teLeft + "px";
    }
  };

  // Reset the input to correspond to the selection (or to be empty,
  // when not typing and nothing is selected)
  TextareaInput.prototype.reset = function (typing) {
    if (this.contextMenuPending || this.composing) { return }
    var cm = this.cm;
    if (cm.somethingSelected()) {
      this.prevInput = "";
      var content = cm.getSelection();
      this.textarea.value = content;
      if (cm.state.focused) { selectInput(this.textarea); }
      if (ie && ie_version >= 9) { this.hasSelection = content; }
    } else if (!typing) {
      this.prevInput = this.textarea.value = "";
      if (ie && ie_version >= 9) { this.hasSelection = null; }
    }
  };

  TextareaInput.prototype.getField = function () { return this.textarea };

  TextareaInput.prototype.supportsTouch = function () { return false };

  TextareaInput.prototype.focus = function () {
    if (this.cm.options.readOnly != "nocursor" && (!mobile || activeElt() != this.textarea)) {
      try { this.textarea.focus(); }
      catch (e) {} // IE8 will throw if the textarea is display: none or not in DOM
    }
  };

  TextareaInput.prototype.blur = function () { this.textarea.blur(); };

  TextareaInput.prototype.resetPosition = function () {
    this.wrapper.style.top = this.wrapper.style.left = 0;
  };

  TextareaInput.prototype.receivedFocus = function () { this.slowPoll(); };

  // Poll for input changes, using the normal rate of polling. This
  // runs as long as the editor is focused.
  TextareaInput.prototype.slowPoll = function () {
      var this$1 = this;

    if (this.pollingFast) { return }
    this.polling.set(this.cm.options.pollInterval, function () {
      this$1.poll();
      if (this$1.cm.state.focused) { this$1.slowPoll(); }
    });
  };

  // When an event has just come in that is likely to add or change
  // something in the input textarea, we poll faster, to ensure that
  // the change appears on the screen quickly.
  TextareaInput.prototype.fastPoll = function () {
    var missed = false, input = this;
    input.pollingFast = true;
    function p() {
      var changed = input.poll();
      if (!changed && !missed) {missed = true; input.polling.set(60, p);}
      else {input.pollingFast = false; input.slowPoll();}
    }
    input.polling.set(20, p);
  };

  // Read input from the textarea, and update the document to match.
  // When something is selected, it is present in the textarea, and
  // selected (unless it is huge, in which case a placeholder is
  // used). When nothing is selected, the cursor sits after previously
  // seen text (can be empty), which is stored in prevInput (we must
  // not reset the textarea when typing, because that breaks IME).
  TextareaInput.prototype.poll = function () {
      var this$1 = this;

    var cm = this.cm, input = this.textarea, prevInput = this.prevInput;
    // Since this is called a *lot*, try to bail out as cheaply as
    // possible when it is clear that nothing happened. hasSelection
    // will be the case when there is a lot of text in the textarea,
    // in which case reading its value would be expensive.
    if (this.contextMenuPending || !cm.state.focused ||
        (hasSelection(input) && !prevInput && !this.composing) ||
        cm.isReadOnly() || cm.options.disableInput || cm.state.keySeq)
      { return false }

    var text = input.value;
    // If nothing changed, bail.
    if (text == prevInput && !cm.somethingSelected()) { return false }
    // Work around nonsensical selection resetting in IE9/10, and
    // inexplicable appearance of private area unicode characters on
    // some key combos in Mac (#2689).
    if (ie && ie_version >= 9 && this.hasSelection === text ||
        mac && /[\uf700-\uf7ff]/.test(text)) {
      cm.display.input.reset();
      return false
    }

    if (cm.doc.sel == cm.display.selForContextMenu) {
      var first = text.charCodeAt(0);
      if (first == 0x200b && !prevInput) { prevInput = "\u200b"; }
      if (first == 0x21da) { this.reset(); return this.cm.execCommand("undo") }
    }
    // Find the part of the input that is actually new
    var same = 0, l = Math.min(prevInput.length, text.length);
    while (same < l && prevInput.charCodeAt(same) == text.charCodeAt(same)) { ++same; }

    runInOp(cm, function () {
      applyTextInput(cm, text.slice(same), prevInput.length - same,
                     null, this$1.composing ? "*compose" : null);

      // Don't leave long text in the textarea, since it makes further polling slow
      if (text.length > 1000 || text.indexOf("\n") > -1) { input.value = this$1.prevInput = ""; }
      else { this$1.prevInput = text; }

      if (this$1.composing) {
        this$1.composing.range.clear();
        this$1.composing.range = cm.markText(this$1.composing.start, cm.getCursor("to"),
                                           {className: "CodeMirror-composing"});
      }
    });
    return true
  };

  TextareaInput.prototype.ensurePolled = function () {
    if (this.pollingFast && this.poll()) { this.pollingFast = false; }
  };

  TextareaInput.prototype.onKeyPress = function () {
    if (ie && ie_version >= 9) { this.hasSelection = null; }
    this.fastPoll();
  };

  TextareaInput.prototype.onContextMenu = function (e) {
    var input = this, cm = input.cm, display = cm.display, te = input.textarea;
    if (input.contextMenuPending) { input.contextMenuPending(); }
    var pos = posFromMouse(cm, e), scrollPos = display.scroller.scrollTop;
    if (!pos || presto) { return } // Opera is difficult.

    // Reset the current text selection only if the click is done outside of the selection
    // and 'resetSelectionOnContextMenu' option is true.
    var reset = cm.options.resetSelectionOnContextMenu;
    if (reset && cm.doc.sel.contains(pos) == -1)
      { operation(cm, setSelection)(cm.doc, simpleSelection(pos), sel_dontScroll); }

    var oldCSS = te.style.cssText, oldWrapperCSS = input.wrapper.style.cssText;
    var wrapperBox = input.wrapper.offsetParent.getBoundingClientRect();
    input.wrapper.style.cssText = "position: static";
    te.style.cssText = "position: absolute; width: 30px; height: 30px;\n      top: " + (e.clientY - wrapperBox.top - 5) + "px; left: " + (e.clientX - wrapperBox.left - 5) + "px;\n      z-index: 1000; background: " + (ie ? "rgba(255, 255, 255, .05)" : "transparent") + ";\n      outline: none; border-width: 0; outline: none; overflow: hidden; opacity: .05; filter: alpha(opacity=5);";
    var oldScrollY;
    if (webkit) { oldScrollY = window.scrollY; } // Work around Chrome issue (#2712)
    display.input.focus();
    if (webkit) { window.scrollTo(null, oldScrollY); }
    display.input.reset();
    // Adds "Select all" to context menu in FF
    if (!cm.somethingSelected()) { te.value = input.prevInput = " "; }
    input.contextMenuPending = rehide;
    display.selForContextMenu = cm.doc.sel;
    clearTimeout(display.detectingSelectAll);

    // Select-all will be greyed out if there's nothing to select, so
    // this adds a zero-width space so that we can later check whether
    // it got selected.
    function prepareSelectAllHack() {
      if (te.selectionStart != null) {
        var selected = cm.somethingSelected();
        var extval = "\u200b" + (selected ? te.value : "");
        te.value = "\u21da"; // Used to catch context-menu undo
        te.value = extval;
        input.prevInput = selected ? "" : "\u200b";
        te.selectionStart = 1; te.selectionEnd = extval.length;
        // Re-set this, in case some other handler touched the
        // selection in the meantime.
        display.selForContextMenu = cm.doc.sel;
      }
    }
    function rehide() {
      if (input.contextMenuPending != rehide) { return }
      input.contextMenuPending = false;
      input.wrapper.style.cssText = oldWrapperCSS;
      te.style.cssText = oldCSS;
      if (ie && ie_version < 9) { display.scrollbars.setScrollTop(display.scroller.scrollTop = scrollPos); }

      // Try to detect the user choosing select-all
      if (te.selectionStart != null) {
        if (!ie || (ie && ie_version < 9)) { prepareSelectAllHack(); }
        var i = 0, poll = function () {
          if (display.selForContextMenu == cm.doc.sel && te.selectionStart == 0 &&
              te.selectionEnd > 0 && input.prevInput == "\u200b") {
            operation(cm, selectAll)(cm);
          } else if (i++ < 10) {
            display.detectingSelectAll = setTimeout(poll, 500);
          } else {
            display.selForContextMenu = null;
            display.input.reset();
          }
        };
        display.detectingSelectAll = setTimeout(poll, 200);
      }
    }

    if (ie && ie_version >= 9) { prepareSelectAllHack(); }
    if (captureRightClick) {
      e_stop(e);
      var mouseup = function () {
        off(window, "mouseup", mouseup);
        setTimeout(rehide, 20);
      };
      on(window, "mouseup", mouseup);
    } else {
      setTimeout(rehide, 50);
    }
  };

  TextareaInput.prototype.readOnlyChanged = function (val) {
    if (!val) { this.reset(); }
    this.textarea.disabled = val == "nocursor";
    this.textarea.readOnly = !!val;
  };

  TextareaInput.prototype.setUneditable = function () {};

  TextareaInput.prototype.needsContentAttribute = false;

  function fromTextArea(textarea, options) {
    options = options ? copyObj(options) : {};
    options.value = textarea.value;
    if (!options.tabindex && textarea.tabIndex)
      { options.tabindex = textarea.tabIndex; }
    if (!options.placeholder && textarea.placeholder)
      { options.placeholder = textarea.placeholder; }
    // Set autofocus to true if this textarea is focused, or if it has
    // autofocus and no other element is focused.
    if (options.autofocus == null) {
      var hasFocus = activeElt();
      options.autofocus = hasFocus == textarea ||
        textarea.getAttribute("autofocus") != null && hasFocus == document.body;
    }

    function save() {textarea.value = cm.getValue();}

    var realSubmit;
    if (textarea.form) {
      on(textarea.form, "submit", save);
      // Deplorable hack to make the submit method do the right thing.
      if (!options.leaveSubmitMethodAlone) {
        var form = textarea.form;
        realSubmit = form.submit;
        try {
          var wrappedSubmit = form.submit = function () {
            save();
            form.submit = realSubmit;
            form.submit();
            form.submit = wrappedSubmit;
          };
        } catch(e) {}
      }
    }

    options.finishInit = function (cm) {
      cm.save = save;
      cm.getTextArea = function () { return textarea; };
      cm.toTextArea = function () {
        cm.toTextArea = isNaN; // Prevent this from being ran twice
        save();
        textarea.parentNode.removeChild(cm.getWrapperElement());
        textarea.style.display = "";
        if (textarea.form) {
          off(textarea.form, "submit", save);
          if (!options.leaveSubmitMethodAlone && typeof textarea.form.submit == "function")
            { textarea.form.submit = realSubmit; }
        }
      };
    };

    textarea.style.display = "none";
    var cm = CodeMirror(function (node) { return textarea.parentNode.insertBefore(node, textarea.nextSibling); },
      options);
    return cm
  }

  function addLegacyProps(CodeMirror) {
    CodeMirror.off = off;
    CodeMirror.on = on;
    CodeMirror.wheelEventPixels = wheelEventPixels;
    CodeMirror.Doc = Doc;
    CodeMirror.splitLines = splitLinesAuto;
    CodeMirror.countColumn = countColumn;
    CodeMirror.findColumn = findColumn;
    CodeMirror.isWordChar = isWordCharBasic;
    CodeMirror.Pass = Pass;
    CodeMirror.signal = signal;
    CodeMirror.Line = Line;
    CodeMirror.changeEnd = changeEnd;
    CodeMirror.scrollbarModel = scrollbarModel;
    CodeMirror.Pos = Pos;
    CodeMirror.cmpPos = cmp;
    CodeMirror.modes = modes;
    CodeMirror.mimeModes = mimeModes;
    CodeMirror.resolveMode = resolveMode;
    CodeMirror.getMode = getMode;
    CodeMirror.modeExtensions = modeExtensions;
    CodeMirror.extendMode = extendMode;
    CodeMirror.copyState = copyState;
    CodeMirror.startState = startState;
    CodeMirror.innerMode = innerMode;
    CodeMirror.commands = commands;
    CodeMirror.keyMap = keyMap;
    CodeMirror.keyName = keyName;
    CodeMirror.isModifierKey = isModifierKey;
    CodeMirror.lookupKey = lookupKey;
    CodeMirror.normalizeKeyMap = normalizeKeyMap;
    CodeMirror.StringStream = StringStream;
    CodeMirror.SharedTextMarker = SharedTextMarker;
    CodeMirror.TextMarker = TextMarker;
    CodeMirror.LineWidget = LineWidget;
    CodeMirror.e_preventDefault = e_preventDefault;
    CodeMirror.e_stopPropagation = e_stopPropagation;
    CodeMirror.e_stop = e_stop;
    CodeMirror.addClass = addClass;
    CodeMirror.contains = contains;
    CodeMirror.rmClass = rmClass;
    CodeMirror.keyNames = keyNames;
  }

  // EDITOR CONSTRUCTOR

  defineOptions(CodeMirror);

  addEditorMethods(CodeMirror);

  // Set up methods on CodeMirror's prototype to redirect to the editor's document.
  var dontDelegate = "iter insert remove copy getEditor constructor".split(" ");
  for (var prop in Doc.prototype) { if (Doc.prototype.hasOwnProperty(prop) && indexOf(dontDelegate, prop) < 0)
    { CodeMirror.prototype[prop] = (function(method) {
      return function() {return method.apply(this.doc, arguments)}
    })(Doc.prototype[prop]); } }

  eventMixin(Doc);
  CodeMirror.inputStyles = {"textarea": TextareaInput, "contenteditable": ContentEditableInput};

  // Extra arguments are stored as the mode's dependencies, which is
  // used by (legacy) mechanisms like loadmode.js to automatically
  // load a mode. (Preferred mechanism is the require/define calls.)
  CodeMirror.defineMode = function(name/*, mode, */) {
    if (!CodeMirror.defaults.mode && name != "null") { CodeMirror.defaults.mode = name; }
    defineMode.apply(this, arguments);
  };

  CodeMirror.defineMIME = defineMIME;

  // Minimal default mode.
  CodeMirror.defineMode("null", function () { return ({token: function (stream) { return stream.skipToEnd(); }}); });
  CodeMirror.defineMIME("text/plain", "null");

  // EXTENSIONS

  CodeMirror.defineExtension = function (name, func) {
    CodeMirror.prototype[name] = func;
  };
  CodeMirror.defineDocExtension = function (name, func) {
    Doc.prototype[name] = func;
  };

  CodeMirror.fromTextArea = fromTextArea;

  addLegacyProps(CodeMirror);

  CodeMirror.version = "5.65.4";

  return CodeMirror;

})));


/***/ }),

/***/ "./node_modules/codemirror/mode/python/python.js":
/*!*******************************************************!*\
  !*** ./node_modules/codemirror/mode/python/python.js ***!
  \*******************************************************/
/***/ ((__unused_webpack_module, __unused_webpack_exports, __webpack_require__) => {

// CodeMirror, copyright (c) by Marijn Haverbeke and others
// Distributed under an MIT license: https://codemirror.net/LICENSE

(function(mod) {
  if (true) // CommonJS
    mod(__webpack_require__(/*! ../../lib/codemirror */ "./node_modules/codemirror/lib/codemirror.js"));
  else {}
})(function(CodeMirror) {
  "use strict";

  function wordRegexp(words) {
    return new RegExp("^((" + words.join(")|(") + "))\\b");
  }

  var wordOperators = wordRegexp(["and", "or", "not", "is"]);
  var commonKeywords = ["as", "assert", "break", "class", "continue",
                        "def", "del", "elif", "else", "except", "finally",
                        "for", "from", "global", "if", "import",
                        "lambda", "pass", "raise", "return",
                        "try", "while", "with", "yield", "in"];
  var commonBuiltins = ["abs", "all", "any", "bin", "bool", "bytearray", "callable", "chr",
                        "classmethod", "compile", "complex", "delattr", "dict", "dir", "divmod",
                        "enumerate", "eval", "filter", "float", "format", "frozenset",
                        "getattr", "globals", "hasattr", "hash", "help", "hex", "id",
                        "input", "int", "isinstance", "issubclass", "iter", "len",
                        "list", "locals", "map", "max", "memoryview", "min", "next",
                        "object", "oct", "open", "ord", "pow", "property", "range",
                        "repr", "reversed", "round", "set", "setattr", "slice",
                        "sorted", "staticmethod", "str", "sum", "super", "tuple",
                        "type", "vars", "zip", "__import__", "NotImplemented",
                        "Ellipsis", "__debug__"];
  CodeMirror.registerHelper("hintWords", "python", commonKeywords.concat(commonBuiltins));

  function top(state) {
    return state.scopes[state.scopes.length - 1];
  }

  CodeMirror.defineMode("python", function(conf, parserConf) {
    var ERRORCLASS = "error";

    var delimiters = parserConf.delimiters || parserConf.singleDelimiters || /^[\(\)\[\]\{\}@,:`=;\.\\]/;
    //               (Backwards-compatibility with old, cumbersome config system)
    var operators = [parserConf.singleOperators, parserConf.doubleOperators, parserConf.doubleDelimiters, parserConf.tripleDelimiters,
                     parserConf.operators || /^([-+*/%\/&|^]=?|[<>=]+|\/\/=?|\*\*=?|!=|[~!@]|\.\.\.)/]
    for (var i = 0; i < operators.length; i++) if (!operators[i]) operators.splice(i--, 1)

    var hangingIndent = parserConf.hangingIndent || conf.indentUnit;

    var myKeywords = commonKeywords, myBuiltins = commonBuiltins;
    if (parserConf.extra_keywords != undefined)
      myKeywords = myKeywords.concat(parserConf.extra_keywords);

    if (parserConf.extra_builtins != undefined)
      myBuiltins = myBuiltins.concat(parserConf.extra_builtins);

    var py3 = !(parserConf.version && Number(parserConf.version) < 3)
    if (py3) {
      // since http://legacy.python.org/dev/peps/pep-0465/ @ is also an operator
      var identifiers = parserConf.identifiers|| /^[_A-Za-z\u00A1-\uFFFF][_A-Za-z0-9\u00A1-\uFFFF]*/;
      myKeywords = myKeywords.concat(["nonlocal", "False", "True", "None", "async", "await"]);
      myBuiltins = myBuiltins.concat(["ascii", "bytes", "exec", "print"]);
      var stringPrefixes = new RegExp("^(([rbuf]|(br)|(rb)|(fr)|(rf))?('{3}|\"{3}|['\"]))", "i");
    } else {
      var identifiers = parserConf.identifiers|| /^[_A-Za-z][_A-Za-z0-9]*/;
      myKeywords = myKeywords.concat(["exec", "print"]);
      myBuiltins = myBuiltins.concat(["apply", "basestring", "buffer", "cmp", "coerce", "execfile",
                                      "file", "intern", "long", "raw_input", "reduce", "reload",
                                      "unichr", "unicode", "xrange", "False", "True", "None"]);
      var stringPrefixes = new RegExp("^(([rubf]|(ur)|(br))?('{3}|\"{3}|['\"]))", "i");
    }
    var keywords = wordRegexp(myKeywords);
    var builtins = wordRegexp(myBuiltins);

    // tokenizers
    function tokenBase(stream, state) {
      var sol = stream.sol() && state.lastToken != "\\"
      if (sol) state.indent = stream.indentation()
      // Handle scope changes
      if (sol && top(state).type == "py") {
        var scopeOffset = top(state).offset;
        if (stream.eatSpace()) {
          var lineOffset = stream.indentation();
          if (lineOffset > scopeOffset)
            pushPyScope(state);
          else if (lineOffset < scopeOffset && dedent(stream, state) && stream.peek() != "#")
            state.errorToken = true;
          return null;
        } else {
          var style = tokenBaseInner(stream, state);
          if (scopeOffset > 0 && dedent(stream, state))
            style += " " + ERRORCLASS;
          return style;
        }
      }
      return tokenBaseInner(stream, state);
    }

    function tokenBaseInner(stream, state, inFormat) {
      if (stream.eatSpace()) return null;

      // Handle Comments
      if (!inFormat && stream.match(/^#.*/)) return "comment";

      // Handle Number Literals
      if (stream.match(/^[0-9\.]/, false)) {
        var floatLiteral = false;
        // Floats
        if (stream.match(/^[\d_]*\.\d+(e[\+\-]?\d+)?/i)) { floatLiteral = true; }
        if (stream.match(/^[\d_]+\.\d*/)) { floatLiteral = true; }
        if (stream.match(/^\.\d+/)) { floatLiteral = true; }
        if (floatLiteral) {
          // Float literals may be "imaginary"
          stream.eat(/J/i);
          return "number";
        }
        // Integers
        var intLiteral = false;
        // Hex
        if (stream.match(/^0x[0-9a-f_]+/i)) intLiteral = true;
        // Binary
        if (stream.match(/^0b[01_]+/i)) intLiteral = true;
        // Octal
        if (stream.match(/^0o[0-7_]+/i)) intLiteral = true;
        // Decimal
        if (stream.match(/^[1-9][\d_]*(e[\+\-]?[\d_]+)?/)) {
          // Decimal literals may be "imaginary"
          stream.eat(/J/i);
          // TODO - Can you have imaginary longs?
          intLiteral = true;
        }
        // Zero by itself with no other piece of number.
        if (stream.match(/^0(?![\dx])/i)) intLiteral = true;
        if (intLiteral) {
          // Integer literals may be "long"
          stream.eat(/L/i);
          return "number";
        }
      }

      // Handle Strings
      if (stream.match(stringPrefixes)) {
        var isFmtString = stream.current().toLowerCase().indexOf('f') !== -1;
        if (!isFmtString) {
          state.tokenize = tokenStringFactory(stream.current(), state.tokenize);
          return state.tokenize(stream, state);
        } else {
          state.tokenize = formatStringFactory(stream.current(), state.tokenize);
          return state.tokenize(stream, state);
        }
      }

      for (var i = 0; i < operators.length; i++)
        if (stream.match(operators[i])) return "operator"

      if (stream.match(delimiters)) return "punctuation";

      if (state.lastToken == "." && stream.match(identifiers))
        return "property";

      if (stream.match(keywords) || stream.match(wordOperators))
        return "keyword";

      if (stream.match(builtins))
        return "builtin";

      if (stream.match(/^(self|cls)\b/))
        return "variable-2";

      if (stream.match(identifiers)) {
        if (state.lastToken == "def" || state.lastToken == "class")
          return "def";
        return "variable";
      }

      // Handle non-detected items
      stream.next();
      return inFormat ? null :ERRORCLASS;
    }

    function formatStringFactory(delimiter, tokenOuter) {
      while ("rubf".indexOf(delimiter.charAt(0).toLowerCase()) >= 0)
        delimiter = delimiter.substr(1);

      var singleline = delimiter.length == 1;
      var OUTCLASS = "string";

      function tokenNestedExpr(depth) {
        return function(stream, state) {
          var inner = tokenBaseInner(stream, state, true)
          if (inner == "punctuation") {
            if (stream.current() == "{") {
              state.tokenize = tokenNestedExpr(depth + 1)
            } else if (stream.current() == "}") {
              if (depth > 1) state.tokenize = tokenNestedExpr(depth - 1)
              else state.tokenize = tokenString
            }
          }
          return inner
        }
      }

      function tokenString(stream, state) {
        while (!stream.eol()) {
          stream.eatWhile(/[^'"\{\}\\]/);
          if (stream.eat("\\")) {
            stream.next();
            if (singleline && stream.eol())
              return OUTCLASS;
          } else if (stream.match(delimiter)) {
            state.tokenize = tokenOuter;
            return OUTCLASS;
          } else if (stream.match('{{')) {
            // ignore {{ in f-str
            return OUTCLASS;
          } else if (stream.match('{', false)) {
            // switch to nested mode
            state.tokenize = tokenNestedExpr(0)
            if (stream.current()) return OUTCLASS;
            else return state.tokenize(stream, state)
          } else if (stream.match('}}')) {
            return OUTCLASS;
          } else if (stream.match('}')) {
            // single } in f-string is an error
            return ERRORCLASS;
          } else {
            stream.eat(/['"]/);
          }
        }
        if (singleline) {
          if (parserConf.singleLineStringErrors)
            return ERRORCLASS;
          else
            state.tokenize = tokenOuter;
        }
        return OUTCLASS;
      }
      tokenString.isString = true;
      return tokenString;
    }

    function tokenStringFactory(delimiter, tokenOuter) {
      while ("rubf".indexOf(delimiter.charAt(0).toLowerCase()) >= 0)
        delimiter = delimiter.substr(1);

      var singleline = delimiter.length == 1;
      var OUTCLASS = "string";

      function tokenString(stream, state) {
        while (!stream.eol()) {
          stream.eatWhile(/[^'"\\]/);
          if (stream.eat("\\")) {
            stream.next();
            if (singleline && stream.eol())
              return OUTCLASS;
          } else if (stream.match(delimiter)) {
            state.tokenize = tokenOuter;
            return OUTCLASS;
          } else {
            stream.eat(/['"]/);
          }
        }
        if (singleline) {
          if (parserConf.singleLineStringErrors)
            return ERRORCLASS;
          else
            state.tokenize = tokenOuter;
        }
        return OUTCLASS;
      }
      tokenString.isString = true;
      return tokenString;
    }

    function pushPyScope(state) {
      while (top(state).type != "py") state.scopes.pop()
      state.scopes.push({offset: top(state).offset + conf.indentUnit,
                         type: "py",
                         align: null})
    }

    function pushBracketScope(stream, state, type) {
      var align = stream.match(/^[\s\[\{\(]*(?:#|$)/, false) ? null : stream.column() + 1
      state.scopes.push({offset: state.indent + hangingIndent,
                         type: type,
                         align: align})
    }

    function dedent(stream, state) {
      var indented = stream.indentation();
      while (state.scopes.length > 1 && top(state).offset > indented) {
        if (top(state).type != "py") return true;
        state.scopes.pop();
      }
      return top(state).offset != indented;
    }

    function tokenLexer(stream, state) {
      if (stream.sol()) {
        state.beginningOfLine = true;
        state.dedent = false;
      }

      var style = state.tokenize(stream, state);
      var current = stream.current();

      // Handle decorators
      if (state.beginningOfLine && current == "@")
        return stream.match(identifiers, false) ? "meta" : py3 ? "operator" : ERRORCLASS;

      if (/\S/.test(current)) state.beginningOfLine = false;

      if ((style == "variable" || style == "builtin")
          && state.lastToken == "meta")
        style = "meta";

      // Handle scope changes.
      if (current == "pass" || current == "return")
        state.dedent = true;

      if (current == "lambda") state.lambda = true;
      if (current == ":" && !state.lambda && top(state).type == "py" && stream.match(/^\s*(?:#|$)/, false))
        pushPyScope(state);

      if (current.length == 1 && !/string|comment/.test(style)) {
        var delimiter_index = "[({".indexOf(current);
        if (delimiter_index != -1)
          pushBracketScope(stream, state, "])}".slice(delimiter_index, delimiter_index+1));

        delimiter_index = "])}".indexOf(current);
        if (delimiter_index != -1) {
          if (top(state).type == current) state.indent = state.scopes.pop().offset - hangingIndent
          else return ERRORCLASS;
        }
      }
      if (state.dedent && stream.eol() && top(state).type == "py" && state.scopes.length > 1)
        state.scopes.pop();

      return style;
    }

    var external = {
      startState: function(basecolumn) {
        return {
          tokenize: tokenBase,
          scopes: [{offset: basecolumn || 0, type: "py", align: null}],
          indent: basecolumn || 0,
          lastToken: null,
          lambda: false,
          dedent: 0
        };
      },

      token: function(stream, state) {
        var addErr = state.errorToken;
        if (addErr) state.errorToken = false;
        var style = tokenLexer(stream, state);

        if (style && style != "comment")
          state.lastToken = (style == "keyword" || style == "punctuation") ? stream.current() : style;
        if (style == "punctuation") style = null;

        if (stream.eol() && state.lambda)
          state.lambda = false;
        return addErr ? style + " " + ERRORCLASS : style;
      },

      indent: function(state, textAfter) {
        if (state.tokenize != tokenBase)
          return state.tokenize.isString ? CodeMirror.Pass : 0;

        var scope = top(state)
        var closing = scope.type == textAfter.charAt(0) ||
            scope.type == "py" && !state.dedent && /^(else:|elif |except |finally:)/.test(textAfter)
        if (scope.align != null)
          return scope.align - (closing ? 1 : 0)
        else
          return scope.offset - (closing ? hangingIndent : 0)
      },

      electricInput: /^\s*([\}\]\)]|else:|elif |except |finally:)$/,
      closeBrackets: {triples: "'\""},
      lineComment: "#",
      fold: "indent"
    };
    return external;
  });

  CodeMirror.defineMIME("text/x-python", "python");

  var words = function(str) { return str.split(" "); };

  CodeMirror.defineMIME("text/x-cython", {
    name: "python",
    extra_keywords: words("by cdef cimport cpdef ctypedef enum except "+
                          "extern gil include nogil property public "+
                          "readonly struct union DEF IF ELIF ELSE")
  });

});


/***/ }),

/***/ "./node_modules/css-loader/dist/cjs.js!./node_modules/codemirror/addon/hint/show-hint.css":
/*!************************************************************************************************!*\
  !*** ./node_modules/css-loader/dist/cjs.js!./node_modules/codemirror/addon/hint/show-hint.css ***!
  \************************************************************************************************/
/***/ ((module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _css_loader_dist_runtime_sourceMaps_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../../css-loader/dist/runtime/sourceMaps.js */ "./node_modules/css-loader/dist/runtime/sourceMaps.js");
/* harmony import */ var _css_loader_dist_runtime_sourceMaps_js__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(_css_loader_dist_runtime_sourceMaps_js__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var _css_loader_dist_runtime_api_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../../css-loader/dist/runtime/api.js */ "./node_modules/css-loader/dist/runtime/api.js");
/* harmony import */ var _css_loader_dist_runtime_api_js__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(_css_loader_dist_runtime_api_js__WEBPACK_IMPORTED_MODULE_1__);
// Imports


var ___CSS_LOADER_EXPORT___ = _css_loader_dist_runtime_api_js__WEBPACK_IMPORTED_MODULE_1___default()((_css_loader_dist_runtime_sourceMaps_js__WEBPACK_IMPORTED_MODULE_0___default()));
// Module
___CSS_LOADER_EXPORT___.push([module.id, ".CodeMirror-hints {\n  position: absolute;\n  z-index: 10;\n  overflow: hidden;\n  list-style: none;\n\n  margin: 0;\n  padding: 2px;\n\n  -webkit-box-shadow: 2px 3px 5px rgba(0,0,0,.2);\n  -moz-box-shadow: 2px 3px 5px rgba(0,0,0,.2);\n  box-shadow: 2px 3px 5px rgba(0,0,0,.2);\n  border-radius: 3px;\n  border: 1px solid silver;\n\n  background: white;\n  font-size: 90%;\n  font-family: monospace;\n\n  max-height: 20em;\n  overflow-y: auto;\n}\n\n.CodeMirror-hint {\n  margin: 0;\n  padding: 0 4px;\n  border-radius: 2px;\n  white-space: pre;\n  color: black;\n  cursor: pointer;\n}\n\nli.CodeMirror-hint-active {\n  background: #08f;\n  color: white;\n}\n", "",{"version":3,"sources":["webpack://./node_modules/codemirror/addon/hint/show-hint.css"],"names":[],"mappings":"AAAA;EACE,kBAAkB;EAClB,WAAW;EACX,gBAAgB;EAChB,gBAAgB;;EAEhB,SAAS;EACT,YAAY;;EAEZ,8CAA8C;EAC9C,2CAA2C;EAC3C,sCAAsC;EACtC,kBAAkB;EAClB,wBAAwB;;EAExB,iBAAiB;EACjB,cAAc;EACd,sBAAsB;;EAEtB,gBAAgB;EAChB,gBAAgB;AAClB;;AAEA;EACE,SAAS;EACT,cAAc;EACd,kBAAkB;EAClB,gBAAgB;EAChB,YAAY;EACZ,eAAe;AACjB;;AAEA;EACE,gBAAgB;EAChB,YAAY;AACd","sourcesContent":[".CodeMirror-hints {\n  position: absolute;\n  z-index: 10;\n  overflow: hidden;\n  list-style: none;\n\n  margin: 0;\n  padding: 2px;\n\n  -webkit-box-shadow: 2px 3px 5px rgba(0,0,0,.2);\n  -moz-box-shadow: 2px 3px 5px rgba(0,0,0,.2);\n  box-shadow: 2px 3px 5px rgba(0,0,0,.2);\n  border-radius: 3px;\n  border: 1px solid silver;\n\n  background: white;\n  font-size: 90%;\n  font-family: monospace;\n\n  max-height: 20em;\n  overflow-y: auto;\n}\n\n.CodeMirror-hint {\n  margin: 0;\n  padding: 0 4px;\n  border-radius: 2px;\n  white-space: pre;\n  color: black;\n  cursor: pointer;\n}\n\nli.CodeMirror-hint-active {\n  background: #08f;\n  color: white;\n}\n"],"sourceRoot":""}]);
// Exports
/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (___CSS_LOADER_EXPORT___);


/***/ }),

/***/ "./node_modules/css-loader/dist/cjs.js!./node_modules/codemirror/addon/lint/lint.css":
/*!*******************************************************************************************!*\
  !*** ./node_modules/css-loader/dist/cjs.js!./node_modules/codemirror/addon/lint/lint.css ***!
  \*******************************************************************************************/
/***/ ((module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _css_loader_dist_runtime_sourceMaps_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../../css-loader/dist/runtime/sourceMaps.js */ "./node_modules/css-loader/dist/runtime/sourceMaps.js");
/* harmony import */ var _css_loader_dist_runtime_sourceMaps_js__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(_css_loader_dist_runtime_sourceMaps_js__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var _css_loader_dist_runtime_api_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../../css-loader/dist/runtime/api.js */ "./node_modules/css-loader/dist/runtime/api.js");
/* harmony import */ var _css_loader_dist_runtime_api_js__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(_css_loader_dist_runtime_api_js__WEBPACK_IMPORTED_MODULE_1__);
/* harmony import */ var _css_loader_dist_runtime_getUrl_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../../../css-loader/dist/runtime/getUrl.js */ "./node_modules/css-loader/dist/runtime/getUrl.js");
/* harmony import */ var _css_loader_dist_runtime_getUrl_js__WEBPACK_IMPORTED_MODULE_2___default = /*#__PURE__*/__webpack_require__.n(_css_loader_dist_runtime_getUrl_js__WEBPACK_IMPORTED_MODULE_2__);
// Imports



var ___CSS_LOADER_URL_IMPORT_0___ = new URL(/* asset import */ __webpack_require__(/*! data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAQAAAADCAYAAAC09K7GAAAAAXNSR0IArs4c6QAAAAZiS0dEAP8A/wD/oL2nkwAAAAlwSFlzAAALEwAACxMBAJqcGAAAAAd0SU1FB9sJFhQXEbhTg7YAAAAZdEVYdENvbW1lbnQAQ3JlYXRlZCB3aXRoIEdJTVBXgQ4XAAAAMklEQVQI12NkgIIvJ3QXMjAwdDN+OaEbysDA4MPAwNDNwMCwiOHLCd1zX07o6kBVGQEAKBANtobskNMAAAAASUVORK5CYII= */ "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAQAAAADCAYAAAC09K7GAAAAAXNSR0IArs4c6QAAAAZiS0dEAP8A/wD/oL2nkwAAAAlwSFlzAAALEwAACxMBAJqcGAAAAAd0SU1FB9sJFhQXEbhTg7YAAAAZdEVYdENvbW1lbnQAQ3JlYXRlZCB3aXRoIEdJTVBXgQ4XAAAAMklEQVQI12NkgIIvJ3QXMjAwdDN+OaEbysDA4MPAwNDNwMCwiOHLCd1zX07o6kBVGQEAKBANtobskNMAAAAASUVORK5CYII="), __webpack_require__.b);
var ___CSS_LOADER_URL_IMPORT_1___ = new URL(/* asset import */ __webpack_require__(/*! data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAQAAAADCAYAAAC09K7GAAAAAXNSR0IArs4c6QAAAAZiS0dEAP8A/wD/oL2nkwAAAAlwSFlzAAALEwAACxMBAJqcGAAAAAd0SU1FB9sJDw4cOCW1/KIAAAAZdEVYdENvbW1lbnQAQ3JlYXRlZCB3aXRoIEdJTVBXgQ4XAAAAHElEQVQI12NggIL/DAz/GdA5/xkY/qPKMDAwAADLZwf5rvm+LQAAAABJRU5ErkJggg== */ "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAQAAAADCAYAAAC09K7GAAAAAXNSR0IArs4c6QAAAAZiS0dEAP8A/wD/oL2nkwAAAAlwSFlzAAALEwAACxMBAJqcGAAAAAd0SU1FB9sJDw4cOCW1/KIAAAAZdEVYdENvbW1lbnQAQ3JlYXRlZCB3aXRoIEdJTVBXgQ4XAAAAHElEQVQI12NggIL/DAz/GdA5/xkY/qPKMDAwAADLZwf5rvm+LQAAAABJRU5ErkJggg=="), __webpack_require__.b);
var ___CSS_LOADER_URL_IMPORT_2___ = new URL(/* asset import */ __webpack_require__(/*! data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABAAAAAQCAMAAAAoLQ9TAAAANlBMVEX/uwDvrwD/uwD/uwD/uwD/uwD/uwD/uwD/uwD6twD/uwAAAADurwD2tQD7uAD+ugAAAAD/uwDhmeTRAAAADHRSTlMJ8mN1EYcbmiixgACm7WbuAAAAVklEQVR42n3PUQqAIBBFUU1LLc3u/jdbOJoW1P08DA9Gba8+YWJ6gNJoNYIBzAA2chBth5kLmG9YUoG0NHAUwFXwO9LuBQL1giCQb8gC9Oro2vp5rncCIY8L8uEx5ZkAAAAASUVORK5CYII= */ "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABAAAAAQCAMAAAAoLQ9TAAAANlBMVEX/uwDvrwD/uwD/uwD/uwD/uwD/uwD/uwD/uwD6twD/uwAAAADurwD2tQD7uAD+ugAAAAD/uwDhmeTRAAAADHRSTlMJ8mN1EYcbmiixgACm7WbuAAAAVklEQVR42n3PUQqAIBBFUU1LLc3u/jdbOJoW1P08DA9Gba8+YWJ6gNJoNYIBzAA2chBth5kLmG9YUoG0NHAUwFXwO9LuBQL1giCQb8gC9Oro2vp5rncCIY8L8uEx5ZkAAAAASUVORK5CYII="), __webpack_require__.b);
var ___CSS_LOADER_URL_IMPORT_3___ = new URL(/* asset import */ __webpack_require__(/*! data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABAAAAAQCAMAAAAoLQ9TAAAAHlBMVEW7AAC7AACxAAC7AAC7AAAAAAC4AAC5AAD///+7AAAUdclpAAAABnRSTlMXnORSiwCK0ZKSAAAATUlEQVR42mWPOQ7AQAgDuQLx/z8csYRmPRIFIwRGnosRrpamvkKi0FTIiMASR3hhKW+hAN6/tIWhu9PDWiTGNEkTtIOucA5Oyr9ckPgAWm0GPBog6v4AAAAASUVORK5CYII= */ "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABAAAAAQCAMAAAAoLQ9TAAAAHlBMVEW7AAC7AACxAAC7AAC7AAAAAAC4AAC5AAD///+7AAAUdclpAAAABnRSTlMXnORSiwCK0ZKSAAAATUlEQVR42mWPOQ7AQAgDuQLx/z8csYRmPRIFIwRGnosRrpamvkKi0FTIiMASR3hhKW+hAN6/tIWhu9PDWiTGNEkTtIOucA5Oyr9ckPgAWm0GPBog6v4AAAAASUVORK5CYII="), __webpack_require__.b);
var ___CSS_LOADER_URL_IMPORT_4___ = new URL(/* asset import */ __webpack_require__(/*! data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAcAAAAHCAMAAADzjKfhAAAACVBMVEUAAAAAAAC/v7914kyHAAAAAXRSTlMAQObYZgAAACNJREFUeNo1ioEJAAAIwmz/H90iFFSGJgFMe3gaLZ0od+9/AQZ0ADosbYraAAAAAElFTkSuQmCC */ "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAcAAAAHCAMAAADzjKfhAAAACVBMVEUAAAAAAAC/v7914kyHAAAAAXRSTlMAQObYZgAAACNJREFUeNo1ioEJAAAIwmz/H90iFFSGJgFMe3gaLZ0od+9/AQZ0ADosbYraAAAAAElFTkSuQmCC"), __webpack_require__.b);
var ___CSS_LOADER_EXPORT___ = _css_loader_dist_runtime_api_js__WEBPACK_IMPORTED_MODULE_1___default()((_css_loader_dist_runtime_sourceMaps_js__WEBPACK_IMPORTED_MODULE_0___default()));
var ___CSS_LOADER_URL_REPLACEMENT_0___ = _css_loader_dist_runtime_getUrl_js__WEBPACK_IMPORTED_MODULE_2___default()(___CSS_LOADER_URL_IMPORT_0___);
var ___CSS_LOADER_URL_REPLACEMENT_1___ = _css_loader_dist_runtime_getUrl_js__WEBPACK_IMPORTED_MODULE_2___default()(___CSS_LOADER_URL_IMPORT_1___);
var ___CSS_LOADER_URL_REPLACEMENT_2___ = _css_loader_dist_runtime_getUrl_js__WEBPACK_IMPORTED_MODULE_2___default()(___CSS_LOADER_URL_IMPORT_2___);
var ___CSS_LOADER_URL_REPLACEMENT_3___ = _css_loader_dist_runtime_getUrl_js__WEBPACK_IMPORTED_MODULE_2___default()(___CSS_LOADER_URL_IMPORT_3___);
var ___CSS_LOADER_URL_REPLACEMENT_4___ = _css_loader_dist_runtime_getUrl_js__WEBPACK_IMPORTED_MODULE_2___default()(___CSS_LOADER_URL_IMPORT_4___);
// Module
___CSS_LOADER_EXPORT___.push([module.id, "/* The lint marker gutter */\n.CodeMirror-lint-markers {\n  width: 16px;\n}\n\n.CodeMirror-lint-tooltip {\n  background-color: #ffd;\n  border: 1px solid black;\n  border-radius: 4px 4px 4px 4px;\n  color: black;\n  font-family: monospace;\n  font-size: 10pt;\n  overflow: hidden;\n  padding: 2px 5px;\n  position: fixed;\n  white-space: pre;\n  white-space: pre-wrap;\n  z-index: 100;\n  max-width: 600px;\n  opacity: 0;\n  transition: opacity .4s;\n  -moz-transition: opacity .4s;\n  -webkit-transition: opacity .4s;\n  -o-transition: opacity .4s;\n  -ms-transition: opacity .4s;\n}\n\n.CodeMirror-lint-mark {\n  background-position: left bottom;\n  background-repeat: repeat-x;\n}\n\n.CodeMirror-lint-mark-warning {\n  background-image: url(" + ___CSS_LOADER_URL_REPLACEMENT_0___ + ");\n}\n\n.CodeMirror-lint-mark-error {\n  background-image: url(" + ___CSS_LOADER_URL_REPLACEMENT_1___ + ");\n}\n\n.CodeMirror-lint-marker {\n  background-position: center center;\n  background-repeat: no-repeat;\n  cursor: pointer;\n  display: inline-block;\n  height: 16px;\n  width: 16px;\n  vertical-align: middle;\n  position: relative;\n}\n\n.CodeMirror-lint-message {\n  padding-left: 18px;\n  background-position: top left;\n  background-repeat: no-repeat;\n}\n\n.CodeMirror-lint-marker-warning, .CodeMirror-lint-message-warning {\n  background-image: url(" + ___CSS_LOADER_URL_REPLACEMENT_2___ + ");\n}\n\n.CodeMirror-lint-marker-error, .CodeMirror-lint-message-error {\n  background-image: url(" + ___CSS_LOADER_URL_REPLACEMENT_3___ + ");\n}\n\n.CodeMirror-lint-marker-multiple {\n  background-image: url(" + ___CSS_LOADER_URL_REPLACEMENT_4___ + ");\n  background-repeat: no-repeat;\n  background-position: right bottom;\n  width: 100%; height: 100%;\n}\n\n.CodeMirror-lint-line-error {\n  background-color: rgba(183, 76, 81, 0.08);\n}\n\n.CodeMirror-lint-line-warning {\n  background-color: rgba(255, 211, 0, 0.1);\n}\n", "",{"version":3,"sources":["webpack://./node_modules/codemirror/addon/lint/lint.css"],"names":[],"mappings":"AAAA,2BAA2B;AAC3B;EACE,WAAW;AACb;;AAEA;EACE,sBAAsB;EACtB,uBAAuB;EACvB,8BAA8B;EAC9B,YAAY;EACZ,sBAAsB;EACtB,eAAe;EACf,gBAAgB;EAChB,gBAAgB;EAChB,eAAe;EACf,gBAAgB;EAChB,qBAAqB;EACrB,YAAY;EACZ,gBAAgB;EAChB,UAAU;EACV,uBAAuB;EACvB,4BAA4B;EAC5B,+BAA+B;EAC/B,0BAA0B;EAC1B,2BAA2B;AAC7B;;AAEA;EACE,gCAAgC;EAChC,2BAA2B;AAC7B;;AAEA;EACE,yDAA+U;AACjV;;AAEA;EACE,yDAAmT;AACrT;;AAEA;EACE,kCAAkC;EAClC,4BAA4B;EAC5B,eAAe;EACf,qBAAqB;EACrB,YAAY;EACZ,WAAW;EACX,sBAAsB;EACtB,kBAAkB;AACpB;;AAEA;EACE,kBAAkB;EAClB,6BAA6B;EAC7B,4BAA4B;AAC9B;;AAEA;EACE,yDAAuW;AACzW;;AAEA;EACE,yDAAmT;AACrT;;AAEA;EACE,yDAAuN;EACvN,4BAA4B;EAC5B,iCAAiC;EACjC,WAAW,EAAE,YAAY;AAC3B;;AAEA;EACE,yCAAyC;AAC3C;;AAEA;EACE,wCAAwC;AAC1C","sourcesContent":["/* The lint marker gutter */\n.CodeMirror-lint-markers {\n  width: 16px;\n}\n\n.CodeMirror-lint-tooltip {\n  background-color: #ffd;\n  border: 1px solid black;\n  border-radius: 4px 4px 4px 4px;\n  color: black;\n  font-family: monospace;\n  font-size: 10pt;\n  overflow: hidden;\n  padding: 2px 5px;\n  position: fixed;\n  white-space: pre;\n  white-space: pre-wrap;\n  z-index: 100;\n  max-width: 600px;\n  opacity: 0;\n  transition: opacity .4s;\n  -moz-transition: opacity .4s;\n  -webkit-transition: opacity .4s;\n  -o-transition: opacity .4s;\n  -ms-transition: opacity .4s;\n}\n\n.CodeMirror-lint-mark {\n  background-position: left bottom;\n  background-repeat: repeat-x;\n}\n\n.CodeMirror-lint-mark-warning {\n  background-image: url(\"data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAQAAAADCAYAAAC09K7GAAAAAXNSR0IArs4c6QAAAAZiS0dEAP8A/wD/oL2nkwAAAAlwSFlzAAALEwAACxMBAJqcGAAAAAd0SU1FB9sJFhQXEbhTg7YAAAAZdEVYdENvbW1lbnQAQ3JlYXRlZCB3aXRoIEdJTVBXgQ4XAAAAMklEQVQI12NkgIIvJ3QXMjAwdDN+OaEbysDA4MPAwNDNwMCwiOHLCd1zX07o6kBVGQEAKBANtobskNMAAAAASUVORK5CYII=\");\n}\n\n.CodeMirror-lint-mark-error {\n  background-image: url(\"data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAQAAAADCAYAAAC09K7GAAAAAXNSR0IArs4c6QAAAAZiS0dEAP8A/wD/oL2nkwAAAAlwSFlzAAALEwAACxMBAJqcGAAAAAd0SU1FB9sJDw4cOCW1/KIAAAAZdEVYdENvbW1lbnQAQ3JlYXRlZCB3aXRoIEdJTVBXgQ4XAAAAHElEQVQI12NggIL/DAz/GdA5/xkY/qPKMDAwAADLZwf5rvm+LQAAAABJRU5ErkJggg==\");\n}\n\n.CodeMirror-lint-marker {\n  background-position: center center;\n  background-repeat: no-repeat;\n  cursor: pointer;\n  display: inline-block;\n  height: 16px;\n  width: 16px;\n  vertical-align: middle;\n  position: relative;\n}\n\n.CodeMirror-lint-message {\n  padding-left: 18px;\n  background-position: top left;\n  background-repeat: no-repeat;\n}\n\n.CodeMirror-lint-marker-warning, .CodeMirror-lint-message-warning {\n  background-image: url(\"data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABAAAAAQCAMAAAAoLQ9TAAAANlBMVEX/uwDvrwD/uwD/uwD/uwD/uwD/uwD/uwD/uwD6twD/uwAAAADurwD2tQD7uAD+ugAAAAD/uwDhmeTRAAAADHRSTlMJ8mN1EYcbmiixgACm7WbuAAAAVklEQVR42n3PUQqAIBBFUU1LLc3u/jdbOJoW1P08DA9Gba8+YWJ6gNJoNYIBzAA2chBth5kLmG9YUoG0NHAUwFXwO9LuBQL1giCQb8gC9Oro2vp5rncCIY8L8uEx5ZkAAAAASUVORK5CYII=\");\n}\n\n.CodeMirror-lint-marker-error, .CodeMirror-lint-message-error {\n  background-image: url(\"data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABAAAAAQCAMAAAAoLQ9TAAAAHlBMVEW7AAC7AACxAAC7AAC7AAAAAAC4AAC5AAD///+7AAAUdclpAAAABnRSTlMXnORSiwCK0ZKSAAAATUlEQVR42mWPOQ7AQAgDuQLx/z8csYRmPRIFIwRGnosRrpamvkKi0FTIiMASR3hhKW+hAN6/tIWhu9PDWiTGNEkTtIOucA5Oyr9ckPgAWm0GPBog6v4AAAAASUVORK5CYII=\");\n}\n\n.CodeMirror-lint-marker-multiple {\n  background-image: url(\"data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAcAAAAHCAMAAADzjKfhAAAACVBMVEUAAAAAAAC/v7914kyHAAAAAXRSTlMAQObYZgAAACNJREFUeNo1ioEJAAAIwmz/H90iFFSGJgFMe3gaLZ0od+9/AQZ0ADosbYraAAAAAElFTkSuQmCC\");\n  background-repeat: no-repeat;\n  background-position: right bottom;\n  width: 100%; height: 100%;\n}\n\n.CodeMirror-lint-line-error {\n  background-color: rgba(183, 76, 81, 0.08);\n}\n\n.CodeMirror-lint-line-warning {\n  background-color: rgba(255, 211, 0, 0.1);\n}\n"],"sourceRoot":""}]);
// Exports
/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (___CSS_LOADER_EXPORT___);


/***/ }),

/***/ "./node_modules/css-loader/dist/cjs.js!./node_modules/codemirror/addon/scroll/simplescrollbars.css":
/*!*********************************************************************************************************!*\
  !*** ./node_modules/css-loader/dist/cjs.js!./node_modules/codemirror/addon/scroll/simplescrollbars.css ***!
  \*********************************************************************************************************/
/***/ ((module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _css_loader_dist_runtime_sourceMaps_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../../css-loader/dist/runtime/sourceMaps.js */ "./node_modules/css-loader/dist/runtime/sourceMaps.js");
/* harmony import */ var _css_loader_dist_runtime_sourceMaps_js__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(_css_loader_dist_runtime_sourceMaps_js__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var _css_loader_dist_runtime_api_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../../css-loader/dist/runtime/api.js */ "./node_modules/css-loader/dist/runtime/api.js");
/* harmony import */ var _css_loader_dist_runtime_api_js__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(_css_loader_dist_runtime_api_js__WEBPACK_IMPORTED_MODULE_1__);
// Imports


var ___CSS_LOADER_EXPORT___ = _css_loader_dist_runtime_api_js__WEBPACK_IMPORTED_MODULE_1___default()((_css_loader_dist_runtime_sourceMaps_js__WEBPACK_IMPORTED_MODULE_0___default()));
// Module
___CSS_LOADER_EXPORT___.push([module.id, ".CodeMirror-simplescroll-horizontal div, .CodeMirror-simplescroll-vertical div {\n  position: absolute;\n  background: #ccc;\n  -moz-box-sizing: border-box;\n  box-sizing: border-box;\n  border: 1px solid #bbb;\n  border-radius: 2px;\n}\n\n.CodeMirror-simplescroll-horizontal, .CodeMirror-simplescroll-vertical {\n  position: absolute;\n  z-index: 6;\n  background: #eee;\n}\n\n.CodeMirror-simplescroll-horizontal {\n  bottom: 0; left: 0;\n  height: 8px;\n}\n.CodeMirror-simplescroll-horizontal div {\n  bottom: 0;\n  height: 100%;\n}\n\n.CodeMirror-simplescroll-vertical {\n  right: 0; top: 0;\n  width: 8px;\n}\n.CodeMirror-simplescroll-vertical div {\n  right: 0;\n  width: 100%;\n}\n\n\n.CodeMirror-overlayscroll .CodeMirror-scrollbar-filler, .CodeMirror-overlayscroll .CodeMirror-gutter-filler {\n  display: none;\n}\n\n.CodeMirror-overlayscroll-horizontal div, .CodeMirror-overlayscroll-vertical div {\n  position: absolute;\n  background: #bcd;\n  border-radius: 3px;\n}\n\n.CodeMirror-overlayscroll-horizontal, .CodeMirror-overlayscroll-vertical {\n  position: absolute;\n  z-index: 6;\n}\n\n.CodeMirror-overlayscroll-horizontal {\n  bottom: 0; left: 0;\n  height: 6px;\n}\n.CodeMirror-overlayscroll-horizontal div {\n  bottom: 0;\n  height: 100%;\n}\n\n.CodeMirror-overlayscroll-vertical {\n  right: 0; top: 0;\n  width: 6px;\n}\n.CodeMirror-overlayscroll-vertical div {\n  right: 0;\n  width: 100%;\n}\n", "",{"version":3,"sources":["webpack://./node_modules/codemirror/addon/scroll/simplescrollbars.css"],"names":[],"mappings":"AAAA;EACE,kBAAkB;EAClB,gBAAgB;EAChB,2BAA2B;EAC3B,sBAAsB;EACtB,sBAAsB;EACtB,kBAAkB;AACpB;;AAEA;EACE,kBAAkB;EAClB,UAAU;EACV,gBAAgB;AAClB;;AAEA;EACE,SAAS,EAAE,OAAO;EAClB,WAAW;AACb;AACA;EACE,SAAS;EACT,YAAY;AACd;;AAEA;EACE,QAAQ,EAAE,MAAM;EAChB,UAAU;AACZ;AACA;EACE,QAAQ;EACR,WAAW;AACb;;;AAGA;EACE,aAAa;AACf;;AAEA;EACE,kBAAkB;EAClB,gBAAgB;EAChB,kBAAkB;AACpB;;AAEA;EACE,kBAAkB;EAClB,UAAU;AACZ;;AAEA;EACE,SAAS,EAAE,OAAO;EAClB,WAAW;AACb;AACA;EACE,SAAS;EACT,YAAY;AACd;;AAEA;EACE,QAAQ,EAAE,MAAM;EAChB,UAAU;AACZ;AACA;EACE,QAAQ;EACR,WAAW;AACb","sourcesContent":[".CodeMirror-simplescroll-horizontal div, .CodeMirror-simplescroll-vertical div {\n  position: absolute;\n  background: #ccc;\n  -moz-box-sizing: border-box;\n  box-sizing: border-box;\n  border: 1px solid #bbb;\n  border-radius: 2px;\n}\n\n.CodeMirror-simplescroll-horizontal, .CodeMirror-simplescroll-vertical {\n  position: absolute;\n  z-index: 6;\n  background: #eee;\n}\n\n.CodeMirror-simplescroll-horizontal {\n  bottom: 0; left: 0;\n  height: 8px;\n}\n.CodeMirror-simplescroll-horizontal div {\n  bottom: 0;\n  height: 100%;\n}\n\n.CodeMirror-simplescroll-vertical {\n  right: 0; top: 0;\n  width: 8px;\n}\n.CodeMirror-simplescroll-vertical div {\n  right: 0;\n  width: 100%;\n}\n\n\n.CodeMirror-overlayscroll .CodeMirror-scrollbar-filler, .CodeMirror-overlayscroll .CodeMirror-gutter-filler {\n  display: none;\n}\n\n.CodeMirror-overlayscroll-horizontal div, .CodeMirror-overlayscroll-vertical div {\n  position: absolute;\n  background: #bcd;\n  border-radius: 3px;\n}\n\n.CodeMirror-overlayscroll-horizontal, .CodeMirror-overlayscroll-vertical {\n  position: absolute;\n  z-index: 6;\n}\n\n.CodeMirror-overlayscroll-horizontal {\n  bottom: 0; left: 0;\n  height: 6px;\n}\n.CodeMirror-overlayscroll-horizontal div {\n  bottom: 0;\n  height: 100%;\n}\n\n.CodeMirror-overlayscroll-vertical {\n  right: 0; top: 0;\n  width: 6px;\n}\n.CodeMirror-overlayscroll-vertical div {\n  right: 0;\n  width: 100%;\n}\n"],"sourceRoot":""}]);
// Exports
/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (___CSS_LOADER_EXPORT___);


/***/ }),

/***/ "./node_modules/css-loader/dist/cjs.js!./node_modules/codemirror/lib/codemirror.css":
/*!******************************************************************************************!*\
  !*** ./node_modules/css-loader/dist/cjs.js!./node_modules/codemirror/lib/codemirror.css ***!
  \******************************************************************************************/
/***/ ((module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _css_loader_dist_runtime_sourceMaps_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../css-loader/dist/runtime/sourceMaps.js */ "./node_modules/css-loader/dist/runtime/sourceMaps.js");
/* harmony import */ var _css_loader_dist_runtime_sourceMaps_js__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(_css_loader_dist_runtime_sourceMaps_js__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var _css_loader_dist_runtime_api_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../css-loader/dist/runtime/api.js */ "./node_modules/css-loader/dist/runtime/api.js");
/* harmony import */ var _css_loader_dist_runtime_api_js__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(_css_loader_dist_runtime_api_js__WEBPACK_IMPORTED_MODULE_1__);
// Imports


var ___CSS_LOADER_EXPORT___ = _css_loader_dist_runtime_api_js__WEBPACK_IMPORTED_MODULE_1___default()((_css_loader_dist_runtime_sourceMaps_js__WEBPACK_IMPORTED_MODULE_0___default()));
// Module
___CSS_LOADER_EXPORT___.push([module.id, "/* BASICS */\n\n.CodeMirror {\n  /* Set height, width, borders, and global font properties here */\n  font-family: monospace;\n  height: 300px;\n  color: black;\n  direction: ltr;\n}\n\n/* PADDING */\n\n.CodeMirror-lines {\n  padding: 4px 0; /* Vertical padding around content */\n}\n.CodeMirror pre.CodeMirror-line,\n.CodeMirror pre.CodeMirror-line-like {\n  padding: 0 4px; /* Horizontal padding of content */\n}\n\n.CodeMirror-scrollbar-filler, .CodeMirror-gutter-filler {\n  background-color: white; /* The little square between H and V scrollbars */\n}\n\n/* GUTTER */\n\n.CodeMirror-gutters {\n  border-right: 1px solid #ddd;\n  background-color: #f7f7f7;\n  white-space: nowrap;\n}\n.CodeMirror-linenumbers {}\n.CodeMirror-linenumber {\n  padding: 0 3px 0 5px;\n  min-width: 20px;\n  text-align: right;\n  color: #999;\n  white-space: nowrap;\n}\n\n.CodeMirror-guttermarker { color: black; }\n.CodeMirror-guttermarker-subtle { color: #999; }\n\n/* CURSOR */\n\n.CodeMirror-cursor {\n  border-left: 1px solid black;\n  border-right: none;\n  width: 0;\n}\n/* Shown when moving in bi-directional text */\n.CodeMirror div.CodeMirror-secondarycursor {\n  border-left: 1px solid silver;\n}\n.cm-fat-cursor .CodeMirror-cursor {\n  width: auto;\n  border: 0 !important;\n  background: #7e7;\n}\n.cm-fat-cursor div.CodeMirror-cursors {\n  z-index: 1;\n}\n.cm-fat-cursor .CodeMirror-line::selection,\n.cm-fat-cursor .CodeMirror-line > span::selection, \n.cm-fat-cursor .CodeMirror-line > span > span::selection { background: transparent; }\n.cm-fat-cursor .CodeMirror-line::-moz-selection,\n.cm-fat-cursor .CodeMirror-line > span::-moz-selection,\n.cm-fat-cursor .CodeMirror-line > span > span::-moz-selection { background: transparent; }\n.cm-fat-cursor { caret-color: transparent; }\n@-moz-keyframes blink {\n  0% {}\n  50% { background-color: transparent; }\n  100% {}\n}\n@-webkit-keyframes blink {\n  0% {}\n  50% { background-color: transparent; }\n  100% {}\n}\n@keyframes blink {\n  0% {}\n  50% { background-color: transparent; }\n  100% {}\n}\n\n/* Can style cursor different in overwrite (non-insert) mode */\n.CodeMirror-overwrite .CodeMirror-cursor {}\n\n.cm-tab { display: inline-block; text-decoration: inherit; }\n\n.CodeMirror-rulers {\n  position: absolute;\n  left: 0; right: 0; top: -50px; bottom: 0;\n  overflow: hidden;\n}\n.CodeMirror-ruler {\n  border-left: 1px solid #ccc;\n  top: 0; bottom: 0;\n  position: absolute;\n}\n\n/* DEFAULT THEME */\n\n.cm-s-default .cm-header {color: blue;}\n.cm-s-default .cm-quote {color: #090;}\n.cm-negative {color: #d44;}\n.cm-positive {color: #292;}\n.cm-header, .cm-strong {font-weight: bold;}\n.cm-em {font-style: italic;}\n.cm-link {text-decoration: underline;}\n.cm-strikethrough {text-decoration: line-through;}\n\n.cm-s-default .cm-keyword {color: #708;}\n.cm-s-default .cm-atom {color: #219;}\n.cm-s-default .cm-number {color: #164;}\n.cm-s-default .cm-def {color: #00f;}\n.cm-s-default .cm-variable,\n.cm-s-default .cm-punctuation,\n.cm-s-default .cm-property,\n.cm-s-default .cm-operator {}\n.cm-s-default .cm-variable-2 {color: #05a;}\n.cm-s-default .cm-variable-3, .cm-s-default .cm-type {color: #085;}\n.cm-s-default .cm-comment {color: #a50;}\n.cm-s-default .cm-string {color: #a11;}\n.cm-s-default .cm-string-2 {color: #f50;}\n.cm-s-default .cm-meta {color: #555;}\n.cm-s-default .cm-qualifier {color: #555;}\n.cm-s-default .cm-builtin {color: #30a;}\n.cm-s-default .cm-bracket {color: #997;}\n.cm-s-default .cm-tag {color: #170;}\n.cm-s-default .cm-attribute {color: #00c;}\n.cm-s-default .cm-hr {color: #999;}\n.cm-s-default .cm-link {color: #00c;}\n\n.cm-s-default .cm-error {color: #f00;}\n.cm-invalidchar {color: #f00;}\n\n.CodeMirror-composing { border-bottom: 2px solid; }\n\n/* Default styles for common addons */\n\ndiv.CodeMirror span.CodeMirror-matchingbracket {color: #0b0;}\ndiv.CodeMirror span.CodeMirror-nonmatchingbracket {color: #a22;}\n.CodeMirror-matchingtag { background: rgba(255, 150, 0, .3); }\n.CodeMirror-activeline-background {background: #e8f2ff;}\n\n/* STOP */\n\n/* The rest of this file contains styles related to the mechanics of\n   the editor. You probably shouldn't touch them. */\n\n.CodeMirror {\n  position: relative;\n  overflow: hidden;\n  background: white;\n}\n\n.CodeMirror-scroll {\n  overflow: scroll !important; /* Things will break if this is overridden */\n  /* 50px is the magic margin used to hide the element's real scrollbars */\n  /* See overflow: hidden in .CodeMirror */\n  margin-bottom: -50px; margin-right: -50px;\n  padding-bottom: 50px;\n  height: 100%;\n  outline: none; /* Prevent dragging from highlighting the element */\n  position: relative;\n  z-index: 0;\n}\n.CodeMirror-sizer {\n  position: relative;\n  border-right: 50px solid transparent;\n}\n\n/* The fake, visible scrollbars. Used to force redraw during scrolling\n   before actual scrolling happens, thus preventing shaking and\n   flickering artifacts. */\n.CodeMirror-vscrollbar, .CodeMirror-hscrollbar, .CodeMirror-scrollbar-filler, .CodeMirror-gutter-filler {\n  position: absolute;\n  z-index: 6;\n  display: none;\n  outline: none;\n}\n.CodeMirror-vscrollbar {\n  right: 0; top: 0;\n  overflow-x: hidden;\n  overflow-y: scroll;\n}\n.CodeMirror-hscrollbar {\n  bottom: 0; left: 0;\n  overflow-y: hidden;\n  overflow-x: scroll;\n}\n.CodeMirror-scrollbar-filler {\n  right: 0; bottom: 0;\n}\n.CodeMirror-gutter-filler {\n  left: 0; bottom: 0;\n}\n\n.CodeMirror-gutters {\n  position: absolute; left: 0; top: 0;\n  min-height: 100%;\n  z-index: 3;\n}\n.CodeMirror-gutter {\n  white-space: normal;\n  height: 100%;\n  display: inline-block;\n  vertical-align: top;\n  margin-bottom: -50px;\n}\n.CodeMirror-gutter-wrapper {\n  position: absolute;\n  z-index: 4;\n  background: none !important;\n  border: none !important;\n}\n.CodeMirror-gutter-background {\n  position: absolute;\n  top: 0; bottom: 0;\n  z-index: 4;\n}\n.CodeMirror-gutter-elt {\n  position: absolute;\n  cursor: default;\n  z-index: 4;\n}\n.CodeMirror-gutter-wrapper ::selection { background-color: transparent }\n.CodeMirror-gutter-wrapper ::-moz-selection { background-color: transparent }\n\n.CodeMirror-lines {\n  cursor: text;\n  min-height: 1px; /* prevents collapsing before first draw */\n}\n.CodeMirror pre.CodeMirror-line,\n.CodeMirror pre.CodeMirror-line-like {\n  /* Reset some styles that the rest of the page might have set */\n  -moz-border-radius: 0; -webkit-border-radius: 0; border-radius: 0;\n  border-width: 0;\n  background: transparent;\n  font-family: inherit;\n  font-size: inherit;\n  margin: 0;\n  white-space: pre;\n  word-wrap: normal;\n  line-height: inherit;\n  color: inherit;\n  z-index: 2;\n  position: relative;\n  overflow: visible;\n  -webkit-tap-highlight-color: transparent;\n  -webkit-font-variant-ligatures: contextual;\n  font-variant-ligatures: contextual;\n}\n.CodeMirror-wrap pre.CodeMirror-line,\n.CodeMirror-wrap pre.CodeMirror-line-like {\n  word-wrap: break-word;\n  white-space: pre-wrap;\n  word-break: normal;\n}\n\n.CodeMirror-linebackground {\n  position: absolute;\n  left: 0; right: 0; top: 0; bottom: 0;\n  z-index: 0;\n}\n\n.CodeMirror-linewidget {\n  position: relative;\n  z-index: 2;\n  padding: 0.1px; /* Force widget margins to stay inside of the container */\n}\n\n.CodeMirror-widget {}\n\n.CodeMirror-rtl pre { direction: rtl; }\n\n.CodeMirror-code {\n  outline: none;\n}\n\n/* Force content-box sizing for the elements where we expect it */\n.CodeMirror-scroll,\n.CodeMirror-sizer,\n.CodeMirror-gutter,\n.CodeMirror-gutters,\n.CodeMirror-linenumber {\n  -moz-box-sizing: content-box;\n  box-sizing: content-box;\n}\n\n.CodeMirror-measure {\n  position: absolute;\n  width: 100%;\n  height: 0;\n  overflow: hidden;\n  visibility: hidden;\n}\n\n.CodeMirror-cursor {\n  position: absolute;\n  pointer-events: none;\n}\n.CodeMirror-measure pre { position: static; }\n\ndiv.CodeMirror-cursors {\n  visibility: hidden;\n  position: relative;\n  z-index: 3;\n}\ndiv.CodeMirror-dragcursors {\n  visibility: visible;\n}\n\n.CodeMirror-focused div.CodeMirror-cursors {\n  visibility: visible;\n}\n\n.CodeMirror-selected { background: #d9d9d9; }\n.CodeMirror-focused .CodeMirror-selected { background: #d7d4f0; }\n.CodeMirror-crosshair { cursor: crosshair; }\n.CodeMirror-line::selection, .CodeMirror-line > span::selection, .CodeMirror-line > span > span::selection { background: #d7d4f0; }\n.CodeMirror-line::-moz-selection, .CodeMirror-line > span::-moz-selection, .CodeMirror-line > span > span::-moz-selection { background: #d7d4f0; }\n\n.cm-searching {\n  background-color: #ffa;\n  background-color: rgba(255, 255, 0, .4);\n}\n\n/* Used to force a border model for a node */\n.cm-force-border { padding-right: .1px; }\n\n@media print {\n  /* Hide the cursor when printing */\n  .CodeMirror div.CodeMirror-cursors {\n    visibility: hidden;\n  }\n}\n\n/* See issue #2901 */\n.cm-tab-wrap-hack:after { content: ''; }\n\n/* Help users use markselection to safely style text background */\nspan.CodeMirror-selectedtext { background: none; }\n", "",{"version":3,"sources":["webpack://./node_modules/codemirror/lib/codemirror.css"],"names":[],"mappings":"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","sourcesContent":["/* BASICS */\n\n.CodeMirror {\n  /* Set height, width, borders, and global font properties here */\n  font-family: monospace;\n  height: 300px;\n  color: black;\n  direction: ltr;\n}\n\n/* PADDING */\n\n.CodeMirror-lines {\n  padding: 4px 0; /* Vertical padding around content */\n}\n.CodeMirror pre.CodeMirror-line,\n.CodeMirror pre.CodeMirror-line-like {\n  padding: 0 4px; /* Horizontal padding of content */\n}\n\n.CodeMirror-scrollbar-filler, .CodeMirror-gutter-filler {\n  background-color: white; /* The little square between H and V scrollbars */\n}\n\n/* GUTTER */\n\n.CodeMirror-gutters {\n  border-right: 1px solid #ddd;\n  background-color: #f7f7f7;\n  white-space: nowrap;\n}\n.CodeMirror-linenumbers {}\n.CodeMirror-linenumber {\n  padding: 0 3px 0 5px;\n  min-width: 20px;\n  text-align: right;\n  color: #999;\n  white-space: nowrap;\n}\n\n.CodeMirror-guttermarker { color: black; }\n.CodeMirror-guttermarker-subtle { color: #999; }\n\n/* CURSOR */\n\n.CodeMirror-cursor {\n  border-left: 1px solid black;\n  border-right: none;\n  width: 0;\n}\n/* Shown when moving in bi-directional text */\n.CodeMirror div.CodeMirror-secondarycursor {\n  border-left: 1px solid silver;\n}\n.cm-fat-cursor .CodeMirror-cursor {\n  width: auto;\n  border: 0 !important;\n  background: #7e7;\n}\n.cm-fat-cursor div.CodeMirror-cursors {\n  z-index: 1;\n}\n.cm-fat-cursor .CodeMirror-line::selection,\n.cm-fat-cursor .CodeMirror-line > span::selection, \n.cm-fat-cursor .CodeMirror-line > span > span::selection { background: transparent; }\n.cm-fat-cursor .CodeMirror-line::-moz-selection,\n.cm-fat-cursor .CodeMirror-line > span::-moz-selection,\n.cm-fat-cursor .CodeMirror-line > span > span::-moz-selection { background: transparent; }\n.cm-fat-cursor { caret-color: transparent; }\n@-moz-keyframes blink {\n  0% {}\n  50% { background-color: transparent; }\n  100% {}\n}\n@-webkit-keyframes blink {\n  0% {}\n  50% { background-color: transparent; }\n  100% {}\n}\n@keyframes blink {\n  0% {}\n  50% { background-color: transparent; }\n  100% {}\n}\n\n/* Can style cursor different in overwrite (non-insert) mode */\n.CodeMirror-overwrite .CodeMirror-cursor {}\n\n.cm-tab { display: inline-block; text-decoration: inherit; }\n\n.CodeMirror-rulers {\n  position: absolute;\n  left: 0; right: 0; top: -50px; bottom: 0;\n  overflow: hidden;\n}\n.CodeMirror-ruler {\n  border-left: 1px solid #ccc;\n  top: 0; bottom: 0;\n  position: absolute;\n}\n\n/* DEFAULT THEME */\n\n.cm-s-default .cm-header {color: blue;}\n.cm-s-default .cm-quote {color: #090;}\n.cm-negative {color: #d44;}\n.cm-positive {color: #292;}\n.cm-header, .cm-strong {font-weight: bold;}\n.cm-em {font-style: italic;}\n.cm-link {text-decoration: underline;}\n.cm-strikethrough {text-decoration: line-through;}\n\n.cm-s-default .cm-keyword {color: #708;}\n.cm-s-default .cm-atom {color: #219;}\n.cm-s-default .cm-number {color: #164;}\n.cm-s-default .cm-def {color: #00f;}\n.cm-s-default .cm-variable,\n.cm-s-default .cm-punctuation,\n.cm-s-default .cm-property,\n.cm-s-default .cm-operator {}\n.cm-s-default .cm-variable-2 {color: #05a;}\n.cm-s-default .cm-variable-3, .cm-s-default .cm-type {color: #085;}\n.cm-s-default .cm-comment {color: #a50;}\n.cm-s-default .cm-string {color: #a11;}\n.cm-s-default .cm-string-2 {color: #f50;}\n.cm-s-default .cm-meta {color: #555;}\n.cm-s-default .cm-qualifier {color: #555;}\n.cm-s-default .cm-builtin {color: #30a;}\n.cm-s-default .cm-bracket {color: #997;}\n.cm-s-default .cm-tag {color: #170;}\n.cm-s-default .cm-attribute {color: #00c;}\n.cm-s-default .cm-hr {color: #999;}\n.cm-s-default .cm-link {color: #00c;}\n\n.cm-s-default .cm-error {color: #f00;}\n.cm-invalidchar {color: #f00;}\n\n.CodeMirror-composing { border-bottom: 2px solid; }\n\n/* Default styles for common addons */\n\ndiv.CodeMirror span.CodeMirror-matchingbracket {color: #0b0;}\ndiv.CodeMirror span.CodeMirror-nonmatchingbracket {color: #a22;}\n.CodeMirror-matchingtag { background: rgba(255, 150, 0, .3); }\n.CodeMirror-activeline-background {background: #e8f2ff;}\n\n/* STOP */\n\n/* The rest of this file contains styles related to the mechanics of\n   the editor. You probably shouldn't touch them. */\n\n.CodeMirror {\n  position: relative;\n  overflow: hidden;\n  background: white;\n}\n\n.CodeMirror-scroll {\n  overflow: scroll !important; /* Things will break if this is overridden */\n  /* 50px is the magic margin used to hide the element's real scrollbars */\n  /* See overflow: hidden in .CodeMirror */\n  margin-bottom: -50px; margin-right: -50px;\n  padding-bottom: 50px;\n  height: 100%;\n  outline: none; /* Prevent dragging from highlighting the element */\n  position: relative;\n  z-index: 0;\n}\n.CodeMirror-sizer {\n  position: relative;\n  border-right: 50px solid transparent;\n}\n\n/* The fake, visible scrollbars. Used to force redraw during scrolling\n   before actual scrolling happens, thus preventing shaking and\n   flickering artifacts. */\n.CodeMirror-vscrollbar, .CodeMirror-hscrollbar, .CodeMirror-scrollbar-filler, .CodeMirror-gutter-filler {\n  position: absolute;\n  z-index: 6;\n  display: none;\n  outline: none;\n}\n.CodeMirror-vscrollbar {\n  right: 0; top: 0;\n  overflow-x: hidden;\n  overflow-y: scroll;\n}\n.CodeMirror-hscrollbar {\n  bottom: 0; left: 0;\n  overflow-y: hidden;\n  overflow-x: scroll;\n}\n.CodeMirror-scrollbar-filler {\n  right: 0; bottom: 0;\n}\n.CodeMirror-gutter-filler {\n  left: 0; bottom: 0;\n}\n\n.CodeMirror-gutters {\n  position: absolute; left: 0; top: 0;\n  min-height: 100%;\n  z-index: 3;\n}\n.CodeMirror-gutter {\n  white-space: normal;\n  height: 100%;\n  display: inline-block;\n  vertical-align: top;\n  margin-bottom: -50px;\n}\n.CodeMirror-gutter-wrapper {\n  position: absolute;\n  z-index: 4;\n  background: none !important;\n  border: none !important;\n}\n.CodeMirror-gutter-background {\n  position: absolute;\n  top: 0; bottom: 0;\n  z-index: 4;\n}\n.CodeMirror-gutter-elt {\n  position: absolute;\n  cursor: default;\n  z-index: 4;\n}\n.CodeMirror-gutter-wrapper ::selection { background-color: transparent }\n.CodeMirror-gutter-wrapper ::-moz-selection { background-color: transparent }\n\n.CodeMirror-lines {\n  cursor: text;\n  min-height: 1px; /* prevents collapsing before first draw */\n}\n.CodeMirror pre.CodeMirror-line,\n.CodeMirror pre.CodeMirror-line-like {\n  /* Reset some styles that the rest of the page might have set */\n  -moz-border-radius: 0; -webkit-border-radius: 0; border-radius: 0;\n  border-width: 0;\n  background: transparent;\n  font-family: inherit;\n  font-size: inherit;\n  margin: 0;\n  white-space: pre;\n  word-wrap: normal;\n  line-height: inherit;\n  color: inherit;\n  z-index: 2;\n  position: relative;\n  overflow: visible;\n  -webkit-tap-highlight-color: transparent;\n  -webkit-font-variant-ligatures: contextual;\n  font-variant-ligatures: contextual;\n}\n.CodeMirror-wrap pre.CodeMirror-line,\n.CodeMirror-wrap pre.CodeMirror-line-like {\n  word-wrap: break-word;\n  white-space: pre-wrap;\n  word-break: normal;\n}\n\n.CodeMirror-linebackground {\n  position: absolute;\n  left: 0; right: 0; top: 0; bottom: 0;\n  z-index: 0;\n}\n\n.CodeMirror-linewidget {\n  position: relative;\n  z-index: 2;\n  padding: 0.1px; /* Force widget margins to stay inside of the container */\n}\n\n.CodeMirror-widget {}\n\n.CodeMirror-rtl pre { direction: rtl; }\n\n.CodeMirror-code {\n  outline: none;\n}\n\n/* Force content-box sizing for the elements where we expect it */\n.CodeMirror-scroll,\n.CodeMirror-sizer,\n.CodeMirror-gutter,\n.CodeMirror-gutters,\n.CodeMirror-linenumber {\n  -moz-box-sizing: content-box;\n  box-sizing: content-box;\n}\n\n.CodeMirror-measure {\n  position: absolute;\n  width: 100%;\n  height: 0;\n  overflow: hidden;\n  visibility: hidden;\n}\n\n.CodeMirror-cursor {\n  position: absolute;\n  pointer-events: none;\n}\n.CodeMirror-measure pre { position: static; }\n\ndiv.CodeMirror-cursors {\n  visibility: hidden;\n  position: relative;\n  z-index: 3;\n}\ndiv.CodeMirror-dragcursors {\n  visibility: visible;\n}\n\n.CodeMirror-focused div.CodeMirror-cursors {\n  visibility: visible;\n}\n\n.CodeMirror-selected { background: #d9d9d9; }\n.CodeMirror-focused .CodeMirror-selected { background: #d7d4f0; }\n.CodeMirror-crosshair { cursor: crosshair; }\n.CodeMirror-line::selection, .CodeMirror-line > span::selection, .CodeMirror-line > span > span::selection { background: #d7d4f0; }\n.CodeMirror-line::-moz-selection, .CodeMirror-line > span::-moz-selection, .CodeMirror-line > span > span::-moz-selection { background: #d7d4f0; }\n\n.cm-searching {\n  background-color: #ffa;\n  background-color: rgba(255, 255, 0, .4);\n}\n\n/* Used to force a border model for a node */\n.cm-force-border { padding-right: .1px; }\n\n@media print {\n  /* Hide the cursor when printing */\n  .CodeMirror div.CodeMirror-cursors {\n    visibility: hidden;\n  }\n}\n\n/* See issue #2901 */\n.cm-tab-wrap-hack:after { content: ''; }\n\n/* Help users use markselection to safely style text background */\nspan.CodeMirror-selectedtext { background: none; }\n"],"sourceRoot":""}]);
// Exports
/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (___CSS_LOADER_EXPORT___);


/***/ }),

/***/ "./node_modules/css-loader/dist/cjs.js!./node_modules/sass-loader/dist/cjs.js!./style.scss":
/*!*************************************************************************************************!*\
  !*** ./node_modules/css-loader/dist/cjs.js!./node_modules/sass-loader/dist/cjs.js!./style.scss ***!
  \*************************************************************************************************/
/***/ ((module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _node_modules_css_loader_dist_runtime_sourceMaps_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./node_modules/css-loader/dist/runtime/sourceMaps.js */ "./node_modules/css-loader/dist/runtime/sourceMaps.js");
/* harmony import */ var _node_modules_css_loader_dist_runtime_sourceMaps_js__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(_node_modules_css_loader_dist_runtime_sourceMaps_js__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var _node_modules_css_loader_dist_runtime_api_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./node_modules/css-loader/dist/runtime/api.js */ "./node_modules/css-loader/dist/runtime/api.js");
/* harmony import */ var _node_modules_css_loader_dist_runtime_api_js__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(_node_modules_css_loader_dist_runtime_api_js__WEBPACK_IMPORTED_MODULE_1__);
/* harmony import */ var _node_modules_css_loader_dist_cjs_js_node_modules_codemirror_lib_codemirror_css__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! -!./node_modules/css-loader/dist/cjs.js!./node_modules/codemirror/lib/codemirror.css */ "./node_modules/css-loader/dist/cjs.js!./node_modules/codemirror/lib/codemirror.css");
/* harmony import */ var _node_modules_css_loader_dist_cjs_js_node_modules_codemirror_addon_hint_show_hint_css__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! -!./node_modules/css-loader/dist/cjs.js!./node_modules/codemirror/addon/hint/show-hint.css */ "./node_modules/css-loader/dist/cjs.js!./node_modules/codemirror/addon/hint/show-hint.css");
/* harmony import */ var _node_modules_css_loader_dist_cjs_js_node_modules_codemirror_addon_lint_lint_css__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! -!./node_modules/css-loader/dist/cjs.js!./node_modules/codemirror/addon/lint/lint.css */ "./node_modules/css-loader/dist/cjs.js!./node_modules/codemirror/addon/lint/lint.css");
/* harmony import */ var _node_modules_css_loader_dist_cjs_js_node_modules_codemirror_addon_scroll_simplescrollbars_css__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! -!./node_modules/css-loader/dist/cjs.js!./node_modules/codemirror/addon/scroll/simplescrollbars.css */ "./node_modules/css-loader/dist/cjs.js!./node_modules/codemirror/addon/scroll/simplescrollbars.css");
// Imports






var ___CSS_LOADER_EXPORT___ = _node_modules_css_loader_dist_runtime_api_js__WEBPACK_IMPORTED_MODULE_1___default()((_node_modules_css_loader_dist_runtime_sourceMaps_js__WEBPACK_IMPORTED_MODULE_0___default()));
___CSS_LOADER_EXPORT___.i(_node_modules_css_loader_dist_cjs_js_node_modules_codemirror_lib_codemirror_css__WEBPACK_IMPORTED_MODULE_2__["default"]);
___CSS_LOADER_EXPORT___.i(_node_modules_css_loader_dist_cjs_js_node_modules_codemirror_addon_hint_show_hint_css__WEBPACK_IMPORTED_MODULE_3__["default"]);
___CSS_LOADER_EXPORT___.i(_node_modules_css_loader_dist_cjs_js_node_modules_codemirror_addon_lint_lint_css__WEBPACK_IMPORTED_MODULE_4__["default"]);
___CSS_LOADER_EXPORT___.i(_node_modules_css_loader_dist_cjs_js_node_modules_codemirror_addon_scroll_simplescrollbars_css__WEBPACK_IMPORTED_MODULE_5__["default"]);
// Module
___CSS_LOADER_EXPORT___.push([module.id, "* {\n  box-sizing: border-box;\n}\n\n.editor {\n  float: left;\n  width: 50%;\n  margin: 0;\n  padding: 2%;\n  height: 100%;\n  background-color: gainsboro;\n  border: gainsboro;\n  border-radius: 10px;\n}\n.editor .shortcut {\n  color: gray;\n  font-size: 14px;\n  display: inline;\n  margin: 0 5px;\n}\n.editor .line-error {\n  background: #fbc2c4 !important;\n  color: #8a1f11 !important;\n}\n.editor .error-marker {\n  color: black;\n  width: 10px !important;\n  background-color: #ff0000;\n}\n.editor .error-marker .error-message {\n  display: none;\n  position: absolute;\n  background-color: #ddd;\n  border: 1px solid #999;\n  padding: 6px;\n  width: 140px;\n  left: 15px;\n  top: -1em;\n}\n.editor .error-marker:hover .error-message {\n  display: block;\n}\n\n.save_load {\n  width: 100%;\n  height: 100%;\n  float: left;\n}", "",{"version":3,"sources":["webpack://./style.scss"],"names":[],"mappings":"AAKA;EACE,sBAAA;AAAF;;AAGA;EACE,WAAA;EACA,UAAA;EACA,SAAA;EACA,WAAA;EACA,YAAA;EACA,2BAAA;EACA,iBAAA;EACA,mBAAA;AAAF;AACE;EACE,WAAA;EACA,eAAA;EACA,eAAA;EACA,aAAA;AACJ;AACE;EACE,8BAAA;EACA,yBAAA;AACJ;AACE;EACE,YAAA;EACA,sBAAA;EACA,yBAAA;AACJ;AAGI;EACE,aAAA;EACA,kBAAA;EACA,sBAAA;EACA,sBAAA;EACA,YAAA;EACA,YAAA;EACA,UAAA;EACA,SAAA;AADN;AAMI;EACE,cAAA;AAJN;;AAQA;EACE,WAAA;EACA,YAAA;EACA,WAAA;AALF","sourcesContent":["@import \"node_modules/codemirror/lib/codemirror.css\";\n@import \"node_modules/codemirror/addon/hint/show-hint.css\";\n@import \"node_modules/codemirror/addon/lint/lint.css\";\n@import \"node_modules/codemirror/addon/scroll/simplescrollbars.css\";\n\n* {\n  box-sizing: border-box;\n}\n\n.editor {\n  float: left;\n  width: 50%;\n  margin: 0;\n  padding: 2%;\n  height: 100%;\n  background-color: gainsboro;\n  border: gainsboro;\n  border-radius: 10px;\n  .shortcut{\n    color: gray ;\n    font-size: 14px ;\n    display: inline;\n    margin: 0 5px;\n  }\n  .line-error {\n    background: #fbc2c4 !important;\n    color: #8a1f11 !important;\n  }\n  .error-marker {\n    color: black;\n    width: 10px !important;\n    background-color: #ff0000;\n  }\n\n  .error-marker {\n    .error-message {\n      display: none;\n      position: absolute;\n      background-color: #ddd;\n      border: 1px solid #999;\n      padding: 6px;\n      width: 140px;\n      left: 15px;\n      top: -1em;\n    }\n  }\n\n  .error-marker:hover {\n    .error-message {\n      display: block;\n    }\n  }\n}\n.save_load {\n  width: 100%;\n  height: 100%;\n  float: left;\n}"],"sourceRoot":""}]);
// Exports
/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (___CSS_LOADER_EXPORT___);


/***/ }),

/***/ "./node_modules/css-loader/dist/runtime/api.js":
/*!*****************************************************!*\
  !*** ./node_modules/css-loader/dist/runtime/api.js ***!
  \*****************************************************/
/***/ ((module) => {

"use strict";


/*
  MIT License http://www.opensource.org/licenses/mit-license.php
  Author Tobias Koppers @sokra
*/
module.exports = function (cssWithMappingToString) {
  var list = []; // return the list of modules as css string

  list.toString = function toString() {
    return this.map(function (item) {
      var content = "";
      var needLayer = typeof item[5] !== "undefined";

      if (item[4]) {
        content += "@supports (".concat(item[4], ") {");
      }

      if (item[2]) {
        content += "@media ".concat(item[2], " {");
      }

      if (needLayer) {
        content += "@layer".concat(item[5].length > 0 ? " ".concat(item[5]) : "", " {");
      }

      content += cssWithMappingToString(item);

      if (needLayer) {
        content += "}";
      }

      if (item[2]) {
        content += "}";
      }

      if (item[4]) {
        content += "}";
      }

      return content;
    }).join("");
  }; // import a list of modules into the list


  list.i = function i(modules, media, dedupe, supports, layer) {
    if (typeof modules === "string") {
      modules = [[null, modules, undefined]];
    }

    var alreadyImportedModules = {};

    if (dedupe) {
      for (var k = 0; k < this.length; k++) {
        var id = this[k][0];

        if (id != null) {
          alreadyImportedModules[id] = true;
        }
      }
    }

    for (var _k = 0; _k < modules.length; _k++) {
      var item = [].concat(modules[_k]);

      if (dedupe && alreadyImportedModules[item[0]]) {
        continue;
      }

      if (typeof layer !== "undefined") {
        if (typeof item[5] === "undefined") {
          item[5] = layer;
        } else {
          item[1] = "@layer".concat(item[5].length > 0 ? " ".concat(item[5]) : "", " {").concat(item[1], "}");
          item[5] = layer;
        }
      }

      if (media) {
        if (!item[2]) {
          item[2] = media;
        } else {
          item[1] = "@media ".concat(item[2], " {").concat(item[1], "}");
          item[2] = media;
        }
      }

      if (supports) {
        if (!item[4]) {
          item[4] = "".concat(supports);
        } else {
          item[1] = "@supports (".concat(item[4], ") {").concat(item[1], "}");
          item[4] = supports;
        }
      }

      list.push(item);
    }
  };

  return list;
};

/***/ }),

/***/ "./node_modules/css-loader/dist/runtime/getUrl.js":
/*!********************************************************!*\
  !*** ./node_modules/css-loader/dist/runtime/getUrl.js ***!
  \********************************************************/
/***/ ((module) => {

"use strict";


module.exports = function (url, options) {
  if (!options) {
    options = {};
  }

  if (!url) {
    return url;
  }

  url = String(url.__esModule ? url.default : url); // If url is already wrapped in quotes, remove them

  if (/^['"].*['"]$/.test(url)) {
    url = url.slice(1, -1);
  }

  if (options.hash) {
    url += options.hash;
  } // Should url be wrapped?
  // See https://drafts.csswg.org/css-values-3/#urls


  if (/["'() \t\n]|(%20)/.test(url) || options.needQuotes) {
    return "\"".concat(url.replace(/"/g, '\\"').replace(/\n/g, "\\n"), "\"");
  }

  return url;
};

/***/ }),

/***/ "./node_modules/css-loader/dist/runtime/sourceMaps.js":
/*!************************************************************!*\
  !*** ./node_modules/css-loader/dist/runtime/sourceMaps.js ***!
  \************************************************************/
/***/ ((module) => {

"use strict";


module.exports = function (item) {
  var content = item[1];
  var cssMapping = item[3];

  if (!cssMapping) {
    return content;
  }

  if (typeof btoa === "function") {
    var base64 = btoa(unescape(encodeURIComponent(JSON.stringify(cssMapping))));
    var data = "sourceMappingURL=data:application/json;charset=utf-8;base64,".concat(base64);
    var sourceMapping = "/*# ".concat(data, " */");
    var sourceURLs = cssMapping.sources.map(function (source) {
      return "/*# sourceURL=".concat(cssMapping.sourceRoot || "").concat(source, " */");
    });
    return [content].concat(sourceURLs).concat([sourceMapping]).join("\n");
  }

  return [content].join("\n");
};

/***/ }),

/***/ "./node_modules/file-saver/dist/FileSaver.min.js":
/*!*******************************************************!*\
  !*** ./node_modules/file-saver/dist/FileSaver.min.js ***!
  \*******************************************************/
/***/ (function(module, exports, __webpack_require__) {

var __WEBPACK_AMD_DEFINE_FACTORY__, __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;(function(a,b){if(true)!(__WEBPACK_AMD_DEFINE_ARRAY__ = [], __WEBPACK_AMD_DEFINE_FACTORY__ = (b),
		__WEBPACK_AMD_DEFINE_RESULT__ = (typeof __WEBPACK_AMD_DEFINE_FACTORY__ === 'function' ?
		(__WEBPACK_AMD_DEFINE_FACTORY__.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__)) : __WEBPACK_AMD_DEFINE_FACTORY__),
		__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));else {}})(this,function(){"use strict";function b(a,b){return"undefined"==typeof b?b={autoBom:!1}:"object"!=typeof b&&(console.warn("Deprecated: Expected third argument to be a object"),b={autoBom:!b}),b.autoBom&&/^\s*(?:text\/\S*|application\/xml|\S*\/\S*\+xml)\s*;.*charset\s*=\s*utf-8/i.test(a.type)?new Blob(["\uFEFF",a],{type:a.type}):a}function c(a,b,c){var d=new XMLHttpRequest;d.open("GET",a),d.responseType="blob",d.onload=function(){g(d.response,b,c)},d.onerror=function(){console.error("could not download file")},d.send()}function d(a){var b=new XMLHttpRequest;b.open("HEAD",a,!1);try{b.send()}catch(a){}return 200<=b.status&&299>=b.status}function e(a){try{a.dispatchEvent(new MouseEvent("click"))}catch(c){var b=document.createEvent("MouseEvents");b.initMouseEvent("click",!0,!0,window,0,0,0,80,20,!1,!1,!1,!1,0,null),a.dispatchEvent(b)}}var f="object"==typeof window&&window.window===window?window:"object"==typeof self&&self.self===self?self:"object"==typeof __webpack_require__.g&&__webpack_require__.g.global===__webpack_require__.g?__webpack_require__.g:void 0,a=f.navigator&&/Macintosh/.test(navigator.userAgent)&&/AppleWebKit/.test(navigator.userAgent)&&!/Safari/.test(navigator.userAgent),g=f.saveAs||("object"!=typeof window||window!==f?function(){}:"download"in HTMLAnchorElement.prototype&&!a?function(b,g,h){var i=f.URL||f.webkitURL,j=document.createElement("a");g=g||b.name||"download",j.download=g,j.rel="noopener","string"==typeof b?(j.href=b,j.origin===location.origin?e(j):d(j.href)?c(b,g,h):e(j,j.target="_blank")):(j.href=i.createObjectURL(b),setTimeout(function(){i.revokeObjectURL(j.href)},4E4),setTimeout(function(){e(j)},0))}:"msSaveOrOpenBlob"in navigator?function(f,g,h){if(g=g||f.name||"download","string"!=typeof f)navigator.msSaveOrOpenBlob(b(f,h),g);else if(d(f))c(f,g,h);else{var i=document.createElement("a");i.href=f,i.target="_blank",setTimeout(function(){e(i)})}}:function(b,d,e,g){if(g=g||open("","_blank"),g&&(g.document.title=g.document.body.innerText="downloading..."),"string"==typeof b)return c(b,d,e);var h="application/octet-stream"===b.type,i=/constructor/i.test(f.HTMLElement)||f.safari,j=/CriOS\/[\d]+/.test(navigator.userAgent);if((j||h&&i||a)&&"undefined"!=typeof FileReader){var k=new FileReader;k.onloadend=function(){var a=k.result;a=j?a:a.replace(/^data:[^;]*;/,"data:attachment/file;"),g?g.location.href=a:location=a,g=null},k.readAsDataURL(b)}else{var l=f.URL||f.webkitURL,m=l.createObjectURL(b);g?g.location=m:location.href=m,g=null,setTimeout(function(){l.revokeObjectURL(m)},4E4)}});f.saveAs=g.saveAs=g, true&&(module.exports=g)});

//# sourceMappingURL=FileSaver.min.js.map

/***/ }),

/***/ "./style.scss":
/*!********************!*\
  !*** ./style.scss ***!
  \********************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _node_modules_style_loader_dist_runtime_injectStylesIntoStyleTag_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! !./node_modules/style-loader/dist/runtime/injectStylesIntoStyleTag.js */ "./node_modules/style-loader/dist/runtime/injectStylesIntoStyleTag.js");
/* harmony import */ var _node_modules_style_loader_dist_runtime_injectStylesIntoStyleTag_js__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(_node_modules_style_loader_dist_runtime_injectStylesIntoStyleTag_js__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var _node_modules_style_loader_dist_runtime_styleDomAPI_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! !./node_modules/style-loader/dist/runtime/styleDomAPI.js */ "./node_modules/style-loader/dist/runtime/styleDomAPI.js");
/* harmony import */ var _node_modules_style_loader_dist_runtime_styleDomAPI_js__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(_node_modules_style_loader_dist_runtime_styleDomAPI_js__WEBPACK_IMPORTED_MODULE_1__);
/* harmony import */ var _node_modules_style_loader_dist_runtime_insertBySelector_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! !./node_modules/style-loader/dist/runtime/insertBySelector.js */ "./node_modules/style-loader/dist/runtime/insertBySelector.js");
/* harmony import */ var _node_modules_style_loader_dist_runtime_insertBySelector_js__WEBPACK_IMPORTED_MODULE_2___default = /*#__PURE__*/__webpack_require__.n(_node_modules_style_loader_dist_runtime_insertBySelector_js__WEBPACK_IMPORTED_MODULE_2__);
/* harmony import */ var _node_modules_style_loader_dist_runtime_setAttributesWithoutAttributes_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! !./node_modules/style-loader/dist/runtime/setAttributesWithoutAttributes.js */ "./node_modules/style-loader/dist/runtime/setAttributesWithoutAttributes.js");
/* harmony import */ var _node_modules_style_loader_dist_runtime_setAttributesWithoutAttributes_js__WEBPACK_IMPORTED_MODULE_3___default = /*#__PURE__*/__webpack_require__.n(_node_modules_style_loader_dist_runtime_setAttributesWithoutAttributes_js__WEBPACK_IMPORTED_MODULE_3__);
/* harmony import */ var _node_modules_style_loader_dist_runtime_insertStyleElement_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! !./node_modules/style-loader/dist/runtime/insertStyleElement.js */ "./node_modules/style-loader/dist/runtime/insertStyleElement.js");
/* harmony import */ var _node_modules_style_loader_dist_runtime_insertStyleElement_js__WEBPACK_IMPORTED_MODULE_4___default = /*#__PURE__*/__webpack_require__.n(_node_modules_style_loader_dist_runtime_insertStyleElement_js__WEBPACK_IMPORTED_MODULE_4__);
/* harmony import */ var _node_modules_style_loader_dist_runtime_styleTagTransform_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! !./node_modules/style-loader/dist/runtime/styleTagTransform.js */ "./node_modules/style-loader/dist/runtime/styleTagTransform.js");
/* harmony import */ var _node_modules_style_loader_dist_runtime_styleTagTransform_js__WEBPACK_IMPORTED_MODULE_5___default = /*#__PURE__*/__webpack_require__.n(_node_modules_style_loader_dist_runtime_styleTagTransform_js__WEBPACK_IMPORTED_MODULE_5__);
/* harmony import */ var _node_modules_css_loader_dist_cjs_js_node_modules_sass_loader_dist_cjs_js_style_scss__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! !!./node_modules/css-loader/dist/cjs.js!./node_modules/sass-loader/dist/cjs.js!./style.scss */ "./node_modules/css-loader/dist/cjs.js!./node_modules/sass-loader/dist/cjs.js!./style.scss");

      
      
      
      
      
      
      
      
      

var options = {};

options.styleTagTransform = (_node_modules_style_loader_dist_runtime_styleTagTransform_js__WEBPACK_IMPORTED_MODULE_5___default());
options.setAttributes = (_node_modules_style_loader_dist_runtime_setAttributesWithoutAttributes_js__WEBPACK_IMPORTED_MODULE_3___default());

      options.insert = _node_modules_style_loader_dist_runtime_insertBySelector_js__WEBPACK_IMPORTED_MODULE_2___default().bind(null, "head");
    
options.domAPI = (_node_modules_style_loader_dist_runtime_styleDomAPI_js__WEBPACK_IMPORTED_MODULE_1___default());
options.insertStyleElement = (_node_modules_style_loader_dist_runtime_insertStyleElement_js__WEBPACK_IMPORTED_MODULE_4___default());

var update = _node_modules_style_loader_dist_runtime_injectStylesIntoStyleTag_js__WEBPACK_IMPORTED_MODULE_0___default()(_node_modules_css_loader_dist_cjs_js_node_modules_sass_loader_dist_cjs_js_style_scss__WEBPACK_IMPORTED_MODULE_6__["default"], options);




       /* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (_node_modules_css_loader_dist_cjs_js_node_modules_sass_loader_dist_cjs_js_style_scss__WEBPACK_IMPORTED_MODULE_6__["default"] && _node_modules_css_loader_dist_cjs_js_node_modules_sass_loader_dist_cjs_js_style_scss__WEBPACK_IMPORTED_MODULE_6__["default"].locals ? _node_modules_css_loader_dist_cjs_js_node_modules_sass_loader_dist_cjs_js_style_scss__WEBPACK_IMPORTED_MODULE_6__["default"].locals : undefined);


/***/ }),

/***/ "./node_modules/style-loader/dist/runtime/injectStylesIntoStyleTag.js":
/*!****************************************************************************!*\
  !*** ./node_modules/style-loader/dist/runtime/injectStylesIntoStyleTag.js ***!
  \****************************************************************************/
/***/ ((module) => {

"use strict";


var stylesInDOM = [];

function getIndexByIdentifier(identifier) {
  var result = -1;

  for (var i = 0; i < stylesInDOM.length; i++) {
    if (stylesInDOM[i].identifier === identifier) {
      result = i;
      break;
    }
  }

  return result;
}

function modulesToDom(list, options) {
  var idCountMap = {};
  var identifiers = [];

  for (var i = 0; i < list.length; i++) {
    var item = list[i];
    var id = options.base ? item[0] + options.base : item[0];
    var count = idCountMap[id] || 0;
    var identifier = "".concat(id, " ").concat(count);
    idCountMap[id] = count + 1;
    var indexByIdentifier = getIndexByIdentifier(identifier);
    var obj = {
      css: item[1],
      media: item[2],
      sourceMap: item[3],
      supports: item[4],
      layer: item[5]
    };

    if (indexByIdentifier !== -1) {
      stylesInDOM[indexByIdentifier].references++;
      stylesInDOM[indexByIdentifier].updater(obj);
    } else {
      var updater = addElementStyle(obj, options);
      options.byIndex = i;
      stylesInDOM.splice(i, 0, {
        identifier: identifier,
        updater: updater,
        references: 1
      });
    }

    identifiers.push(identifier);
  }

  return identifiers;
}

function addElementStyle(obj, options) {
  var api = options.domAPI(options);
  api.update(obj);

  var updater = function updater(newObj) {
    if (newObj) {
      if (newObj.css === obj.css && newObj.media === obj.media && newObj.sourceMap === obj.sourceMap && newObj.supports === obj.supports && newObj.layer === obj.layer) {
        return;
      }

      api.update(obj = newObj);
    } else {
      api.remove();
    }
  };

  return updater;
}

module.exports = function (list, options) {
  options = options || {};
  list = list || [];
  var lastIdentifiers = modulesToDom(list, options);
  return function update(newList) {
    newList = newList || [];

    for (var i = 0; i < lastIdentifiers.length; i++) {
      var identifier = lastIdentifiers[i];
      var index = getIndexByIdentifier(identifier);
      stylesInDOM[index].references--;
    }

    var newLastIdentifiers = modulesToDom(newList, options);

    for (var _i = 0; _i < lastIdentifiers.length; _i++) {
      var _identifier = lastIdentifiers[_i];

      var _index = getIndexByIdentifier(_identifier);

      if (stylesInDOM[_index].references === 0) {
        stylesInDOM[_index].updater();

        stylesInDOM.splice(_index, 1);
      }
    }

    lastIdentifiers = newLastIdentifiers;
  };
};

/***/ }),

/***/ "./node_modules/style-loader/dist/runtime/insertBySelector.js":
/*!********************************************************************!*\
  !*** ./node_modules/style-loader/dist/runtime/insertBySelector.js ***!
  \********************************************************************/
/***/ ((module) => {

"use strict";


var memo = {};
/* istanbul ignore next  */

function getTarget(target) {
  if (typeof memo[target] === "undefined") {
    var styleTarget = document.querySelector(target); // Special case to return head of iframe instead of iframe itself

    if (window.HTMLIFrameElement && styleTarget instanceof window.HTMLIFrameElement) {
      try {
        // This will throw an exception if access to iframe is blocked
        // due to cross-origin restrictions
        styleTarget = styleTarget.contentDocument.head;
      } catch (e) {
        // istanbul ignore next
        styleTarget = null;
      }
    }

    memo[target] = styleTarget;
  }

  return memo[target];
}
/* istanbul ignore next  */


function insertBySelector(insert, style) {
  var target = getTarget(insert);

  if (!target) {
    throw new Error("Couldn't find a style target. This probably means that the value for the 'insert' parameter is invalid.");
  }

  target.appendChild(style);
}

module.exports = insertBySelector;

/***/ }),

/***/ "./node_modules/style-loader/dist/runtime/insertStyleElement.js":
/*!**********************************************************************!*\
  !*** ./node_modules/style-loader/dist/runtime/insertStyleElement.js ***!
  \**********************************************************************/
/***/ ((module) => {

"use strict";


/* istanbul ignore next  */
function insertStyleElement(options) {
  var element = document.createElement("style");
  options.setAttributes(element, options.attributes);
  options.insert(element, options.options);
  return element;
}

module.exports = insertStyleElement;

/***/ }),

/***/ "./node_modules/style-loader/dist/runtime/setAttributesWithoutAttributes.js":
/*!**********************************************************************************!*\
  !*** ./node_modules/style-loader/dist/runtime/setAttributesWithoutAttributes.js ***!
  \**********************************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


/* istanbul ignore next  */
function setAttributesWithoutAttributes(styleElement) {
  var nonce =  true ? __webpack_require__.nc : 0;

  if (nonce) {
    styleElement.setAttribute("nonce", nonce);
  }
}

module.exports = setAttributesWithoutAttributes;

/***/ }),

/***/ "./node_modules/style-loader/dist/runtime/styleDomAPI.js":
/*!***************************************************************!*\
  !*** ./node_modules/style-loader/dist/runtime/styleDomAPI.js ***!
  \***************************************************************/
/***/ ((module) => {

"use strict";


/* istanbul ignore next  */
function apply(styleElement, options, obj) {
  var css = "";

  if (obj.supports) {
    css += "@supports (".concat(obj.supports, ") {");
  }

  if (obj.media) {
    css += "@media ".concat(obj.media, " {");
  }

  var needLayer = typeof obj.layer !== "undefined";

  if (needLayer) {
    css += "@layer".concat(obj.layer.length > 0 ? " ".concat(obj.layer) : "", " {");
  }

  css += obj.css;

  if (needLayer) {
    css += "}";
  }

  if (obj.media) {
    css += "}";
  }

  if (obj.supports) {
    css += "}";
  }

  var sourceMap = obj.sourceMap;

  if (sourceMap && typeof btoa !== "undefined") {
    css += "\n/*# sourceMappingURL=data:application/json;base64,".concat(btoa(unescape(encodeURIComponent(JSON.stringify(sourceMap)))), " */");
  } // For old IE

  /* istanbul ignore if  */


  options.styleTagTransform(css, styleElement, options.options);
}

function removeStyleElement(styleElement) {
  // istanbul ignore if
  if (styleElement.parentNode === null) {
    return false;
  }

  styleElement.parentNode.removeChild(styleElement);
}
/* istanbul ignore next  */


function domAPI(options) {
  var styleElement = options.insertStyleElement(options);
  return {
    update: function update(obj) {
      apply(styleElement, options, obj);
    },
    remove: function remove() {
      removeStyleElement(styleElement);
    }
  };
}

module.exports = domAPI;

/***/ }),

/***/ "./node_modules/style-loader/dist/runtime/styleTagTransform.js":
/*!*********************************************************************!*\
  !*** ./node_modules/style-loader/dist/runtime/styleTagTransform.js ***!
  \*********************************************************************/
/***/ ((module) => {

"use strict";


/* istanbul ignore next  */
function styleTagTransform(css, styleElement) {
  if (styleElement.styleSheet) {
    styleElement.styleSheet.cssText = css;
  } else {
    while (styleElement.firstChild) {
      styleElement.removeChild(styleElement.firstChild);
    }

    styleElement.appendChild(document.createTextNode(css));
  }
}

module.exports = styleTagTransform;

/***/ }),

/***/ "./ast.ts":
/*!****************!*\
  !*** ./ast.ts ***!
  \****************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";

// import { TypeCheckError } from "./type-check";
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.stringifyOp = exports.UniOp = exports.BinOp = void 0;
// TODO: should we split up arithmetic ops from bool ops?
var BinOp;
(function (BinOp) {
    BinOp[BinOp["Plus"] = 0] = "Plus";
    BinOp[BinOp["Minus"] = 1] = "Minus";
    BinOp[BinOp["Mul"] = 2] = "Mul";
    BinOp[BinOp["IDiv"] = 3] = "IDiv";
    BinOp[BinOp["Mod"] = 4] = "Mod";
    BinOp[BinOp["Eq"] = 5] = "Eq";
    BinOp[BinOp["Neq"] = 6] = "Neq";
    BinOp[BinOp["Lte"] = 7] = "Lte";
    BinOp[BinOp["Gte"] = 8] = "Gte";
    BinOp[BinOp["Lt"] = 9] = "Lt";
    BinOp[BinOp["Gt"] = 10] = "Gt";
    BinOp[BinOp["Is"] = 11] = "Is";
    BinOp[BinOp["And"] = 12] = "And";
    BinOp[BinOp["Or"] = 13] = "Or";
})(BinOp = exports.BinOp || (exports.BinOp = {}));
;
var UniOp;
(function (UniOp) {
    UniOp[UniOp["Neg"] = 0] = "Neg";
    UniOp[UniOp["Not"] = 1] = "Not";
})(UniOp = exports.UniOp || (exports.UniOp = {}));
;
function stringifyOp(op) {
    switch (op) {
        case BinOp.Plus: return "+";
        case BinOp.Minus: return "-";
        case BinOp.Mul: return "*";
        case BinOp.IDiv: return "//";
        case BinOp.Mod: return "%";
        case BinOp.Eq: return "==";
        case BinOp.Neq: return "!=";
        case BinOp.Lte: return "<=";
        case BinOp.Gte: return ">=";
        case BinOp.Lt: return "<";
        case BinOp.Gt: return ">";
        case BinOp.Is: return "is";
        case BinOp.And: return "and";
        case BinOp.Or: return "or";
        case UniOp.Neg: return "-";
        case UniOp.Not: return "not";
        default: throw new Error("undefined op");
    }
}
exports.stringifyOp = stringifyOp;


/***/ }),

/***/ "./autocomplete.ts":
/*!*************************!*\
  !*** ./autocomplete.ts ***!
  \*************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.autocompleteHint = void 0;
const codemirror_1 = __importDefault(__webpack_require__(/*! codemirror */ "./node_modules/codemirror/lib/codemirror.js"));
function autocompleteHint(editor, keywords, getToken) {
    // Find the token at the cursor
    var currPos = editor.getCursor();
    var token = getToken(editor, currPos), tprop = token;
    var isClassMethod = false;
    if (token.string[token.string.length - 1] === ".") {
        isClassMethod = true;
        token = tprop = {
            start: currPos.ch,
            end: currPos.ch,
            string: "",
            state: token.state,
            type: "property",
        };
    }
    else if (token.type == "property") {
        isClassMethod = true;
    }
    //ignore any non word or property token
    else if (!/^[\w$_]*$/.test(token.string)) {
        token = tprop = {
            start: currPos.ch,
            end: currPos.ch,
            string: "",
            state: token.state,
            className: token.string == ":" ? "python-type" : null,
        };
    }
    if (!context || isClassMethod) {
        var context = [];
        context.push(tprop);
        var completionList = getCompletions(keywords, token, context);
        completionList = completionList.sort();
        //show dropdown with one word (restrict automatic autocomplete of single word)
        if (completionList.length == 1) {
            completionList.push(" ");
        }
    }
    return {
        list: completionList,
        from: codemirror_1.default.Pos(currPos.line, token.start),
        to: codemirror_1.default.Pos(currPos.line, token.end),
    };
}
exports.autocompleteHint = autocompleteHint;
function getCompletions(wordList, token, context) {
    var completions = [];
    var prefix = token.string;
    if (context) {
        // If this is a property, see if it belongs to some object we can
        // find in the current environment.
        var obj = context.pop(), base;
        const hasCompleteList = ["variable", "property", "builtin", "keyword"];
        if (hasCompleteList.indexOf(obj.type) !== -1) {
            base = obj.string;
        }
        while (base != null && context.length) {
            base = base[context.pop().string];
        }
        if (base != null) {
            completions = gatherCompletions(wordList, prefix);
        }
    }
    return completions;
}
function gatherCompletions(wordList, prefix) {
    var completions = [];
    for (var i = 0; i < wordList.length; i++) {
        var str = wordList[i];
        //only add word if not already in array and prefix matches word
        if (str.indexOf(prefix) == 0 && !strExists(completions, str)) {
            completions.push(str);
        }
    }
    return completions;
}
function strExists(arr, item) {
    for (var i = 0; i < arr.length; i++) {
        if (arr[i] == item) {
            return true;
        }
    }
    return false;
}


/***/ }),

/***/ "./compiler.ts":
/*!*********************!*\
  !*** ./compiler.ts ***!
  \*********************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.compile = exports.makeLocals = exports.emptyEnv = void 0;
const ast_1 = __webpack_require__(/*! ./ast */ "./ast.ts");
const utils_1 = __webpack_require__(/*! ./utils */ "./utils.ts");
exports.emptyEnv = {
    globals: new Map(),
    classes: new Map(),
    classIndices: new Map(),
    functionNames: new Map(),
    locals: new Set(),
    labels: [],
    offset: 0,
    vtableMethods: []
};
function makeLocals(locals) {
    const localDefines = [];
    locals.forEach(v => {
        localDefines.push(`(local $${v} i32)`);
    });
    return localDefines;
}
exports.makeLocals = makeLocals;
function compile(ast, env) {
    const withDefines = env;
    const definedVars = new Set(); //getLocals(ast);
    definedVars.add("$last");
    definedVars.add("$selector");
    definedVars.add("$scratch"); // for memory allocation
    definedVars.forEach(env.locals.add, env.locals);
    const localDefines = makeLocals(definedVars);
    const globalNames = ast.inits.map(init => init.name);
    const funs = [];
    ast.funs.forEach(f => {
        funs.push(codeGenDef(f, withDefines).join("\n"));
    });
    const classes = ast.classes.map(cls => codeGenClass(cls, withDefines)).flat();
    const allFuns = funs.concat(classes).join("\n\n");
    // const stmts = ast.filter((stmt) => stmt.tag !== "fun");
    const inits = ast.inits.map(init => codeGenInit(init, withDefines)).flat();
    withDefines.labels = ast.body.map(block => block.label);
    var bodyCommands = "(local.set $$selector (i32.const 0))\n";
    bodyCommands += "(loop $loop\n";
    var blockCommands = "(local.get $$selector)\n";
    blockCommands += `(br_table ${ast.body.map(block => block.label).join(" ")})`;
    ast.body.forEach(block => {
        blockCommands = `(block ${block.label}
              ${blockCommands}    
            ) ;; end ${block.label}
            ${block.stmts.map(stmt => codeGenStmt(stmt, withDefines).join('\n')).join('\n')}
            `;
    });
    bodyCommands += blockCommands;
    bodyCommands += ") ;; end $loop";
    // const commandGroups = ast.stmts.map((stmt) => codeGenStmt(stmt, withDefines));
    const allCommands = [...localDefines, ...inits, bodyCommands];
    withDefines.locals.clear();
    ast.inits.forEach(x => withDefines.globals.set(x.name, true));
    return {
        globals: globalNames,
        functions: allFuns,
        mainSource: allCommands.join("\n"),
        newEnv: withDefines
    };
}
exports.compile = compile;
function codeGenStmt(stmt, env) {
    switch (stmt.tag) {
        case "store":
            return [
                ...codeGenValue(stmt.start, env),
                ...codeGenValue(stmt.offset, env),
                ...codeGenValue(stmt.value, env),
                `call $store`
            ];
        case "assign":
            var valStmts = codeGenExpr(stmt.value, env);
            if (env.locals.has(stmt.name)) {
                return valStmts.concat([`(local.set $${stmt.name})`]);
            }
            else {
                return valStmts.concat([`(global.set $${stmt.name})`]);
            }
        case "return":
            var valStmts = codeGenValue(stmt.value, env);
            valStmts.push("return");
            return valStmts;
        case "expr":
            var exprStmts = codeGenExpr(stmt.expr, env);
            return exprStmts.concat([`(local.set $$last)`]);
        case "pass":
            return [];
        case "ifjmp":
            const thnIdx = env.labels.findIndex(e => e === stmt.thn);
            const elsIdx = env.labels.findIndex(e => e === stmt.els);
            return [...codeGenValue(stmt.cond, env),
                `(if 
          (then
            (local.set $$selector (i32.const ${thnIdx}))
            (br $loop)
          ) 
          (else 
            (local.set $$selector (i32.const ${elsIdx}))
            (br $loop)
          )
         )`];
        case "jmp":
            const lblIdx = env.labels.findIndex(e => e === stmt.lbl);
            return [`(local.set $$selector (i32.const ${lblIdx}))`, `(br $loop)`];
    }
}
function codeGenExpr(expr, env) {
    switch (expr.tag) {
        case "value":
            return codeGenValue(expr.value, env);
        case "binop":
            const lhsStmts = codeGenValue(expr.left, env);
            const rhsStmts = codeGenValue(expr.right, env);
            return [...lhsStmts, ...rhsStmts, codeGenBinOp(expr.op)];
        case "uniop":
            const exprStmts = codeGenValue(expr.expr, env);
            switch (expr.op) {
                case ast_1.UniOp.Neg:
                    // negate bignum length to indicate sign change
                    return [
                        ...exprStmts,
                        `(local.set $$scratch)`,
                        `(local.get $$scratch)`,
                        `(i32.const 0)`,
                        `(i32.const 0)`,
                        `(local.get $$scratch)`,
                        `(i32.const 0)`,
                        `(call $load)`,
                        `(i32.sub)`,
                        `(call $store)`,
                        `(local.get $$scratch)`
                    ];
                case ast_1.UniOp.Not:
                    return [`(i32.const 0)`, ...exprStmts, `(i32.eq)`];
            }
        case "builtin1":
            const argTyp = expr.a.type;
            const argStmts = codeGenValue(expr.arg, env);
            var callName = expr.name;
            if (expr.name === "print" && argTyp === utils_1.NUM) {
                callName = "print_num";
            }
            else if (expr.name === "print" && argTyp === utils_1.BOOL) {
                callName = "print_bool";
            }
            else if (expr.name === "print" && argTyp === utils_1.NONE) {
                callName = "print_none";
            }
            return argStmts.concat([`(call $${callName})`]);
        case "builtin2":
            const leftStmts = codeGenValue(expr.left, env);
            const rightStmts = codeGenValue(expr.right, env);
            return [...leftStmts, ...rightStmts, `(call $${expr.name})`];
        case "call":
            var valStmts = expr.arguments.map((arg) => codeGenValue(arg, env)).flat();
            valStmts.push(`(call $${expr.name})`);
            return valStmts;
        case "call_indirect":
            var valStmts = codeGenExpr(expr.fn, env);
            var fnStmts = expr.arguments.map((arg) => codeGenValue(arg, env)).flat();
            return [...fnStmts, ...valStmts, `(call_indirect (type ${(0, utils_1.makeWasmFunType)(expr.arguments.length)}))`];
        case "alloc":
            return [
                ...codeGenValue(expr.amount, env),
                `call $alloc`
            ];
        case "load":
            return [
                ...codeGenValue(expr.start, env),
                ...codeGenValue(expr.offset, env),
                `call $load`
            ];
    }
}
function codeGenValue(val, env) {
    switch (val.tag) {
        case "num":
            var x = BigInt(val.value); // for division
            if (x === BigInt(0))
                return ["(i32.const 0)"];
            var n = 0;
            var digits = [];
            while (x != BigInt(0)) {
                if (x < 0) {
                    x *= BigInt(-1);
                }
                digits.push(Number(x & BigInt(0x7fffffff)));
                x = x / BigInt(1 << 31);
                n = n + 1;
            }
            n = n + 1; // store (n+1) blocks (n: number of digits)
            var i = 0;
            var return_val = [];
            return_val.push(`(i32.const ${n})`);
            return_val.push(`(call $alloc)`);
            return_val.push(`(local.set $$scratch)`);
            // store the bignum in (n+1) blocks
            // store number of blocks in the first block
            return_val.push(`(local.get $$scratch)`);
            return_val.push(`(i32.const ${i})`);
            return_val.push(`(i32.const ${n - 1})`);
            return_val.push(`call $store`);
            i = i + 1;
            // store the digits in the rest of blocks
            for (i; i < n; i++) {
                return_val.push(`(local.get $$scratch)`);
                return_val.push(`(i32.const ${i})`);
                return_val.push(`(i32.const ${digits[i - 1]})`);
                return_val.push(`call $store`);
            }
            return_val.push(`(local.get $$scratch)`);
            return return_val;
        case "wasmint":
            return ["(i32.const " + val.value + ")"];
        case "bool":
            return [`(i32.const ${Number(val.value)})`];
        case "none":
            return [`(i32.const 0)`];
        case "id":
            if (env.locals.has(val.name)) {
                return [`(local.get $${val.name})`];
            }
            else {
                return [`(global.get $${val.name})`];
            }
    }
}
function codeGenBinOp(op) {
    switch (op) {
        case ast_1.BinOp.Plus:
            return "(call $$add)";
        case ast_1.BinOp.Minus:
            return "(call $$sub)";
        case ast_1.BinOp.Mul:
            return "(call $$mul)";
        case ast_1.BinOp.IDiv:
            return "(call $$div)";
        case ast_1.BinOp.Mod:
            return "(call $$mod)";
        case ast_1.BinOp.Eq:
            return "(call $$eq)";
        case ast_1.BinOp.Neq:
            return "(call $$neq)";
        case ast_1.BinOp.Lte:
            return "(call $$lte)";
        case ast_1.BinOp.Gte:
            return "(call $$gte)";
        case ast_1.BinOp.Lt:
            return "(call $$lt)";
        case ast_1.BinOp.Gt:
            return "(call $$gt)";
        case ast_1.BinOp.Is:
            return "(i32.eq)";
        case ast_1.BinOp.And:
            return "(i32.and)";
        case ast_1.BinOp.Or:
            return "(i32.or)";
    }
}
function codeGenInit(init, env) {
    const value = codeGenValue(init.value, env);
    if (env.locals.has(init.name)) {
        return [...value, `(local.set $${init.name})`];
    }
    else {
        return [...value, `(global.set $${init.name})`];
    }
}
function codeGenDef(def, env) {
    var definedVars = new Set();
    def.inits.forEach(v => definedVars.add(v.name));
    definedVars.add("$last");
    definedVars.add("$selector");
    definedVars.add("$scratch");
    // def.parameters.forEach(p => definedVars.delete(p.name));
    definedVars.forEach(env.locals.add, env.locals);
    def.parameters.forEach(p => env.locals.add(p.name));
    env.labels = def.body.map(block => block.label);
    const localDefines = makeLocals(definedVars);
    const locals = localDefines.join("\n");
    const inits = def.inits.map(init => codeGenInit(init, env)).flat().join("\n");
    var params = def.parameters.map(p => `(param $${p.name} i32)`).join(" ");
    var bodyCommands = "(local.set $$selector (i32.const 0))\n";
    bodyCommands += "(loop $loop\n";
    var blockCommands = "(local.get $$selector)\n";
    blockCommands += `(br_table ${def.body.map(block => block.label).join(" ")})`;
    def.body.forEach(block => {
        blockCommands = `(block ${block.label}
              ${blockCommands}    
            ) ;; end ${block.label}
            ${block.stmts.map(stmt => codeGenStmt(stmt, env).join('\n')).join('\n')}
            `;
    });
    bodyCommands += blockCommands;
    bodyCommands += ") ;; end $loop";
    env.locals.clear();
    return [`
  (func $${def.name} ${params} (result i32)
    ${locals}
    ${inits}
    ${bodyCommands}
    (i32.const 0)
    (return))`];
}
function codeGenClass(cls, env) {
    const methods = [...cls.methods];
    methods.forEach(method => method.name = (0, utils_1.createMethodName)(cls.name, method.name));
    const result = methods.map(method => codeGenDef(method, env));
    return result.flat();
}


/***/ }),

/***/ "./const.ts":
/*!******************!*\
  !*** ./const.ts ***!
  \******************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.default_functions = exports.default_keywords = void 0;
exports.default_keywords = [
    "and",
    "del",
    "from",
    "not",
    "while",
    "as",
    "elif",
    "global",
    "or",
    "with",
    "assert",
    "else",
    "if",
    "pass",
    "yield",
    "break",
    "except",
    "import",
    "print",
    "class",
    "exec",
    "in",
    "raise",
    "continue",
    "finally",
    "is",
    "return",
    "def",
    "for",
    "lambda",
    "try",
    "int",
    "bool",
    "str",
];
exports.default_functions = [
    "abs()",
    "delattr()",
    "hash()",
    "memoryview()",
    "set()",
    "all()",
    "dict()",
    "help()",
    "min()",
    "setattr()",
    "any()",
    "dir()",
    "hex()",
    "next()",
    "slice()",
    "ascii()",
    "divmod()",
    "id()",
    "object()",
    "sorted()",
    "bin()",
    "enumerate()",
    "input()",
    "oct()",
    "staticmethod()",
    "eval()",
    "open()",
    "str()",
    "breakpoint()",
    "exec()",
    "isinstance()",
    "ord()",
    "sum()",
    "bytearray()",
    "filter()",
    "issubclass()",
    "pow()",
    "super()",
    "bytes()",
    "float()",
    "iter()",
    "print()",
    "tuple()",
    "callable()",
    "format()",
    "len()",
    "property()",
    "type()",
    "chr()",
    "frozenset()",
    "list()",
    "range()",
    "vars()",
    "classmethod()",
    "getattr()",
    "locals()",
    "repr()",
    "zip()",
    "compile()",
    "globals()",
    "map()",
    "reversed()",
    "__import__()",
    "complex()",
    "hasattr()",
    "max()",
    "round()",
];


/***/ }),

/***/ "./errors.ts":
/*!*******************!*\
  !*** ./errors.ts ***!
  \*******************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.wasmErrorImports = exports.importObjectErrors = exports.flattenAssertNotNone = exports.assert_not_none = exports.OperationOnNoneError = exports.OperationOnNoneNote = exports.flattenDivideByZero = exports.divide_by_zero = exports.DivideByZeroError = exports.DivideByZeroNote = exports.getRE = exports.registerRE = exports.runtimeErrorRegistry = exports.RuntimeError = exports.drawSquiggly = exports.fullSrcLine = exports.TYPE_ERROR_STRING = exports.RUNTIME_ERROR_STRING = void 0;
const lower_1 = __webpack_require__(/*! ./lower */ "./lower.ts");
exports.RUNTIME_ERROR_STRING = "RUNTIME ERROR";
exports.TYPE_ERROR_STRING = "TYPE ERROR";
/****** Full line of src that contains an error ******/
function fullSrcLine(SRC, fromLocIdx, fromLocCol, eolLocIdx) {
    const lineStart = fromLocIdx - fromLocCol + 1; // src and col has an offset of 1
    return SRC.slice(lineStart, eolLocIdx);
}
exports.fullSrcLine = fullSrcLine;
// TODO: how to draw squigglies if the error spans multiple lines?
function drawSquiggly(fromLocRow, endLocRow, fromLocCol, endLocCol) {
    return (fromLocRow === endLocRow) ? `${' '.repeat(fromLocCol - 1)}${'^'.repeat(endLocCol - fromLocCol)}` : '';
}
exports.drawSquiggly = drawSquiggly;
/****** Runtime Errors *******/
/**
 * Runtime Error base class.
 */
class RuntimeError extends Error {
    constructor(SRC, a) {
        const trueProto = new.target.prototype;
        super();
        // Alternatively use Object.setPrototypeOf if you have an ES6 environment.
        this.__proto__ = trueProto;
        this.a = (a) ?? undefined;
        this.SRC = (SRC) ?? undefined;
        this.name = exports.RUNTIME_ERROR_STRING;
        this.message = "You shouldn't see this. Compiler's cursed. Check if you prepared the error before throwing it out.";
        this.note = "";
    }
    getA() {
        return this.a;
    }
    // Create error message lazily to reduce memory overhead
    prepare() {
        var locSquigglySrc = "";
        if (this.a && this.SRC) {
            const a = this.a;
            const SRC = this.SRC;
            const fromLoc = a.fromLoc;
            const endLoc = a.endLoc;
            const eolLoc = a.eolLoc;
            const loc = ` on line ${fromLoc.row} at col ${fromLoc.col}`;
            const src = fullSrcLine(SRC, fromLoc.srcIdx, fromLoc.col, eolLoc.srcIdx);
            const squiggly = drawSquiggly(fromLoc.row, endLoc.row, fromLoc.col, endLoc.col);
            locSquigglySrc = `${loc}\n\n${src}\n${squiggly}`;
        }
        const msg = this.note + locSquigglySrc;
        this.message = msg;
    }
    getErrMsg() {
        return String(this);
    }
}
exports.RuntimeError = RuntimeError;
// TODO: Should the error registry be global, be put in ImportedObjects, or be somewhere else? 
exports.runtimeErrorRegistry = new Array();
function registerRE(e, registry = exports.runtimeErrorRegistry) {
    registry.push(e);
    return registry.length - 1;
}
exports.registerRE = registerRE;
function getRE(reNum, registry = exports.runtimeErrorRegistry) {
    return registry[reNum];
}
exports.getRE = getRE;
/**** Common Error checking behaviors ****/
function assert_not_zero(arg, reNum) {
    if (arg === 0) {
        const re = getRE(reNum);
        re.prepare();
        throw re;
    }
    return arg;
}
/********** Divide by Zero Error ***********/
exports.DivideByZeroNote = "cannot divide by zero";
class DivideByZeroError extends RuntimeError {
    constructor() {
        super(...arguments);
        this.note = exports.DivideByZeroNote;
    }
}
exports.DivideByZeroError = DivideByZeroError;
exports.divide_by_zero = assert_not_zero;
function flattenDivideByZero(a, rval) {
    const error = new DivideByZeroError(exports.importObjectErrors.src, a);
    const reNum = registerRE(error);
    const posArg = (0, lower_1.flattenWasmInt)(reNum);
    return { tag: "expr", expr: { tag: "call", name: `divide_by_zero`, arguments: [rval, posArg] } };
}
exports.flattenDivideByZero = flattenDivideByZero;
/********* Operation On None Error *********/
// TODO: Separate into different cases (Method call on None, Field access on None, indexing on None, etc.)
exports.OperationOnNoneNote = "cannot perform operation on none";
class OperationOnNoneError extends RuntimeError {
    constructor() {
        super(...arguments);
        this.note = exports.OperationOnNoneNote;
    }
}
exports.OperationOnNoneError = OperationOnNoneError;
exports.assert_not_none = assert_not_zero;
function flattenAssertNotNone(a, oval) {
    const error = new OperationOnNoneError(exports.importObjectErrors.src, a);
    const reNum = registerRE(error);
    const posArg = (0, lower_1.flattenWasmInt)(reNum);
    return { tag: "expr", expr: { tag: "call", name: `assert_not_none`, arguments: [oval, posArg] } };
}
exports.flattenAssertNotNone = flattenAssertNotNone;
/******* WASM Imports *******/
exports.importObjectErrors = {
    src: "",
    assert_not_none: // For reporting source code in runtime errors.  
    exports.assert_not_none,
    divide_by_zero: exports.divide_by_zero,
};
exports.wasmErrorImports = `
    (func $assert_not_none (import "errors" "assert_not_none") (param i32) (param i32) (result i32))
    (func $divide_by_zero (import "errors" "divide_by_zero")  (param i32) (param i32) (result i32))
`;


/***/ }),

/***/ "./lower.ts":
/*!******************!*\
  !*** ./lower.ts ***!
  \******************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.flattenWasmInt = exports.lowerProgram = exports.closureName = void 0;
const AST = __importStar(__webpack_require__(/*! ./ast */ "./ast.ts"));
const ERRORS = __importStar(__webpack_require__(/*! ./errors */ "./errors.ts"));
const utils_1 = __webpack_require__(/*! ./utils */ "./utils.ts");
let nameCounters = new Map();
function generateName(base) {
    if (nameCounters.has(base)) {
        var cur = nameCounters.get(base);
        nameCounters.set(base, cur + 1);
        return base + (cur + 1);
    }
    else {
        nameCounters.set(base, 1);
        return base + 1;
    }
}
function closureName(f, ancestors) {
    return `${[f, ...ancestors.map(f => f.name)].reverse().join("_$")}_$closure$`;
}
exports.closureName = closureName;
// function lbl(a: Type, base: string) : [string, IR.Stmt<Type>] {
//   const name = generateName(base);
//   return [name, {tag: "label", a: a, name: name}];
// }
var blocks = [];
function lowerProgram(p, env) {
    nameCounters = new Map();
    blocks = [];
    var firstBlock = { a: p.a, label: generateName("$startProg"), stmts: [] };
    blocks.push(firstBlock);
    p.funs.forEach(f => env.functionNames.set(f.name, closureName(f.name, [])));
    var [closures, cinits, cstmts] = lowerFunDefs(p.funs, env);
    [...closures, ...p.classes].forEach(cls => {
        env.classIndices.set(cls.name, env.vtableMethods.length);
        env.vtableMethods.push(...cls.methods
            .filter(method => !method.name.includes("__init__"))
            .map((method) => [(0, utils_1.createMethodName)(cls.name, method.name), method.parameters.length]));
    });
    var classes = lowerClasses([...closures, ...p.classes], env);
    var [inits, generatedClasses] = flattenStmts([...cstmts, ...p.stmts], blocks, env);
    return {
        a: p.a,
        funs: [],
        inits: [...inits, ...lowerVarInits([...cinits, ...p.inits], env)],
        classes: [...classes, ...generatedClasses],
        body: blocks
    };
}
exports.lowerProgram = lowerProgram;
function lowerFunDefs(fs, env) {
    const defs = fs.map(f => lowerFunDef(f, env, []));
    return [defs.map(x => x[0]).flat(), defs.map(x => x[1]), defs.map(x => x[2])];
}
function lowerFunDef(f, env, ancestors) {
    var name = closureName(f.name, ancestors);
    var type = (0, utils_1.CLASS)(name);
    var self = { name: "self", type };
    var envCopy = { ...env, functionNames: new Map(env.functionNames) };
    f.children.forEach(c => envCopy.functionNames.set(c.name, closureName(c.name, [f, ...ancestors])));
    var defs = f.children.map(x => lowerFunDef(x, envCopy, [f, ...ancestors]));
    var assignStmt = { tag: "assign", name: f.name, value: { a: { type }, tag: "construct", name } };
    var varInit = { name: f.name, type, value: { tag: "none" } };
    // TODO(pashabou): children, populate fields and methods of closure class
    return [
        [{
                name,
                fields: [],
                methods: [
                    {
                        name: "__init__",
                        parameters: [self],
                        ret: f.ret,
                        inits: [],
                        body: [],
                        nonlocals: [],
                        children: []
                    },
                    {
                        ...f,
                        name: utils_1.APPLY,
                        parameters: [self, ...f.parameters],
                        inits: [varInit, ...defs.map(x => x[1]), ...f.inits],
                        body: [assignStmt, ...defs.map(x => x[2]), ...f.body]
                    }
                ],
                typeParams: []
            }, ...defs.map(x => x[0]).flat()],
        varInit,
        assignStmt
    ];
}
function lowerMethodDefs(fs, env) {
    const defs = fs.map(f => lowerMethodDef(f, env));
    return [defs.map(x => x[0]).flat(), defs.map(x => x[1])];
}
function lowerMethodDef(f, env) {
    var blocks = [];
    var firstBlock = { a: f.a, label: generateName("$startFun"), stmts: [] };
    blocks.push(firstBlock);
    var [bodyinits, classes] = flattenStmts(f.body, blocks, env);
    return [classes, { ...f, inits: [...bodyinits, ...lowerVarInits(f.inits, env)], body: blocks }];
}
function lowerVarInits(inits, env) {
    return inits.map(i => lowerVarInit(i, env));
}
function lowerVarInit(init, env) {
    return {
        ...init,
        value: literalToVal(init.value)
    };
}
function lowerClasses(classes, env) {
    return classes.map(c => lowerClass(c, env)).flat();
}
function lowerClass(cls, env) {
    // init not in vtable 
    // (we currently do no reordering, we leave that to inheritance team)
    const [classes, methods] = lowerMethodDefs(cls.methods, env);
    return [
        ...classes,
        {
            ...cls,
            fields: lowerVarInits(cls.fields, env),
            methods
        }
    ];
}
function literalToVal(lit) {
    switch (lit.tag) {
        case "num":
            return { ...lit, value: BigInt((lit.value).toLocaleString('fullwide', { useGrouping: false })) };
        case "bool":
            return lit;
        case "none":
            return lit;
    }
}
function flattenStmts(s, blocks, env) {
    var inits = [];
    var classes = [];
    s.forEach(stmt => {
        const res = flattenStmt(stmt, blocks, env);
        inits.push(...res[0]);
        classes.push(...res[1]);
    });
    return [inits, classes];
}
function flattenListComp(e, env, blocks) {
    // console.log("list comp in ir", e, "----------------");
    var compStartLbl = generateName("$compstart");
    var compbodyLbl = generateName("$compbody");
    var compEndLbl = generateName("$compend");
    var listAddLbl = generateName("$listadd");
    // var newListName = generateName("$newList");
    var localenv = env;
    localenv.labels.push(compStartLbl, compbodyLbl, compEndLbl, listAddLbl);
    // start
    blocks.push({ a: e.a, label: compStartLbl, stmts: [] });
    // a.hasNext() call
    var hasNextCall = { tag: "method-call", obj: e.iterable, method: "hasNext", arguments: [], a: { ...e.a, tag: utils_1.BOOL } };
    var [cinits, cstmts, cexpr, ceclass] = flattenExprToVal(hasNextCall, blocks, localenv);
    pushStmtsToLastBlock(blocks, ...cstmts, { tag: "ifjmp", cond: cexpr, thn: compbodyLbl, els: compEndLbl });
    // console.log(cinits, cstmts, cexpr);
    // body
    blocks.push({ a: e.a, label: compbodyLbl, stmts: [] });
    // assign a.next() to elem
    var nextCall = { tag: "method-call", obj: e.iterable, method: "next", arguments: [], a: { ...e.a, type: utils_1.NUM } };
    var elem = "";
    if (e.elem.tag == "id")
        elem = e.elem.name;
    var nextAssign = [{ tag: "assign", name: elem, value: nextCall, a: { ...e.a, type: utils_1.NONE } }];
    var [bodyinits, bodyclasses] = flattenStmts(nextAssign, blocks, localenv);
    // cond
    if (e.cond) {
        var [dinits, dstmts, dexpr, declass] = flattenExprToVal(e.cond, blocks, localenv);
        pushStmtsToLastBlock(blocks, ...dstmts, { tag: "ifjmp", cond: dexpr, thn: listAddLbl, els: compStartLbl });
        // console.log("dinits", dinits, "dstmts", dstmts, "dexpr", dexpr);
    }
    else {
        pushStmtsToLastBlock(blocks, { tag: "jmp", lbl: listAddLbl });
    }
    // list add
    blocks.push({ a: e.a, label: listAddLbl, stmts: [] });
    // do left expr
    var [binits, bstmts, bexpr, beclass] = flattenExprToVal(e.left, blocks, localenv);
    bodyinits.concat(binits);
    // console.log("binits", binits, "bstmts", bstmts, "bexpr", bexpr, "bodyinits", bodyinits);
    // display (NEED TO ADD TO ARRAY)
    var displayExpr = { tag: "builtin1", name: "print", arg: e.left, a: e.left.a };
    var disp = { tag: "expr", expr: displayExpr, a: { ...e.a, type: utils_1.NONE } };
    // var [einits, estmts, eexpr] = flattenExprToVal(displayExpr, localenv);
    var [body_init, body_class] = flattenStmt(disp, blocks, localenv);
    bodyinits.concat(body_init);
    // console.log("einits", einits, "estmts", estmts, "eexpr", eexpr);
    pushStmtsToLastBlock(blocks, ...bstmts, { tag: "jmp", lbl: compStartLbl });
    // end
    blocks.push({ a: e.a, label: compEndLbl, stmts: [] });
    if (e.cond)
        return [[...cinits, ...bodyinits, ...body_init, ...dinits, ...binits],
            [...cstmts, ...dstmts, ...bstmts],
            {
                a: e.a,
                tag: "value",
                value: {
                    a: { ...e.a, type: utils_1.NUM },
                    tag: "id",
                    name: elem
                },
            }, [...ceclass, ...bodyclasses, ...body_class, ...declass, ...beclass]];
    else
        return [[...cinits, ...bodyinits, ...body_init, ...binits],
            [...cstmts, ...bstmts],
            {
                a: e.a,
                tag: "value",
                value: {
                    a: { ...e.a, type: utils_1.NUM },
                    tag: "id",
                    name: elem
                },
            }, [...ceclass, ...bodyclasses, ...body_class, ...beclass]];
}
function flattenStmt(s, blocks, env) {
    switch (s.tag) {
        case "assign":
            var [valinits, valstmts, vale, classes] = flattenExprToExpr(s.value, blocks, env);
            blocks[blocks.length - 1].stmts.push(...valstmts, { a: s.a, tag: "assign", name: s.name, value: vale });
            return [valinits, classes];
        // return [valinits, [
        //   ...valstmts,
        //   { a: s.a, tag: "assign", name: s.name, value: vale}
        // ]];
        case "return":
            var [valinits, valstmts, val, classes] = flattenExprToVal(s.value, blocks, env);
            blocks[blocks.length - 1].stmts.push(...valstmts, { tag: "return", a: s.a, value: val });
            return [valinits, classes];
        // return [valinits, [
        //     ...valstmts,
        //     {tag: "return", a: s.a, value: val}
        // ]];
        case "expr":
            var [inits, stmts, e, classes] = flattenExprToExpr(s.expr, blocks, env);
            blocks[blocks.length - 1].stmts.push(...stmts, { tag: "expr", a: s.a, expr: e });
            return [inits, classes];
        //  return [inits, [ ...stmts, {tag: "expr", a: s.a, expr: e } ]];
        case "pass":
            return [[], []];
        case "field-assign": {
            var [oinits, ostmts, oval, oclasses] = flattenExprToVal(s.obj, blocks, env);
            var [ninits, nstmts, nval, nclasses] = flattenExprToVal(s.value, blocks, env);
            if (s.obj.a.type.tag !== "class") {
                throw new Error("Compiler's cursed, go home.");
            }
            const classdata = env.classes.get(s.obj.a.type.name);
            const offset = { tag: "wasmint", value: classdata.get(s.field)[0] };
            pushStmtsToLastBlock(blocks, ...ostmts, ...nstmts, {
                tag: "store",
                a: s.a,
                start: oval,
                offset: offset,
                value: nval
            });
            return [[...oinits, ...ninits], oclasses.concat(nclasses)];
        }
        // return [[...oinits, ...ninits], [...ostmts, ...nstmts, {
        //   tag: "field-assign",
        //   a: s.a,
        //   obj: oval,
        //   field: s.field,
        //   value: nval
        // }]];
        case "if":
            var thenLbl = generateName("$then");
            var elseLbl = generateName("$else");
            var endLbl = generateName("$end");
            var endjmp = { tag: "jmp", lbl: endLbl };
            var [cinits, cstmts, cexpr, cclasses] = flattenExprToVal(s.cond, blocks, env);
            var condjmp = { tag: "ifjmp", cond: cexpr, thn: thenLbl, els: elseLbl };
            pushStmtsToLastBlock(blocks, ...cstmts, condjmp);
            blocks.push({ a: s.a, label: thenLbl, stmts: [] });
            var [theninits, thenclasses] = flattenStmts(s.thn, blocks, env);
            pushStmtsToLastBlock(blocks, endjmp);
            blocks.push({ a: s.a, label: elseLbl, stmts: [] });
            var [elseinits, elseclasses] = flattenStmts(s.els, blocks, env);
            pushStmtsToLastBlock(blocks, endjmp);
            blocks.push({ a: s.a, label: endLbl, stmts: [] });
            return [[...cinits, ...theninits, ...elseinits], [...cclasses, ...thenclasses, ...elseclasses]];
        // return [[...cinits, ...theninits, ...elseinits], [
        //   ...cstmts, 
        //   condjmp,
        //   startlbl,
        //   ...thenstmts,
        //   endjmp,
        //   elslbl,
        //   ...elsestmts,
        //   endjmp,
        //   endlbl,
        // ]];
        case "while":
            var whileStartLbl = generateName("$whilestart");
            var whilebodyLbl = generateName("$whilebody");
            var whileEndLbl = generateName("$whileend");
            //pushing labels to utilize them for continue and break statements
            env.labels.push(whileStartLbl, whilebodyLbl, whileEndLbl);
            pushStmtsToLastBlock(blocks, { tag: "jmp", lbl: whileStartLbl });
            blocks.push({ a: s.a, label: whileStartLbl, stmts: [] });
            var [cinits, cstmts, cexpr, cclasses] = flattenExprToVal(s.cond, blocks, env);
            pushStmtsToLastBlock(blocks, ...cstmts, { tag: "ifjmp", cond: cexpr, thn: whilebodyLbl, els: whileEndLbl });
            blocks.push({ a: s.a, label: whilebodyLbl, stmts: [] });
            var [bodyinits, bodyclasses] = flattenStmts(s.body, blocks, env);
            pushStmtsToLastBlock(blocks, { tag: "jmp", lbl: whileStartLbl });
            blocks.push({ a: s.a, label: whileEndLbl, stmts: [] });
            return [[...cinits, ...bodyinits], [...cclasses, ...bodyclasses]];
        case "continue":
            if (env.labels.length > 2)
                pushStmtsToLastBlock(blocks, { tag: "jmp", lbl: env.labels[env.labels.length - 3] });
            return [[], []];
        case "break":
            if (env.labels.length > 0)
                pushStmtsToLastBlock(blocks, { tag: "jmp", lbl: env.labels[env.labels.length - 1] });
            return [[], []];
        case "for":
            var forStartLbl = generateName("$forstart");
            var forbodyLbl = generateName("$forbody");
            var forEndLbl = generateName("$forend");
            var localenv = env;
            localenv.labels.push(forStartLbl, forbodyLbl, forEndLbl);
            // reset the values class to the original state at the start of the loop - nested loops use case
            var resetCall = { tag: "method-call", obj: s.values, method: "reset", arguments: [], a: { ...s.a, type: utils_1.NONE } };
            var resetStmt = [{ tag: "expr", expr: resetCall, a: { ...s.a, type: utils_1.NONE } }];
            flattenStmts(resetStmt, blocks, localenv);
            pushStmtsToLastBlock(blocks, { tag: "jmp", lbl: forStartLbl });
            blocks.push({ a: s.a, label: forStartLbl, stmts: [] });
            var hasnextCall = { tag: "method-call", obj: s.values, method: "hasnext", arguments: [], a: { ...s.a, type: utils_1.BOOL } };
            var nextCall = { tag: "method-call", obj: s.values, method: "next", arguments: [], a: s.a };
            var [cinits, cstmts, cexpr] = flattenExprToVal(hasnextCall, blocks, localenv);
            pushStmtsToLastBlock(blocks, ...cstmts, { tag: "ifjmp", cond: cexpr, thn: forbodyLbl, els: forEndLbl });
            blocks.push({ a: s.a, label: forbodyLbl, stmts: [] });
            var nextAssign = [{ tag: "assign", name: s.iterator, value: nextCall, a: s.a }];
            flattenStmts(nextAssign, blocks, localenv); // to add wasm code for i = c.next(). has no inits 
            var [bodyinits, bodyclasses] = flattenStmts(s.body, blocks, localenv);
            pushStmtsToLastBlock(blocks, { tag: "jmp", lbl: forStartLbl });
            blocks.push({ a: s.a, label: forEndLbl, stmts: [] });
            return [[...cinits, ...bodyinits], [...bodyclasses]];
    }
}
function flattenExprToExpr(e, blocks, env) {
    switch (e.tag) {
        case "uniop":
            var [inits, stmts, val, classes] = flattenExprToVal(e.expr, blocks, env);
            return [inits, stmts, {
                    ...e,
                    expr: val
                }, classes];
        case "binop":
            var [linits, lstmts, lval, lclasses] = flattenExprToVal(e.left, blocks, env);
            var [rinits, rstmts, rval, rclasses] = flattenExprToVal(e.right, blocks, env);
            var checkDenom = [];
            if (e.op == AST.BinOp.IDiv || e.op == AST.BinOp.Mod) { // check division by zero
                checkDenom.push(ERRORS.flattenDivideByZero(e.a, rval));
            }
            return [[...linits, ...rinits], [...lstmts, ...rstmts, ...checkDenom], {
                    ...e,
                    left: lval,
                    right: rval
                }, [...lclasses, ...rclasses]];
        case "builtin1":
            var [inits, stmts, val, classes] = flattenExprToVal(e.arg, blocks, env);
            return [inits, stmts, { tag: "builtin1", a: e.a, name: e.name, arg: val }, classes];
        case "builtin2":
            var [linits, lstmts, lval, lclasses] = flattenExprToVal(e.left, blocks, env);
            var [rinits, rstmts, rval, rclasses] = flattenExprToVal(e.right, blocks, env);
            return [[...linits, ...rinits], [...lstmts, ...rstmts], {
                    ...e,
                    left: lval,
                    right: rval
                }, [...lclasses, ...rclasses]];
        case "call":
            const [finits, fstmts, fval, fclasses] = flattenExprToVal(e.fn, blocks, env);
            const callpairs = e.arguments.map(a => flattenExprToVal(a, blocks, env));
            const callinits = callpairs.map(cp => cp[0]).flat();
            const callstmts = callpairs.map(cp => cp[1]).flat();
            const callvals = callpairs.map(cp => cp[2]).flat();
            const callclasses = callpairs.map(cp => cp[3]).flat();
            const checkObj = ERRORS.flattenAssertNotNone(e.a, fval);
            const zeroOffset = { tag: "wasmint", value: 0 };
            return [
                [...finits, ...callinits],
                [...fstmts, checkObj, ...callstmts],
                {
                    ...e,
                    tag: "call_indirect",
                    fn: { tag: "load", start: fval, offset: zeroOffset },
                    arguments: [fval, ...callvals]
                },
                [...fclasses, ...callclasses]
            ];
        case "method-call": {
            const [objinits, objstmts, objval, objclasses] = flattenExprToVal(e.obj, blocks, env);
            const argpairs = e.arguments.map(a => flattenExprToVal(a, blocks, env));
            const arginits = argpairs.map(cp => cp[0]).flat();
            const argstmts = argpairs.map(cp => cp[1]).flat();
            const argvals = argpairs.map(cp => cp[2]).flat();
            const argclasses = argpairs.map(cp => cp[3]).flat();
            var objTyp = e.obj.a;
            if (objTyp.type.tag !== "class") { // I don't think this error can happen
                throw new Error("Report this as a bug to the compiler developer, this shouldn't happen " + objTyp.type.tag);
            }
            const className = objTyp.type.name;
            const checkObj = ERRORS.flattenAssertNotNone(e.a, objval);
            const callMethod = { tag: "call", name: `${className}$${e.method}`, arguments: [objval, ...argvals] };
            return [
                [...objinits, ...arginits],
                [...objstmts, checkObj, ...argstmts],
                callMethod,
                [...objclasses, ...argclasses]
            ];
        }
        case "lookup": {
            const [oinits, ostmts, oval, oclasses] = flattenExprToVal(e.obj, blocks, env);
            if (e.obj.a.type.tag !== "class") {
                throw new Error("Compiler's cursed, go home");
            }
            const classdata = env.classes.get(e.obj.a.type.name);
            const [offset, _] = classdata.get(e.field);
            const checkObj = ERRORS.flattenAssertNotNone(e.a, oval);
            return [oinits, [...ostmts, checkObj], {
                    tag: "load",
                    start: oval,
                    offset: { tag: "wasmint", value: offset }
                }, oclasses];
        }
        case "construct":
            const classdata = env.classes.get(e.name);
            const fields = [...classdata.entries()];
            const newName = generateName("newObj");
            const alloc = { tag: "alloc", amount: { tag: "wasmint", value: fields.length + 1 } };
            const assigns = fields.map(f => {
                const [_, [index, value]] = f;
                return {
                    tag: "store",
                    start: { tag: "id", name: newName },
                    offset: { tag: "wasmint", value: index },
                    value: value
                };
            });
            return [
                [{ name: newName, type: e.a.type, value: { tag: "none" } }],
                [{ tag: "assign", name: newName, value: alloc }, {
                        tag: "store",
                        start: { tag: "id", name: newName },
                        offset: { tag: "wasmint", value: 0 },
                        value: { tag: "wasmint", value: env.classIndices.get(e.name) }
                    }, ...assigns,
                    { tag: "expr", expr: { tag: "call", name: `${e.name}$__init__`, arguments: [{ a: e.a, tag: "id", name: newName }] } }
                ],
                { a: e.a, tag: "value", value: { a: e.a, tag: "id", name: newName } },
                []
            ];
        case "list-comp":
            return flattenListComp(e, env, blocks);
        case "id":
            return [[], [], { tag: "value", value: { ...e } }, []];
        case "literal":
            return [[], [], { tag: "value", value: literalToVal(e.value) }, []];
        case "if-expr": {
            var thenLbl = generateName("$ifExprThen");
            var elseLbl = generateName("$ifExprElse");
            var endLbl = generateName("$ifExprEnd");
            var ifExprTmpVal = generateName("$ifExprTmp");
            var endjmp = { tag: "jmp", lbl: endLbl };
            let [cinits, cstmts, cexpr, cclasses] = flattenExprToVal(e.cond, blocks, env);
            var condjmp = { tag: "ifjmp", cond: cexpr, thn: thenLbl, els: elseLbl };
            pushStmtsToLastBlock(blocks, ...cstmts, condjmp);
            blocks.push({ a: e.a, label: thenLbl, stmts: [] });
            var [thninits, thnstmts, thnexpr, thnclasses] = flattenExprToExpr(e.thn, blocks, env);
            pushStmtsToLastBlock(blocks, ...thnstmts, { a: e.a, tag: "assign", name: ifExprTmpVal, value: thnexpr }, endjmp);
            blocks.push({ a: e.a, label: elseLbl, stmts: [] });
            var [elsinits, elsstmts, elsexpr, elseclasses] = flattenExprToExpr(e.els, blocks, env);
            pushStmtsToLastBlock(blocks, ...elsstmts, { a: e.a, tag: "assign", name: ifExprTmpVal, value: elsexpr }, endjmp);
            blocks.push({ a: e.a, label: endLbl, stmts: [] });
            var varDefForTmp = { a: e.a, name: ifExprTmpVal, type: e.a.type, value: { a: { type: { tag: "none" } }, tag: "none" } };
            return [
                [...cinits, ...elsinits, ...thninits, varDefForTmp],
                [],
                { a: e.a, tag: "value", value: { a: e.a, tag: "id", name: ifExprTmpVal } },
                [...cclasses, ...thnclasses, ...elseclasses]
            ];
        }
        case "lambda":
            var [classDef, constrExpr] = lambdaToClass(e);
            const classFields = new Map();
            classDef.fields.forEach((field, i) => classFields.set(field.name, [i, field.value]));
            env.classes.set(classDef.name, classFields);
            env.classIndices.set(classDef.name, env.vtableMethods.length);
            env.vtableMethods.push(...classDef.methods
                .filter(method => !method.name.includes("__init__"))
                .map((method) => [
                (0, utils_1.createMethodName)(classDef.name, method.name), method.parameters.length
            ]));
            const irClass = lowerClass(classDef, env);
            irClass[0].a = e.a;
            const [cinits, cstmts, cval, cclasses] = flattenExprToExpr(constrExpr, blocks, env);
            return [cinits, cstmts, cval, [...irClass, ...cclasses]];
    }
}
function lambdaToClass(lambda) {
    var lambdaClassName = generateName("lambda");
    var params = lambda.params.map((param, i) => ({
        name: param,
        type: lambda.type.params[i]
    }));
    return [
        {
            name: lambdaClassName,
            fields: [],
            methods: [
                {
                    name: "__init__",
                    parameters: [{ name: "self", type: (0, utils_1.CLASS)(lambdaClassName) }],
                    ret: utils_1.NONE,
                    inits: [],
                    body: [],
                    nonlocals: [],
                    children: []
                },
                {
                    name: utils_1.APPLY,
                    parameters: [{ name: "self", type: (0, utils_1.CLASS)(lambdaClassName) }, ...params],
                    ret: lambda.type.ret,
                    inits: [],
                    body: [{ a: { type: lambda.type.ret }, tag: "return", value: lambda.expr }],
                    nonlocals: [],
                    children: []
                }
            ],
            typeParams: [],
        },
        { a: lambda.a, tag: "construct", name: lambdaClassName }
    ];
}
function flattenExprToVal(e, blocks, env) {
    var [binits, bstmts, bexpr, bclasses] = flattenExprToExpr(e, blocks, env);
    if (bexpr.tag === "value") {
        return [binits, bstmts, bexpr.value, bclasses];
    }
    else {
        var newName = generateName("valname");
        var setNewName = {
            tag: "assign",
            a: e.a,
            name: newName,
            value: bexpr
        };
        // TODO: we have to add a new var init for the new variable we're creating here.
        // but what should the default value be?
        return [
            [...binits, { a: e.a, name: newName, type: e.a.type, value: { tag: "none" } }],
            [...bstmts, setNewName],
            { tag: "id", name: newName, a: e.a },
            bclasses
        ];
    }
}
function pushStmtsToLastBlock(blocks, ...stmts) {
    blocks[blocks.length - 1].stmts.push(...stmts);
}
function flattenWasmInt(val) {
    return { tag: "wasmint", value: val };
}
exports.flattenWasmInt = flattenWasmInt;


/***/ }),

/***/ "./monomorphizer.ts":
/*!**************************!*\
  !*** ./monomorphizer.ts ***!
  \**************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.monomorphizeProgram = exports.processInits = exports.processMethodParams = exports.getCanonicalTypeName = exports.monomorphizeClass = exports.processStmts = exports.processExprs = exports.resolveZero = exports.concretizeGenericTypes = void 0;
const utils_1 = __webpack_require__(/*! ./utils */ "./utils.ts");
function concretizeGenericTypes(type, genv) {
    switch (type.tag) {
        case "typevar":
            return genv.typeVars.get(type.name);
        case "class":
            const cparams = type.params.map(p => concretizeGenericTypes(p, genv));
            return { ...type, params: cparams };
        default:
            return type;
    }
}
exports.concretizeGenericTypes = concretizeGenericTypes;
function resolveZero(type, a) {
    switch (type.tag) {
        case "number":
            return { a: { ...a, type: utils_1.NUM }, tag: "num", value: 0 };
        case "bool":
            return { a: { ...a, type: utils_1.BOOL }, tag: "bool", value: false };
        case "class":
            return { a: { ...a, type: utils_1.NONE }, tag: "none" };
    }
}
exports.resolveZero = resolveZero;
function processExprs(expr, genv) {
    if (expr.a.type === undefined) {
        return expr;
    }
    expr.a.type = concretizeGenericTypes(expr.a.type, genv);
    switch (expr.tag) {
        case "binop":
            const binL = processExprs(expr.left, genv);
            const binR = processExprs(expr.right, genv);
            if (expr.a.type.tag === "class" && expr.a.type.params.length > 0) {
                return { ...expr, a: { ...expr.a, type: (0, utils_1.CLASS)(getCanonicalTypeName(expr.a.type)) }, left: binL, right: binR };
            }
            return { ...expr, left: binL, right: binR };
        case "call":
            const cExprs = expr.arguments.map(a => processExprs(a, genv));
            if (expr.a.type.tag === "class" && expr.a.type.params.length > 0) {
                return { ...expr, a: { ...expr.a, type: (0, utils_1.CLASS)(getCanonicalTypeName(expr.a.type)) }, arguments: cExprs };
            }
            return { ...expr, arguments: cExprs };
        case "construct":
            if (expr.a.type.tag === "class" && expr.a.type.params.length > 0) {
                const constructCname = getCanonicalTypeName(expr.a.type);
                return { ...expr, a: { ...expr.a, type: (0, utils_1.CLASS)(constructCname) }, name: constructCname };
            }
            return expr;
        case "id":
            if (expr.a.type.tag === "class" && expr.a.type.params.length > 0) {
                return { ...expr, a: { ...expr.a, type: (0, utils_1.CLASS)(getCanonicalTypeName(expr.a.type)) } };
            }
            return expr;
        case "index":
            const inxExpr = processExprs(expr.index, genv);
            const inxObj = processExprs(expr.obj, genv);
            if (expr.a.type.tag === "class" && expr.a.type.params.length > 0) {
                return { ...expr, a: { ...expr.a, type: (0, utils_1.CLASS)(getCanonicalTypeName(expr.a.type)) }, index: inxExpr, obj: inxObj };
            }
            return { ...expr, index: inxExpr, obj: inxObj };
        case "lookup":
            const lObj = processExprs(expr.obj, genv);
            if (expr.a.type.tag === "class" && expr.a.type.params.length > 0) {
                return { ...expr, a: { ...expr.a, type: (0, utils_1.CLASS)(getCanonicalTypeName(expr.a.type)) }, obj: lObj };
            }
            return { ...expr, obj: lObj };
        case "method-call":
            const mcExprs = expr.arguments.map(a => processExprs(a, genv));
            const mcObj = processExprs(expr.obj, genv);
            if (expr.a.type.tag === "class" && expr.a.type.params.length > 0) {
                return { ...expr, a: { ...expr.a, type: (0, utils_1.CLASS)(getCanonicalTypeName(expr.a.type)) }, arguments: mcExprs, obj: mcObj };
            }
            return { ...expr, arguments: mcExprs, obj: mcObj };
        case "uniop":
            const uexpr = processExprs(expr.expr, genv);
            if (expr.a.type.tag === "class" && expr.a.type.params.length > 0) {
                return { ...expr, a: { ...expr.a, type: (0, utils_1.CLASS)(getCanonicalTypeName(expr.a.type)) }, expr: uexpr };
            }
            return { ...expr, expr: uexpr };
        case "builtin1":
            const b1arg = processExprs(expr.arg, genv);
            if (expr.a.type.tag === "class" && expr.a.type.params.length > 0) {
                return { ...expr, a: { ...expr.a, type: (0, utils_1.CLASS)(getCanonicalTypeName(expr.a.type)) }, arg: b1arg };
            }
            return { ...expr, arg: b1arg };
        case "builtin2":
            const b2left = processExprs(expr.left, genv);
            const b2right = processExprs(expr.right, genv);
            if (expr.a.type.tag === "class" && expr.a.type.params.length > 0) {
                return { ...expr, a: { ...expr.a, type: (0, utils_1.CLASS)(getCanonicalTypeName(expr.a.type)) }, left: b2left, right: b2right };
            }
            return { ...expr, left: b2left, right: b2right };
        default:
            return expr;
    }
}
exports.processExprs = processExprs;
function processStmts(stmt, genv) {
    if (stmt.a.type === undefined) {
        return stmt;
    }
    stmt.a.type = concretizeGenericTypes(stmt.a.type, genv);
    switch (stmt.tag) {
        case "assign":
            const assignValueExpr = processExprs(stmt.value, genv);
            if (stmt.a.type.tag === "class" && stmt.a.type.params.length > 0) {
                return { ...stmt, a: { ...stmt.a, type: (0, utils_1.CLASS)(getCanonicalTypeName(stmt.a.type)) }, value: assignValueExpr };
            }
            return { ...stmt, value: assignValueExpr };
        case "expr":
            const expr = processExprs(stmt.expr, genv);
            if (stmt.a.type.tag === "class" && stmt.a.type.params.length > 0) {
                return { ...stmt, a: { ...stmt.a, type: (0, utils_1.CLASS)(getCanonicalTypeName(stmt.a.type)) }, expr };
            }
            return { ...stmt, expr };
        case "field-assign":
            const faobj = processExprs(stmt.obj, genv);
            const faval = processExprs(stmt.value, genv);
            if (stmt.a.type.tag === "class" && stmt.a.type.params.length > 0) {
                return { ...stmt, a: { ...stmt.a, type: (0, utils_1.CLASS)(getCanonicalTypeName(stmt.a.type)) }, obj: faobj, value: faval };
            }
            return { ...stmt, obj: faobj, value: faval };
        case "index-assign":
            const iaobj = processExprs(stmt.obj, genv);
            const iinx = processExprs(stmt.index, genv);
            const ival = processExprs(stmt.value, genv);
            if (stmt.a.type.tag === "class" && stmt.a.type.params.length > 0) {
                return { ...stmt, a: { ...stmt.a, type: (0, utils_1.CLASS)(getCanonicalTypeName(stmt.a.type)) }, obj: iaobj, index: iinx, value: ival };
            }
            return { ...stmt, obj: iaobj, index: iinx, value: ival };
        case "if":
            const ifcond = processExprs(stmt.cond, genv);
            const ifthn = stmt.thn.map(st => processStmts(st, genv));
            const ifels = stmt.els.map(st => processStmts(st, genv));
            if (stmt.a.type.tag === "class" && stmt.a.type.params.length > 0) {
                return { ...stmt, a: { ...stmt.a, type: (0, utils_1.CLASS)(getCanonicalTypeName(stmt.a.type)) }, cond: ifcond, thn: ifthn, els: ifels };
            }
            return { ...stmt, cond: ifcond, thn: ifthn, els: ifels };
        case "return":
            const retExpr = processExprs(stmt.value, genv);
            if (stmt.a.type.tag === "class" && stmt.a.type.params.length > 0) {
                return { ...stmt, a: { ...stmt.a, type: (0, utils_1.CLASS)(getCanonicalTypeName(stmt.a.type)) }, value: retExpr };
            }
            return { ...stmt, value: retExpr };
        case "while":
            const wcond = processExprs(stmt.cond, genv);
            const wBody = stmt.body.map(st => processStmts(st, genv));
            if (stmt.a.type.tag === "class" && stmt.a.type.params.length > 0) {
                return { ...stmt, a: { ...stmt.a, type: (0, utils_1.CLASS)(getCanonicalTypeName(stmt.a.type)) }, cond: wcond, body: wBody };
            }
            return { ...stmt, cond: wcond, body: wBody };
        case "for":
            const { body, iterator, values } = stmt;
            const wbody = body.map(st => processStmts(st, genv));
            const wvalues = processExprs(values, genv);
            if (stmt.a.type.tag === "class" && stmt.a.type.params.length > 0) {
                return { ...stmt, a: { ...stmt.a, type: (0, utils_1.CLASS)(getCanonicalTypeName(stmt.a.type)) }, iterator, body: wbody, values: wvalues };
            }
            return { ...stmt, iterator, values: wvalues, body: wbody };
        default:
            return stmt;
    }
}
exports.processStmts = processStmts;
function monomorphizeClass(cname, canonicalName, classes, genv) {
    let cClass = classes[genv.classesInx.get(cname)];
    let mClass = JSON.parse(JSON.stringify(cClass));
    mClass.name = canonicalName;
    mClass.typeParams = [];
    mClass.fields = mClass.fields.map(field => {
        if (field.type.tag === "typevar" || (field.type.tag === "class" && field.type.params.length > 0)) {
            field.type = concretizeGenericTypes(field.type, genv);
            field.value = resolveZero(field.type, field.a);
        }
        return field;
    });
    mClass.methods = mClass.methods.map(method => {
        method.parameters = method.parameters.map(p => {
            const ptype = concretizeGenericTypes(p.type, genv);
            return { ...p, type: ptype };
        });
        method.inits = method.inits.map(init => {
            if (init.type.tag === "typevar" || (init.type.tag === "class" && init.type.params.length > 0)) {
                init.type = concretizeGenericTypes(init.type, genv);
                init.value = resolveZero(init.type, init.a);
            }
            return init;
        });
        method.ret = concretizeGenericTypes(method.ret, genv);
        return method;
    });
    mClass.fields = processInits(mClass.fields, classes, genv);
    mClass.methods = mClass.methods.map(m => {
        // assuming method annotation is none, we don't do anything with it
        return { ...m, parameters: processMethodParams(m.parameters, classes, genv), inits: processInits(m.inits, classes, genv),
            body: m.body.map(s => processStmts(s, genv)) };
    });
    return mClass;
}
exports.monomorphizeClass = monomorphizeClass;
function getCanonicalTypeName(t) {
    switch (t.tag) {
        case "number":
        case "bool":
            return t.tag;
        case "class":
            const paramNames = t.params.map(p => getCanonicalTypeName(p)).join("$");
            return t.name + "$" + paramNames;
        default:
            throw new Error(`Invalid State Exception : unexpected type passed as a generic type ${t.tag}`);
    }
}
exports.getCanonicalTypeName = getCanonicalTypeName;
function processMethodParams(params, classes, genv) {
    return params.map(param => {
        if (param.type.tag === "class" && param.type.params.length > 0) { // this implies a var init of a class with generic types
            const canonicalName = getCanonicalTypeName(param.type);
            if (!genv.morphedClasses.has(canonicalName)) {
                const typeCname = param.type.name;
                param.type.params.forEach((tv, inx) => genv.typeVars.set(classes[genv.classesInx.get(typeCname)].typeParams[inx], tv));
                genv.morphedClasses.add(canonicalName);
                classes.push(monomorphizeClass(typeCname, canonicalName, classes, genv));
            }
            return { ...param, type: (0, utils_1.CLASS)(canonicalName) };
        }
        return param;
    });
}
exports.processMethodParams = processMethodParams;
function processInits(inits, classes, genv) {
    return inits.map(init => {
        if (init.type.tag === "class" && init.type.params.length > 0) {
            const canonicalName = getCanonicalTypeName(init.type);
            if (!genv.morphedClasses.has(canonicalName)) {
                const typeCname = init.type.name;
                init.type.params.forEach((tv, inx) => genv.typeVars.set(classes[genv.classesInx.get(typeCname)].typeParams[inx], tv));
                genv.morphedClasses.add(canonicalName);
                classes.push(monomorphizeClass(typeCname, canonicalName, classes, genv));
            }
            return { ...init, type: (0, utils_1.CLASS)(canonicalName) };
        }
        return init;
    });
}
exports.processInits = processInits;
function monomorphizeProgram(program) {
    let classesInx = new Map();
    program.classes.forEach((clazz, inx) => classesInx.set(clazz.name, inx));
    let genv = { classesInx, typeVars: new Map(), morphedClasses: new Set() };
    const inits = processInits(program.inits, program.classes, genv);
    const monoMorphizedClasses = program.classes.filter(clazz => clazz.typeParams.length === 0);
    const processedStmts = program.stmts.map(s => processStmts(s, genv));
    return { ...program, inits, classes: monoMorphizedClasses, typeVarInits: [], stmts: processedStmts };
}
exports.monomorphizeProgram = monomorphizeProgram;


/***/ }),

/***/ "./optimization.ts":
/*!*************************!*\
  !*** ./optimization.ts ***!
  \*************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.generateEnvironments = exports.optimizeProgram = exports.generateEnvironmentFunctions = exports.generateEnvironmentProgram = exports.optimizeClass = exports.optimizeFunction = exports.computePredecessorSuccessor = exports.optimizeStatements = exports.optimizeExpression = exports.evaluateUniOp = exports.evaluateBinOp = exports.checkIfFoldableBinOp = exports.optimizeValue = void 0;
const ast_1 = __webpack_require__(/*! ./ast */ "./ast.ts");
const optimization_utils_1 = __webpack_require__(/*! ./optimization_utils */ "./optimization_utils.ts");
function optimizeValue(val, env) {
    if (val.tag !== "id") {
        return val;
    }
    if (env.vars.has(val.name)) {
        if (["nac", "undef"].includes(env.vars.get(val.name).tag))
            return val;
        val = env.vars.get(val.name).value;
    }
    return val;
}
exports.optimizeValue = optimizeValue;
function checkIfFoldableBinOp(op, leftVal, rightVal) {
    if ([ast_1.BinOp.IDiv, ast_1.BinOp.Mod].includes(op)) {
        if (!(0, optimization_utils_1.isTagBigInt)(leftVal) || !(0, optimization_utils_1.isTagBigInt)(rightVal))
            throw new Error("Compiler Error: Function should be invoked only if the expression can be folded");
        if (rightVal.value === 0n)
            return false;
    }
    return true;
}
exports.checkIfFoldableBinOp = checkIfFoldableBinOp;
function evaluateBinOp(op, leftVal, rightVal) {
    if ([ast_1.BinOp.Plus, ast_1.BinOp.Minus, ast_1.BinOp.IDiv, ast_1.BinOp.Mul, ast_1.BinOp.Gt, ast_1.BinOp.Lt, ast_1.BinOp.Gte, ast_1.BinOp.Lte, ast_1.BinOp.Mod].includes(op)) {
        if (!(0, optimization_utils_1.isTagBigInt)(leftVal) || !(0, optimization_utils_1.isTagBigInt)(rightVal))
            throw new Error("Compiler Error: Function should be invoked only if the expression can be folded");
        switch (op) {
            case ast_1.BinOp.Plus: return { tag: "num", value: leftVal.value + rightVal.value };
            case ast_1.BinOp.Minus: return { tag: "num", value: leftVal.value - rightVal.value };
            case ast_1.BinOp.Mul: return { tag: "num", value: leftVal.value * rightVal.value };
            case ast_1.BinOp.IDiv: return { tag: "num", value: leftVal.value / rightVal.value };
            case ast_1.BinOp.Mod: return { tag: "num", value: leftVal.value % rightVal.value };
            case ast_1.BinOp.Gt: return { tag: "bool", value: leftVal.value > rightVal.value };
            case ast_1.BinOp.Lt: return { tag: "bool", value: leftVal.value < rightVal.value };
            case ast_1.BinOp.Gte: return { tag: "bool", value: leftVal.value >= rightVal.value };
            case ast_1.BinOp.Lte: return { tag: "bool", value: leftVal.value <= rightVal.value };
        }
    }
    else if ([ast_1.BinOp.And, ast_1.BinOp.Or].includes(op)) {
        if (!(0, optimization_utils_1.isTagBoolean)(leftVal) || !(0, optimization_utils_1.isTagBoolean)(rightVal))
            throw new Error("Compiler Error: Function should be invoked only if the expression can be folded");
        switch (op) {
            case ast_1.BinOp.And: return { tag: "bool", value: leftVal.value && rightVal.value };
            case ast_1.BinOp.Or: return { tag: "bool", value: leftVal.value || rightVal.value };
        }
    }
    else if ([ast_1.BinOp.Eq, ast_1.BinOp.Neq].includes(op)) {
        if (!(0, optimization_utils_1.isTagEqual)(leftVal, rightVal) || (0, optimization_utils_1.isTagNone)(leftVal) || (0, optimization_utils_1.isTagNone)(rightVal) || (0, optimization_utils_1.isTagId)(leftVal) || (0, optimization_utils_1.isTagId)(rightVal))
            throw new Error("Compiler Error: Function should be invoked only if the expression can be folded");
        switch (op) {
            case ast_1.BinOp.Eq: return { tag: "bool", value: leftVal.value === rightVal.value };
        }
    }
    else {
        //Is operator handler
        if (!(0, optimization_utils_1.isTagNone)(leftVal) || !(0, optimization_utils_1.isTagNone)(rightVal))
            throw new Error("Compiler Error: Function should be invoked only if the expression can be folded");
        return { tag: "bool", value: true };
    }
}
exports.evaluateBinOp = evaluateBinOp;
function evaluateUniOp(op, val) {
    switch (op) {
        case ast_1.UniOp.Neg:
            if ((0, optimization_utils_1.isTagId)(val) || (0, optimization_utils_1.isTagNone)(val) || (0, optimization_utils_1.isTagBoolean)(val))
                throw new Error("Compiler Error");
            const minus1 = -1n;
            return { tag: "num", value: minus1 * val.value };
        case ast_1.UniOp.Not:
            if (!(0, optimization_utils_1.isTagBoolean)(val))
                throw new Error("Compiler Error");
            return { tag: "bool", value: !(val.value) };
    }
}
exports.evaluateUniOp = evaluateUniOp;
function optimizeExpression(e, env) {
    switch (e.tag) {
        case "value":
            var optimizedValue = optimizeValue(e.value, env);
            return { ...e, value: optimizedValue };
        case "binop":
            var left = optimizeValue(e.left, env);
            var right = optimizeValue(e.right, env);
            if (left.tag === "id" || right.tag === "id" || !checkIfFoldableBinOp(e.op, left, right))
                return { ...e, left: left, right: right };
            var val = evaluateBinOp(e.op, left, right);
            return { tag: "value", value: val };
        case "uniop":
            var arg = optimizeValue(e.expr, env);
            if (arg.tag === "id")
                return { ...e, expr: arg };
            var val = evaluateUniOp(e.op, arg);
            return e;
        // NOTE(joe): had to skip this optimization b/c negative literals for bignums not supported
        // return {tag: "value", value: val};
        case "builtin1":
            var arg = optimizeValue(e.arg, env);
            return { ...e, arg: arg };
        case "builtin2":
            var left = optimizeValue(e.left, env);
            var right = optimizeValue(e.right, env);
            return { ...e, left: left, right: right };
        case "call":
            var modifiedParams = e.arguments.map(a => {
                return optimizeValue(a, env);
            });
            return { ...e, arguments: modifiedParams };
        case "alloc":
            var amount = optimizeValue(e.amount, env);
            return { ...e, amount: amount };
        case "load":
            var start = optimizeValue(e.start, env);
            var offset = optimizeValue(e.offset, env);
            return { ...e, start: start, offset: offset };
        default:
            return e;
    }
}
exports.optimizeExpression = optimizeExpression;
function optimizeStatements(stmt, env) {
    switch (stmt.tag) {
        case "assign":
            var optimizedExpression = optimizeExpression(stmt.value, env);
            if (optimizedExpression.tag === "value") {
                if (optimizedExpression.value.tag === "id") {
                    env.vars.set(stmt.name, { tag: "nac" });
                }
                else {
                    env.vars.set(stmt.name, { tag: "val", value: optimizedExpression.value });
                }
            }
            else {
                env.vars.set(stmt.name, { tag: "nac" });
            }
            return { ...stmt, value: optimizedExpression };
        case "return":
            var optimizedValue = optimizeValue(stmt.value, env);
            return { ...stmt, value: optimizedValue };
        case "expr":
            var optimizedExpression = optimizeExpression(stmt.expr, env);
            return { ...stmt, expr: optimizedExpression };
        case "pass":
            return stmt;
        case "ifjmp":
            var optimizedValue = optimizeValue(stmt.cond, env);
            return { ...stmt, cond: optimizedValue };
        case "jmp":
            return stmt;
        case "store":
            return stmt;
    }
}
exports.optimizeStatements = optimizeStatements;
//Assuming jumps if it occurs will occur at the last statement of the block
function computePredecessorSuccessor(basicBlocks) {
    let succs = new Map();
    let preds = new Map();
    let blockMapping = new Map();
    basicBlocks.forEach(basicBlock => {
        blockMapping.set(basicBlock.label, basicBlock);
        const lastStmt = basicBlock.stmts[basicBlock.stmts.length - 1];
        if (lastStmt !== undefined && lastStmt.tag === "ifjmp") {
            //Assigning successors
            if (succs.has(basicBlock.label) && !succs.get(basicBlock.label).includes(lastStmt.thn))
                succs.set(basicBlock.label, [...succs.get(basicBlock.label), lastStmt.thn]);
            else if (!succs.has(basicBlock.label))
                succs.set(basicBlock.label, [lastStmt.thn]);
            if (succs.has(basicBlock.label) && !succs.get(basicBlock.label).includes(lastStmt.els))
                succs.set(basicBlock.label, [...succs.get(basicBlock.label), lastStmt.els]);
            else if (!succs.has(basicBlock.label))
                succs.set(basicBlock.label, [lastStmt.els]);
            //Assigning predecessors
            if (preds.has(lastStmt.thn) && !preds.get(lastStmt.thn).includes(basicBlock.label))
                preds.set(lastStmt.thn, [...preds.get(lastStmt.thn), basicBlock.label]);
            else if (!preds.has(lastStmt.thn))
                preds.set(lastStmt.thn, [basicBlock.label]);
            if (preds.has(lastStmt.els) && !preds.get(lastStmt.els).includes(basicBlock.label))
                preds.set(lastStmt.els, [...preds.get(lastStmt.els), basicBlock.label]);
            else if (!preds.has(lastStmt.els))
                preds.set(lastStmt.els, [basicBlock.label]);
        }
        else if (lastStmt !== undefined && lastStmt.tag === "jmp") {
            //Assigning successors
            if (succs.has(basicBlock.label) && !succs.get(basicBlock.label).includes(lastStmt.lbl))
                succs.set(basicBlock.label, [...succs.get(basicBlock.label), lastStmt.lbl]);
            else if (!succs.has(basicBlock.label))
                succs.set(basicBlock.label, [lastStmt.lbl]);
            //Assigning predecessors
            if (preds.has(lastStmt.lbl) && !preds.get(lastStmt.lbl).includes(basicBlock.label))
                preds.set(lastStmt.lbl, [...preds.get(lastStmt.lbl), basicBlock.label]);
            else if (!preds.has(lastStmt.lbl))
                preds.set(lastStmt.lbl, [basicBlock.label]);
        }
    });
    return [preds, succs, blockMapping];
}
exports.computePredecessorSuccessor = computePredecessorSuccessor;
function computeInitEnv(varDefs, dummyEnv) {
    var env = { vars: new Map() };
    varDefs.forEach(def => {
        if (!dummyEnv)
            env.vars.set(def.name, { tag: "val", value: def.value });
        else
            env.vars.set(def.name, { tag: "undef" });
    });
    return env;
}
function mergeEnvironment(a, b) {
    var returnEnv = { vars: new Map() };
    a.vars.forEach((aValue, key) => {
        const bValue = b.vars.get(key);
        if (bValue.tag === "nac" || aValue.tag === "nac")
            returnEnv.vars.set(key, { tag: "nac" });
        else if (aValue.tag === "undef" && bValue.tag === "undef") {
            returnEnv.vars.set(key, { tag: "undef" });
        }
        else if (aValue.tag === "undef") {
            returnEnv.vars.set(key, { tag: "val", value: bValue.value });
        }
        else if (bValue.tag === "undef") {
            returnEnv.vars.set(key, { tag: "val", value: aValue.value });
        }
        else if ((0, optimization_utils_1.checkValueEquality)(aValue.value, bValue.value))
            returnEnv.vars.set(key, { tag: "val", value: aValue.value });
        else
            returnEnv.vars.set(key, { tag: "nac" });
    });
    return returnEnv;
}
function updateEnvironmentByBlock(inEnv, block) {
    var outEnv = { vars: new Map(inEnv.vars) };
    block.stmts.forEach(statement => {
        if (statement === undefined) {
            console.log(block.stmts);
        }
        if (statement.tag === "assign") {
            const optimizedExpression = optimizeExpression(statement.value, outEnv);
            if (optimizedExpression.tag === "value") {
                if (optimizedExpression.value.tag === "id") {
                    outEnv.vars.set(statement.name, { tag: "nac" });
                }
                else {
                    outEnv.vars.set(statement.name, { tag: "val", value: optimizedExpression.value });
                }
            }
            else {
                outEnv.vars.set(statement.name, { tag: "nac" });
            }
        }
    });
    return outEnv;
}
function duplicateEnv(env) {
    return { vars: new Map(env.vars) };
}
function addParamsToEnv(params, env, dummyEnv) {
    params.forEach(p => {
        if (dummyEnv) {
            env.vars.set(p.name, { tag: "undef" });
        }
        else {
            env.vars.set(p.name, { tag: "nac" });
        }
    });
}
function optimizeBlock(block, env) {
    var blockOptimized = false;
    var newStmts = block.stmts.map(s => {
        var optimizedstatement = optimizeStatements(s, env);
        if (!blockOptimized && !(0, optimization_utils_1.checkStmtEquality)(optimizedstatement, s))
            blockOptimized = true;
        return optimizedstatement;
    });
    return [{ ...block, stmts: newStmts }, blockOptimized];
}
function optimizeFunction(func) {
    var [inEnvMapping, _outEnvMapping] = generateEnvironmentFunctions(func);
    var functionOptimized = false;
    //Write code to optimize functions here
    var newBody = func.body.map(b => {
        var tempBlockEnv = duplicateEnv(inEnvMapping.get(b.label));
        var [optimizedBlock, blockOptimized] = optimizeBlock(b, tempBlockEnv);
        if (!functionOptimized && blockOptimized)
            functionOptimized = true;
        return optimizedBlock;
    });
    /* NOTE(joe): taking out all recursive optimization because there is no easy
     * way to add fallthrough cases above */
    // if (functionOptimized) return optimizeFunction({...func, body: newBody})
    return { ...func, body: newBody };
}
exports.optimizeFunction = optimizeFunction;
function optimizeClass(c) {
    var optimizedMethods = c.methods.map(m => {
        return optimizeFunction(m);
    });
    return { ...c, methods: optimizedMethods };
}
exports.optimizeClass = optimizeClass;
function generateEnvironmentProgram(program) {
    var initialEnv = computeInitEnv(program.inits, false);
    var inEnvMapping = new Map();
    var outEnvMapping = new Map();
    var dummyEnv = computeInitEnv(program.inits, true);
    program.body.forEach(f => {
        inEnvMapping.set(f.label, duplicateEnv(dummyEnv));
        outEnvMapping.set(f.label, duplicateEnv(dummyEnv));
    });
    var [preds, succs, blockMapping] = computePredecessorSuccessor(program.body);
    preds.set(program.body[0].label, ["VD"]);
    succs.set("VD", [program.body[0].label]);
    outEnvMapping.set("VD", initialEnv);
    generateEnvironments([program.body[0].label], inEnvMapping, outEnvMapping, preds, succs, blockMapping);
    return [inEnvMapping, outEnvMapping];
}
exports.generateEnvironmentProgram = generateEnvironmentProgram;
function generateEnvironmentFunctions(func) {
    var initialEnv = computeInitEnv(func.inits, false);
    addParamsToEnv(func.parameters, initialEnv, false);
    var inEnvMapping = new Map();
    var outEnvMapping = new Map();
    var dummyEnv = computeInitEnv(func.inits, true);
    addParamsToEnv(func.parameters, initialEnv, true);
    func.body.forEach(f => {
        inEnvMapping.set(f.label, duplicateEnv(dummyEnv));
        outEnvMapping.set(f.label, duplicateEnv(dummyEnv));
    });
    inEnvMapping.set(func.body[0].label, initialEnv);
    var [preds, succs, blockMapping] = computePredecessorSuccessor(func.body);
    preds.set(func.body[0].label, ["VD"]);
    succs.set("VD", [func.body[0].label]);
    outEnvMapping.set("VD", initialEnv);
    generateEnvironments([func.body[0].label], inEnvMapping, outEnvMapping, preds, succs, blockMapping);
    return [inEnvMapping, outEnvMapping];
}
exports.generateEnvironmentFunctions = generateEnvironmentFunctions;
function optimizeProgram(program) {
    var [inEnvMapping, _outEnvMapping] = generateEnvironmentProgram(program);
    //Write code to optimize the program using the environment
    var programOptimized = false;
    var newBody = program.body.map(b => {
        var tempBlockEnv = duplicateEnv(inEnvMapping.get(b.label));
        var [optimizedBlock, blockOptimized] = optimizeBlock(b, tempBlockEnv);
        if (!programOptimized && blockOptimized)
            programOptimized = true;
        return optimizedBlock;
    });
    /* NOTE(joe): turning this off; it (a) doesn't have fallthrough cases for new
     * expressions and (b) when I add fallthrough cases, it stack-overflows */
    //if (programOptimized) program = optimizeProgram({...program, body: newBody});
    var newClass = program.classes.map(c => {
        return optimizeClass(c);
    });
    var newFunctions = program.funs.map(f => {
        return optimizeFunction(f);
    });
    return { ...program, body: newBody, classes: newClass, funs: newFunctions };
}
exports.optimizeProgram = optimizeProgram;
function mergeAllPreds(predecessorBlocks, outEnvMapping) {
    if (predecessorBlocks.length === 0) {
        throw new Error(`CompileError: Block with predecessors`);
    }
    var inEnv = outEnvMapping.get(predecessorBlocks[0]);
    predecessorBlocks.slice(1).forEach(b => {
        inEnv = mergeEnvironment(inEnv, outEnvMapping.get(b));
    });
    return inEnv;
}
function checkEnvEquality(a, b) {
    const aVars = a.vars;
    const bVars = b.vars;
    for (const key of aVars.keys()) {
        const aValue = aVars.get(key);
        const bValue = bVars.get(key);
        if (!(0, optimization_utils_1.checkCompileValEquality)(aValue, bValue))
            return false;
    }
    return true;
}
function generateEnvironments(workList, inEnvMapping, outEnvMapping, preds, succs, blockMapping) {
    if (workList.length === 0)
        return;
    const currBlock = workList.pop();
    const newInEnv = mergeAllPreds(preds.get(currBlock), outEnvMapping);
    if (checkEnvEquality(inEnvMapping.get(currBlock), newInEnv)) {
        generateEnvironments(workList, inEnvMapping, outEnvMapping, preds, succs, blockMapping);
        return;
    }
    inEnvMapping.set(currBlock, newInEnv);
    outEnvMapping.set(currBlock, updateEnvironmentByBlock(newInEnv, blockMapping.get(currBlock)));
    const wlAddition = (succs.get(currBlock) === undefined) ? ([]) : (succs.get(currBlock));
    generateEnvironments([...workList, ...wlAddition], inEnvMapping, outEnvMapping, preds, succs, blockMapping);
    return;
}
exports.generateEnvironments = generateEnvironments;


/***/ }),

/***/ "./optimization_utils.ts":
/*!*******************************!*\
  !*** ./optimization_utils.ts ***!
  \*******************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.checkStmtEquality = exports.checkExprEquality = exports.checkCompileValEquality = exports.checkValueEquality = exports.isTagEqual = exports.isTagNumber = exports.isTagBigInt = exports.isTagBoolean = exports.isTagNone = exports.isTagId = void 0;
function isTagId(value) {
    return value.tag === "id";
}
exports.isTagId = isTagId;
function isTagNone(value) {
    return value.tag === "none";
}
exports.isTagNone = isTagNone;
function isTagBoolean(value) {
    return value.tag === "bool";
}
exports.isTagBoolean = isTagBoolean;
function isTagBigInt(value) {
    return value.tag === "num";
}
exports.isTagBigInt = isTagBigInt;
function isTagNumber(value) {
    return value.tag === "wasmint";
}
exports.isTagNumber = isTagNumber;
function isTagEqual(a, b) {
    if (isTagBigInt(a) && isTagBigInt(b) || isTagBoolean(a) && isTagBoolean(b) || isTagNone(a) && isTagNone(b))
        return true;
    else
        return false;
}
exports.isTagEqual = isTagEqual;
function checkValueEquality(a, b) {
    if (a.tag !== b.tag)
        return false;
    else if (a.tag === "none" || b.tag === "none")
        return true;
    else if (a.tag === "id" || b.tag === "id") {
        if (b.tag !== "id" || a.tag !== b.tag)
            throw new Error(`Compiler Error!`); //Will never be executed (to convince typescript)
        if (a.name === b.name)
            return true;
        return false;
    }
    else if (a.value === b.value)
        return true;
    return false;
}
exports.checkValueEquality = checkValueEquality;
function checkCompileValEquality(a, b) {
    if (a.tag !== b.tag)
        return false;
    if (a.tag === "val") {
        return checkValueEquality(a.value, b.value);
    }
    return true;
}
exports.checkCompileValEquality = checkCompileValEquality;
function checkExprEquality(a, b) {
    if (a.tag !== b.tag)
        return false;
    switch (a.tag) {
        case "value":
            if (b.tag !== "value")
                throw new Error(`Compiler Error!`); //Will never be executed, sanity check
            return checkValueEquality(a.value, b.value);
        case "binop":
            if (b.tag !== "binop")
                throw new Error(`Compiler Error!`); //Will never be executed, sanity check
            if (a.op !== b.op)
                return false;
            return checkValueEquality(a.left, b.left) && checkValueEquality(a.right, b.right);
        case "uniop":
            if (b.tag !== "uniop")
                throw new Error(`Compiler Error!`); //Will never be executed, sanity check
            if (a.op !== b.op)
                return false;
            return checkValueEquality(a.expr, b.expr);
        case "builtin1":
            if (b.tag !== "builtin1")
                throw new Error(`Compiler Error!`); //Will never be executed, santiy check
            if (a.name !== b.name)
                return false;
            return checkValueEquality(a.arg, b.arg);
        case "builtin2":
            if (b.tag !== "builtin2")
                throw new Error(`Compiler Error!`); //Will never be executed, sanity check
            if (a.name !== b.name)
                return false;
            return checkValueEquality(a.left, b.left) && checkValueEquality(a.right, b.right);
        case "call":
            if (b.tag !== "call")
                throw new Error(`Compiler Error!`); //Will never be executed, sanity check
            if (a.name !== b.name || a.arguments.length !== b.arguments.length)
                return false;
            for (let index = 0; index < a.arguments.length; index++) {
                const argA = a.arguments[index];
                const argB = b.arguments[index];
                if (!checkValueEquality(argA, argB))
                    return false;
            }
            return true;
        case "alloc":
            if (b.tag !== "alloc")
                throw new Error(`Compiler Error!`); //Will never be executed, sanity check
            return checkValueEquality(a.amount, b.amount);
        case "load":
            if (b.tag !== "load")
                throw new Error(`Compiler Error!`); //Will never be executed, sanity check
            return checkValueEquality(a.start, b.start) && checkValueEquality(a.offset, b.offset);
    }
}
exports.checkExprEquality = checkExprEquality;
function checkStmtEquality(a, b) {
    if (a.tag !== b.tag)
        return false;
    switch (a.tag) {
        case "assign":
            if (b.tag !== "assign")
                throw new Error(`Compiler Error!`); //Will never be executed, sanity check
            if (a.name !== b.name)
                return false;
            return checkExprEquality(a.value, b.value);
        case "return":
            if (b.tag !== "return")
                throw new Error(`Compiler Error!`); //Will never be executed, sanity check
            return checkValueEquality(a.value, b.value);
        case "expr":
            if (b.tag !== "expr")
                throw new Error(`Compiler Error!`); //Will never be executed, sanity check
            return checkExprEquality(a.expr, b.expr);
        case "pass":
            if (b.tag !== "pass")
                throw new Error(`Compiler Error!`); //Will never be executed, sanity check
            return true;
        case "ifjmp":
            if (b.tag !== "ifjmp")
                throw new Error(`Compiler Error!`); //Will never be executed, sanity check
            if ((a.thn !== b.thn) || (a.els !== b.els))
                return false;
            return checkValueEquality(a.cond, b.cond);
        case "jmp":
            if (b.tag !== "jmp")
                throw new Error(`Compiler Error!`); //Will never be executed, sanity check
            return (a.lbl === b.lbl);
        case "store":
            if (b.tag !== "store")
                throw new Error(`Compiler Error!`); //Will never be executed, sanity check
            return checkValueEquality(a.start, b.start) && checkValueEquality(a.offset, b.offset);
    }
}
exports.checkStmtEquality = checkStmtEquality;


/***/ }),

/***/ "./parser.ts":
/*!*******************!*\
  !*** ./parser.ts ***!
  \*******************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.parse = exports.traverseHelper = exports.traverse = exports.isClassDef = exports.isFunDef = exports.isScopeDef = exports.isTypeVarInit = exports.isVarInit = exports.traverseDefs = exports.traverseClassHelper = exports.traverseClass = exports.traverseGenericParams = exports.traverseFunDefHelper = exports.traverseFunDef = exports.traverseScopeDef = exports.traverseTypeVarInitHelper = exports.traverseTypeVarInit = exports.traverseVarInitHelper = exports.traverseVarInit = exports.traverseParameters = exports.traverseParameterHelper = exports.traverseParameter = exports.traverseTypeList = exports.traverseType = exports.traverseStmtHelper = exports.traverseStmt = exports.traverseLambdaParams = exports.traverseArguments = exports.traverseExprHelper = exports.traverseExpr = exports.traverseLiteralHelper = exports.traverseLiteral = exports.nextLineBreakLoc = exports.indToLoc = exports.binarySearch = void 0;
const python_1 = __webpack_require__(/*! @lezer/python */ "./node_modules/@lezer/python/dist/index.cjs");
const ast_1 = __webpack_require__(/*! ./ast */ "./ast.ts");
const utils_1 = __webpack_require__(/*! ./utils */ "./utils.ts");
const treeprinter_1 = __webpack_require__(/*! ./treeprinter */ "./treeprinter.ts");
const MKLAMBDA = "mklambda";
/**
 * Binary search on sorted array.
 * Returns the index at which target should be inserted in arr and the value at that index of arr.
 *
 * @param arr sorted array
 * @param target target to insert
 * @returns idx to insert target in arr and the value at that index of arr
 */
function binarySearch(arr, target) {
    var left = 0;
    var right = arr.length;
    var ans = 0;
    while (left <= right) {
        const mid = (left + right) >> 1;
        if (arr[mid] < target) {
            ans = mid;
            left = mid + 1;
        }
        else {
            right = mid - 1;
        }
    }
    // console.log(arr, target, ans)
    return ans;
}
exports.binarySearch = binarySearch;
/**
 * Convert a index in source to source `Location` object, which contains row and col information
 * @param srcIdx index in source
 * @param env ParserEnv, uses lineBreakIndices
 * @returns Location object of the corresponding index
 */
function indToLoc(srcIdx, env) {
    const row = binarySearch(env.lineBreakIndices, srcIdx) + 1;
    const col = srcIdx - env.lineBreakIndices[row - 1];
    return { row: row, col: col, srcIdx: srcIdx };
}
exports.indToLoc = indToLoc;
function nextLineBreakLoc(loc, env) {
    // if ending index is at the beginning of a new line, then the line break should be at one row above
    const row = (loc.col === 1) ? loc.row - 1 : loc.row;
    const col = env.lineBreakIndices[row] - env.lineBreakIndices[row - 1];
    return { row: row, col: col, srcIdx: env.lineBreakIndices[row] };
}
exports.nextLineBreakLoc = nextLineBreakLoc;
/**
 * Wrapper around the regular traverser to give the generated AST node a Location information.
 * This requires each AST node to have its own traverser:
 *   An AST node should be generated by traversing a collection of 'continuous' lezer tree nodes.
 *   The traverser should start at the highest left-most lezer node,
 *   and end at the highest right-most lezer node.
 *   Usually, the start and end node are the same: the AST node
 *   corresponds to a sub-lezer tree rooted at a single node.
 * @param traverser regular lezer tree to AST traverser
 * @param storeSrc if the location added should contain source string
 * @returns new traverser that adds location information onto the AST node that the regular traverser produces
 */
function wrap_locs(traverser, storeSrc = false) {
    return function (c, s, env, ...args) {
        const fromLoc = indToLoc(c.from, env);
        const node = traverser(c, s, env, ...args);
        const endLoc = indToLoc(c.to, env);
        const eolLoc = nextLineBreakLoc(endLoc, env);
        if (storeSrc) // only store full src in the Program node
            return { ...node, a: { ...node.a, fromLoc: fromLoc, endLoc: endLoc, eolLoc: eolLoc, src: s } };
        else
            return { ...node, a: { ...node.a, fromLoc: fromLoc, endLoc: endLoc, eolLoc: eolLoc } };
    };
}
exports.traverseLiteral = wrap_locs(traverseLiteralHelper);
function traverseLiteralHelper(c, s, env) {
    switch (c.type.name) {
        case "Number":
            return {
                tag: "num",
                value: Number(s.substring(c.from, c.to))
            };
        case "Boolean":
            return {
                tag: "bool",
                value: s.substring(c.from, c.to) === "True"
            };
        case "None":
            return {
                tag: "none"
            };
        case "VariableName":
            let vname = s.substring(c.from, c.to).trim();
            if (vname !== "__ZERO__") {
                throw new Error("ParseError: Not a literal");
            }
            return {
                tag: "zero"
            };
        default:
            throw new Error("Not literal");
    }
}
exports.traverseLiteralHelper = traverseLiteralHelper;
exports.traverseExpr = wrap_locs(traverseExprHelper);
function traverseExprHelper(c, s, env) {
    switch (c.type.name) {
        case "Number":
        case "Boolean":
        case "None":
            return {
                tag: "literal",
                value: (0, exports.traverseLiteral)(c, s, env)
            };
        case "VariableName":
            return {
                tag: "id",
                name: s.substring(c.from, c.to)
            };
        case "ArrayComprehensionExpression":
            c.firstChild(); // '['
            c.nextSibling();
            const left = (0, exports.traverseExpr)(c, s, env); // left
            c.nextSibling(); // for
            c.nextSibling();
            const elem = (0, exports.traverseExpr)(c, s, env); // elem
            c.nextSibling(); // in
            c.nextSibling();
            // conditions for parsing iterable to be added --!!
            const iterable = (0, exports.traverseExpr)(c, s, env); // iterable
            c.nextSibling();
            var cond;
            if (s.substring(c.from, c.to) !== ']') {
                if (s.substring(c.from, c.to) !== 'if')
                    throw new Error("PARSE TYPE ERROR: only if condition allowed in comprehensions");
                c.nextSibling();
                cond = (0, exports.traverseExpr)(c, s, env); // cond which evaluates to a binary expr
            }
            c.parent();
            return {
                tag: "list-comp",
                left,
                elem,
                iterable,
                cond
            };
        case "CallExpression":
            c.firstChild();
            const callExpr = (0, exports.traverseExpr)(c, s, env);
            c.nextSibling(); // go to arglist
            if (callExpr.tag === "id" && callExpr.name === MKLAMBDA) {
                c.firstChild();
                c.nextSibling();
                const callableType = traverseType(c, s, env);
                if (callableType.tag !== "callable") {
                    throw new Error(`First argument to ${MKLAMBDA} must be callable.`);
                }
                c.nextSibling(); // Focus on ,
                c.nextSibling(); // Focus on lambda
                let maybeLambda = c;
                if (maybeLambda.type.name !== "LambdaExpression") {
                    throw new Error(`Second argument to ${MKLAMBDA} must be a lamdba.`);
                }
                c.firstChild(); // Focus on object
                c.nextSibling(); // Focus on lambda
                var params = traverseLambdaParams(c, s);
                c.nextSibling();
                c.nextSibling();
                var expr = (0, exports.traverseExpr)(c, s, env);
                c.parent();
                c.parent();
                c.parent();
                return {
                    tag: "lambda",
                    type: callableType,
                    params,
                    expr,
                };
            }
            let args = traverseArguments(c, s, env);
            c.parent(); // pop CallExpression
            if (callExpr.tag === "lookup") {
                return {
                    tag: "method-call",
                    obj: callExpr.obj,
                    method: callExpr.field,
                    arguments: args
                };
            }
            else if (callExpr.tag === "id") {
                const callName = callExpr.name;
                var expr;
                if (callName === "print" || callName === "abs") {
                    return {
                        tag: "builtin1",
                        name: callName,
                        arg: args[0]
                    };
                }
                else if (callName === "max" || callName === "min" || callName === "pow") {
                    return {
                        tag: "builtin2",
                        name: callName,
                        left: args[0],
                        right: args[1]
                    };
                }
            }
            return { tag: "call", fn: callExpr, arguments: args };
        case "BinaryExpression":
            c.firstChild(); // go to lhs 
            const lhsExpr = (0, exports.traverseExpr)(c, s, env);
            c.nextSibling(); // go to op
            var opStr = s.substring(c.from, c.to);
            var op;
            switch (opStr) {
                case "+":
                    op = ast_1.BinOp.Plus;
                    break;
                case "-":
                    op = ast_1.BinOp.Minus;
                    break;
                case "*":
                    op = ast_1.BinOp.Mul;
                    break;
                case "//":
                    op = ast_1.BinOp.IDiv;
                    break;
                case "%":
                    op = ast_1.BinOp.Mod;
                    break;
                case "==":
                    op = ast_1.BinOp.Eq;
                    break;
                case "!=":
                    op = ast_1.BinOp.Neq;
                    break;
                case "<=":
                    op = ast_1.BinOp.Lte;
                    break;
                case ">=":
                    op = ast_1.BinOp.Gte;
                    break;
                case "<":
                    op = ast_1.BinOp.Lt;
                    break;
                case ">":
                    op = ast_1.BinOp.Gt;
                    break;
                case "is":
                    op = ast_1.BinOp.Is;
                    break;
                case "and":
                    op = ast_1.BinOp.And;
                    break;
                case "or":
                    op = ast_1.BinOp.Or;
                    break;
                default:
                    throw new Error("Could not parse op at " + c.from + " " + c.to + ": " + s.substring(c.from, c.to));
            }
            c.nextSibling(); // go to rhs
            const rhsExpr = (0, exports.traverseExpr)(c, s, env);
            c.parent();
            return {
                tag: "binop",
                op: op,
                left: lhsExpr,
                right: rhsExpr
            };
        case "ParenthesizedExpression":
            c.firstChild(); // Focus on (
            c.nextSibling(); // Focus on inside
            var expr = (0, exports.traverseExpr)(c, s, env);
            c.parent();
            return expr;
        case "UnaryExpression":
            c.firstChild(); // Focus on op
            var opStr = s.substring(c.from, c.to);
            var op;
            switch (opStr) {
                case "-":
                    op = ast_1.UniOp.Neg;
                    break;
                case "not":
                    op = ast_1.UniOp.Not;
                    break;
                default:
                    throw new Error("Could not parse op at " + c.from + " " + c.to + ": " + s.substring(c.from, c.to));
            }
            c.nextSibling(); // go to expr
            var expr = (0, exports.traverseExpr)(c, s, env);
            c.parent();
            return {
                tag: "uniop",
                op: op,
                expr: expr
            };
        case "MemberExpression":
            c.firstChild(); // Focus on object
            var objExpr = (0, exports.traverseExpr)(c, s, env);
            c.nextSibling(); // Focus on .
            c.nextSibling(); // Focus on property
            var propName = s.substring(c.from, c.to);
            c.parent();
            return {
                tag: "lookup",
                obj: objExpr,
                field: propName
            };
        case "self":
            return {
                tag: "id",
                name: "self"
            };
        case "ConditionalExpression":
            c.firstChild();
            var thn = (0, exports.traverseExpr)(c, s, env);
            c.nextSibling(); //if
            c.nextSibling();
            var cond = (0, exports.traverseExpr)(c, s, env);
            c.nextSibling(); //else
            c.nextSibling();
            var els = (0, exports.traverseExpr)(c, s, env);
            c.parent();
            return { tag: "if-expr", thn, cond, els };
        default:
            throw new Error("Could not parse expr at " + c.from + " " + c.to + ": " + s.substring(c.from, c.to));
    }
}
exports.traverseExprHelper = traverseExprHelper;
function traverseArguments(c, s, env) {
    c.firstChild(); // Focuses on open paren
    const args = [];
    c.nextSibling();
    while (c.type.name !== ")") {
        let expr = (0, exports.traverseExpr)(c, s, env);
        args.push(expr);
        c.nextSibling(); // Focuses on either "," or ")"
        c.nextSibling(); // Focuses on a VariableName
    }
    c.parent(); // Pop to ArgList
    return args;
}
exports.traverseArguments = traverseArguments;
function traverseLambdaParams(c, s) {
    let hasNext = c.firstChild(); // Focuses on open paren
    if (!hasNext) {
        return [];
    }
    const params = [];
    while (hasNext) {
        let paramName = s.substring(c.from, c.to);
        params.push(paramName);
        c.nextSibling(); // Focuses on either "," or ":"
        hasNext = c.nextSibling();
    }
    c.parent(); // Pop to ArgList
    return params;
}
exports.traverseLambdaParams = traverseLambdaParams;
exports.traverseStmt = wrap_locs(traverseStmtHelper);
function traverseStmtHelper(c, s, env) {
    switch (c.node.type.name) {
        case "ReturnStatement":
            c.firstChild(); // Focus return keyword
            var value;
            if (c.nextSibling()) // Focus expression
                value = (0, exports.traverseExpr)(c, s, env);
            else
                value = { tag: "literal", value: { tag: "none" } };
            c.parent();
            return { tag: "return", value };
        case "AssignStatement":
            c.firstChild(); // go to name
            const target = (0, exports.traverseExpr)(c, s, env);
            c.nextSibling(); // go to equals
            c.nextSibling(); // go to value
            var value = (0, exports.traverseExpr)(c, s, env);
            c.parent();
            if (target.tag === "lookup") {
                return {
                    tag: "field-assign",
                    obj: target.obj,
                    field: target.field,
                    value: value
                };
            }
            else if (target.tag === "id") {
                return {
                    tag: "assign",
                    name: target.name,
                    value: value
                };
            }
            else {
                throw new Error("Unknown target while parsing assignment");
            }
        case "ExpressionStatement":
            c.firstChild();
            const expr = (0, exports.traverseExpr)(c, s, env);
            c.parent(); // pop going into stmt
            return { tag: "expr", expr: expr };
        // case "FunctionDefinition":
        //   c.firstChild();  // Focus on def
        //   c.nextSibling(); // Focus on name of function
        //   var name = s.substring(c.from, c.to);
        //   c.nextSibling(); // Focus on ParamList
        //   var parameters = traverseParameters(c, s)
        //   c.nextSibling(); // Focus on Body or TypeDef
        //   let ret : Type = NONE;
        //   if(c.type.name === "TypeDef") {
        //     c.firstChild();
        //     ret = traverseType(c, s);
        //     c.parent();
        //   }
        //   c.firstChild();  // Focus on :
        //   var body = [];
        //   while(c.nextSibling()) {
        //     body.push(traverseStmt(c, s));
        //   }
        // console.log("Before pop to body: ", c.type.name);
        //   c.parent();      // Pop to Body
        // console.log("Before pop to def: ", c.type.name);
        //   c.parent();      // Pop to FunctionDefinition
        //   return {
        //     tag: "fun",
        //     name, parameters, body, ret
        //   }
        case "IfStatement":
            c.firstChild(); // Focus on if
            c.nextSibling(); // Focus on cond
            var cond = (0, exports.traverseExpr)(c, s, env);
            // console.log("Cond:", cond);
            c.nextSibling(); // Focus on : thn
            c.firstChild(); // Focus on :
            var thn = [];
            var els = [];
            while (c.nextSibling()) { // Focus on thn stmts
                thn.push((0, exports.traverseStmt)(c, s, env));
            }
            // console.log("Thn:", thn);
            c.parent();
            if (c.nextSibling()) { // Focus on else
                c.nextSibling(); // Focus on : els
                c.firstChild(); // Focus on :
                while (c.nextSibling()) { // Focus on els stmts
                    els.push((0, exports.traverseStmt)(c, s, env));
                }
                c.parent();
            }
            c.parent();
            return {
                tag: "if",
                cond: cond,
                thn: thn,
                els: els
            };
        case "WhileStatement":
            c.firstChild(); // Focus on while
            c.nextSibling(); // Focus on condition
            var cond = (0, exports.traverseExpr)(c, s, env);
            c.nextSibling(); // Focus on body
            var body = [];
            c.firstChild(); // Focus on :
            while (c.nextSibling()) {
                body.push((0, exports.traverseStmt)(c, s, env));
            }
            c.parent();
            c.parent();
            return {
                tag: "while",
                cond,
                body
            };
        case "PassStatement":
            return { tag: "pass" };
        case "ContinueStatement":
            return { tag: "continue" };
        case "BreakStatement":
            return { tag: "break" };
        case "ForStatement":
            c.firstChild(); // Focus on for
            c.nextSibling(); // Focus on variablename
            if (c.type.name != "VariableName")
                throw new Error("Iterator must be a variable");
            var iterator = s.substring(c.from, c.to); // considering iterator as string
            c.nextSibling(); // Focus on in
            c.nextSibling(); // Focus on values/list
            var values = (0, exports.traverseExpr)(c, s, env);
            c.nextSibling(); // Focus on Body
            var body = [];
            c.firstChild(); // Focus on :
            while (c.nextSibling()) {
                body.push((0, exports.traverseStmt)(c, s, env));
            }
            c.parent();
            c.parent();
            return { tag: "for", iterator, values, body };
        default:
            throw new Error("Could not parse stmt at " + c.node.from + " " + c.node.to + ": " + s.substring(c.from, c.to));
    }
}
exports.traverseStmtHelper = traverseStmtHelper;
function traverseType(c, s, env) {
    switch (c.type.name) {
        case "VariableName":
            let name = s.substring(c.from, c.to);
            switch (name) {
                case "int": return utils_1.NUM;
                case "bool": return utils_1.BOOL;
                default: return (0, utils_1.CLASS)(name);
            }
        case "None": // None is mentionable in Callable types
            return utils_1.NONE;
        case "MemberExpression":
            c.firstChild(); // focus on class
            let cname = s.substring(c.from, c.to).trim();
            if (cname === "Callable") {
                c.nextSibling();
                c.nextSibling();
                const params = traverseTypeList(c, s, env);
                c.nextSibling();
                c.nextSibling();
                const ret = traverseType(c, s, env);
                c.parent();
                // return NONE;
                return (0, utils_1.CALLABLE)(params, ret);
            }
            c.nextSibling(); // focus on [
            c.nextSibling(); // focus on VariableName or ]
            const params = [];
            while (c.type.name !== "]") {
                params.push(traverseType(c, s, env));
                c.nextSibling(); // focus on , or ]
                c.nextSibling(); // focus on VariableName or ]
            }
            c.parent();
            return { tag: "class", name: cname, params };
        default:
            throw new Error("ParseError : Could not parse type");
    }
}
exports.traverseType = traverseType;
function traverseTypeList(c, s, env) {
    // console.error(s.substring(c.from, c.to));
    c.firstChild(); // Focuses on open paren
    const types = [];
    c.nextSibling(); // Focuses on a VariableName
    while (c.type.name !== "]") {
        let typ = traverseType(c, s, env);
        c.nextSibling(); // Focuses on "TypeDef", hopefully, or "," if mistake
        c.nextSibling(); // Move on to comma or ")"
        types.push(typ);
    }
    c.parent(); // Pop to ParamList
    return types;
}
exports.traverseTypeList = traverseTypeList;
exports.traverseParameter = wrap_locs(traverseParameterHelper);
function traverseParameterHelper(c, s, env) {
    let name = s.substring(c.from, c.to);
    c.nextSibling(); // Focuses on "TypeDef", hopefully, or "," if mistake
    let nextTagName = c.type.name; // NOTE(joe): a bit of a hack so the next line doesn't if-split
    if (nextTagName !== "TypeDef") {
        throw new Error("Missed type annotation for parameter " + name);
    }
    ;
    c.firstChild(); // Enter TypeDef
    c.nextSibling(); // Focuses on type itself
    let typ = traverseType(c, s, env);
    c.parent();
    return { name, type: typ };
}
exports.traverseParameterHelper = traverseParameterHelper;
function traverseParameters(c, s, env) {
    c.firstChild(); // Focuses on open paren
    const parameters = [];
    c.nextSibling(); // Focuses on a VariableName
    while (c.type.name !== ")") {
        parameters.push((0, exports.traverseParameter)(c, s, env));
        c.nextSibling(); // Move on to comma or ")"
        c.nextSibling(); // Focuses on a VariableName or 
    }
    c.parent(); // Pop to ParamList
    return parameters;
}
exports.traverseParameters = traverseParameters;
exports.traverseVarInit = wrap_locs(traverseVarInitHelper);
function traverseVarInitHelper(c, s, env) {
    c.firstChild(); // go to name
    var name = s.substring(c.from, c.to);
    c.nextSibling(); // go to : type
    if (c.type.name !== "TypeDef") {
        c.parent();
        throw Error("invalid variable init");
    }
    c.firstChild(); // go to :
    c.nextSibling(); // go to type
    const type = traverseType(c, s, env);
    c.parent();
    c.nextSibling(); // go to =
    c.nextSibling(); // go to value
    var value = (0, exports.traverseLiteral)(c, s, env);
    c.parent();
    return { name, type, value };
}
exports.traverseVarInitHelper = traverseVarInitHelper;
exports.traverseTypeVarInit = wrap_locs(traverseTypeVarInitHelper);
function traverseTypeVarInitHelper(c, s, env) {
    c.firstChild(); // focus on type var name
    var name = s.substring(c.from, c.to).trim();
    c.nextSibling(); // focus on AssignOp
    c.nextSibling(); // focus on CallExpression
    c.firstChild(); // focus on TypeVar
    c.nextSibling(); // focus on ArgList
    c.firstChild(); // Focuses on open parens
    c.nextSibling(); // Focuses on a String | close parens
    let canonicalName = name;
    if (c.type.name === "String") {
        canonicalName = s.substring(c.from + 1, c.to - 1).trim();
        c.nextSibling(); // Focus on or close parens
    }
    if (c.type.name !== ")") {
        throw Error("ParseError : constrained type variables are not supported.");
    }
    c.parent(); // go to ArgList
    c.parent(); // go to CallExpression
    c.parent(); // go to AssigmentStatement
    // TODO : Need to delete this once we have removed types from AST
    const types = [];
    return { name, canonicalName, types };
}
exports.traverseTypeVarInitHelper = traverseTypeVarInitHelper;
function traverseScopeDef(c, s, env) {
    c.firstChild(); // go to scope
    if (c.type.name !== "nonlocal") {
        c.parent();
        throw Error("invalid variable scope");
    }
    c.nextSibling(); // go to name
    const name = s.substring(c.from, c.to);
    c.parent();
    return { name };
}
exports.traverseScopeDef = traverseScopeDef;
exports.traverseFunDef = wrap_locs(traverseFunDefHelper);
function traverseFunDefHelper(c, s, env) {
    c.firstChild(); // Focus on def
    c.nextSibling(); // Focus on name of function
    var name = s.substring(c.from, c.to);
    c.nextSibling(); // Focus on ParamList
    var parameters = traverseParameters(c, s, env);
    c.nextSibling(); // Focus on Body or TypeDef
    let ret = utils_1.NONE;
    if (c.type.name === "TypeDef") {
        c.firstChild();
        ret = traverseType(c, s, env);
        c.parent();
        c.nextSibling();
    }
    c.firstChild(); // Focus on :
    var inits = [];
    var nonlocals = [];
    var children = [];
    var body = [];
    var hasChild = c.nextSibling();
    while (hasChild) {
        if (isVarInit(c, s, env)) {
            inits.push((0, exports.traverseVarInit)(c, s, env));
        }
        else if (isScopeDef(c, s)) {
            nonlocals.push(traverseScopeDef(c, s, env));
        }
        else if (isFunDef(c, s, env)) {
            children.push((0, exports.traverseFunDef)(c, s, env));
        }
        else {
            break;
        }
        hasChild = c.nextSibling();
    }
    while (hasChild) {
        body.push((0, exports.traverseStmt)(c, s, env));
        hasChild = c.nextSibling();
    }
    // console.log("Before pop to body: ", c.type.name);
    c.parent(); // Pop to Body
    // console.log("Before pop to def: ", c.type.name);
    c.parent(); // Pop to FunctionDefinition
    return { name, parameters, ret, inits, body, nonlocals, children };
}
exports.traverseFunDefHelper = traverseFunDefHelper;
function traverseGenericParams(c, s) {
    const typeParams = [];
    if (c.type.name !== "ArgList") {
        return typeParams;
    }
    c.firstChild(); // Focus on (
    c.nextSibling(); // Focus on first argument
    let arg1C = c;
    if (arg1C.type.name !== "MemberExpression") {
        c.parent();
        return typeParams;
    }
    c.firstChild();
    if (s.substring(c.from, c.to).trim() !== "Generic") {
        c.parent();
        c.parent();
        return typeParams;
    }
    c.nextSibling(); // Focus on [
    c.nextSibling(); // Focus on VariableName or ]
    let typeVarC = c;
    while (typeVarC.type.name !== "]") {
        typeParams.push(s.substring(typeVarC.from, typeVarC.to).trim());
        typeVarC.nextSibling(); // Focus on , or ]
        typeVarC.nextSibling(); // Focus on VariableName
    }
    c.parent(); // / Go back to MemberExpression
    c.parent(); // Go back to ArgList
    return typeParams;
}
exports.traverseGenericParams = traverseGenericParams;
exports.traverseClass = wrap_locs(traverseClassHelper);
function traverseClassHelper(c, s, env) {
    const fields = [];
    const methods = [];
    c.firstChild();
    c.nextSibling(); // Focus on class name
    const className = s.substring(c.from, c.to);
    c.nextSibling(); // Focus on arglist/superclass/generic type vars(s)
    const typeParams = traverseGenericParams(c, s);
    c.nextSibling(); // Focus on body
    c.firstChild(); // Focus colon
    while (c.nextSibling()) { // Focuses first field
        if (isVarInit(c, s, env)) {
            fields.push((0, exports.traverseVarInit)(c, s, env));
        }
        else if (isFunDef(c, s, env)) {
            methods.push((0, exports.traverseFunDef)(c, s, env));
        }
        else {
            throw new Error(`Could not parse the body of class: ${className}`);
        }
    }
    c.parent();
    c.parent();
    if (!methods.find(method => method.name === "__init__")) {
        const typeVars = typeParams.map(tp => {
            return (0, utils_1.CLASS)(tp);
        });
        methods.push({ name: "__init__", parameters: [{ name: "self", type: (0, utils_1.CLASS)(className, typeVars) }], ret: utils_1.NONE, inits: [], body: [], nonlocals: [], children: [] });
    }
    return {
        name: className,
        typeParams,
        fields,
        methods
    };
}
exports.traverseClassHelper = traverseClassHelper;
function traverseDefs(c, s, env) {
    const inits = [];
    const funs = [];
    const classes = [];
    while (true) {
        if (isVarInit(c, s, env)) {
            inits.push((0, exports.traverseVarInit)(c, s, env));
        }
        else if (isFunDef(c, s, env)) {
            funs.push((0, exports.traverseFunDef)(c, s, env));
        }
        else if (isClassDef(c, s, env)) {
            classes.push((0, exports.traverseClass)(c, s, env));
        }
        else {
            return [inits, funs, classes];
        }
        c.nextSibling();
    }
}
exports.traverseDefs = traverseDefs;
function isVarInit(c, s, env) {
    if (c.type.name === "AssignStatement") {
        c.firstChild(); // Focus on lhs
        c.nextSibling(); // go to : type
        const isVar = c.type.name === "TypeDef";
        c.parent();
        return isVar;
    }
    else {
        return false;
    }
}
exports.isVarInit = isVarInit;
function isTypeVarInit(c, s) {
    if (c.type.name === "AssignStatement") {
        c.firstChild(); // Focus on lhs
        c.nextSibling(); // go to AssignOp
        c.nextSibling(); // go to CallExpression
        if (c.type.name !== "CallExpression") {
            c.parent();
            return false;
        }
        c.firstChild(); // Focus on TypeVar
        if (c.type.name !== "VariableName" || s.substring(c.from, c.to).trim() !== "TypeVar") {
            c.parent();
            c.parent();
            return false;
        }
        c.parent();
        c.parent();
        return true;
    }
    else {
        return false;
    }
}
exports.isTypeVarInit = isTypeVarInit;
function isScopeDef(c, s) {
    return c.type.name === "ScopeStatement";
}
exports.isScopeDef = isScopeDef;
function isFunDef(c, s, env) {
    return c.type.name === "FunctionDefinition";
}
exports.isFunDef = isFunDef;
function isClassDef(c, s, env) {
    return c.type.name === "ClassDefinition";
}
exports.isClassDef = isClassDef;
exports.traverse = wrap_locs(traverseHelper, true);
function traverseHelper(c, s, env) {
    switch (c.node.type.name) {
        case "Script":
            const inits = [];
            const funs = [];
            const classes = [];
            const stmts = [];
            const typeVarInits = [];
            var hasChild = c.firstChild();
            while (hasChild) {
                if (isVarInit(c, s, env)) {
                    inits.push((0, exports.traverseVarInit)(c, s, env));
                }
                else if (isTypeVarInit(c, s)) {
                    typeVarInits.push((0, exports.traverseTypeVarInit)(c, s, env));
                }
                else if (isFunDef(c, s, env)) {
                    funs.push((0, exports.traverseFunDef)(c, s, env));
                }
                else if (isClassDef(c, s, env)) {
                    classes.push((0, exports.traverseClass)(c, s, env));
                }
                else {
                    break;
                }
                hasChild = c.nextSibling();
            }
            while (hasChild) {
                stmts.push((0, exports.traverseStmt)(c, s, env));
                hasChild = c.nextSibling();
            }
            c.parent();
            return { funs, inits, typeVarInits, classes, stmts };
        default:
            throw new Error("Could not parse program at " + c.node.from + " " + c.node.to);
    }
}
exports.traverseHelper = traverseHelper;
function parse(source) {
    const env = {
        lineBreakIndices: [],
    };
    source += "\n";
    env.lineBreakIndices = [-1];
    for (var i = 0; i < source.length; i++) {
        if (source[i] == '\n') {
            env.lineBreakIndices.push(i);
        }
    }
    const t = python_1.parser.parse(source);
    const str = (0, treeprinter_1.stringifyTree)(t.cursor(), source, 0);
    const ast = (0, exports.traverse)(t.cursor(), source, env);
    return ast;
}
exports.parse = parse;


/***/ }),

/***/ "./repl.ts":
/*!*****************!*\
  !*** ./repl.ts ***!
  \*****************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.BasicREPL = void 0;
const runner_1 = __webpack_require__(/*! ./runner */ "./runner.ts");
const type_check_1 = __webpack_require__(/*! ./type-check */ "./type-check.ts");
const optimization_1 = __webpack_require__(/*! ./optimization */ "./optimization.ts");
const parser_1 = __webpack_require__(/*! ./parser */ "./parser.ts");
const lower_1 = __webpack_require__(/*! ./lower */ "./lower.ts");
class BasicREPL {
    constructor(importObject) {
        this.importObject = importObject;
        if (!importObject.js) {
            const memory = new WebAssembly.Memory({ initial: 2000, maximum: 2000 });
            const view = new Int32Array(memory.buffer);
            view[0] = 4;
            this.importObject.js = { memory: memory };
        }
        this.currentEnv = {
            globals: new Map(),
            classes: new Map(),
            classIndices: new Map(),
            functionNames: new Map(),
            locals: new Set(),
            labels: [],
            offset: 1,
            vtableMethods: []
        };
        this.currentTypeEnv = type_check_1.defaultTypeEnv;
        this.functions = "";
    }
    async run(source) {
        const config = { importObject: this.importObject, env: this.currentEnv, typeEnv: this.currentTypeEnv, functions: this.functions };
        const [result, newEnv, newTypeEnv, newFunctions, instance] = await (0, runner_1.run)(source, config);
        this.currentEnv = newEnv;
        this.currentTypeEnv = newTypeEnv;
        this.functions += newFunctions;
        const currentGlobals = this.importObject.env || {};
        Object.keys(instance.instance.exports).forEach(k => {
            const maybeGlobal = instance.instance.exports[k];
            if (maybeGlobal instanceof WebAssembly.Global) {
                currentGlobals[k] = maybeGlobal;
            }
        });
        this.importObject.env = currentGlobals;
        return result;
    }
    optimize(source) {
        // console.log(stmt);
        const config = { importObject: this.importObject, env: this.currentEnv, typeEnv: this.currentTypeEnv, functions: this.functions };
        const parsed = (0, parser_1.parse)(source);
        const [tprogram, tenv] = (0, type_check_1.tc)(config.typeEnv, parsed);
        const globalEnv = (0, runner_1.augmentEnv)(config.env, tprogram);
        const irprogram = (0, lower_1.lowerProgram)(tprogram, globalEnv);
        if (!this.importObject.js) {
            const memory = new WebAssembly.Memory({ initial: 2000, maximum: 2000 });
            this.importObject.js = { memory: memory };
        }
        return [irprogram, (0, optimization_1.optimizeProgram)(irprogram)];
    }
    tc(source) {
        const config = { importObject: this.importObject, env: this.currentEnv, typeEnv: this.currentTypeEnv, functions: this.functions };
        const parsed = (0, parser_1.parse)(source);
        const [result, _] = (0, type_check_1.tc)(this.currentTypeEnv, parsed);
        return result.a.type;
    }
}
exports.BasicREPL = BasicREPL;


/***/ }),

/***/ "./runner.ts":
/*!*******************!*\
  !*** ./runner.ts ***!
  \*******************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

// This is a mashup of tutorials from:
//
// - https://github.com/AssemblyScript/wabt.js/
// - https://developer.mozilla.org/en-US/docs/WebAssembly/Using_the_JavaScript_API
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.run = exports.augmentEnv = exports.runWat = void 0;
const wabt_1 = __importDefault(__webpack_require__(/*! wabt */ "wabt"));
const compiler_1 = __webpack_require__(/*! ./compiler */ "./compiler.ts");
const parser_1 = __webpack_require__(/*! ./parser */ "./parser.ts");
const type_check_1 = __webpack_require__(/*! ./type-check */ "./type-check.ts");
const utils_1 = __webpack_require__(/*! ./utils */ "./utils.ts");
const lower_1 = __webpack_require__(/*! ./lower */ "./lower.ts");
const monomorphizer_1 = __webpack_require__(/*! ./monomorphizer */ "./monomorphizer.ts");
const optimization_1 = __webpack_require__(/*! ./optimization */ "./optimization.ts");
const errors_1 = __webpack_require__(/*! ./errors */ "./errors.ts");
// NOTE(joe): This is a hack to get the CLI Repl to run. WABT registers a global
// uncaught exn handler, and this is not allowed when running the REPL
// (https://nodejs.org/api/repl.html#repl_global_uncaught_exceptions). No reason
// is given for this in the docs page, and I haven't spent time on the domain
// module to figure out what's going on here. It doesn't seem critical for WABT
// to have this support, so we patch it away.
if (typeof process !== "undefined") {
    const oldProcessOn = process.on;
    process.on = (...args) => {
        if (args[0] === "uncaughtException") {
            return;
        }
        else {
            return oldProcessOn.apply(process, args);
        }
    };
}
async function runWat(source, importObject) {
    const wabtInterface = await (0, wabt_1.default)();
    const myModule = wabtInterface.parseWat("test.wat", source);
    var asBinary = myModule.toBinary({});
    var wasmModule = await WebAssembly.instantiate(asBinary.buffer, importObject);
    const result = wasmModule.instance.exports.exported_func();
    return [result, wasmModule];
}
exports.runWat = runWat;
function augmentEnv(env, prog) {
    const newGlobals = new Map(env.globals);
    const newClasses = new Map(env.classes);
    const newClassIndices = new Map(env.classIndices);
    const functionNames = new Map(env.functionNames);
    var newOffset = env.offset;
    prog.inits.forEach((v) => {
        newGlobals.set(v.name, true);
    });
    prog.funs.forEach(f => {
        functionNames.set(f.name, (0, lower_1.closureName)(f.name, []));
        const addClasses = (f, ancestors) => {
            newClasses.set((0, lower_1.closureName)(f.name, ancestors), new Map());
            f.children.forEach(c => addClasses(c, [f, ...ancestors]));
        };
        addClasses(f, []);
    });
    prog.classes.forEach(cls => {
        const classFields = new Map();
        cls.fields.forEach((field, i) => classFields.set(field.name, [i + 1, field.value]));
        newClasses.set(cls.name, classFields);
    });
    return {
        globals: newGlobals,
        classes: newClasses,
        classIndices: newClassIndices,
        functionNames,
        locals: env.locals,
        labels: env.labels,
        offset: newOffset,
        vtableMethods: env.vtableMethods,
    };
}
exports.augmentEnv = augmentEnv;
// export async function run(source : string, config: Config) : Promise<[Value, compiler.GlobalEnv, GlobalTypeEnv, string]> {
async function run(source, config) {
    config.importObject.errors.src = source; // for error reporting
    const parsed = (0, parser_1.parse)(source);
    const [tprogram, tenv] = (0, type_check_1.tc)(config.typeEnv, parsed);
    const tmprogram = (0, monomorphizer_1.monomorphizeProgram)(tprogram);
    const globalEnv = augmentEnv(config.env, tmprogram);
    const irprogram = (0, lower_1.lowerProgram)(tmprogram, globalEnv);
    const optIr = (0, optimization_1.optimizeProgram)(irprogram);
    const progTyp = tmprogram.a.type;
    var returnType = "";
    var returnExpr = "";
    // const lastExpr = parsed.stmts[parsed.stmts.length - 1]
    // const lastExprTyp = lastExpr.a;
    // console.log("LASTEXPR", lastExpr);
    if (progTyp !== utils_1.NONE) {
        returnType = "(result i32)";
        returnExpr = "(local.get $$last)";
    }
    let globalsBefore = config.env.globals;
    // const compiled = compiler.compile(tprogram, config.env);
    const compiled = (0, compiler_1.compile)(optIr, globalEnv);
    const vtable = `(table ${globalEnv.vtableMethods.length} funcref)
    (elem (i32.const 0) ${globalEnv.vtableMethods.map(method => `$${method[0]}`).join(" ")})`;
    const typeSet = new Set();
    globalEnv.vtableMethods.forEach(([_, paramNum]) => typeSet.add(paramNum));
    let types = "";
    typeSet.forEach(paramNum => {
        let paramType = "";
        if (paramNum > 0) {
            paramType = `(param${" i32".repeat(paramNum)})`;
        }
        types += `(type ${(0, utils_1.makeWasmFunType)(paramNum)} (func ${paramType} (result i32)))\n`;
    });
    const globalImports = [...globalsBefore.keys()].map(name => `(import "env" "${name}" (global $${name} (mut i32)))`).join("\n");
    const globalDecls = compiled.globals.map(name => `(global $${name} (export "${name}") (mut i32) (i32.const 0))`).join("\n");
    const importObject = config.importObject;
    if (!importObject.js) {
        const memory = new WebAssembly.Memory({ initial: 2000, maximum: 2000 });
        importObject.js = { memory: memory };
    }
    const wasmSource = `(module
    (import "js" "memory" (memory 1))
    ${errors_1.wasmErrorImports}
    (func $print_num (import "imports" "print_num") (param i32) (result i32))
    (func $print_bool (import "imports" "print_bool") (param i32) (result i32))
    (func $print_none (import "imports" "print_none") (param i32) (result i32))
    (func $abs (import "imports" "abs") (param i32) (result i32))
    (func $min (import "imports" "min") (param i32) (param i32) (result i32))
    (func $max (import "imports" "max") (param i32) (param i32) (result i32))
    (func $pow (import "imports" "pow") (param i32) (param i32) (result i32))
    (func $alloc (import "libmemory" "alloc") (param i32) (result i32))
    (func $load (import "libmemory" "load") (param i32) (param i32) (result i32))
    (func $store (import "libmemory" "store") (param i32) (param i32) (param i32))
    (func $$add (import "imports" "$add") (param i32) (param i32) (result i32))
    (func $$sub (import "imports" "$sub") (param i32) (param i32) (result i32))
    (func $$mul (import "imports" "$mul") (param i32) (param i32) (result i32))
    (func $$div (import "imports" "$div") (param i32) (param i32) (result i32))
    (func $$mod (import "imports" "$mod") (param i32) (param i32) (result i32))
    (func $$eq (import "imports" "$eq") (param i32) (param i32) (result i32))
    (func $$neq (import "imports" "$neq") (param i32) (param i32) (result i32))
    (func $$lte (import "imports" "$lte") (param i32) (param i32) (result i32))
    (func $$gte (import "imports" "$gte") (param i32) (param i32) (result i32))
    (func $$lt (import "imports" "$lt") (param i32) (param i32) (result i32))
    (func $$gt (import "imports" "$gt") (param i32) (param i32) (result i32))
    ${types}
    ${globalImports}
    ${globalDecls}
    ${vtable}
    ${config.functions}
    ${compiled.functions}
    (func (export "exported_func") ${returnType}
      ${compiled.mainSource}
      ${returnExpr}
    )
  )`;
    const [result, instance] = await runWat(wasmSource, importObject);
    return [(0, utils_1.PyValue)(progTyp, result), compiled.newEnv, tenv, compiled.functions, instance];
}
exports.run = run;


/***/ }),

/***/ "./treeprinter.ts":
/*!************************!*\
  !*** ./treeprinter.ts ***!
  \************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.stringifyTree = void 0;
function stringifyTree(t, source, d) {
    var str = "";
    var spaces = " ".repeat(d * 2);
    str += spaces + t.type.name;
    if (["Number", "CallExpression", "BinaryExpression", "UnaryExpression", "ArithOp", "VariableName"].includes(t.type.name)) {
        str += " --> " + source.substring(t.from, t.to);
    }
    str += "\n";
    if (t.firstChild()) {
        do {
            str += stringifyTree(t, source, d + 1);
        } while (t.nextSibling());
        t.parent();
    }
    return str;
}
exports.stringifyTree = stringifyTree;


/***/ }),

/***/ "./type-check.ts":
/*!***********************!*\
  !*** ./type-check.ts ***!
  \***********************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.tcIterator = exports.tcLiteral = exports.tcExpr = exports.tcStmt = exports.tcBlock = exports.tcClass = exports.tcTypeVars = exports.resolveTypeTypeParams = exports.resolveParameterTypeParams = exports.resolveFunDefTypeParams = exports.resolveVarInitTypeParams = exports.resolveClassTypeParams = exports.tcGenericClass = exports.tcDef = exports.tcInit = exports.tc = exports.augmentTEnv = exports.specializeType = exports.specializeMethodType = exports.specializeFieldType = exports.isValidType = exports.join = exports.isAssignable = exports.isSubtype = exports.isNoneOrClassOrCallable = exports.equalType = exports.equalTypeParams = exports.equalCallable = exports.emptyLocalTypeEnv = exports.emptyGlobalTypeEnv = exports.defaultTypeEnv = exports.TypeCheckError = void 0;
const ast_1 = __webpack_require__(/*! ./ast */ "./ast.ts");
const utils_1 = __webpack_require__(/*! ./utils */ "./utils.ts");
const errors_1 = __webpack_require__(/*! ./errors */ "./errors.ts");
// I  TypeScript: https://github.com/microsoft/TypeScript/issues/13965
class TypeCheckError extends Error {
    constructor(SRC, message, a) {
        const fromLoc = a?.fromLoc;
        const endLoc = a?.endLoc;
        const eolLoc = a?.eolLoc;
        const trueProto = new.target.prototype;
        const loc = (a) ? ` on line ${fromLoc.row} at col ${fromLoc.col}` : '';
        const src = (a) ? (0, errors_1.fullSrcLine)(SRC, fromLoc.srcIdx, fromLoc.col, eolLoc.srcIdx) : '';
        // TODO: how to draw squigglies if the error spans multiple lines?
        const squiggly = (a) ? (0, errors_1.drawSquiggly)(fromLoc.row, endLoc.row, fromLoc.col, endLoc.col) : '';
        const msg = `\n\n${src}\n${squiggly}`;
        const res = "TYPE ERROR: " + message + loc + msg;
        super(res);
        this.a = (a) ?? undefined;
        this.errMsg = res;
        // Alternatively use Object.setPrototypeOf if you have an ES6 environment.
        this.__proto__ = trueProto;
    }
    getA() {
        return this.a;
    }
    getErrMsg() {
        return this.errMsg;
    }
}
exports.TypeCheckError = TypeCheckError;
const copyLocals = (locals) => {
    return {
        ...locals,
        vars: new Map(locals.vars)
    };
};
const copyGlobals = (env) => {
    return {
        globals: new Map(env.globals),
        functions: new Map(env.functions),
        classes: new Map(env.classes),
        typevars: new Map(env.typevars)
    };
};
const defaultGlobalFunctions = new Map();
defaultGlobalFunctions.set("abs", [[utils_1.NUM], utils_1.NUM]);
defaultGlobalFunctions.set("max", [[utils_1.NUM, utils_1.NUM], utils_1.NUM]);
defaultGlobalFunctions.set("min", [[utils_1.NUM, utils_1.NUM], utils_1.NUM]);
defaultGlobalFunctions.set("pow", [[utils_1.NUM, utils_1.NUM], utils_1.NUM]);
defaultGlobalFunctions.set("print", [[(0, utils_1.CLASS)("object")], utils_1.NUM]);
exports.defaultTypeEnv = {
    globals: new Map(),
    functions: defaultGlobalFunctions,
    classes: new Map(),
    typevars: new Map()
};
function emptyGlobalTypeEnv() {
    return {
        globals: new Map(),
        functions: new Map(),
        classes: new Map(),
        typevars: new Map()
    };
}
exports.emptyGlobalTypeEnv = emptyGlobalTypeEnv;
function emptyLocalTypeEnv() {
    return {
        vars: new Map(),
        expectedRet: utils_1.NONE,
        actualRet: utils_1.NONE,
        topLevel: true
    };
}
exports.emptyLocalTypeEnv = emptyLocalTypeEnv;
// combine the elements of two arrays into an array of tuples.
// DANGER: throws an error if argument arrays don't have the same length.
function zip(l1, l2) {
    if (l1.length !== l2.length) {
        throw new TypeCheckError(`Tried to zip two arrays of different length`);
    }
    return l1.map((el, i) => [el, l2[i]]);
}
function equalCallable(t1, t2) {
    return t1.params.length === t2.params.length &&
        t1.params.every((param, i) => equalType(param, t2.params[i])) && equalType(t1.ret, t2.ret);
}
exports.equalCallable = equalCallable;
// Check if a list of type-parameters are equal.
function equalTypeParams(params1, params2) {
    if (params1.length !== params2.length) {
        return false;
    }
    return zip(params1, params2).reduce((isEqual, [p1, p2]) => {
        return isEqual && equalType(p1, p2);
    }, true);
}
exports.equalTypeParams = equalTypeParams;
function equalType(t1, t2) {
    return (t1 === t2 ||
        (t1.tag === "class" && t2.tag === "class" && t1.name === t2.name) ||
        (t1.tag === "callable" && t2.tag === "callable" && equalCallable(t1, t2)) ||
        (t1.tag === "typevar" && t2.tag === "typevar" && t1.name === t2.name));
}
exports.equalType = equalType;
function isNoneOrClassOrCallable(t) {
    return t.tag === "none" || t.tag === "class" || t.tag === "callable";
}
exports.isNoneOrClassOrCallable = isNoneOrClassOrCallable;
function isSubtype(env, t1, t2) {
    return equalType(t1, t2) || t1.tag === "none" && (t2.tag === "class" || t2.tag === "callable");
}
exports.isSubtype = isSubtype;
function isAssignable(env, t1, t2) {
    return isSubtype(env, t1, t2);
}
exports.isAssignable = isAssignable;
function join(env, t1, t2) {
    return utils_1.NONE;
}
exports.join = join;
// Test if a type is valid and does not have any undefined/non-existent
// classes and that all instantiated type-parameters are valid.
function isValidType(env, t) {
    // primitive types are valid types.
    if (t.tag === "number" || t.tag === "bool" || t.tag === "none") {
        return true;
    }
    // TODO: haven't taken the time to understand what either is, 
    // but considering it always valid for now.
    if (t.tag === "either") {
        return true;
    }
    // TODO: type-variables always valid types in this context ?
    if (t.tag === "typevar") {
        return true;
    }
    if (t.tag === "callable") {
        // TODO: actually check if callable is valid
        return true;
    }
    // TODO: handle all other newer non-class types here
    // At this point we know t is a CLASS
    if (!env.classes.has(t.name)) {
        return false;
    }
    let [_fieldsTy, _methodsTy, typeparams] = env.classes.get(t.name);
    if (t.params.length !== typeparams.length) {
        return false;
    }
    return zip(typeparams, t.params).reduce((isValid, [typevar, typeparam]) => {
        return isValid && isValidType(env, typeparam);
    }, true);
}
exports.isValidType = isValidType;
// Populate the instantiated type-parameters of the class type objTy in
// field type fieldTy. This replaces typevars in fieldTy with their concrete
// instantiations from objTy. Uninstantiated type-parameters are left as typevars.
function specializeFieldType(env, objTy, fieldTy) {
    if (objTy.tag !== "class") {
        // TODO: should we throw an error here ?
        // Don't think this should ever happen unless
        // something is really wrong.
        return fieldTy;
    }
    if (objTy.params.length === 0) {
        // classes without type parameters
        // do not need and specialization.
        return fieldTy;
    }
    // get a list of type-parameters of the class.
    let [_fields, _methods, typeparams] = env.classes.get(objTy.name);
    // create a mapping from the type-parameter name to the corresponding instantiated type.
    let map = new Map(zip(typeparams, objTy.params)); //.filter(([_typevar, typeparam]) => typeparam.tag !== "typevar"));
    return specializeType(map, fieldTy);
}
exports.specializeFieldType = specializeFieldType;
// Populate the instantiated type-parameters of the class type objTy in
// the method type given by argTypes and retType.
function specializeMethodType(env, objTy, [argTypes, retType]) {
    if (objTy.tag !== "class") {
        // TODO: should we throw an error here ?
        // Don't think this should ever happen unless
        // something is really wrong.
        return [argTypes, retType];
    }
    if (objTy.params.length === 0) {
        // classes without type parameters
        // do not need and specialization.
        return [argTypes, retType];
    }
    let [_fields, _methods, typeparams] = env.classes.get(objTy.name);
    let map = new Map(zip(typeparams, objTy.params)); //.filter(([_typevar, typeparam]) => typeparam.tag !== "typevar"));
    let specializedRetType = specializeType(map, retType);
    let specializedArgTypes = argTypes.map(argType => specializeType(map, argType));
    return [specializedArgTypes, specializedRetType];
}
exports.specializeMethodType = specializeMethodType;
// Replace typevars based on the environment mapping the typevars
// to their current instantiated types.
function specializeType(env, t) {
    // primitive types cannot be specialized any further.
    if (t.tag === "either" || t.tag === "none" || t.tag === "bool" || t.tag === "number") {
        return t;
    }
    if (t.tag === "typevar") {
        if (!env.has(t.name)) {
            // Uninstantiated typevars are left as is.
            return t;
        }
        return env.get(t.name);
    }
    if (t.tag === "callable") {
        // TODO: Actually specialize the callable
        return t;
    }
    // at this point t has to be a class type
    let specializedParams = t.params.map(p => specializeType(env, p));
    return (0, utils_1.CLASS)(t.name, specializedParams);
}
exports.specializeType = specializeType;
function augmentTEnv(env, program) {
    const newGlobs = new Map(env.globals);
    const newFuns = new Map(env.functions);
    const newClasses = new Map(env.classes);
    const newTypevars = new Map(env.typevars);
    program.inits.forEach(init => newGlobs.set(init.name, init.type));
    program.funs.forEach(fun => newGlobs.set(fun.name, (0, utils_1.CALLABLE)(fun.parameters.map(p => p.type), fun.ret)));
    program.classes.forEach(cls => {
        const fields = new Map();
        const methods = new Map();
        cls.fields.forEach(field => fields.set(field.name, field.type));
        cls.methods.forEach(method => methods.set(method.name, [method.parameters.map(p => p.type), method.ret]));
        const typeParams = cls.typeParams;
        newClasses.set(cls.name, [fields, methods, [...typeParams]]);
    });
    program.typeVarInits.forEach(tv => {
        if (newGlobs.has(tv.name) || newTypevars.has(tv.name) || newClasses.has(tv.name)) {
            throw new TypeCheckError(`Duplicate identifier '${tv.name}' for type-variable`);
        }
        newTypevars.set(tv.name, [tv.canonicalName]);
    });
    return { globals: newGlobs, functions: newFuns, classes: newClasses, typevars: newTypevars };
}
exports.augmentTEnv = augmentTEnv;
function tc(env, program) {
    const SRC = program.a.src;
    const locals = emptyLocalTypeEnv();
    const newEnv = augmentTEnv(env, program);
    const tTypeVars = program.typeVarInits.map(tv => tcTypeVars(newEnv, tv, SRC));
    const tInits = program.inits.map(init => tcInit(newEnv, init, SRC));
    const tDefs = program.funs.map(fun => tcDef(newEnv, fun, new Map(), SRC));
    const tClasses = program.classes.map(cls => {
        if (cls.typeParams.length === 0) {
            return tcClass(newEnv, cls, SRC);
        }
        else {
            let rCls = resolveClassTypeParams(newEnv, cls);
            return tcGenericClass(newEnv, rCls, SRC);
        }
    });
    // program.inits.forEach(init => env.globals.set(init.name, tcInit(init)));
    // program.funs.forEach(fun => env.functions.set(fun.name, [fun.parameters.map(p => p.type), fun.ret]));
    // program.funs.forEach(fun => tcDef(env, fun));
    // Strategy here is to allow tcBlock to populate the locals, then copy to the
    // global env afterwards (tcBlock changes locals)
    const tBody = tcBlock(newEnv, locals, program.stmts, SRC);
    var lastTyp = utils_1.NONE;
    if (tBody.length) {
        lastTyp = tBody[tBody.length - 1].a.type;
    }
    // TODO(joe): check for assignment in existing env vs. new declaration
    // and look for assignment consistency
    for (let name of locals.vars.keys()) {
        newEnv.globals.set(name, locals.vars.get(name));
    }
    const aprogram = { a: { ...program.a, type: lastTyp }, inits: tInits, funs: tDefs, classes: tClasses, stmts: tBody, typeVarInits: tTypeVars };
    return [aprogram, newEnv];
}
exports.tc = tc;
function tcInit(env, init, SRC) {
    if (!isValidType(env, init.type)) {
        throw new TypeCheckError(SRC, `Invalid type annotation '${JSON.stringify(init.type)}' for '${init.name}'`);
    }
    if (init.type.tag === "typevar") {
        if (init.value.tag !== "zero") {
            throw new TypeCheckError(SRC, `Generic variables must be initialized with __ZERO__`);
        }
        return { ...init, a: { ...init.a, type: utils_1.NONE } };
    }
    const valTyp = tcLiteral(init.value);
    if (isAssignable(env, valTyp, init.type)) {
        return { ...init, a: { ...init.a, type: utils_1.NONE } };
    }
    else {
        throw new TypeCheckError(SRC, `Expected type ${JSON.stringify(init.type.tag)}; got type ${JSON.stringify(valTyp.tag)}`, init.value.a);
    }
}
exports.tcInit = tcInit;
function tcDef(env, fun, nonlocalEnv, SRC) {
    var locals = emptyLocalTypeEnv();
    locals.vars.set(fun.name, (0, utils_1.CALLABLE)(fun.parameters.map(x => x.type), fun.ret));
    locals.expectedRet = fun.ret;
    locals.topLevel = false;
    fun.parameters.forEach(p => {
        if (!isValidType(env, p.type)) {
            throw new TypeCheckError(SRC, `Invalid type annotation '${JSON.stringify(p.type)}' for parameter '${p.name}' in function '${fun.name}'`);
        }
        locals.vars.set(p.name, p.type);
    });
    var nonlocals = fun.nonlocals.map(init => ({ name: init.name, a: { ...init.a, type: nonlocalEnv.get(init.name) } }));
    fun.parameters.forEach(p => locals.vars.set(p.name, p.type));
    fun.inits.forEach(init => locals.vars.set(init.name, tcInit(env, init, SRC).type));
    nonlocals.forEach(init => locals.vars.set(init.name, init.a.type));
    var envCopy = copyGlobals(env);
    fun.children.forEach(f => envCopy.functions.set(f.name, [f.parameters.map(x => x.type), f.ret]));
    var children = fun.children.map(f => tcDef(envCopy, f, locals.vars, SRC));
    fun.children.forEach(child => locals.vars.set(child.name, (0, utils_1.CALLABLE)(child.parameters.map(x => x.type), child.ret)));
    const tBody = tcBlock(envCopy, locals, fun.body, SRC);
    if (!isAssignable(envCopy, locals.actualRet, locals.expectedRet))
        // TODO: what locations to be reported here?
        throw new TypeCheckError(`expected return type of block: ${JSON.stringify(locals.expectedRet)} does not match actual return type: ${JSON.stringify(locals.actualRet)}`);
    return { ...fun, a: { ...fun.a, type: utils_1.NONE }, body: tBody, nonlocals, children };
}
exports.tcDef = tcDef;
// Generic classes are type-checked by treating all typevars as completely unconstrained
// types that we do not know anything about.
function tcGenericClass(env, cls, SRC) {
    // ensure all type parameters are defined as type variables
    cls.typeParams.forEach(param => {
        if (!env.typevars.has(param)) {
            throw new TypeCheckError(SRC, `undefined type variable ${param} used in definition of class ${cls.name}`);
        }
    });
    return tcClass(env, cls, SRC);
}
exports.tcGenericClass = tcGenericClass;
function resolveClassTypeParams(env, cls) {
    let [fieldsTy, methodsTy, typeparams] = env.classes.get(cls.name);
    let newFieldsTy = new Map(Array.from(fieldsTy.entries()).map(([name, type]) => {
        let [_, newType] = resolveTypeTypeParams(cls.typeParams, type);
        return [name, newType];
    }));
    let newMethodsTy = new Map(Array.from(methodsTy.entries()).map(([name, [params, ret]]) => {
        let [_, newRet] = resolveTypeTypeParams(cls.typeParams, ret);
        let newParams = params.map(p => {
            let [_, newP] = resolveTypeTypeParams(cls.typeParams, p);
            return newP;
        });
        return [name, [newParams, newRet]];
    }));
    env.classes.set(cls.name, [newFieldsTy, newMethodsTy, typeparams]);
    let newFields = cls.fields.map(field => resolveVarInitTypeParams(cls.typeParams, field));
    let newMethods = cls.methods.map(method => resolveFunDefTypeParams(cls.typeParams, method));
    return { ...cls, fields: newFields, methods: newMethods };
}
exports.resolveClassTypeParams = resolveClassTypeParams;
function resolveVarInitTypeParams(env, init) {
    let [_, newType] = resolveTypeTypeParams(env, init.type);
    return { ...init, type: newType };
}
exports.resolveVarInitTypeParams = resolveVarInitTypeParams;
function resolveFunDefTypeParams(env, fun) {
    let newParameters = fun.parameters.map(p => resolveParameterTypeParams(env, p));
    let [_, newRet] = resolveTypeTypeParams(env, fun.ret);
    let newInits = fun.inits.map(i => resolveVarInitTypeParams(env, i));
    return { ...fun, ret: newRet, parameters: newParameters, inits: newInits };
}
exports.resolveFunDefTypeParams = resolveFunDefTypeParams;
function resolveParameterTypeParams(env, param) {
    let [_, newType] = resolveTypeTypeParams(env, param.type);
    return { ...param, type: newType };
}
exports.resolveParameterTypeParams = resolveParameterTypeParams;
function resolveTypeTypeParams(env, type) {
    if (type.tag !== "class") {
        return [false, type];
    }
    if (env.indexOf(type.name) !== -1) {
        return [true, (0, utils_1.TYPEVAR)(type.name)];
    }
    let newParams = type.params.map((p) => {
        let [_, newType] = resolveTypeTypeParams(env, p);
        return newType;
    });
    return [true, { ...type, params: newParams }];
}
exports.resolveTypeTypeParams = resolveTypeTypeParams;
function tcTypeVars(env, tv, SRC) {
    return { ...tv, a: { ...tv.a, type: utils_1.NONE } };
}
exports.tcTypeVars = tcTypeVars;
function tcClass(env, cls, SRC) {
    const tFields = cls.fields.map(field => tcInit(env, field, SRC));
    const tMethods = cls.methods.map(method => tcDef(env, method, new Map(), SRC));
    const init = cls.methods.find(method => method.name === "__init__"); // we'll always find __init__
    const tParams = cls.typeParams.map(utils_1.TYPEVAR);
    if (init.parameters.length !== 1 ||
        init.parameters[0].name !== "self" ||
        !equalType(init.parameters[0].type, (0, utils_1.CLASS)(cls.name, tParams)) ||
        init.ret !== utils_1.NONE) {
        const reason = (init.parameters.length !== 1) ? `${init.parameters.length} parameters` :
            (init.parameters[0].name !== "self") ? `parameter name ${init.parameters[0].name}` :
                (!equalType(init.parameters[0].type, (0, utils_1.CLASS)(cls.name))) ? `parameter type ${JSON.stringify(init.parameters[0].type.tag)}` :
                    (init.ret !== utils_1.NONE) ? `return type ${JSON.stringify(init.ret.tag)}` : "unknown reason";
        throw new TypeCheckError(SRC, `__init__ takes 1 parameter \`self\` of the same type of the class \`${cls.name}\` with return type of \`None\`, got ${reason}`, init.a);
    }
    return { a: { ...cls.a, type: utils_1.NONE }, name: cls.name, fields: tFields, methods: tMethods, typeParams: cls.typeParams };
}
exports.tcClass = tcClass;
function tcBlock(env, locals, stmts, SRC) {
    var tStmts = stmts.map(stmt => tcStmt(env, locals, stmt, SRC));
    return tStmts;
}
exports.tcBlock = tcBlock;
function tcStmt(env, locals, stmt, SRC) {
    switch (stmt.tag) {
        case "assign":
            const tValExpr = tcExpr(env, locals, stmt.value, SRC);
            var nameTyp;
            if (locals.vars.has(stmt.name)) {
                nameTyp = locals.vars.get(stmt.name);
            }
            else if (env.globals.has(stmt.name)) {
                nameTyp = env.globals.get(stmt.name);
            }
            else {
                throw new TypeCheckError(SRC, "Unbound id: " + stmt.name);
            }
            // TODO: this is an ugly temporary hack for generic constructor
            // calls until explicit annotations are supported.
            // Until then constructors for generic classes are properly checked only
            // when directly assigned to variables and will fail in unexpected ways otherwise.
            if (nameTyp.tag === 'class' && nameTyp.params.length !== 0 && tValExpr.a.type.tag === 'class' && tValExpr.a.type.name === nameTyp.name && tValExpr.tag === 'construct') {
                // it would have been impossible for the inner type-checking
                // code to properly infer and fill in the type parameters for
                // the constructor call. So we copy it from the type of the variable
                // we are assigning to.
                tValExpr.a.type.params = [...nameTyp.params];
            }
            if (!isAssignable(env, tValExpr.a.type, nameTyp))
                throw new TypeCheckError(SRC, `Assignment value should have assignable type to type ${JSON.stringify(nameTyp.tag)}, got ${JSON.stringify(tValExpr.a.type.tag)}`, tValExpr.a);
            return { a: { ...stmt.a, type: utils_1.NONE }, tag: stmt.tag, name: stmt.name, value: tValExpr };
        case "expr":
            const tExpr = tcExpr(env, locals, stmt.expr, SRC);
            return { a: tExpr.a, tag: stmt.tag, expr: tExpr };
        case "if":
            var tCond = tcExpr(env, locals, stmt.cond, SRC);
            const tThn = tcBlock(env, locals, stmt.thn, SRC);
            const thnTyp = locals.actualRet;
            locals.actualRet = utils_1.NONE;
            const tEls = tcBlock(env, locals, stmt.els, SRC);
            const elsTyp = locals.actualRet;
            if (tCond.a.type !== utils_1.BOOL)
                throw new TypeCheckError(SRC, `Condition Expression Must be have type "bool", got ${JSON.stringify(tCond.a.type.tag)}`, tCond.a);
            if (thnTyp !== elsTyp)
                locals.actualRet = { tag: "either", left: thnTyp, right: elsTyp };
            return { a: { ...stmt.a, type: thnTyp }, tag: stmt.tag, cond: tCond, thn: tThn, els: tEls };
        case "return":
            if (locals.topLevel)
                // TODO: error reporting for checking returns
                throw new TypeCheckError(SRC, "cannot return outside of functions");
            const tRet = tcExpr(env, locals, stmt.value, SRC);
            if (!isAssignable(env, tRet.a.type, locals.expectedRet))
                throw new TypeCheckError(SRC, "expected return type `" + locals.expectedRet.tag + "`; got type `" + tRet.a.type.tag + "`", stmt.a); // returning the loc of the entire return statement here because the retExpr might be empty
            locals.actualRet = tRet.a.type;
            return { a: tRet.a, tag: stmt.tag, value: tRet };
        case "while":
            var tCond = tcExpr(env, locals, stmt.cond, SRC);
            const tBody = tcBlock(env, locals, stmt.body, SRC);
            if (!equalType(tCond.a.type, utils_1.BOOL))
                throw new TypeCheckError(SRC, `Condition Expression Must be a bool, got ${JSON.stringify(tCond.a.type.tag)}`, tCond.a);
            return { a: { ...stmt.a, type: utils_1.NONE }, tag: stmt.tag, cond: tCond, body: tBody };
        case "pass":
            return { a: { ...stmt.a, type: utils_1.NONE }, tag: stmt.tag };
        case "break":
        case "continue":
            return { a: { ...stmt.a, type: utils_1.NONE }, tag: stmt.tag };
        case "for":
            var tIterator = tcIterator(env, locals, stmt.iterator);
            var tValObject = tcExpr(env, locals, stmt.values, SRC);
            if (tValObject.a.type.tag !== "class")
                throw new TypeCheckError("values require an object");
            if (!env.classes.has(tValObject.a.type.name))
                throw new TypeCheckError("values on an unknown class");
            const [__, methods] = env.classes.get(tValObject.a.type.name);
            if (!(methods.has("hasnext")) || methods.get("hasnext")[1].tag != utils_1.BOOL.tag)
                throw new TypeCheckError(SRC, "iterable class must have hasnext method with boolean return type");
            if (!(methods.has("next"))) {
                throw new TypeCheckError(SRC, "No next method");
            }
            const methodType = specializeMethodType(env, tValObject.a.type, methods.get("next"));
            if (!equalType(methodType[1], tIterator)) {
                throw new TypeCheckError(SRC, "iterable class must have next method with same return type as iterator");
            }
            if (!(methods.has("reset")) || methods.get("reset")[1].tag != utils_1.NONE.tag)
                throw new TypeCheckError(SRC, "iterable class must have reset method with none return type");
            const tforBody = tcBlock(env, locals, stmt.body, SRC);
            return { a: { ...stmt.a, type: tIterator }, tag: stmt.tag, iterator: stmt.iterator, values: tValObject, body: tforBody };
        case "field-assign":
            var tObj = tcExpr(env, locals, stmt.obj, SRC);
            const tVal = tcExpr(env, locals, stmt.value, SRC);
            if (tObj.a.type.tag !== "class")
                throw new TypeCheckError(SRC, `field assignments require an object, got ${JSON.stringify(tObj.a.type.tag)}`, tObj.a);
            if (!env.classes.has(tObj.a.type.name))
                throw new TypeCheckError(SRC, `field assignment on an unknown class \`${tObj.a.type.name}\``, tObj.a);
            const [fields, _] = env.classes.get(tObj.a.type.name);
            if (!fields.has(stmt.field))
                throw new TypeCheckError(SRC, `could not find field \`${stmt.field}\` in class \`${tObj.a.type.name}\``, stmt.a);
            let fieldTy = specializeFieldType(env, tObj.a.type, fields.get(stmt.field));
            // TODO: this is an ugly temporary hack for generic constructor
            // calls until explicit annotations are supported.
            // Until then constructors for generic classes are properly checked only
            // when directly assigned to fields and will fail in unexpected ways otherwise.
            if (fieldTy.tag === "class" && fieldTy.params.length !== 0 && tVal.a.type.tag === 'class' && tVal.a.type.name === fieldTy.name && tVal.tag === 'construct') {
                // it would have been impossible for the inner type-checking
                // code to properly infer and fill in the type parameters for
                // the constructor call. So we copy it from the type of the field
                // we are assigning to.
                tVal.a.type.params = [...fieldTy.params];
            }
            if (!isAssignable(env, tVal.a.type, fieldTy))
                throw new TypeCheckError(SRC, `field \`${stmt.field}\` expected type: ${JSON.stringify(fields.get(stmt.field).tag)}, got value of type ${JSON.stringify(tVal.a.type.tag)}`, tVal.a);
            return { ...stmt, a: { ...stmt.a, type: utils_1.NONE }, obj: tObj, value: tVal };
    }
}
exports.tcStmt = tcStmt;
function tcExpr(env, locals, expr, SRC) {
    switch (expr.tag) {
        case "literal":
            return { ...expr, a: { ...expr.a, type: tcLiteral(expr.value) } };
        case "binop":
            const tLeft = tcExpr(env, locals, expr.left, SRC);
            const tRight = tcExpr(env, locals, expr.right, SRC);
            const tBin = { ...expr, left: tLeft, right: tRight };
            switch (expr.op) {
                case ast_1.BinOp.Plus:
                case ast_1.BinOp.Minus:
                case ast_1.BinOp.Mul:
                case ast_1.BinOp.IDiv:
                case ast_1.BinOp.Mod:
                    if (equalType(tLeft.a.type, utils_1.NUM) && equalType(tRight.a.type, utils_1.NUM)) {
                        return { ...tBin, a: { ...expr.a, type: utils_1.NUM } };
                    }
                    else {
                        throw new TypeCheckError(SRC, `Binary operator \`${(0, ast_1.stringifyOp)(expr.op)}\` expects type "number" on both sides, got ${JSON.stringify(tLeft.a.type.tag)} and ${JSON.stringify(tRight.a.type.tag)}`, expr.a);
                    }
                case ast_1.BinOp.Eq:
                case ast_1.BinOp.Neq:
                    if (tLeft.a.type.tag === "class" || tRight.a.type.tag === "class")
                        throw new TypeCheckError(SRC, "cannot apply operator '==' on class types");
                    if (tLeft.a.type.tag === "typevar" || tRight.a.type.tag === "typevar")
                        throw new TypeCheckError(SRC, "cannot apply operator '==' on unconstrained type parameters");
                    if (equalType(tLeft.a.type, tRight.a.type)) {
                        return { ...tBin, a: { ...expr.a, type: utils_1.BOOL } };
                    }
                    else {
                        throw new TypeCheckError(SRC, `Binary operator \`${(0, ast_1.stringifyOp)(expr.op)}\` expects the same type on both sides, got ${JSON.stringify(tLeft.a.type.tag)} and ${JSON.stringify(tRight.a.type.tag)}`, expr.a);
                    }
                case ast_1.BinOp.Lte:
                case ast_1.BinOp.Gte:
                case ast_1.BinOp.Lt:
                case ast_1.BinOp.Gt:
                    if (equalType(tLeft.a.type, utils_1.NUM) && equalType(tRight.a.type, utils_1.NUM)) {
                        return { ...tBin, a: { ...expr.a, type: utils_1.BOOL } };
                    }
                    else {
                        throw new TypeCheckError(SRC, `Binary operator \`${(0, ast_1.stringifyOp)(expr.op)}\` expects type "number" on both sides, got ${JSON.stringify(tLeft.a.type.tag)} and ${JSON.stringify(tRight.a.type.tag)}`, expr.a);
                    }
                case ast_1.BinOp.And:
                case ast_1.BinOp.Or:
                    if (equalType(tLeft.a.type, utils_1.BOOL) && equalType(tRight.a.type, utils_1.BOOL)) {
                        return { ...tBin, a: { ...expr.a, type: utils_1.BOOL } };
                    }
                    else {
                        throw new TypeCheckError(SRC, `Binary operator \`${(0, ast_1.stringifyOp)(expr.op)}\` expects type "bool" on both sides, got ${JSON.stringify(tLeft.a.type.tag)} and ${JSON.stringify(tRight.a.type.tag)}`, expr.a);
                    }
                case ast_1.BinOp.Is:
                    if (!isNoneOrClassOrCallable(tLeft.a.type) || !isNoneOrClassOrCallable(tRight.a.type))
                        throw new TypeCheckError(SRC, `Binary operator \`${(0, ast_1.stringifyOp)(expr.op)}\` expects type "class", "none", or "callable" on both sides, got ${JSON.stringify(tLeft.a.type.tag)} and ${JSON.stringify(tRight.a.type.tag)}`, expr.a);
                    return { ...tBin, a: { ...expr.a, type: utils_1.BOOL } };
            }
        case "uniop":
            const tExpr = tcExpr(env, locals, expr.expr, SRC);
            const tUni = { ...expr, a: tExpr.a, expr: tExpr };
            switch (expr.op) {
                case ast_1.UniOp.Neg:
                    if (equalType(tExpr.a.type, utils_1.NUM)) {
                        return tUni;
                    }
                    else {
                        throw new TypeCheckError(SRC, `Unary operator \`${(0, ast_1.stringifyOp)(expr.op)}\` expects type "number", got ${JSON.stringify(tExpr.a.type.tag)}`, expr.a);
                    }
                case ast_1.UniOp.Not:
                    if (equalType(tExpr.a.type, utils_1.BOOL)) {
                        return tUni;
                    }
                    else {
                        throw new TypeCheckError(SRC, `Unary operator \`${(0, ast_1.stringifyOp)(expr.op)}\` expects type "bool", got ${JSON.stringify(tExpr.a.type.tag)}`, expr.a);
                    }
            }
        case "id":
            if (locals.vars.has(expr.name)) {
                return { ...expr, a: { ...expr.a, type: locals.vars.get(expr.name) } };
            }
            else if (env.globals.has(expr.name)) {
                return { ...expr, a: { ...expr.a, type: env.globals.get(expr.name) } };
            }
            else {
                throw new TypeCheckError(SRC, "Unbound id: " + expr.name, expr.a);
            }
        case "lambda":
            if (expr.params.length !== expr.type.params.length) {
                throw new TypeCheckError("Mismatch in number of parameters: " + expr.type.params.length + " != " + expr.params.length);
            }
            const lambdaLocals = copyLocals(locals);
            expr.params.forEach((param, i) => {
                lambdaLocals.vars.set(param, expr.type.params[i]);
            });
            let ret = tcExpr(env, lambdaLocals, expr.expr, SRC);
            if (!isAssignable(env, ret.a.type, expr.type.ret)) {
                throw new TypeCheckError("Expected type " + JSON.stringify(expr.type.ret) + " in lambda, got type " + JSON.stringify(ret.a.type.tag));
            }
            return { a: { ...expr.a, type: expr.type }, tag: "lambda", params: expr.params, type: expr.type, expr: ret };
        case "builtin1":
            // TODO: type check `len` after lists are implemented
            if (expr.name === "print") {
                const tArg = tcExpr(env, locals, expr.arg, SRC);
                // [lisa] commented out for now because it's failing some hidden test
                // if (tArg.a.type.tag !== "number" && tArg.a.type.tag !== "bool") {
                //   throw new TypeCheckError(SRC, `print() expects types "int" or "bool" as the argument, got ${JSON.stringify(tArg.a.type.tag)}`, tArg.a, tArg.a.endLoc);
                // }
                return { ...expr, a: tArg.a, arg: tArg };
            }
            else if (env.functions.has(expr.name)) {
                const [[expectedArgTyp], retTyp] = env.functions.get(expr.name);
                const tArg = tcExpr(env, locals, expr.arg, SRC);
                if (isAssignable(env, tArg.a.type, expectedArgTyp)) {
                    return { ...expr, a: { ...expr.a, type: retTyp }, arg: tArg };
                }
                else {
                    throw new TypeCheckError(SRC, `Function call expects an argument of type ${JSON.stringify(expectedArgTyp.tag)}, got ${JSON.stringify(tArg.a.type.tag)}`, expr.a);
                }
            }
            else {
                throw new TypeCheckError(SRC, "Undefined function: " + expr.name, expr.a);
            }
        case "builtin2":
            if (env.functions.has(expr.name)) {
                const [[leftTyp, rightTyp], retTyp] = env.functions.get(expr.name);
                const tLeftArg = tcExpr(env, locals, expr.left, SRC);
                const tRightArg = tcExpr(env, locals, expr.right, SRC);
                if (isAssignable(env, leftTyp, tLeftArg.a.type) && isAssignable(env, rightTyp, tRightArg.a.type)) {
                    return { ...expr, a: { ...expr.a, type: retTyp }, left: tLeftArg, right: tRightArg };
                }
                else {
                    throw new TypeCheckError(SRC, `Function call expects arguments of types ${JSON.stringify(leftTyp.tag)} and ${JSON.stringify(rightTyp.tag)}, got ${JSON.stringify(tLeftArg.a.type.tag)} and ${JSON.stringify(tRightArg.a.type.tag)}`, expr.a);
                }
            }
            else {
                throw new TypeCheckError(SRC, "Undefined function: " + expr.name, expr.a);
            }
        case "call":
            if (expr.fn.tag === "id" && env.classes.has(expr.fn.name)) {
                // surprise surprise this is actually a constructor
                const tConstruct = { a: { ...expr.a, type: (0, utils_1.CLASS)(expr.fn.name) }, tag: "construct", name: expr.fn.name };
                const [_, methods] = env.classes.get(expr.fn.name);
                if (methods.has("__init__")) {
                    const [initArgs, initRet] = methods.get("__init__");
                    if (expr.arguments.length !== initArgs.length - 1)
                        throw new TypeCheckError(SRC, `__init__ takes 1 parameter \`self\` of the same type of the class \`${expr.fn.name}\` with return type of \`None\`, got ${expr.arguments.length} parameters`, expr.a);
                    if (initRet !== utils_1.NONE)
                        throw new TypeCheckError(SRC, `__init__ takes 1 parameter \`self\` of the same type of the class \`${expr.fn.name}\` with return type of \`None\`, gotreturn type ${JSON.stringify(initRet.tag)}`, expr.a);
                    return tConstruct;
                }
                else {
                    return tConstruct;
                }
            }
            else {
                const newFn = tcExpr(env, locals, expr.fn, SRC);
                if (newFn.a.type.tag !== "callable") {
                    throw new TypeCheckError("Cannot call non-callable expression");
                }
                const tArgs = expr.arguments.map(arg => tcExpr(env, locals, arg, SRC));
                if (newFn.a.type.params.length === expr.arguments.length &&
                    newFn.a.type.params.every((param, i) => isAssignable(env, tArgs[i].a.type, param))) {
                    return { ...expr, a: { ...expr.a, type: newFn.a.type.ret }, arguments: tArgs, fn: newFn };
                }
                else {
                    const tArgsStr = tArgs.map(tArg => JSON.stringify(tArg.a.type.tag)).join(", ");
                    const argTypesStr = newFn.a.type.params.map(argType => JSON.stringify(argType.tag)).join(", ");
                    throw new TypeCheckError(SRC, `Function call expects arguments of types [${argTypesStr}], got [${tArgsStr}]`, expr.a);
                }
            }
        case "lookup":
            var tObj = tcExpr(env, locals, expr.obj, SRC);
            if (tObj.a.type.tag === "class") {
                if (env.classes.has(tObj.a.type.name)) {
                    const [fields, _] = env.classes.get(tObj.a.type.name);
                    if (fields.has(expr.field)) {
                        return { ...expr, a: { ...expr.a, type: specializeFieldType(env, tObj.a.type, fields.get(expr.field)) }, obj: tObj };
                    }
                    else {
                        throw new TypeCheckError(SRC, `could not find field ${expr.field} in class ${tObj.a.type.name}`, expr.a);
                    }
                }
                else {
                    throw new TypeCheckError(SRC, `field lookup on an unknown class ${tObj.a.type.name}`, expr.a);
                }
            }
            else {
                throw new TypeCheckError(SRC, `field lookups require an object of type "class", got ${JSON.stringify(tObj.a.type.tag)}`, expr.a);
            }
        case "method-call":
            var tObj = tcExpr(env, locals, expr.obj, SRC);
            var tArgs = expr.arguments.map(arg => tcExpr(env, locals, arg, SRC));
            if (tObj.a.type.tag === "class") {
                if (env.classes.has(tObj.a.type.name)) {
                    const [_, methods] = env.classes.get(tObj.a.type.name);
                    if (methods.has(expr.method)) {
                        const [methodArgs, methodRet] = specializeMethodType(env, tObj.a.type, methods.get(expr.method));
                        const realArgs = [tObj].concat(tArgs);
                        if (methodArgs.length === realArgs.length &&
                            methodArgs.every((argTyp, i) => isAssignable(env, realArgs[i].a.type, argTyp))) {
                            return { ...expr, a: { ...expr.a, type: methodRet }, obj: tObj, arguments: tArgs };
                        }
                        else {
                            const argTypesStr = methodArgs.map(argType => JSON.stringify(argType.tag)).join(", ");
                            const tArgsStr = realArgs.map(tArg => JSON.stringify(tArg.a.type.tag)).join(", ");
                            throw new TypeCheckError(SRC, `Method call ${expr.method} expects arguments of types [${argTypesStr}], got [${tArgsStr}]`, expr.a);
                        }
                    }
                    else {
                        throw new TypeCheckError(SRC, `could not found method ${expr.method} in class ${tObj.a.type.name}`, expr.a);
                    }
                }
                else {
                    throw new TypeCheckError(SRC, `method call on an unknown class ${tObj.a.type.name}`, expr.a);
                }
            }
            else {
                throw new TypeCheckError(SRC, `method calls require an object of type "class", got ${JSON.stringify(tObj.a.type.tag)}`, expr.a);
            }
        case "list-comp":
            // check if iterable is instance of class
            const iterable = tcExpr(env, locals, expr.iterable, SRC);
            if (iterable.a.type.tag === "class") {
                const classData = env.classes.get(iterable.a.type.name);
                // check if next and hasNext methods are there
                if (!classData[1].has("next") || !classData[1].has("hasNext"))
                    throw new Error("TYPE ERROR: Class of the instance must have next() and hasNext() methods");
                // need to create a local env for elem to be inside comprehension only
                var loc = locals;
                if (expr.elem.tag === "id") {
                    loc.vars.set(expr.elem.name, utils_1.NUM);
                    const elem = { ...expr.elem, a: { ...expr, type: utils_1.NUM } };
                    const left = tcExpr(env, loc, expr.left, SRC);
                    var cond;
                    if (expr.cond)
                        cond = tcExpr(env, loc, expr.cond, SRC);
                    if (cond && cond.a.type.tag !== "bool")
                        throw new Error("TYPE ERROR: comprehension if condition must return bool");
                    return { ...expr, left, elem, cond, iterable, a: { ...expr, type: (0, utils_1.CLASS)(iterable.a.type.name) } };
                }
                else
                    throw new Error("TYPE ERROR: elem has to be an id");
            }
            else
                throw new Error("TYPE ERROR: Iterable must be an instance of a class");
        case "if-expr":
            var tThn = tcExpr(env, locals, expr.thn, SRC);
            var tCond = tcExpr(env, locals, expr.cond, SRC);
            var tEls = tcExpr(env, locals, expr.els, SRC);
            if (!equalType(tCond.a.type, utils_1.BOOL))
                throw new TypeCheckError(SRC, "Condition Expression Must be a bool", expr.a);
            //TODO (Michael Maddy, Closures): Might not work for inheritence...
            if (!equalType(tThn.a.type, tEls.a.type))
                throw new TypeCheckError(SRC, `if-expr type mismatch: ${JSON.stringify(tThn.a)} is not the same as ${JSON.stringify(tEls.a)}`, expr.a);
            //Instead the type could be either the type of thn or els, and not error if they are not the same type.
            // var newType = join(env, tThn.a, tEls.a)
            return { ...expr, a: tThn.a, cond: tCond, thn: tThn, els: tEls };
        default: throw new TypeCheckError(SRC, `unimplemented type checking for expr: ${expr}`, expr.a);
    }
}
exports.tcExpr = tcExpr;
function tcLiteral(literal) {
    switch (literal.tag) {
        case "bool": return utils_1.BOOL;
        case "num": return utils_1.NUM;
        case "none": return utils_1.NONE;
    }
}
exports.tcLiteral = tcLiteral;
// function to return the type of iterator in for-loop. Finds the string in globals/locals and returns its type
// Will be extended to include tuples etc in later commits
function tcIterator(env, locals, iterator) {
    if (locals.vars.has(iterator))
        return locals.vars.get(iterator);
    else if (env.globals.has(iterator))
        return env.globals.get(iterator);
    throw new TypeCheckError(`Undefined iterator`);
}
exports.tcIterator = tcIterator;


/***/ }),

/***/ "./utils.ts":
/*!******************!*\
  !*** ./utils.ts ***!
  \******************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.makeWasmFunType = exports.createMethodName = exports.APPLY = exports.CALLABLE = exports.TYPEVAR = exports.CLASS = exports.NONE = exports.BOOL = exports.NUM = exports.PyZero = exports.PyNone = exports.PyObj = exports.PyBool = exports.PyInt = exports.PyValue = exports.builtin_bignum = exports.save_bignum = exports.store_bignum = exports.alloc_bignum = exports.load_bignum = exports.binop_comp_bignum = exports.binop_bignum = exports.bigMath = void 0;
exports.bigMath = {
    // https://stackoverflow.com/a/64953280
    abs(x) {
        return x < BigInt(0) ? -x : x;
    },
    sign(x) {
        if (x === BigInt(0))
            return BigInt(0);
        return x < BigInt(0) ? BigInt(-1) : BigInt(1);
    },
    pow(base, exponent) {
        return base ** exponent;
    },
    min(value, ...values) {
        for (const v of values)
            if (v < value)
                value = v;
        return value;
    },
    max(value, ...values) {
        for (const v of values)
            if (v > value)
                value = v;
        return value;
    },
    add(value1, value2) {
        return value1 + value2;
    },
    sub(value1, value2) {
        return value1 - value2;
    },
    mul(value1, value2) {
        return value1 * value2;
    },
    div(value1, value2) {
        return value1 / value2;
    },
    mod(value1, value2) {
        return value1 % value2;
    },
    eq(value1, value2) {
        return value1 === value2;
    },
    neq(value1, value2) {
        return value1 !== value2;
    },
    lte(value1, value2) {
        return value1 <= value2;
    },
    gte(value1, value2) {
        return value1 >= value2;
    },
    lt(value1, value2) {
        return value1 < value2;
    },
    gt(value1, value2) {
        return value1 > value2;
    },
};
function binop_bignum(args, builtin, libmem) {
    var rslt = BigInt(0);
    const load = libmem.load;
    if (args.length === 2)
        rslt = builtin(load_bignum(args[0], load), load_bignum(args[1], load));
    else
        throw new Error("Runtime Error: too many arguments for builtin functions");
    return save_bignum(rslt, libmem);
}
exports.binop_bignum = binop_bignum;
function binop_comp_bignum(args, builtin, libmem) {
    var rslt = BigInt(0);
    const load = libmem.load;
    if (args.length === 2)
        rslt = builtin(load_bignum(args[0], load), load_bignum(args[1], load));
    else
        throw new Error("Runtime Error: too many arguments for builtin functions");
    return Number(rslt);
}
exports.binop_comp_bignum = binop_comp_bignum;
function load_bignum(addr, loader) {
    const load = loader;
    if (addr === 0)
        return BigInt(0);
    const numlength = load(addr, 0);
    var bignum = BigInt(0);
    for (let i = Math.abs(numlength); i > 0; i--) {
        bignum <<= BigInt(31);
        bignum += BigInt(load(addr, i) & 0x7fffffff); // mask number to 2^31
    }
    if (numlength < 0)
        bignum *= BigInt(-1);
    return bignum;
}
exports.load_bignum = load_bignum;
function alloc_bignum(numlength, allocator) {
    const alloc = allocator;
    // allocate one extra space for metadata (length)
    return alloc(Math.abs(numlength) + 1);
}
exports.alloc_bignum = alloc_bignum;
function store_bignum(addr, numlength, digits, storer) {
    const store = storer;
    store(addr, 0, numlength);
    digits.forEach((d, i) => {
        store(addr, i + 1, d);
    });
}
exports.store_bignum = store_bignum;
function save_bignum(bignum, libmem) {
    const alloc = libmem.alloc;
    const store = libmem.store;
    const neg = bignum < 0;
    if (neg)
        bignum *= BigInt(-1);
    const digits = [];
    while (bignum > 0) {
        digits.push(Number(bignum & BigInt(0x7fffffff))); // mask number to 2^31
        bignum = bignum >> BigInt(31);
    }
    const numlength = neg ? digits.length * -1 : digits.length;
    if (numlength === 0)
        return 0;
    const addr = alloc_bignum(numlength, alloc);
    store_bignum(addr, numlength, digits, store);
    return addr;
}
exports.save_bignum = save_bignum;
function builtin_bignum(args, builtin, libmem) {
    var rslt = BigInt(0);
    const load = libmem.load;
    if (args.length === 1)
        rslt = builtin(load_bignum(args[0], load));
    else if (args.length === 2)
        rslt = builtin(load_bignum(args[0], load), load_bignum(args[1], load));
    else
        throw new Error("Runtime Error: too many arguments for builtin functions");
    return save_bignum(rslt, libmem);
}
exports.builtin_bignum = builtin_bignum;
function PyValue(typ, result) {
    switch (typ.tag) {
        case "number":
            return PyInt(result);
        case "bool":
            return PyBool(Boolean(result));
        case "class":
            return PyObj(typ.name, result);
        case "none":
            return PyNone();
    }
}
exports.PyValue = PyValue;
function PyInt(n) {
    return { tag: "num", value: n };
}
exports.PyInt = PyInt;
function PyBool(b) {
    return { tag: "bool", value: b };
}
exports.PyBool = PyBool;
function PyObj(name, address) {
    if (address === 0)
        return PyNone();
    else
        return { tag: "object", name, address };
}
exports.PyObj = PyObj;
function PyNone() {
    return { tag: "none" };
}
exports.PyNone = PyNone;
function PyZero() {
    return { tag: "zero" };
}
exports.PyZero = PyZero;
exports.NUM = { tag: "number" };
exports.BOOL = { tag: "bool" };
exports.NONE = { tag: "none" };
function CLASS(name, params = []) { return { tag: "class", name, params }; }
exports.CLASS = CLASS;
;
function TYPEVAR(name) { return { tag: "typevar", name }; }
exports.TYPEVAR = TYPEVAR;
;
function CALLABLE(params, ret) { return { tag: "callable", params, ret }; }
exports.CALLABLE = CALLABLE;
;
exports.APPLY = "apply";
function createMethodName(cls, method) {
    return `${cls}$${method}`;
}
exports.createMethodName = createMethodName;
function makeWasmFunType(paramNum) {
    return `$callable${paramNum}param`;
}
exports.makeWasmFunType = makeWasmFunType;


/***/ }),

/***/ "./webstart.ts":
/*!*********************!*\
  !*** ./webstart.ts ***!
  \*********************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.print_class = void 0;
const repl_1 = __webpack_require__(/*! ./repl */ "./repl.ts");
const type_check_1 = __webpack_require__(/*! ./type-check */ "./type-check.ts");
const utils_1 = __webpack_require__(/*! ./utils */ "./utils.ts");
const errors_1 = __webpack_require__(/*! ./errors */ "./errors.ts");
const codemirror_1 = __importDefault(__webpack_require__(/*! codemirror */ "./node_modules/codemirror/lib/codemirror.js"));
__webpack_require__(/*! codemirror/addon/edit/closebrackets */ "./node_modules/codemirror/addon/edit/closebrackets.js");
__webpack_require__(/*! codemirror/mode/python/python */ "./node_modules/codemirror/mode/python/python.js");
__webpack_require__(/*! codemirror/addon/hint/show-hint */ "./node_modules/codemirror/addon/hint/show-hint.js");
__webpack_require__(/*! codemirror/addon/lint/lint */ "./node_modules/codemirror/addon/lint/lint.js");
__webpack_require__(/*! codemirror/addon/scroll/simplescrollbars */ "./node_modules/codemirror/addon/scroll/simplescrollbars.js");
__webpack_require__(/*! ./style.scss */ "./style.scss");
const autocomplete_1 = __webpack_require__(/*! ./autocomplete */ "./autocomplete.ts");
const const_1 = __webpack_require__(/*! ./const */ "./const.ts");
function stringify(typ, arg, loader) {
    switch (typ.tag) {
        case "number":
            return (0, utils_1.load_bignum)(arg, loader).toString();
        case "bool":
            return arg ? "True" : "False";
        case "none":
            return "None";
        case "class":
            return typ.name;
    }
}
function print_class(memory, repl, pointer, classname, level, met_object, object_number, loader) {
    var fields_offset_ = repl.currentEnv.classes.get(classname);
    var fields_type = repl.currentTypeEnv.classes.get(classname)[0];
    var mem = new Uint32Array(memory.buffer);
    var display = [];
    // A[1][0] refers to the offset value of field A, sorted by the offset value to ensure the iteration has a consistent order. 
    var fields_offset = Array.from(fields_offset_.entries());
    fields_offset.sort((a, b) => {
        return a[1][0] - b[1][0];
    });
    // the reason why pointer beacuse mem is u32 array(4 byte addressing) and the pointer value returned by the run method is in raw address(byte adress)
    // surprisingly(since there is also i64 in wasm), the offset stored int the currentenv is in 4 byte addressing.
    const space = " ";
    if (met_object.has(pointer)) {
        display.push(`${space.repeat(level)}displayed ${met_object.get(pointer)}:${classname} object at addr ${pointer}: ...`);
        return display;
    }
    display.push(`${space.repeat(level)}${object_number}:${classname} object at addr ${pointer}: {`);
    met_object.set(pointer, object_number);
    fields_offset.forEach(thisfield => {
        var thisfield_type = fields_type.get(thisfield[0]);
        if (thisfield_type.tag === "class") {
            if (mem[pointer / 4 + thisfield[1][0]] === 0) {
                display.push(`${space.repeat(level + 2)}${thisfield[0]} : none `);
            }
            else {
                display.push(`${space.repeat(level + 2)}${thisfield[0]}:{`);
                display.push(...print_class(memory, repl, mem[pointer / 4 + thisfield[1][0]], thisfield_type.name, level + 5, met_object, object_number + 1, loader));
                display.push(`${space.repeat(level + 2)}}`);
            }
        }
        else {
            display.push(`${space.repeat(level + 2)}${thisfield[0]} : ${stringify(thisfield_type, mem[pointer / 4 + thisfield[1][0]], loader)} `);
        }
    });
    display.push(`${space.repeat(level + 1)}}`);
    return display;
}
exports.print_class = print_class;
function print(typ, arg, loader) {
    console.log("Logging from WASM: ", arg);
    const elt = document.createElement("pre");
    document.getElementById("output").appendChild(elt);
    elt.innerText = stringify(typ, arg, loader);
    return arg;
}
function assert_not_none(arg) {
    if (arg === 0)
        throw new Error("RUNTIME ERROR: cannot perform operation on none");
    return arg;
}
function get_code_example(name) {
    if (name === "basic class") {
        return "class C:\n" +
            "    a : int = 1\n" +
            "    b : int = 2\n" +
            "c : C = None\n" +
            "c = C()";
    }
    else if (name === "nested class") {
        return "class E(object):\n" +
            "    a : int = 1\n" +
            "class C(object):\n" +
            "    a : bool = True\n" +
            "    e : E = None\n" +
            "    def __init__(self: C):\n" +
            "        self.e = E()\n" +
            "    def d(self: C) -> int:\n" +
            "        return 1\n" +
            "c : C = None\n" +
            "c = C()";
    }
    else if (name === "cyclic linkedlist class") {
        return `class C(object):
  next:C = None
c1:C = None
c2:C = None
c3:C = None
c1 = C()
c2 = C()
c3 = C()
c1.next = c2
c2.next = c3
c3.next = c1
    `;
    }
    else if (name === "linkedlist class") {
        return `class C(object):
  next:C = None
c1:C = None
c2:C = None
c3:C = None
c1 = C()
c2 = C()
c3 = C()
c1.next = c2
c2.next = c3
    `;
    }
    else if (name === "uninitialized member variable") {
        return "class E(object):\n" +
            "    a : int = 1\n" +
            "\n" +
            "class C(E):\n" +
            "    a : int = 2\n" +
            "    e : E = None\n" +
            "    def d(self: C) -> int:\n" +
            "        return 1\n" +
            "c : C = None\n" +
            "c = C()";
    }
    return "";
}
// setup codeMirror instance and events
function webStart() {
    document.addEventListener("DOMContentLoaded", async function () {
        // https://github.com/mdn/webassembly-examples/issues/5
        var codeContent;
        const memory = new WebAssembly.Memory({ initial: 10, maximum: 100 });
        const memoryModule = await fetch('memory.wasm').then(response => response.arrayBuffer()).then(bytes => WebAssembly.instantiate(bytes, { js: { mem: memory } }));
        function initCodeMirror() {
            let isClassMethod = false;
            const userCode = document.getElementById("user-code");
            const editorBox = codemirror_1.default.fromTextArea(userCode, {
                mode: "python",
                theme: "default",
                lineNumbers: true,
                autoCloseBrackets: true,
                lint: true,
                gutters: ["error"],
                extraKeys: {
                    "Ctrl+Space": "autocomplete",
                },
                hintOptions: {
                    alignWithWord: false,
                    completeSingle: false,
                },
                scrollbarStyle: "simple",
            });
            editorBox.on("change", () => {
                userCode.value = editorBox.getValue();
            });
            editorBox.on("inputRead", function onChange(editor, input) {
                if (input.text[0] === ";" || input.text[0] === " " || input.text[0] === ":") {
                    isClassMethod = false;
                    return;
                }
                else if (input.text[0] === "." || isClassMethod) {
                    //autocomplete class methods
                    isClassMethod = true;
                    editor.showHint({
                        hint: () => (0, autocomplete_1.autocompleteHint)(editor, [], function (e, cur) {
                            return e.getTokenAt(cur);
                        }),
                    });
                }
                else {
                    //autocomplete variables, names, top-level functions
                    editor.showHint({
                        hint: () => (0, autocomplete_1.autocompleteHint)(editor, const_1.default_keywords.concat(const_1.default_functions), function (e, cur) {
                            return e.getTokenAt(cur);
                        }),
                    });
                }
            });
            editorBox.on("keydown", (cm, event) => {
                switch (event.code) {
                    //reset isClassMethod variable based on enter or space or backspace
                    case "Enter":
                        isClassMethod = false;
                        return;
                    case "Space":
                        isClassMethod = false;
                        return;
                    case "Backspace":
                        isClassMethod = false;
                        return;
                }
            });
            return editorBox;
        }
        const editorBox = initCodeMirror();
        const loader = memoryModule.instance.exports.load;
        var importObject = {
            imports: {
                assert_not_none: (arg) => assert_not_none(arg),
                print_num: (arg) => print(utils_1.NUM, arg, loader),
                print_bool: (arg) => print(utils_1.BOOL, arg, null),
                print_none: (arg) => print(utils_1.NONE, arg, null),
                abs: (arg) => (0, utils_1.builtin_bignum)([arg], utils_1.bigMath.abs, memoryModule.instance.exports),
                min: (arg1, arg2) => (0, utils_1.builtin_bignum)([arg1, arg2], utils_1.bigMath.min, memoryModule.instance.exports),
                max: (arg1, arg2) => (0, utils_1.builtin_bignum)([arg1, arg2], utils_1.bigMath.max, memoryModule.instance.exports),
                pow: (arg1, arg2) => (0, utils_1.builtin_bignum)([arg1, arg2], utils_1.bigMath.pow, memoryModule.instance.exports),
                $add: (arg1, arg2) => (0, utils_1.binop_bignum)([arg1, arg2], utils_1.bigMath.add, memoryModule.instance.exports),
                $sub: (arg1, arg2) => (0, utils_1.binop_bignum)([arg1, arg2], utils_1.bigMath.sub, memoryModule.instance.exports),
                $mul: (arg1, arg2) => (0, utils_1.binop_bignum)([arg1, arg2], utils_1.bigMath.mul, memoryModule.instance.exports),
                $div: (arg1, arg2) => (0, utils_1.binop_bignum)([arg1, arg2], utils_1.bigMath.div, memoryModule.instance.exports),
                $mod: (arg1, arg2) => (0, utils_1.binop_bignum)([arg1, arg2], utils_1.bigMath.mod, memoryModule.instance.exports),
                $eq: (arg1, arg2) => (0, utils_1.binop_comp_bignum)([arg1, arg2], utils_1.bigMath.eq, memoryModule.instance.exports),
                $neq: (arg1, arg2) => (0, utils_1.binop_comp_bignum)([arg1, arg2], utils_1.bigMath.neq, memoryModule.instance.exports),
                $lte: (arg1, arg2) => (0, utils_1.binop_comp_bignum)([arg1, arg2], utils_1.bigMath.lte, memoryModule.instance.exports),
                $gte: (arg1, arg2) => (0, utils_1.binop_comp_bignum)([arg1, arg2], utils_1.bigMath.gte, memoryModule.instance.exports),
                $lt: (arg1, arg2) => (0, utils_1.binop_comp_bignum)([arg1, arg2], utils_1.bigMath.lt, memoryModule.instance.exports),
                $gt: (arg1, arg2) => (0, utils_1.binop_comp_bignum)([arg1, arg2], utils_1.bigMath.gt, memoryModule.instance.exports),
            },
            errors: errors_1.importObjectErrors,
            libmemory: memoryModule.instance.exports,
            memory_values: memory,
            js: { memory: memory }
        };
        var repl = new repl_1.BasicREPL(importObject);
        function renderResult(result) {
            if (result === undefined) {
                console.log("skip");
                return;
            }
            if (result.tag === "none")
                return;
            const elt = document.createElement("pre");
            document.getElementById("output").appendChild(elt);
            switch (result.tag) {
                case "num":
                    elt.innerText = String(result.value);
                    break;
                case "bool":
                    elt.innerHTML = (result.value) ? "True" : "False";
                    break;
                case "object":
                    // elt.innerHTML = `${result.name} object at ${result.address}`
                    elt.innerHTML = print_class(memory, repl, result.address, result.name, 0, new Map(), 1, loader).join("\n");
                    break;
                default: throw new Error(`Could not render value: ${result}`);
            }
        }
        function renderError(result) {
            // only `TypeCheckError` has `getA` and `getErrMsg`
            if (result instanceof type_check_1.TypeCheckError) {
                console.log(result.getA()); // could be undefined if no Annotation information is passed to the constructor of TypeCheckError
                console.log(result.getErrMsg());
            }
            const elt = document.createElement("pre");
            document.getElementById("output").appendChild(elt);
            elt.setAttribute("style", "color: red");
            elt.innerText = String(result);
        }
        function setupRepl() {
            document.getElementById("output").innerHTML = "";
            const replCodeElement = document.getElementById("next-code");
            replCodeElement.addEventListener("keypress", (e) => {
                if (e.shiftKey && e.key === "Enter") {
                }
                else if (e.key === "Enter") {
                    e.preventDefault();
                    const output = document.createElement("div");
                    const prompt = document.createElement("span");
                    prompt.innerText = "";
                    output.appendChild(prompt);
                    const elt = document.createElement("textarea");
                    // elt.type = "text";
                    elt.disabled = true;
                    elt.className = "repl-code";
                    output.appendChild(elt);
                    document.getElementById("output").appendChild(output);
                    const source = replCodeElement.value;
                    elt.value = source;
                    replCodeElement.value = "";
                    repl.run(source).then((r) => {
                        renderResult(r);
                        printMem();
                        console.log("run finished");
                    })
                        .catch((e) => { renderError(e); console.log("run failed", e); });
                    ;
                }
            });
        }
        function resetRepl() {
            document.getElementById("output").innerHTML = "";
        }
        function printMem() {
            var mem = new Uint32Array(memory.buffer);
            for (let i = 0; i < 25; i++) {
                console.log(mem[i]);
            }
            // mem.forEach((x) => console.log(x));
        }
        function setupCodeExample() {
            const sel = document.querySelector("#exampleSelect");
            console.log('editorBox: ', editorBox);
            sel.addEventListener("change", (e) => {
                const code = get_code_example(sel.value);
                if (code !== "") {
                    // const usercode = document.getElementById("user-code") as HTMLTextAreaElement;
                    editorBox.setValue(code);
                }
            });
        }
        document.getElementById("clear").addEventListener("click", function (e) {
            //repl code disapper (on the right side)
            resetRepl();
            //reset environment
            repl = new repl_1.BasicREPL(importObject);
            //clear editor code
            var element = document.querySelector(".CodeMirror");
            var editor = element.CodeMirror;
            editor.setValue("");
            editor.clearHistory();
        });
        document.getElementById("load").addEventListener("change", function (e) {
            resetRepl();
            repl = new repl_1.BasicREPL(importObject);
            var input = e.target;
            var reader = new FileReader();
            var editorBox = document.querySelector(".CodeMirror");
            const codeNode = editorBox.CodeMirror;
            codeNode.setValue("");
            reader.onload = function () {
                if (codeNode.value != "") {
                    codeNode.setValue("");
                    codeNode.setValue(reader.result);
                }
                else {
                    codeNode.setValue(reader.result);
                }
            };
            reader.readAsText(input.files[0]);
        });
        // window.onload = function(e: Event){
        //   var f = document.getElementById("load")
        //   var reader = new FileReader();
        //   var readerContent
        //   f.onchange = function(){
        //     readerContent = reader.result
        //   }
        //   var contentToLoad = readerContent as string
        //   var codeNode= document.getElementById("user-code") as HTMLTextAreaElement
        //   codeNode.value = contentToLoad
        // }
        document.getElementById("save").addEventListener("click", function (e) {
            var FileSaver = __webpack_require__(/*! file-saver */ "./node_modules/file-saver/dist/FileSaver.min.js");
            var title = prompt("please input file name: ", "untitled");
            //If we click "cancel", the title returned is null
            if (title != null) {
                var codeNode = document.getElementById("user-code");
                var code = codeNode.value;
                var blob = new Blob([code], { type: "text/plain;charset=utf-8" });
                FileSaver.saveAs(blob, title);
            }
        });
        document.getElementById("run").addEventListener("click", function (e) {
            repl = new repl_1.BasicREPL(importObject);
            const source = document.getElementById("user-code");
            resetRepl();
            repl.run(source.value).then((r) => { renderResult(r); console.log("run finished"); })
                .catch((e) => { renderError(e); console.log("run failed", e); });
            ;
        });
        setupRepl();
        setupCodeExample();
    });
}
webStart();


/***/ }),

/***/ "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAQAAAADCAYAAAC09K7GAAAAAXNSR0IArs4c6QAAAAZiS0dEAP8A/wD/oL2nkwAAAAlwSFlzAAALEwAACxMBAJqcGAAAAAd0SU1FB9sJDw4cOCW1/KIAAAAZdEVYdENvbW1lbnQAQ3JlYXRlZCB3aXRoIEdJTVBXgQ4XAAAAHElEQVQI12NggIL/DAz/GdA5/xkY/qPKMDAwAADLZwf5rvm+LQAAAABJRU5ErkJggg==":
/*!**************************************************************************************************************************************************************************************************************************************************************************************************!*\
  !*** data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAQAAAADCAYAAAC09K7GAAAAAXNSR0IArs4c6QAAAAZiS0dEAP8A/wD/oL2nkwAAAAlwSFlzAAALEwAACxMBAJqcGAAAAAd0SU1FB9sJDw4cOCW1/KIAAAAZdEVYdENvbW1lbnQAQ3JlYXRlZCB3aXRoIEdJTVBXgQ4XAAAAHElEQVQI12NggIL/DAz/GdA5/xkY/qPKMDAwAADLZwf5rvm+LQAAAABJRU5ErkJggg== ***!
  \**************************************************************************************************************************************************************************************************************************************************************************************************/
/***/ ((module) => {

"use strict";
module.exports = "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAQAAAADCAYAAAC09K7GAAAAAXNSR0IArs4c6QAAAAZiS0dEAP8A/wD/oL2nkwAAAAlwSFlzAAALEwAACxMBAJqcGAAAAAd0SU1FB9sJDw4cOCW1/KIAAAAZdEVYdENvbW1lbnQAQ3JlYXRlZCB3aXRoIEdJTVBXgQ4XAAAAHElEQVQI12NggIL/DAz/GdA5/xkY/qPKMDAwAADLZwf5rvm+LQAAAABJRU5ErkJggg==";

/***/ }),

/***/ "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAQAAAADCAYAAAC09K7GAAAAAXNSR0IArs4c6QAAAAZiS0dEAP8A/wD/oL2nkwAAAAlwSFlzAAALEwAACxMBAJqcGAAAAAd0SU1FB9sJFhQXEbhTg7YAAAAZdEVYdENvbW1lbnQAQ3JlYXRlZCB3aXRoIEdJTVBXgQ4XAAAAMklEQVQI12NkgIIvJ3QXMjAwdDN+OaEbysDA4MPAwNDNwMCwiOHLCd1zX07o6kBVGQEAKBANtobskNMAAAAASUVORK5CYII=":
/*!******************************************************************************************************************************************************************************************************************************************************************************************************************************!*\
  !*** data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAQAAAADCAYAAAC09K7GAAAAAXNSR0IArs4c6QAAAAZiS0dEAP8A/wD/oL2nkwAAAAlwSFlzAAALEwAACxMBAJqcGAAAAAd0SU1FB9sJFhQXEbhTg7YAAAAZdEVYdENvbW1lbnQAQ3JlYXRlZCB3aXRoIEdJTVBXgQ4XAAAAMklEQVQI12NkgIIvJ3QXMjAwdDN+OaEbysDA4MPAwNDNwMCwiOHLCd1zX07o6kBVGQEAKBANtobskNMAAAAASUVORK5CYII= ***!
  \******************************************************************************************************************************************************************************************************************************************************************************************************************************/
/***/ ((module) => {

"use strict";
module.exports = "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAQAAAADCAYAAAC09K7GAAAAAXNSR0IArs4c6QAAAAZiS0dEAP8A/wD/oL2nkwAAAAlwSFlzAAALEwAACxMBAJqcGAAAAAd0SU1FB9sJFhQXEbhTg7YAAAAZdEVYdENvbW1lbnQAQ3JlYXRlZCB3aXRoIEdJTVBXgQ4XAAAAMklEQVQI12NkgIIvJ3QXMjAwdDN+OaEbysDA4MPAwNDNwMCwiOHLCd1zX07o6kBVGQEAKBANtobskNMAAAAASUVORK5CYII=";

/***/ }),

/***/ "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAcAAAAHCAMAAADzjKfhAAAACVBMVEUAAAAAAAC/v7914kyHAAAAAXRSTlMAQObYZgAAACNJREFUeNo1ioEJAAAIwmz/H90iFFSGJgFMe3gaLZ0od+9/AQZ0ADosbYraAAAAAElFTkSuQmCC":
/*!******************************************************************************************************************************************************************************************************!*\
  !*** data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAcAAAAHCAMAAADzjKfhAAAACVBMVEUAAAAAAAC/v7914kyHAAAAAXRSTlMAQObYZgAAACNJREFUeNo1ioEJAAAIwmz/H90iFFSGJgFMe3gaLZ0od+9/AQZ0ADosbYraAAAAAElFTkSuQmCC ***!
  \******************************************************************************************************************************************************************************************************/
/***/ ((module) => {

"use strict";
module.exports = "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAcAAAAHCAMAAADzjKfhAAAACVBMVEUAAAAAAAC/v7914kyHAAAAAXRSTlMAQObYZgAAACNJREFUeNo1ioEJAAAIwmz/H90iFFSGJgFMe3gaLZ0od+9/AQZ0ADosbYraAAAAAElFTkSuQmCC";

/***/ }),

/***/ "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABAAAAAQCAMAAAAoLQ9TAAAAHlBMVEW7AAC7AACxAAC7AAC7AAAAAAC4AAC5AAD///+7AAAUdclpAAAABnRSTlMXnORSiwCK0ZKSAAAATUlEQVR42mWPOQ7AQAgDuQLx/z8csYRmPRIFIwRGnosRrpamvkKi0FTIiMASR3hhKW+hAN6/tIWhu9PDWiTGNEkTtIOucA5Oyr9ckPgAWm0GPBog6v4AAAAASUVORK5CYII=":
/*!**************************************************************************************************************************************************************************************************************************************************************************************************!*\
  !*** data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABAAAAAQCAMAAAAoLQ9TAAAAHlBMVEW7AAC7AACxAAC7AAC7AAAAAAC4AAC5AAD///+7AAAUdclpAAAABnRSTlMXnORSiwCK0ZKSAAAATUlEQVR42mWPOQ7AQAgDuQLx/z8csYRmPRIFIwRGnosRrpamvkKi0FTIiMASR3hhKW+hAN6/tIWhu9PDWiTGNEkTtIOucA5Oyr9ckPgAWm0GPBog6v4AAAAASUVORK5CYII= ***!
  \**************************************************************************************************************************************************************************************************************************************************************************************************/
/***/ ((module) => {

"use strict";
module.exports = "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABAAAAAQCAMAAAAoLQ9TAAAAHlBMVEW7AAC7AACxAAC7AAC7AAAAAAC4AAC5AAD///+7AAAUdclpAAAABnRSTlMXnORSiwCK0ZKSAAAATUlEQVR42mWPOQ7AQAgDuQLx/z8csYRmPRIFIwRGnosRrpamvkKi0FTIiMASR3hhKW+hAN6/tIWhu9PDWiTGNEkTtIOucA5Oyr9ckPgAWm0GPBog6v4AAAAASUVORK5CYII=";

/***/ }),

/***/ "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABAAAAAQCAMAAAAoLQ9TAAAANlBMVEX/uwDvrwD/uwD/uwD/uwD/uwD/uwD/uwD/uwD6twD/uwAAAADurwD2tQD7uAD+ugAAAAD/uwDhmeTRAAAADHRSTlMJ8mN1EYcbmiixgACm7WbuAAAAVklEQVR42n3PUQqAIBBFUU1LLc3u/jdbOJoW1P08DA9Gba8+YWJ6gNJoNYIBzAA2chBth5kLmG9YUoG0NHAUwFXwO9LuBQL1giCQb8gC9Oro2vp5rncCIY8L8uEx5ZkAAAAASUVORK5CYII=":
/*!******************************************************************************************************************************************************************************************************************************************************************************************************************************************************!*\
  !*** data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABAAAAAQCAMAAAAoLQ9TAAAANlBMVEX/uwDvrwD/uwD/uwD/uwD/uwD/uwD/uwD/uwD6twD/uwAAAADurwD2tQD7uAD+ugAAAAD/uwDhmeTRAAAADHRSTlMJ8mN1EYcbmiixgACm7WbuAAAAVklEQVR42n3PUQqAIBBFUU1LLc3u/jdbOJoW1P08DA9Gba8+YWJ6gNJoNYIBzAA2chBth5kLmG9YUoG0NHAUwFXwO9LuBQL1giCQb8gC9Oro2vp5rncCIY8L8uEx5ZkAAAAASUVORK5CYII= ***!
  \******************************************************************************************************************************************************************************************************************************************************************************************************************************************************/
/***/ ((module) => {

"use strict";
module.exports = "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABAAAAAQCAMAAAAoLQ9TAAAANlBMVEX/uwDvrwD/uwD/uwD/uwD/uwD/uwD/uwD/uwD6twD/uwAAAADurwD2tQD7uAD+ugAAAAD/uwDhmeTRAAAADHRSTlMJ8mN1EYcbmiixgACm7WbuAAAAVklEQVR42n3PUQqAIBBFUU1LLc3u/jdbOJoW1P08DA9Gba8+YWJ6gNJoNYIBzAA2chBth5kLmG9YUoG0NHAUwFXwO9LuBQL1giCQb8gC9Oro2vp5rncCIY8L8uEx5ZkAAAAASUVORK5CYII=";

/***/ }),

/***/ "wabt":
/*!***********************!*\
  !*** external "wabt" ***!
  \***********************/
/***/ ((module) => {

"use strict";
module.exports = wabt;

/***/ }),

/***/ "./node_modules/@lezer/common/dist/index.cjs":
/*!***************************************************!*\
  !*** ./node_modules/@lezer/common/dist/index.cjs ***!
  \***************************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({ value: true }));

// FIXME profile adding a per-Tree TreeNode cache, validating it by
// parent pointer
/// The default maximum length of a `TreeBuffer` node (1024).
const DefaultBufferLength = 1024;
let nextPropID = 0;
class Range {
    constructor(from, to) {
        this.from = from;
        this.to = to;
    }
}
/// Each [node type](#common.NodeType) or [individual tree](#common.Tree)
/// can have metadata associated with it in props. Instances of this
/// class represent prop names.
class NodeProp {
    /// Create a new node prop type.
    constructor(config = {}) {
        this.id = nextPropID++;
        this.perNode = !!config.perNode;
        this.deserialize = config.deserialize || (() => {
            throw new Error("This node type doesn't define a deserialize function");
        });
    }
    /// This is meant to be used with
    /// [`NodeSet.extend`](#common.NodeSet.extend) or
    /// [`LRParser.configure`](#lr.ParserConfig.props) to compute
    /// prop values for each node type in the set. Takes a [match
    /// object](#common.NodeType^match) or function that returns undefined
    /// if the node type doesn't get this prop, and the prop's value if
    /// it does.
    add(match) {
        if (this.perNode)
            throw new RangeError("Can't add per-node props to node types");
        if (typeof match != "function")
            match = NodeType.match(match);
        return (type) => {
            let result = match(type);
            return result === undefined ? null : [this, result];
        };
    }
}
/// Prop that is used to describe matching delimiters. For opening
/// delimiters, this holds an array of node names (written as a
/// space-separated string when declaring this prop in a grammar)
/// for the node types of closing delimiters that match it.
NodeProp.closedBy = new NodeProp({ deserialize: str => str.split(" ") });
/// The inverse of [`closedBy`](#common.NodeProp^closedBy). This is
/// attached to closing delimiters, holding an array of node names
/// of types of matching opening delimiters.
NodeProp.openedBy = new NodeProp({ deserialize: str => str.split(" ") });
/// Used to assign node types to groups (for example, all node
/// types that represent an expression could be tagged with an
/// `"Expression"` group).
NodeProp.group = new NodeProp({ deserialize: str => str.split(" ") });
/// The hash of the [context](#lr.ContextTracker.constructor)
/// that the node was parsed in, if any. Used to limit reuse of
/// contextual nodes.
NodeProp.contextHash = new NodeProp({ perNode: true });
/// The distance beyond the end of the node that the tokenizer
/// looked ahead for any of the tokens inside the node. (The LR
/// parser only stores this when it is larger than 25, for
/// efficiency reasons.)
NodeProp.lookAhead = new NodeProp({ perNode: true });
/// This per-node prop is used to replace a given node, or part of a
/// node, with another tree. This is useful to include trees from
/// different languages.
NodeProp.mounted = new NodeProp({ perNode: true });
/// A mounted tree, which can be [stored](#common.NodeProp^mounted) on
/// a tree node to indicate that parts of its content are
/// represented by another tree.
class MountedTree {
    constructor(
    /// The inner tree.
    tree, 
    /// If this is null, this tree replaces the entire node (it will
    /// be included in the regular iteration instead of its host
    /// node). If not, only the given ranges are considered to be
    /// covered by this tree. This is used for trees that are mixed in
    /// a way that isn't strictly hierarchical. Such mounted trees are
    /// only entered by [`resolveInner`](#common.Tree.resolveInner)
    /// and [`enter`](#common.SyntaxNode.enter).
    overlay, 
    /// The parser used to create this subtree.
    parser) {
        this.tree = tree;
        this.overlay = overlay;
        this.parser = parser;
    }
}
const noProps = Object.create(null);
/// Each node in a syntax tree has a node type associated with it.
class NodeType {
    /// @internal
    constructor(
    /// The name of the node type. Not necessarily unique, but if the
    /// grammar was written properly, different node types with the
    /// same name within a node set should play the same semantic
    /// role.
    name, 
    /// @internal
    props, 
    /// The id of this node in its set. Corresponds to the term ids
    /// used in the parser.
    id, 
    /// @internal
    flags = 0) {
        this.name = name;
        this.props = props;
        this.id = id;
        this.flags = flags;
    }
    static define(spec) {
        let props = spec.props && spec.props.length ? Object.create(null) : noProps;
        let flags = (spec.top ? 1 /* Top */ : 0) | (spec.skipped ? 2 /* Skipped */ : 0) |
            (spec.error ? 4 /* Error */ : 0) | (spec.name == null ? 8 /* Anonymous */ : 0);
        let type = new NodeType(spec.name || "", props, spec.id, flags);
        if (spec.props)
            for (let src of spec.props) {
                if (!Array.isArray(src))
                    src = src(type);
                if (src) {
                    if (src[0].perNode)
                        throw new RangeError("Can't store a per-node prop on a node type");
                    props[src[0].id] = src[1];
                }
            }
        return type;
    }
    /// Retrieves a node prop for this type. Will return `undefined` if
    /// the prop isn't present on this node.
    prop(prop) { return this.props[prop.id]; }
    /// True when this is the top node of a grammar.
    get isTop() { return (this.flags & 1 /* Top */) > 0; }
    /// True when this node is produced by a skip rule.
    get isSkipped() { return (this.flags & 2 /* Skipped */) > 0; }
    /// Indicates whether this is an error node.
    get isError() { return (this.flags & 4 /* Error */) > 0; }
    /// When true, this node type doesn't correspond to a user-declared
    /// named node, for example because it is used to cache repetition.
    get isAnonymous() { return (this.flags & 8 /* Anonymous */) > 0; }
    /// Returns true when this node's name or one of its
    /// [groups](#common.NodeProp^group) matches the given string.
    is(name) {
        if (typeof name == 'string') {
            if (this.name == name)
                return true;
            let group = this.prop(NodeProp.group);
            return group ? group.indexOf(name) > -1 : false;
        }
        return this.id == name;
    }
    /// Create a function from node types to arbitrary values by
    /// specifying an object whose property names are node or
    /// [group](#common.NodeProp^group) names. Often useful with
    /// [`NodeProp.add`](#common.NodeProp.add). You can put multiple
    /// names, separated by spaces, in a single property name to map
    /// multiple node names to a single value.
    static match(map) {
        let direct = Object.create(null);
        for (let prop in map)
            for (let name of prop.split(" "))
                direct[name] = map[prop];
        return (node) => {
            for (let groups = node.prop(NodeProp.group), i = -1; i < (groups ? groups.length : 0); i++) {
                let found = direct[i < 0 ? node.name : groups[i]];
                if (found)
                    return found;
            }
        };
    }
}
/// An empty dummy node type to use when no actual type is available.
NodeType.none = new NodeType("", Object.create(null), 0, 8 /* Anonymous */);
/// A node set holds a collection of node types. It is used to
/// compactly represent trees by storing their type ids, rather than a
/// full pointer to the type object, in a numeric array. Each parser
/// [has](#lr.LRParser.nodeSet) a node set, and [tree
/// buffers](#common.TreeBuffer) can only store collections of nodes
/// from the same set. A set can have a maximum of 2**16 (65536) node
/// types in it, so that the ids fit into 16-bit typed array slots.
class NodeSet {
    /// Create a set with the given types. The `id` property of each
    /// type should correspond to its position within the array.
    constructor(
    /// The node types in this set, by id.
    types) {
        this.types = types;
        for (let i = 0; i < types.length; i++)
            if (types[i].id != i)
                throw new RangeError("Node type ids should correspond to array positions when creating a node set");
    }
    /// Create a copy of this set with some node properties added. The
    /// arguments to this method should be created with
    /// [`NodeProp.add`](#common.NodeProp.add).
    extend(...props) {
        let newTypes = [];
        for (let type of this.types) {
            let newProps = null;
            for (let source of props) {
                let add = source(type);
                if (add) {
                    if (!newProps)
                        newProps = Object.assign({}, type.props);
                    newProps[add[0].id] = add[1];
                }
            }
            newTypes.push(newProps ? new NodeType(type.name, newProps, type.id, type.flags) : type);
        }
        return new NodeSet(newTypes);
    }
}
const CachedNode = new WeakMap(), CachedInnerNode = new WeakMap();
/// Options that control iteration. Can be combined with the `|`
/// operator to enable multiple ones.
exports.IterMode = void 0;
(function (IterMode) {
    /// When enabled, iteration will only visit [`Tree`](#common.Tree)
    /// objects, not nodes packed into
    /// [`TreeBuffer`](#common.TreeBuffer)s.
    IterMode[IterMode["ExcludeBuffers"] = 1] = "ExcludeBuffers";
    /// Enable this to make iteration include anonymous nodes (such as
    /// the nodes that wrap repeated grammar constructs into a balanced
    /// tree).
    IterMode[IterMode["IncludeAnonymous"] = 2] = "IncludeAnonymous";
    /// By default, regular [mounted](#common.NodeProp^mounted) nodes
    /// replace their base node in iteration. Enable this to ignore them
    /// instead.
    IterMode[IterMode["IgnoreMounts"] = 4] = "IgnoreMounts";
    /// This option only applies in
    /// [`enter`](#common.SyntaxNode.enter)-style methods. It tells the
    /// library to not enter mounted overlays if one covers the given
    /// position.
    IterMode[IterMode["IgnoreOverlays"] = 8] = "IgnoreOverlays";
})(exports.IterMode || (exports.IterMode = {}));
/// A piece of syntax tree. There are two ways to approach these
/// trees: the way they are actually stored in memory, and the
/// convenient way.
///
/// Syntax trees are stored as a tree of `Tree` and `TreeBuffer`
/// objects. By packing detail information into `TreeBuffer` leaf
/// nodes, the representation is made a lot more memory-efficient.
///
/// However, when you want to actually work with tree nodes, this
/// representation is very awkward, so most client code will want to
/// use the [`TreeCursor`](#common.TreeCursor) or
/// [`SyntaxNode`](#common.SyntaxNode) interface instead, which provides
/// a view on some part of this data structure, and can be used to
/// move around to adjacent nodes.
class Tree {
    /// Construct a new tree. See also [`Tree.build`](#common.Tree^build).
    constructor(
    /// The type of the top node.
    type, 
    /// This node's child nodes.
    children, 
    /// The positions (offsets relative to the start of this tree) of
    /// the children.
    positions, 
    /// The total length of this tree
    length, 
    /// Per-node [node props](#common.NodeProp) to associate with this node.
    props) {
        this.type = type;
        this.children = children;
        this.positions = positions;
        this.length = length;
        /// @internal
        this.props = null;
        if (props && props.length) {
            this.props = Object.create(null);
            for (let [prop, value] of props)
                this.props[typeof prop == "number" ? prop : prop.id] = value;
        }
    }
    /// @internal
    toString() {
        let mounted = this.prop(NodeProp.mounted);
        if (mounted && !mounted.overlay)
            return mounted.tree.toString();
        let children = "";
        for (let ch of this.children) {
            let str = ch.toString();
            if (str) {
                if (children)
                    children += ",";
                children += str;
            }
        }
        return !this.type.name ? children :
            (/\W/.test(this.type.name) && !this.type.isError ? JSON.stringify(this.type.name) : this.type.name) +
                (children.length ? "(" + children + ")" : "");
    }
    /// Get a [tree cursor](#common.TreeCursor) positioned at the top of
    /// the tree. Mode can be used to [control](#common.IterMode) which
    /// nodes the cursor visits.
    cursor(mode = 0) {
        return new TreeCursor(this.topNode, mode);
    }
    /// Get a [tree cursor](#common.TreeCursor) pointing into this tree
    /// at the given position and side (see
    /// [`moveTo`](#common.TreeCursor.moveTo).
    cursorAt(pos, side = 0, mode = 0) {
        let scope = CachedNode.get(this) || this.topNode;
        let cursor = new TreeCursor(scope);
        cursor.moveTo(pos, side);
        CachedNode.set(this, cursor._tree);
        return cursor;
    }
    /// Get a [syntax node](#common.SyntaxNode) object for the top of the
    /// tree.
    get topNode() {
        return new TreeNode(this, 0, 0, null);
    }
    /// Get the [syntax node](#common.SyntaxNode) at the given position.
    /// If `side` is -1, this will move into nodes that end at the
    /// position. If 1, it'll move into nodes that start at the
    /// position. With 0, it'll only enter nodes that cover the position
    /// from both sides.
    resolve(pos, side = 0) {
        let node = resolveNode(CachedNode.get(this) || this.topNode, pos, side, false);
        CachedNode.set(this, node);
        return node;
    }
    /// Like [`resolve`](#common.Tree.resolve), but will enter
    /// [overlaid](#common.MountedTree.overlay) nodes, producing a syntax node
    /// pointing into the innermost overlaid tree at the given position
    /// (with parent links going through all parent structure, including
    /// the host trees).
    resolveInner(pos, side = 0) {
        let node = resolveNode(CachedInnerNode.get(this) || this.topNode, pos, side, true);
        CachedInnerNode.set(this, node);
        return node;
    }
    /// Iterate over the tree and its children, calling `enter` for any
    /// node that touches the `from`/`to` region (if given) before
    /// running over such a node's children, and `leave` (if given) when
    /// leaving the node. When `enter` returns `false`, that node will
    /// not have its children iterated over (or `leave` called).
    iterate(spec) {
        let { enter, leave, from = 0, to = this.length } = spec;
        for (let c = this.cursor((spec.mode || 0) | exports.IterMode.IncludeAnonymous);;) {
            let entered = false;
            if (c.from <= to && c.to >= from && (c.type.isAnonymous || enter(c) !== false)) {
                if (c.firstChild())
                    continue;
                entered = true;
            }
            for (;;) {
                if (entered && leave && !c.type.isAnonymous)
                    leave(c);
                if (c.nextSibling())
                    break;
                if (!c.parent())
                    return;
                entered = true;
            }
        }
    }
    /// Get the value of the given [node prop](#common.NodeProp) for this
    /// node. Works with both per-node and per-type props.
    prop(prop) {
        return !prop.perNode ? this.type.prop(prop) : this.props ? this.props[prop.id] : undefined;
    }
    /// Returns the node's [per-node props](#common.NodeProp.perNode) in a
    /// format that can be passed to the [`Tree`](#common.Tree)
    /// constructor.
    get propValues() {
        let result = [];
        if (this.props)
            for (let id in this.props)
                result.push([+id, this.props[id]]);
        return result;
    }
    /// Balance the direct children of this tree, producing a copy of
    /// which may have children grouped into subtrees with type
    /// [`NodeType.none`](#common.NodeType^none).
    balance(config = {}) {
        return this.children.length <= 8 /* BranchFactor */ ? this :
            balanceRange(NodeType.none, this.children, this.positions, 0, this.children.length, 0, this.length, (children, positions, length) => new Tree(this.type, children, positions, length, this.propValues), config.makeTree || ((children, positions, length) => new Tree(NodeType.none, children, positions, length)));
    }
    /// Build a tree from a postfix-ordered buffer of node information,
    /// or a cursor over such a buffer.
    static build(data) { return buildTree(data); }
}
/// The empty tree
Tree.empty = new Tree(NodeType.none, [], [], 0);
class FlatBufferCursor {
    constructor(buffer, index) {
        this.buffer = buffer;
        this.index = index;
    }
    get id() { return this.buffer[this.index - 4]; }
    get start() { return this.buffer[this.index - 3]; }
    get end() { return this.buffer[this.index - 2]; }
    get size() { return this.buffer[this.index - 1]; }
    get pos() { return this.index; }
    next() { this.index -= 4; }
    fork() { return new FlatBufferCursor(this.buffer, this.index); }
}
/// Tree buffers contain (type, start, end, endIndex) quads for each
/// node. In such a buffer, nodes are stored in prefix order (parents
/// before children, with the endIndex of the parent indicating which
/// children belong to it)
class TreeBuffer {
    /// Create a tree buffer.
    constructor(
    /// The buffer's content.
    buffer, 
    /// The total length of the group of nodes in the buffer.
    length, 
    /// The node set used in this buffer.
    set) {
        this.buffer = buffer;
        this.length = length;
        this.set = set;
    }
    /// @internal
    get type() { return NodeType.none; }
    /// @internal
    toString() {
        let result = [];
        for (let index = 0; index < this.buffer.length;) {
            result.push(this.childString(index));
            index = this.buffer[index + 3];
        }
        return result.join(",");
    }
    /// @internal
    childString(index) {
        let id = this.buffer[index], endIndex = this.buffer[index + 3];
        let type = this.set.types[id], result = type.name;
        if (/\W/.test(result) && !type.isError)
            result = JSON.stringify(result);
        index += 4;
        if (endIndex == index)
            return result;
        let children = [];
        while (index < endIndex) {
            children.push(this.childString(index));
            index = this.buffer[index + 3];
        }
        return result + "(" + children.join(",") + ")";
    }
    /// @internal
    findChild(startIndex, endIndex, dir, pos, side) {
        let { buffer } = this, pick = -1;
        for (let i = startIndex; i != endIndex; i = buffer[i + 3]) {
            if (checkSide(side, pos, buffer[i + 1], buffer[i + 2])) {
                pick = i;
                if (dir > 0)
                    break;
            }
        }
        return pick;
    }
    /// @internal
    slice(startI, endI, from, to) {
        let b = this.buffer;
        let copy = new Uint16Array(endI - startI);
        for (let i = startI, j = 0; i < endI;) {
            copy[j++] = b[i++];
            copy[j++] = b[i++] - from;
            copy[j++] = b[i++] - from;
            copy[j++] = b[i++] - startI;
        }
        return new TreeBuffer(copy, to - from, this.set);
    }
}
function checkSide(side, pos, from, to) {
    switch (side) {
        case -2 /* Before */: return from < pos;
        case -1 /* AtOrBefore */: return to >= pos && from < pos;
        case 0 /* Around */: return from < pos && to > pos;
        case 1 /* AtOrAfter */: return from <= pos && to > pos;
        case 2 /* After */: return to > pos;
        case 4 /* DontCare */: return true;
    }
}
function enterUnfinishedNodesBefore(node, pos) {
    let scan = node.childBefore(pos);
    while (scan) {
        let last = scan.lastChild;
        if (!last || last.to != scan.to)
            break;
        if (last.type.isError && last.from == last.to) {
            node = scan;
            scan = last.prevSibling;
        }
        else {
            scan = last;
        }
    }
    return node;
}
function resolveNode(node, pos, side, overlays) {
    var _a;
    // Move up to a node that actually holds the position, if possible
    while (node.from == node.to ||
        (side < 1 ? node.from >= pos : node.from > pos) ||
        (side > -1 ? node.to <= pos : node.to < pos)) {
        let parent = !overlays && node instanceof TreeNode && node.index < 0 ? null : node.parent;
        if (!parent)
            return node;
        node = parent;
    }
    let mode = overlays ? 0 : exports.IterMode.IgnoreOverlays;
    // Must go up out of overlays when those do not overlap with pos
    if (overlays)
        for (let scan = node, parent = scan.parent; parent; scan = parent, parent = scan.parent) {
            if (scan instanceof TreeNode && scan.index < 0 && ((_a = parent.enter(pos, side, mode)) === null || _a === void 0 ? void 0 : _a.from) != scan.from)
                node = parent;
        }
    for (;;) {
        let inner = node.enter(pos, side, mode);
        if (!inner)
            return node;
        node = inner;
    }
}
class TreeNode {
    constructor(_tree, from, 
    // Index in parent node, set to -1 if the node is not a direct child of _parent.node (overlay)
    index, _parent) {
        this._tree = _tree;
        this.from = from;
        this.index = index;
        this._parent = _parent;
    }
    get type() { return this._tree.type; }
    get name() { return this._tree.type.name; }
    get to() { return this.from + this._tree.length; }
    nextChild(i, dir, pos, side, mode = 0) {
        for (let parent = this;;) {
            for (let { children, positions } = parent._tree, e = dir > 0 ? children.length : -1; i != e; i += dir) {
                let next = children[i], start = positions[i] + parent.from;
                if (!checkSide(side, pos, start, start + next.length))
                    continue;
                if (next instanceof TreeBuffer) {
                    if (mode & exports.IterMode.ExcludeBuffers)
                        continue;
                    let index = next.findChild(0, next.buffer.length, dir, pos - start, side);
                    if (index > -1)
                        return new BufferNode(new BufferContext(parent, next, i, start), null, index);
                }
                else if ((mode & exports.IterMode.IncludeAnonymous) || (!next.type.isAnonymous || hasChild(next))) {
                    let mounted;
                    if (!(mode & exports.IterMode.IgnoreMounts) &&
                        next.props && (mounted = next.prop(NodeProp.mounted)) && !mounted.overlay)
                        return new TreeNode(mounted.tree, start, i, parent);
                    let inner = new TreeNode(next, start, i, parent);
                    return (mode & exports.IterMode.IncludeAnonymous) || !inner.type.isAnonymous ? inner
                        : inner.nextChild(dir < 0 ? next.children.length - 1 : 0, dir, pos, side);
                }
            }
            if ((mode & exports.IterMode.IncludeAnonymous) || !parent.type.isAnonymous)
                return null;
            if (parent.index >= 0)
                i = parent.index + dir;
            else
                i = dir < 0 ? -1 : parent._parent._tree.children.length;
            parent = parent._parent;
            if (!parent)
                return null;
        }
    }
    get firstChild() { return this.nextChild(0, 1, 0, 4 /* DontCare */); }
    get lastChild() { return this.nextChild(this._tree.children.length - 1, -1, 0, 4 /* DontCare */); }
    childAfter(pos) { return this.nextChild(0, 1, pos, 2 /* After */); }
    childBefore(pos) { return this.nextChild(this._tree.children.length - 1, -1, pos, -2 /* Before */); }
    enter(pos, side, mode = 0) {
        let mounted;
        if (!(mode & exports.IterMode.IgnoreOverlays) && (mounted = this._tree.prop(NodeProp.mounted)) && mounted.overlay) {
            let rPos = pos - this.from;
            for (let { from, to } of mounted.overlay) {
                if ((side > 0 ? from <= rPos : from < rPos) &&
                    (side < 0 ? to >= rPos : to > rPos))
                    return new TreeNode(mounted.tree, mounted.overlay[0].from + this.from, -1, this);
            }
        }
        return this.nextChild(0, 1, pos, side, mode);
    }
    nextSignificantParent() {
        let val = this;
        while (val.type.isAnonymous && val._parent)
            val = val._parent;
        return val;
    }
    get parent() {
        return this._parent ? this._parent.nextSignificantParent() : null;
    }
    get nextSibling() {
        return this._parent && this.index >= 0 ? this._parent.nextChild(this.index + 1, 1, 0, 4 /* DontCare */) : null;
    }
    get prevSibling() {
        return this._parent && this.index >= 0 ? this._parent.nextChild(this.index - 1, -1, 0, 4 /* DontCare */) : null;
    }
    cursor(mode = 0) { return new TreeCursor(this, mode); }
    get tree() { return this._tree; }
    toTree() { return this._tree; }
    resolve(pos, side = 0) {
        return resolveNode(this, pos, side, false);
    }
    resolveInner(pos, side = 0) {
        return resolveNode(this, pos, side, true);
    }
    enterUnfinishedNodesBefore(pos) { return enterUnfinishedNodesBefore(this, pos); }
    getChild(type, before = null, after = null) {
        let r = getChildren(this, type, before, after);
        return r.length ? r[0] : null;
    }
    getChildren(type, before = null, after = null) {
        return getChildren(this, type, before, after);
    }
    /// @internal
    toString() { return this._tree.toString(); }
    get node() { return this; }
    matchContext(context) { return matchNodeContext(this, context); }
}
function getChildren(node, type, before, after) {
    let cur = node.cursor(), result = [];
    if (!cur.firstChild())
        return result;
    if (before != null)
        while (!cur.type.is(before))
            if (!cur.nextSibling())
                return result;
    for (;;) {
        if (after != null && cur.type.is(after))
            return result;
        if (cur.type.is(type))
            result.push(cur.node);
        if (!cur.nextSibling())
            return after == null ? result : [];
    }
}
function matchNodeContext(node, context, i = context.length - 1) {
    for (let p = node.parent; i >= 0; p = p.parent) {
        if (!p)
            return false;
        if (!p.type.isAnonymous) {
            if (context[i] && context[i] != p.name)
                return false;
            i--;
        }
    }
    return true;
}
class BufferContext {
    constructor(parent, buffer, index, start) {
        this.parent = parent;
        this.buffer = buffer;
        this.index = index;
        this.start = start;
    }
}
class BufferNode {
    constructor(context, _parent, index) {
        this.context = context;
        this._parent = _parent;
        this.index = index;
        this.type = context.buffer.set.types[context.buffer.buffer[index]];
    }
    get name() { return this.type.name; }
    get from() { return this.context.start + this.context.buffer.buffer[this.index + 1]; }
    get to() { return this.context.start + this.context.buffer.buffer[this.index + 2]; }
    child(dir, pos, side) {
        let { buffer } = this.context;
        let index = buffer.findChild(this.index + 4, buffer.buffer[this.index + 3], dir, pos - this.context.start, side);
        return index < 0 ? null : new BufferNode(this.context, this, index);
    }
    get firstChild() { return this.child(1, 0, 4 /* DontCare */); }
    get lastChild() { return this.child(-1, 0, 4 /* DontCare */); }
    childAfter(pos) { return this.child(1, pos, 2 /* After */); }
    childBefore(pos) { return this.child(-1, pos, -2 /* Before */); }
    enter(pos, side, mode = 0) {
        if (mode & exports.IterMode.ExcludeBuffers)
            return null;
        let { buffer } = this.context;
        let index = buffer.findChild(this.index + 4, buffer.buffer[this.index + 3], side > 0 ? 1 : -1, pos - this.context.start, side);
        return index < 0 ? null : new BufferNode(this.context, this, index);
    }
    get parent() {
        return this._parent || this.context.parent.nextSignificantParent();
    }
    externalSibling(dir) {
        return this._parent ? null : this.context.parent.nextChild(this.context.index + dir, dir, 0, 4 /* DontCare */);
    }
    get nextSibling() {
        let { buffer } = this.context;
        let after = buffer.buffer[this.index + 3];
        if (after < (this._parent ? buffer.buffer[this._parent.index + 3] : buffer.buffer.length))
            return new BufferNode(this.context, this._parent, after);
        return this.externalSibling(1);
    }
    get prevSibling() {
        let { buffer } = this.context;
        let parentStart = this._parent ? this._parent.index + 4 : 0;
        if (this.index == parentStart)
            return this.externalSibling(-1);
        return new BufferNode(this.context, this._parent, buffer.findChild(parentStart, this.index, -1, 0, 4 /* DontCare */));
    }
    cursor(mode = 0) { return new TreeCursor(this, mode); }
    get tree() { return null; }
    toTree() {
        let children = [], positions = [];
        let { buffer } = this.context;
        let startI = this.index + 4, endI = buffer.buffer[this.index + 3];
        if (endI > startI) {
            let from = buffer.buffer[this.index + 1], to = buffer.buffer[this.index + 2];
            children.push(buffer.slice(startI, endI, from, to));
            positions.push(0);
        }
        return new Tree(this.type, children, positions, this.to - this.from);
    }
    resolve(pos, side = 0) {
        return resolveNode(this, pos, side, false);
    }
    resolveInner(pos, side = 0) {
        return resolveNode(this, pos, side, true);
    }
    enterUnfinishedNodesBefore(pos) { return enterUnfinishedNodesBefore(this, pos); }
    /// @internal
    toString() { return this.context.buffer.childString(this.index); }
    getChild(type, before = null, after = null) {
        let r = getChildren(this, type, before, after);
        return r.length ? r[0] : null;
    }
    getChildren(type, before = null, after = null) {
        return getChildren(this, type, before, after);
    }
    get node() { return this; }
    matchContext(context) { return matchNodeContext(this, context); }
}
/// A tree cursor object focuses on a given node in a syntax tree, and
/// allows you to move to adjacent nodes.
class TreeCursor {
    /// @internal
    constructor(node, 
    /// @internal
    mode = 0) {
        this.mode = mode;
        /// @internal
        this.buffer = null;
        this.stack = [];
        /// @internal
        this.index = 0;
        this.bufferNode = null;
        if (node instanceof TreeNode) {
            this.yieldNode(node);
        }
        else {
            this._tree = node.context.parent;
            this.buffer = node.context;
            for (let n = node._parent; n; n = n._parent)
                this.stack.unshift(n.index);
            this.bufferNode = node;
            this.yieldBuf(node.index);
        }
    }
    /// Shorthand for `.type.name`.
    get name() { return this.type.name; }
    yieldNode(node) {
        if (!node)
            return false;
        this._tree = node;
        this.type = node.type;
        this.from = node.from;
        this.to = node.to;
        return true;
    }
    yieldBuf(index, type) {
        this.index = index;
        let { start, buffer } = this.buffer;
        this.type = type || buffer.set.types[buffer.buffer[index]];
        this.from = start + buffer.buffer[index + 1];
        this.to = start + buffer.buffer[index + 2];
        return true;
    }
    yield(node) {
        if (!node)
            return false;
        if (node instanceof TreeNode) {
            this.buffer = null;
            return this.yieldNode(node);
        }
        this.buffer = node.context;
        return this.yieldBuf(node.index, node.type);
    }
    /// @internal
    toString() {
        return this.buffer ? this.buffer.buffer.childString(this.index) : this._tree.toString();
    }
    /// @internal
    enterChild(dir, pos, side) {
        if (!this.buffer)
            return this.yield(this._tree.nextChild(dir < 0 ? this._tree._tree.children.length - 1 : 0, dir, pos, side, this.mode));
        let { buffer } = this.buffer;
        let index = buffer.findChild(this.index + 4, buffer.buffer[this.index + 3], dir, pos - this.buffer.start, side);
        if (index < 0)
            return false;
        this.stack.push(this.index);
        return this.yieldBuf(index);
    }
    /// Move the cursor to this node's first child. When this returns
    /// false, the node has no child, and the cursor has not been moved.
    firstChild() { return this.enterChild(1, 0, 4 /* DontCare */); }
    /// Move the cursor to this node's last child.
    lastChild() { return this.enterChild(-1, 0, 4 /* DontCare */); }
    /// Move the cursor to the first child that ends after `pos`.
    childAfter(pos) { return this.enterChild(1, pos, 2 /* After */); }
    /// Move to the last child that starts before `pos`.
    childBefore(pos) { return this.enterChild(-1, pos, -2 /* Before */); }
    /// Move the cursor to the child around `pos`. If side is -1 the
    /// child may end at that position, when 1 it may start there. This
    /// will also enter [overlaid](#common.MountedTree.overlay)
    /// [mounted](#common.NodeProp^mounted) trees unless `overlays` is
    /// set to false.
    enter(pos, side, mode = this.mode) {
        if (!this.buffer)
            return this.yield(this._tree.enter(pos, side, mode));
        return mode & exports.IterMode.ExcludeBuffers ? false : this.enterChild(1, pos, side);
    }
    /// Move to the node's parent node, if this isn't the top node.
    parent() {
        if (!this.buffer)
            return this.yieldNode((this.mode & exports.IterMode.IncludeAnonymous) ? this._tree._parent : this._tree.parent);
        if (this.stack.length)
            return this.yieldBuf(this.stack.pop());
        let parent = (this.mode & exports.IterMode.IncludeAnonymous) ? this.buffer.parent : this.buffer.parent.nextSignificantParent();
        this.buffer = null;
        return this.yieldNode(parent);
    }
    /// @internal
    sibling(dir) {
        if (!this.buffer)
            return !this._tree._parent ? false
                : this.yield(this._tree.index < 0 ? null
                    : this._tree._parent.nextChild(this._tree.index + dir, dir, 0, 4 /* DontCare */, this.mode));
        let { buffer } = this.buffer, d = this.stack.length - 1;
        if (dir < 0) {
            let parentStart = d < 0 ? 0 : this.stack[d] + 4;
            if (this.index != parentStart)
                return this.yieldBuf(buffer.findChild(parentStart, this.index, -1, 0, 4 /* DontCare */));
        }
        else {
            let after = buffer.buffer[this.index + 3];
            if (after < (d < 0 ? buffer.buffer.length : buffer.buffer[this.stack[d] + 3]))
                return this.yieldBuf(after);
        }
        return d < 0 ? this.yield(this.buffer.parent.nextChild(this.buffer.index + dir, dir, 0, 4 /* DontCare */, this.mode)) : false;
    }
    /// Move to this node's next sibling, if any.
    nextSibling() { return this.sibling(1); }
    /// Move to this node's previous sibling, if any.
    prevSibling() { return this.sibling(-1); }
    atLastNode(dir) {
        let index, parent, { buffer } = this;
        if (buffer) {
            if (dir > 0) {
                if (this.index < buffer.buffer.buffer.length)
                    return false;
            }
            else {
                for (let i = 0; i < this.index; i++)
                    if (buffer.buffer.buffer[i + 3] < this.index)
                        return false;
            }
            ({ index, parent } = buffer);
        }
        else {
            ({ index, _parent: parent } = this._tree);
        }
        for (; parent; { index, _parent: parent } = parent) {
            if (index > -1)
                for (let i = index + dir, e = dir < 0 ? -1 : parent._tree.children.length; i != e; i += dir) {
                    let child = parent._tree.children[i];
                    if ((this.mode & exports.IterMode.IncludeAnonymous) ||
                        child instanceof TreeBuffer ||
                        !child.type.isAnonymous ||
                        hasChild(child))
                        return false;
                }
        }
        return true;
    }
    move(dir, enter) {
        if (enter && this.enterChild(dir, 0, 4 /* DontCare */))
            return true;
        for (;;) {
            if (this.sibling(dir))
                return true;
            if (this.atLastNode(dir) || !this.parent())
                return false;
        }
    }
    /// Move to the next node in a
    /// [pre-order](https://en.wikipedia.org/wiki/Tree_traversal#Pre-order_(NLR))
    /// traversal, going from a node to its first child or, if the
    /// current node is empty or `enter` is false, its next sibling or
    /// the next sibling of the first parent node that has one.
    next(enter = true) { return this.move(1, enter); }
    /// Move to the next node in a last-to-first pre-order traveral. A
    /// node is followed by its last child or, if it has none, its
    /// previous sibling or the previous sibling of the first parent
    /// node that has one.
    prev(enter = true) { return this.move(-1, enter); }
    /// Move the cursor to the innermost node that covers `pos`. If
    /// `side` is -1, it will enter nodes that end at `pos`. If it is 1,
    /// it will enter nodes that start at `pos`.
    moveTo(pos, side = 0) {
        // Move up to a node that actually holds the position, if possible
        while (this.from == this.to ||
            (side < 1 ? this.from >= pos : this.from > pos) ||
            (side > -1 ? this.to <= pos : this.to < pos))
            if (!this.parent())
                break;
        // Then scan down into child nodes as far as possible
        while (this.enterChild(1, pos, side)) { }
        return this;
    }
    /// Get a [syntax node](#common.SyntaxNode) at the cursor's current
    /// position.
    get node() {
        if (!this.buffer)
            return this._tree;
        let cache = this.bufferNode, result = null, depth = 0;
        if (cache && cache.context == this.buffer) {
            scan: for (let index = this.index, d = this.stack.length; d >= 0;) {
                for (let c = cache; c; c = c._parent)
                    if (c.index == index) {
                        if (index == this.index)
                            return c;
                        result = c;
                        depth = d + 1;
                        break scan;
                    }
                index = this.stack[--d];
            }
        }
        for (let i = depth; i < this.stack.length; i++)
            result = new BufferNode(this.buffer, result, this.stack[i]);
        return this.bufferNode = new BufferNode(this.buffer, result, this.index);
    }
    /// Get the [tree](#common.Tree) that represents the current node, if
    /// any. Will return null when the node is in a [tree
    /// buffer](#common.TreeBuffer).
    get tree() {
        return this.buffer ? null : this._tree._tree;
    }
    /// Iterate over the current node and all its descendants, calling
    /// `enter` when entering a node and `leave`, if given, when leaving
    /// one. When `enter` returns `false`, any children of that node are
    /// skipped, and `leave` isn't called for it.
    iterate(enter, leave) {
        for (let depth = 0;;) {
            let mustLeave = false;
            if (this.type.isAnonymous || enter(this) !== false) {
                if (this.firstChild()) {
                    depth++;
                    continue;
                }
                if (!this.type.isAnonymous)
                    mustLeave = true;
            }
            for (;;) {
                if (mustLeave && leave)
                    leave(this);
                mustLeave = this.type.isAnonymous;
                if (this.nextSibling())
                    break;
                if (!depth)
                    return;
                this.parent();
                depth--;
                mustLeave = true;
            }
        }
    }
    /// Test whether the current node matches a given contexta sequence
    /// of direct parent node names. Empty strings in the context array
    /// are treated as wildcards.
    matchContext(context) {
        if (!this.buffer)
            return matchNodeContext(this.node, context);
        let { buffer } = this.buffer, { types } = buffer.set;
        for (let i = context.length - 1, d = this.stack.length - 1; i >= 0; d--) {
            if (d < 0)
                return matchNodeContext(this.node, context, i);
            let type = types[buffer.buffer[this.stack[d]]];
            if (!type.isAnonymous) {
                if (context[i] && context[i] != type.name)
                    return false;
                i--;
            }
        }
        return true;
    }
}
function hasChild(tree) {
    return tree.children.some(ch => ch instanceof TreeBuffer || !ch.type.isAnonymous || hasChild(ch));
}
function buildTree(data) {
    var _a;
    let { buffer, nodeSet, maxBufferLength = DefaultBufferLength, reused = [], minRepeatType = nodeSet.types.length } = data;
    let cursor = Array.isArray(buffer) ? new FlatBufferCursor(buffer, buffer.length) : buffer;
    let types = nodeSet.types;
    let contextHash = 0, lookAhead = 0;
    function takeNode(parentStart, minPos, children, positions, inRepeat) {
        let { id, start, end, size } = cursor;
        let lookAheadAtStart = lookAhead;
        while (size < 0) {
            cursor.next();
            if (size == -1 /* Reuse */) {
                let node = reused[id];
                children.push(node);
                positions.push(start - parentStart);
                return;
            }
            else if (size == -3 /* ContextChange */) { // Context change
                contextHash = id;
                return;
            }
            else if (size == -4 /* LookAhead */) {
                lookAhead = id;
                return;
            }
            else {
                throw new RangeError(`Unrecognized record size: ${size}`);
            }
        }
        let type = types[id], node, buffer;
        let startPos = start - parentStart;
        if (end - start <= maxBufferLength && (buffer = findBufferSize(cursor.pos - minPos, inRepeat))) {
            // Small enough for a buffer, and no reused nodes inside
            let data = new Uint16Array(buffer.size - buffer.skip);
            let endPos = cursor.pos - buffer.size, index = data.length;
            while (cursor.pos > endPos)
                index = copyToBuffer(buffer.start, data, index);
            node = new TreeBuffer(data, end - buffer.start, nodeSet);
            startPos = buffer.start - parentStart;
        }
        else { // Make it a node
            let endPos = cursor.pos - size;
            cursor.next();
            let localChildren = [], localPositions = [];
            let localInRepeat = id >= minRepeatType ? id : -1;
            let lastGroup = 0, lastEnd = end;
            while (cursor.pos > endPos) {
                if (localInRepeat >= 0 && cursor.id == localInRepeat && cursor.size >= 0) {
                    if (cursor.end <= lastEnd - maxBufferLength) {
                        makeRepeatLeaf(localChildren, localPositions, start, lastGroup, cursor.end, lastEnd, localInRepeat, lookAheadAtStart);
                        lastGroup = localChildren.length;
                        lastEnd = cursor.end;
                    }
                    cursor.next();
                }
                else {
                    takeNode(start, endPos, localChildren, localPositions, localInRepeat);
                }
            }
            if (localInRepeat >= 0 && lastGroup > 0 && lastGroup < localChildren.length)
                makeRepeatLeaf(localChildren, localPositions, start, lastGroup, start, lastEnd, localInRepeat, lookAheadAtStart);
            localChildren.reverse();
            localPositions.reverse();
            if (localInRepeat > -1 && lastGroup > 0) {
                let make = makeBalanced(type);
                node = balanceRange(type, localChildren, localPositions, 0, localChildren.length, 0, end - start, make, make);
            }
            else {
                node = makeTree(type, localChildren, localPositions, end - start, lookAheadAtStart - end);
            }
        }
        children.push(node);
        positions.push(startPos);
    }
    function makeBalanced(type) {
        return (children, positions, length) => {
            let lookAhead = 0, lastI = children.length - 1, last, lookAheadProp;
            if (lastI >= 0 && (last = children[lastI]) instanceof Tree) {
                if (!lastI && last.type == type && last.length == length)
                    return last;
                if (lookAheadProp = last.prop(NodeProp.lookAhead))
                    lookAhead = positions[lastI] + last.length + lookAheadProp;
            }
            return makeTree(type, children, positions, length, lookAhead);
        };
    }
    function makeRepeatLeaf(children, positions, base, i, from, to, type, lookAhead) {
        let localChildren = [], localPositions = [];
        while (children.length > i) {
            localChildren.push(children.pop());
            localPositions.push(positions.pop() + base - from);
        }
        children.push(makeTree(nodeSet.types[type], localChildren, localPositions, to - from, lookAhead - to));
        positions.push(from - base);
    }
    function makeTree(type, children, positions, length, lookAhead = 0, props) {
        if (contextHash) {
            let pair = [NodeProp.contextHash, contextHash];
            props = props ? [pair].concat(props) : [pair];
        }
        if (lookAhead > 25) {
            let pair = [NodeProp.lookAhead, lookAhead];
            props = props ? [pair].concat(props) : [pair];
        }
        return new Tree(type, children, positions, length, props);
    }
    function findBufferSize(maxSize, inRepeat) {
        // Scan through the buffer to find previous siblings that fit
        // together in a TreeBuffer, and don't contain any reused nodes
        // (which can't be stored in a buffer).
        // If `inRepeat` is > -1, ignore node boundaries of that type for
        // nesting, but make sure the end falls either at the start
        // (`maxSize`) or before such a node.
        let fork = cursor.fork();
        let size = 0, start = 0, skip = 0, minStart = fork.end - maxBufferLength;
        let result = { size: 0, start: 0, skip: 0 };
        scan: for (let minPos = fork.pos - maxSize; fork.pos > minPos;) {
            let nodeSize = fork.size;
            // Pretend nested repeat nodes of the same type don't exist
            if (fork.id == inRepeat && nodeSize >= 0) {
                // Except that we store the current state as a valid return
                // value.
                result.size = size;
                result.start = start;
                result.skip = skip;
                skip += 4;
                size += 4;
                fork.next();
                continue;
            }
            let startPos = fork.pos - nodeSize;
            if (nodeSize < 0 || startPos < minPos || fork.start < minStart)
                break;
            let localSkipped = fork.id >= minRepeatType ? 4 : 0;
            let nodeStart = fork.start;
            fork.next();
            while (fork.pos > startPos) {
                if (fork.size < 0) {
                    if (fork.size == -3 /* ContextChange */)
                        localSkipped += 4;
                    else
                        break scan;
                }
                else if (fork.id >= minRepeatType) {
                    localSkipped += 4;
                }
                fork.next();
            }
            start = nodeStart;
            size += nodeSize;
            skip += localSkipped;
        }
        if (inRepeat < 0 || size == maxSize) {
            result.size = size;
            result.start = start;
            result.skip = skip;
        }
        return result.size > 4 ? result : undefined;
    }
    function copyToBuffer(bufferStart, buffer, index) {
        let { id, start, end, size } = cursor;
        cursor.next();
        if (size >= 0 && id < minRepeatType) {
            let startIndex = index;
            if (size > 4) {
                let endPos = cursor.pos - (size - 4);
                while (cursor.pos > endPos)
                    index = copyToBuffer(bufferStart, buffer, index);
            }
            buffer[--index] = startIndex;
            buffer[--index] = end - bufferStart;
            buffer[--index] = start - bufferStart;
            buffer[--index] = id;
        }
        else if (size == -3 /* ContextChange */) {
            contextHash = id;
        }
        else if (size == -4 /* LookAhead */) {
            lookAhead = id;
        }
        return index;
    }
    let children = [], positions = [];
    while (cursor.pos > 0)
        takeNode(data.start || 0, data.bufferStart || 0, children, positions, -1);
    let length = (_a = data.length) !== null && _a !== void 0 ? _a : (children.length ? positions[0] + children[0].length : 0);
    return new Tree(types[data.topID], children.reverse(), positions.reverse(), length);
}
const nodeSizeCache = new WeakMap;
function nodeSize(balanceType, node) {
    if (!balanceType.isAnonymous || node instanceof TreeBuffer || node.type != balanceType)
        return 1;
    let size = nodeSizeCache.get(node);
    if (size == null) {
        size = 1;
        for (let child of node.children) {
            if (child.type != balanceType || !(child instanceof Tree)) {
                size = 1;
                break;
            }
            size += nodeSize(balanceType, child);
        }
        nodeSizeCache.set(node, size);
    }
    return size;
}
function balanceRange(
// The type the balanced tree's inner nodes.
balanceType, 
// The direct children and their positions
children, positions, 
// The index range in children/positions to use
from, to, 
// The start position of the nodes, relative to their parent.
start, 
// Length of the outer node
length, 
// Function to build the top node of the balanced tree
mkTop, 
// Function to build internal nodes for the balanced tree
mkTree) {
    let total = 0;
    for (let i = from; i < to; i++)
        total += nodeSize(balanceType, children[i]);
    let maxChild = Math.ceil((total * 1.5) / 8 /* BranchFactor */);
    let localChildren = [], localPositions = [];
    function divide(children, positions, from, to, offset) {
        for (let i = from; i < to;) {
            let groupFrom = i, groupStart = positions[i], groupSize = nodeSize(balanceType, children[i]);
            i++;
            for (; i < to; i++) {
                let nextSize = nodeSize(balanceType, children[i]);
                if (groupSize + nextSize >= maxChild)
                    break;
                groupSize += nextSize;
            }
            if (i == groupFrom + 1) {
                if (groupSize > maxChild) {
                    let only = children[groupFrom]; // Only trees can have a size > 1
                    divide(only.children, only.positions, 0, only.children.length, positions[groupFrom] + offset);
                    continue;
                }
                localChildren.push(children[groupFrom]);
            }
            else {
                let length = positions[i - 1] + children[i - 1].length - groupStart;
                localChildren.push(balanceRange(balanceType, children, positions, groupFrom, i, groupStart, length, null, mkTree));
            }
            localPositions.push(groupStart + offset - start);
        }
    }
    divide(children, positions, from, to, 0);
    return (mkTop || mkTree)(localChildren, localPositions, length);
}
/// Provides a way to associate values with pieces of trees. As long
/// as that part of the tree is reused, the associated values can be
/// retrieved from an updated tree.
class NodeWeakMap {
    constructor() {
        this.map = new WeakMap();
    }
    setBuffer(buffer, index, value) {
        let inner = this.map.get(buffer);
        if (!inner)
            this.map.set(buffer, inner = new Map);
        inner.set(index, value);
    }
    getBuffer(buffer, index) {
        let inner = this.map.get(buffer);
        return inner && inner.get(index);
    }
    /// Set the value for this syntax node.
    set(node, value) {
        if (node instanceof BufferNode)
            this.setBuffer(node.context.buffer, node.index, value);
        else if (node instanceof TreeNode)
            this.map.set(node.tree, value);
    }
    /// Retrieve value for this syntax node, if it exists in the map.
    get(node) {
        return node instanceof BufferNode ? this.getBuffer(node.context.buffer, node.index)
            : node instanceof TreeNode ? this.map.get(node.tree) : undefined;
    }
    /// Set the value for the node that a cursor currently points to.
    cursorSet(cursor, value) {
        if (cursor.buffer)
            this.setBuffer(cursor.buffer.buffer, cursor.index, value);
        else
            this.map.set(cursor.tree, value);
    }
    /// Retrieve the value for the node that a cursor currently points
    /// to.
    cursorGet(cursor) {
        return cursor.buffer ? this.getBuffer(cursor.buffer.buffer, cursor.index) : this.map.get(cursor.tree);
    }
}

/// Tree fragments are used during [incremental
/// parsing](#common.Parser.startParse) to track parts of old trees
/// that can be reused in a new parse. An array of fragments is used
/// to track regions of an old tree whose nodes might be reused in new
/// parses. Use the static
/// [`applyChanges`](#common.TreeFragment^applyChanges) method to
/// update fragments for document changes.
class TreeFragment {
    /// Construct a tree fragment.
    constructor(
    /// The start of the unchanged range pointed to by this fragment.
    /// This refers to an offset in the _updated_ document (as opposed
    /// to the original tree).
    from, 
    /// The end of the unchanged range.
    to, 
    /// The tree that this fragment is based on.
    tree, 
    /// The offset between the fragment's tree and the document that
    /// this fragment can be used against. Add this when going from
    /// document to tree positions, subtract it to go from tree to
    /// document positions.
    offset, openStart = false, openEnd = false) {
        this.from = from;
        this.to = to;
        this.tree = tree;
        this.offset = offset;
        this.open = (openStart ? 1 /* Start */ : 0) | (openEnd ? 2 /* End */ : 0);
    }
    /// Whether the start of the fragment represents the start of a
    /// parse, or the end of a change. (In the second case, it may not
    /// be safe to reuse some nodes at the start, depending on the
    /// parsing algorithm.)
    get openStart() { return (this.open & 1 /* Start */) > 0; }
    /// Whether the end of the fragment represents the end of a
    /// full-document parse, or the start of a change.
    get openEnd() { return (this.open & 2 /* End */) > 0; }
    /// Create a set of fragments from a freshly parsed tree, or update
    /// an existing set of fragments by replacing the ones that overlap
    /// with a tree with content from the new tree. When `partial` is
    /// true, the parse is treated as incomplete, and the resulting
    /// fragment has [`openEnd`](#common.TreeFragment.openEnd) set to
    /// true.
    static addTree(tree, fragments = [], partial = false) {
        let result = [new TreeFragment(0, tree.length, tree, 0, false, partial)];
        for (let f of fragments)
            if (f.to > tree.length)
                result.push(f);
        return result;
    }
    /// Apply a set of edits to an array of fragments, removing or
    /// splitting fragments as necessary to remove edited ranges, and
    /// adjusting offsets for fragments that moved.
    static applyChanges(fragments, changes, minGap = 128) {
        if (!changes.length)
            return fragments;
        let result = [];
        let fI = 1, nextF = fragments.length ? fragments[0] : null;
        for (let cI = 0, pos = 0, off = 0;; cI++) {
            let nextC = cI < changes.length ? changes[cI] : null;
            let nextPos = nextC ? nextC.fromA : 1e9;
            if (nextPos - pos >= minGap)
                while (nextF && nextF.from < nextPos) {
                    let cut = nextF;
                    if (pos >= cut.from || nextPos <= cut.to || off) {
                        let fFrom = Math.max(cut.from, pos) - off, fTo = Math.min(cut.to, nextPos) - off;
                        cut = fFrom >= fTo ? null : new TreeFragment(fFrom, fTo, cut.tree, cut.offset + off, cI > 0, !!nextC);
                    }
                    if (cut)
                        result.push(cut);
                    if (nextF.to > nextPos)
                        break;
                    nextF = fI < fragments.length ? fragments[fI++] : null;
                }
            if (!nextC)
                break;
            pos = nextC.toA;
            off = nextC.toA - nextC.toB;
        }
        return result;
    }
}
/// A superclass that parsers should extend.
class Parser {
    /// Start a parse, returning a [partial parse](#common.PartialParse)
    /// object. [`fragments`](#common.TreeFragment) can be passed in to
    /// make the parse incremental.
    ///
    /// By default, the entire input is parsed. You can pass `ranges`,
    /// which should be a sorted array of non-empty, non-overlapping
    /// ranges, to parse only those ranges. The tree returned in that
    /// case will start at `ranges[0].from`.
    startParse(input, fragments, ranges) {
        if (typeof input == "string")
            input = new StringInput(input);
        ranges = !ranges ? [new Range(0, input.length)] : ranges.length ? ranges.map(r => new Range(r.from, r.to)) : [new Range(0, 0)];
        return this.createParse(input, fragments || [], ranges);
    }
    /// Run a full parse, returning the resulting tree.
    parse(input, fragments, ranges) {
        let parse = this.startParse(input, fragments, ranges);
        for (;;) {
            let done = parse.advance();
            if (done)
                return done;
        }
    }
}
class StringInput {
    constructor(string) {
        this.string = string;
    }
    get length() { return this.string.length; }
    chunk(from) { return this.string.slice(from); }
    get lineChunks() { return false; }
    read(from, to) { return this.string.slice(from, to); }
}

/// Create a parse wrapper that, after the inner parse completes,
/// scans its tree for mixed language regions with the `nest`
/// function, runs the resulting [inner parses](#common.NestedParse),
/// and then [mounts](#common.NodeProp^mounted) their results onto the
/// tree.
///
/// The nesting function is passed a cursor to provide context for a
/// node, but _should not_ move that cursor, only inspect its
/// properties and optionally access its
/// [node object](#common.TreeCursor.node).
function parseMixed(nest) {
    return (parse, input, fragments, ranges) => new MixedParse(parse, nest, input, fragments, ranges);
}
class InnerParse {
    constructor(parser, parse, overlay, target, ranges) {
        this.parser = parser;
        this.parse = parse;
        this.overlay = overlay;
        this.target = target;
        this.ranges = ranges;
    }
}
class ActiveOverlay {
    constructor(parser, predicate, mounts, index, start, target, prev) {
        this.parser = parser;
        this.predicate = predicate;
        this.mounts = mounts;
        this.index = index;
        this.start = start;
        this.target = target;
        this.prev = prev;
        this.depth = 0;
        this.ranges = [];
    }
}
const stoppedInner = new NodeProp({ perNode: true });
class MixedParse {
    constructor(base, nest, input, fragments, ranges) {
        this.nest = nest;
        this.input = input;
        this.fragments = fragments;
        this.ranges = ranges;
        this.inner = [];
        this.innerDone = 0;
        this.baseTree = null;
        this.stoppedAt = null;
        this.baseParse = base;
    }
    advance() {
        if (this.baseParse) {
            let done = this.baseParse.advance();
            if (!done)
                return null;
            this.baseParse = null;
            this.baseTree = done;
            this.startInner();
            if (this.stoppedAt != null)
                for (let inner of this.inner)
                    inner.parse.stopAt(this.stoppedAt);
        }
        if (this.innerDone == this.inner.length) {
            let result = this.baseTree;
            if (this.stoppedAt != null)
                result = new Tree(result.type, result.children, result.positions, result.length, result.propValues.concat([[stoppedInner, this.stoppedAt]]));
            return result;
        }
        let inner = this.inner[this.innerDone], done = inner.parse.advance();
        if (done) {
            this.innerDone++;
            // This is a somewhat dodgy but super helpful hack where we
            // patch up nodes created by the inner parse (and thus
            // presumably not aliased anywhere else) to hold the information
            // about the inner parse.
            let props = Object.assign(Object.create(null), inner.target.props);
            props[NodeProp.mounted.id] = new MountedTree(done, inner.overlay, inner.parser);
            inner.target.props = props;
        }
        return null;
    }
    get parsedPos() {
        if (this.baseParse)
            return 0;
        let pos = this.input.length;
        for (let i = this.innerDone; i < this.inner.length; i++) {
            if (this.inner[i].ranges[0].from < pos)
                pos = Math.min(pos, this.inner[i].parse.parsedPos);
        }
        return pos;
    }
    stopAt(pos) {
        this.stoppedAt = pos;
        if (this.baseParse)
            this.baseParse.stopAt(pos);
        else
            for (let i = this.innerDone; i < this.inner.length; i++)
                this.inner[i].parse.stopAt(pos);
    }
    startInner() {
        let fragmentCursor = new FragmentCursor(this.fragments);
        let overlay = null;
        let covered = null;
        let cursor = new TreeCursor(new TreeNode(this.baseTree, this.ranges[0].from, 0, null), exports.IterMode.IncludeAnonymous | exports.IterMode.IgnoreMounts);
        scan: for (let nest, isCovered; this.stoppedAt == null || cursor.from < this.stoppedAt;) {
            let enter = true, range;
            if (fragmentCursor.hasNode(cursor)) {
                if (overlay) {
                    let match = overlay.mounts.find(m => m.frag.from <= cursor.from && m.frag.to >= cursor.to && m.mount.overlay);
                    if (match)
                        for (let r of match.mount.overlay) {
                            let from = r.from + match.pos, to = r.to + match.pos;
                            if (from >= cursor.from && to <= cursor.to && !overlay.ranges.some(r => r.from < to && r.to > from))
                                overlay.ranges.push({ from, to });
                        }
                }
                enter = false;
            }
            else if (covered && (isCovered = checkCover(covered.ranges, cursor.from, cursor.to))) {
                enter = isCovered != 2 /* Full */;
            }
            else if (!cursor.type.isAnonymous && cursor.from < cursor.to && (nest = this.nest(cursor, this.input))) {
                if (!cursor.tree)
                    materialize(cursor);
                let oldMounts = fragmentCursor.findMounts(cursor.from, nest.parser);
                if (typeof nest.overlay == "function") {
                    overlay = new ActiveOverlay(nest.parser, nest.overlay, oldMounts, this.inner.length, cursor.from, cursor.tree, overlay);
                }
                else {
                    let ranges = punchRanges(this.ranges, nest.overlay || [new Range(cursor.from, cursor.to)]);
                    if (ranges.length)
                        this.inner.push(new InnerParse(nest.parser, nest.parser.startParse(this.input, enterFragments(oldMounts, ranges), ranges), nest.overlay ? nest.overlay.map(r => new Range(r.from - cursor.from, r.to - cursor.from)) : null, cursor.tree, ranges));
                    if (!nest.overlay)
                        enter = false;
                    else if (ranges.length)
                        covered = { ranges, depth: 0, prev: covered };
                }
            }
            else if (overlay && (range = overlay.predicate(cursor))) {
                if (range === true)
                    range = new Range(cursor.from, cursor.to);
                if (range.from < range.to)
                    overlay.ranges.push(range);
            }
            if (enter && cursor.firstChild()) {
                if (overlay)
                    overlay.depth++;
                if (covered)
                    covered.depth++;
            }
            else {
                for (;;) {
                    if (cursor.nextSibling())
                        break;
                    if (!cursor.parent())
                        break scan;
                    if (overlay && !--overlay.depth) {
                        let ranges = punchRanges(this.ranges, overlay.ranges);
                        if (ranges.length)
                            this.inner.splice(overlay.index, 0, new InnerParse(overlay.parser, overlay.parser.startParse(this.input, enterFragments(overlay.mounts, ranges), ranges), overlay.ranges.map(r => new Range(r.from - overlay.start, r.to - overlay.start)), overlay.target, ranges));
                        overlay = overlay.prev;
                    }
                    if (covered && !--covered.depth)
                        covered = covered.prev;
                }
            }
        }
    }
}
function checkCover(covered, from, to) {
    for (let range of covered) {
        if (range.from >= to)
            break;
        if (range.to > from)
            return range.from <= from && range.to >= to ? 2 /* Full */ : 1 /* Partial */;
    }
    return 0 /* None */;
}
// Take a piece of buffer and convert it into a stand-alone
// TreeBuffer.
function sliceBuf(buf, startI, endI, nodes, positions, off) {
    if (startI < endI) {
        let from = buf.buffer[startI + 1], to = buf.buffer[endI - 2];
        nodes.push(buf.slice(startI, endI, from, to));
        positions.push(from - off);
    }
}
// This function takes a node that's in a buffer, and converts it, and
// its parent buffer nodes, into a Tree. This is again acting on the
// assumption that the trees and buffers have been constructed by the
// parse that was ran via the mix parser, and thus aren't shared with
// any other code, making violations of the immutability safe.
function materialize(cursor) {
    let { node } = cursor, depth = 0;
    // Scan up to the nearest tree
    do {
        cursor.parent();
        depth++;
    } while (!cursor.tree);
    // Find the index of the buffer in that tree
    let i = 0, base = cursor.tree, off = 0;
    for (;; i++) {
        off = base.positions[i] + cursor.from;
        if (off <= node.from && off + base.children[i].length >= node.to)
            break;
    }
    let buf = base.children[i], b = buf.buffer;
    // Split a level in the buffer, putting the nodes before and after
    // the child that contains `node` into new buffers.
    function split(startI, endI, type, innerOffset, length) {
        let i = startI;
        while (b[i + 2] + off <= node.from)
            i = b[i + 3];
        let children = [], positions = [];
        sliceBuf(buf, startI, i, children, positions, innerOffset);
        let from = b[i + 1], to = b[i + 2];
        let isTarget = from + off == node.from && to + off == node.to && b[i] == node.type.id;
        children.push(isTarget ? node.toTree() : split(i + 4, b[i + 3], buf.set.types[b[i]], from, to - from));
        positions.push(from - innerOffset);
        sliceBuf(buf, b[i + 3], endI, children, positions, innerOffset);
        return new Tree(type, children, positions, length);
    }
    base.children[i] = split(0, b.length, NodeType.none, 0, buf.length);
    // Move the cursor back to the target node
    for (let d = 0; d <= depth; d++)
        cursor.childAfter(node.from);
}
class StructureCursor {
    constructor(root, offset) {
        this.offset = offset;
        this.done = false;
        this.cursor = root.cursor(exports.IterMode.IncludeAnonymous | exports.IterMode.IgnoreMounts);
    }
    // Move to the first node (in pre-order) that starts at or after `pos`.
    moveTo(pos) {
        let { cursor } = this, p = pos - this.offset;
        while (!this.done && cursor.from < p) {
            if (cursor.to >= pos && cursor.enter(p, 1, exports.IterMode.IgnoreOverlays | exports.IterMode.ExcludeBuffers)) ;
            else if (!cursor.next(false))
                this.done = true;
        }
    }
    hasNode(cursor) {
        this.moveTo(cursor.from);
        if (!this.done && this.cursor.from + this.offset == cursor.from && this.cursor.tree) {
            for (let tree = this.cursor.tree;;) {
                if (tree == cursor.tree)
                    return true;
                if (tree.children.length && tree.positions[0] == 0 && tree.children[0] instanceof Tree)
                    tree = tree.children[0];
                else
                    break;
            }
        }
        return false;
    }
}
class FragmentCursor {
    constructor(fragments) {
        var _a;
        this.fragments = fragments;
        this.curTo = 0;
        this.fragI = 0;
        if (fragments.length) {
            let first = this.curFrag = fragments[0];
            this.curTo = (_a = first.tree.prop(stoppedInner)) !== null && _a !== void 0 ? _a : first.to;
            this.inner = new StructureCursor(first.tree, -first.offset);
        }
        else {
            this.curFrag = this.inner = null;
        }
    }
    hasNode(node) {
        while (this.curFrag && node.from >= this.curTo)
            this.nextFrag();
        return this.curFrag && this.curFrag.from <= node.from && this.curTo >= node.to && this.inner.hasNode(node);
    }
    nextFrag() {
        var _a;
        this.fragI++;
        if (this.fragI == this.fragments.length) {
            this.curFrag = this.inner = null;
        }
        else {
            let frag = this.curFrag = this.fragments[this.fragI];
            this.curTo = (_a = frag.tree.prop(stoppedInner)) !== null && _a !== void 0 ? _a : frag.to;
            this.inner = new StructureCursor(frag.tree, -frag.offset);
        }
    }
    findMounts(pos, parser) {
        var _a;
        let result = [];
        if (this.inner) {
            this.inner.cursor.moveTo(pos, 1);
            for (let pos = this.inner.cursor.node; pos; pos = pos.parent) {
                let mount = (_a = pos.tree) === null || _a === void 0 ? void 0 : _a.prop(NodeProp.mounted);
                if (mount && mount.parser == parser) {
                    for (let i = this.fragI; i < this.fragments.length; i++) {
                        let frag = this.fragments[i];
                        if (frag.from >= pos.to)
                            break;
                        if (frag.tree == this.curFrag.tree)
                            result.push({
                                frag,
                                pos: pos.from - frag.offset,
                                mount
                            });
                    }
                }
            }
        }
        return result;
    }
}
function punchRanges(outer, ranges) {
    let copy = null, current = ranges;
    for (let i = 1, j = 0; i < outer.length; i++) {
        let gapFrom = outer[i - 1].to, gapTo = outer[i].from;
        for (; j < current.length; j++) {
            let r = current[j];
            if (r.from >= gapTo)
                break;
            if (r.to <= gapFrom)
                continue;
            if (!copy)
                current = copy = ranges.slice();
            if (r.from < gapFrom) {
                copy[j] = new Range(r.from, gapFrom);
                if (r.to > gapTo)
                    copy.splice(j + 1, 0, new Range(gapTo, r.to));
            }
            else if (r.to > gapTo) {
                copy[j--] = new Range(gapTo, r.to);
            }
            else {
                copy.splice(j--, 1);
            }
        }
    }
    return current;
}
function findCoverChanges(a, b, from, to) {
    let iA = 0, iB = 0, inA = false, inB = false, pos = -1e9;
    let result = [];
    for (;;) {
        let nextA = iA == a.length ? 1e9 : inA ? a[iA].to : a[iA].from;
        let nextB = iB == b.length ? 1e9 : inB ? b[iB].to : b[iB].from;
        if (inA != inB) {
            let start = Math.max(pos, from), end = Math.min(nextA, nextB, to);
            if (start < end)
                result.push(new Range(start, end));
        }
        pos = Math.min(nextA, nextB);
        if (pos == 1e9)
            break;
        if (nextA == pos) {
            if (!inA)
                inA = true;
            else {
                inA = false;
                iA++;
            }
        }
        if (nextB == pos) {
            if (!inB)
                inB = true;
            else {
                inB = false;
                iB++;
            }
        }
    }
    return result;
}
// Given a number of fragments for the outer tree, and a set of ranges
// to parse, find fragments for inner trees mounted around those
// ranges, if any.
function enterFragments(mounts, ranges) {
    let result = [];
    for (let { pos, mount, frag } of mounts) {
        let startPos = pos + (mount.overlay ? mount.overlay[0].from : 0), endPos = startPos + mount.tree.length;
        let from = Math.max(frag.from, startPos), to = Math.min(frag.to, endPos);
        if (mount.overlay) {
            let overlay = mount.overlay.map(r => new Range(r.from + pos, r.to + pos));
            let changes = findCoverChanges(ranges, overlay, from, to);
            for (let i = 0, pos = from;; i++) {
                let last = i == changes.length, end = last ? to : changes[i].from;
                if (end > pos)
                    result.push(new TreeFragment(pos, end, mount.tree, -startPos, frag.from >= pos, frag.to <= end));
                if (last)
                    break;
                pos = changes[i].to;
            }
        }
        else {
            result.push(new TreeFragment(from, to, mount.tree, -startPos, frag.from >= startPos, frag.to <= endPos));
        }
    }
    return result;
}

exports.DefaultBufferLength = DefaultBufferLength;
exports.MountedTree = MountedTree;
exports.NodeProp = NodeProp;
exports.NodeSet = NodeSet;
exports.NodeType = NodeType;
exports.NodeWeakMap = NodeWeakMap;
exports.Parser = Parser;
exports.Tree = Tree;
exports.TreeBuffer = TreeBuffer;
exports.TreeCursor = TreeCursor;
exports.TreeFragment = TreeFragment;
exports.parseMixed = parseMixed;


/***/ }),

/***/ "./node_modules/@lezer/highlight/dist/index.cjs":
/*!******************************************************!*\
  !*** ./node_modules/@lezer/highlight/dist/index.cjs ***!
  \******************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({ value: true }));

var common = __webpack_require__(/*! @lezer/common */ "./node_modules/@lezer/common/dist/index.cjs");

let nextTagID = 0;
/// Highlighting tags are markers that denote a highlighting category.
/// They are [associated](#highlight.styleTags) with parts of a syntax
/// tree by a language mode, and then mapped to an actual CSS style by
/// a [highlighter](#highlight.Highlighter).
///
/// Because syntax tree node types and highlight styles have to be
/// able to talk the same language, CodeMirror uses a mostly _closed_
/// [vocabulary](#highlight.tags) of syntax tags (as opposed to
/// traditional open string-based systems, which make it hard for
/// highlighting themes to cover all the tokens produced by the
/// various languages).
///
/// It _is_ possible to [define](#highlight.Tag^define) your own
/// highlighting tags for system-internal use (where you control both
/// the language package and the highlighter), but such tags will not
/// be picked up by regular highlighters (though you can derive them
/// from standard tags to allow highlighters to fall back to those).
class Tag {
    /// @internal
    constructor(
    /// The set of this tag and all its parent tags, starting with
    /// this one itself and sorted in order of decreasing specificity.
    set, 
    /// The base unmodified tag that this one is based on, if it's
    /// modified @internal
    base, 
    /// The modifiers applied to this.base @internal
    modified) {
        this.set = set;
        this.base = base;
        this.modified = modified;
        /// @internal
        this.id = nextTagID++;
    }
    /// Define a new tag. If `parent` is given, the tag is treated as a
    /// sub-tag of that parent, and
    /// [highlighters](#highlight.tagHighlighter) that don't mention
    /// this tag will try to fall back to the parent tag (or grandparent
    /// tag, etc).
    static define(parent) {
        if (parent === null || parent === void 0 ? void 0 : parent.base)
            throw new Error("Can not derive from a modified tag");
        let tag = new Tag([], null, []);
        tag.set.push(tag);
        if (parent)
            for (let t of parent.set)
                tag.set.push(t);
        return tag;
    }
    /// Define a tag _modifier_, which is a function that, given a tag,
    /// will return a tag that is a subtag of the original. Applying the
    /// same modifier to a twice tag will return the same value (`m1(t1)
    /// == m1(t1)`) and applying multiple modifiers will, regardless or
    /// order, produce the same tag (`m1(m2(t1)) == m2(m1(t1))`).
    ///
    /// When multiple modifiers are applied to a given base tag, each
    /// smaller set of modifiers is registered as a parent, so that for
    /// example `m1(m2(m3(t1)))` is a subtype of `m1(m2(t1))`,
    /// `m1(m3(t1)`, and so on.
    static defineModifier() {
        let mod = new Modifier;
        return (tag) => {
            if (tag.modified.indexOf(mod) > -1)
                return tag;
            return Modifier.get(tag.base || tag, tag.modified.concat(mod).sort((a, b) => a.id - b.id));
        };
    }
}
let nextModifierID = 0;
class Modifier {
    constructor() {
        this.instances = [];
        this.id = nextModifierID++;
    }
    static get(base, mods) {
        if (!mods.length)
            return base;
        let exists = mods[0].instances.find(t => t.base == base && sameArray(mods, t.modified));
        if (exists)
            return exists;
        let set = [], tag = new Tag(set, base, mods);
        for (let m of mods)
            m.instances.push(tag);
        let configs = permute(mods);
        for (let parent of base.set)
            for (let config of configs)
                set.push(Modifier.get(parent, config));
        return tag;
    }
}
function sameArray(a, b) {
    return a.length == b.length && a.every((x, i) => x == b[i]);
}
function permute(array) {
    let result = [array];
    for (let i = 0; i < array.length; i++) {
        for (let a of permute(array.slice(0, i).concat(array.slice(i + 1))))
            result.push(a);
    }
    return result;
}
/// This function is used to add a set of tags to a language syntax
/// via [`NodeSet.extend`](#common.NodeSet.extend) or
/// [`LRParser.configure`](#lr.LRParser.configure).
///
/// The argument object maps node selectors to [highlighting
/// tags](#highlight.Tag) or arrays of tags.
///
/// Node selectors may hold one or more (space-separated) node paths.
/// Such a path can be a [node name](#common.NodeType.name), or
/// multiple node names (or `*` wildcards) separated by slash
/// characters, as in `"Block/Declaration/VariableName"`. Such a path
/// matches the final node but only if its direct parent nodes are the
/// other nodes mentioned. A `*` in such a path matches any parent,
/// but only a single levelwildcards that match multiple parents
/// aren't supported, both for efficiency reasons and because Lezer
/// trees make it rather hard to reason about what they would match.)
///
/// A path can be ended with `/...` to indicate that the tag assigned
/// to the node should also apply to all child nodes, even if they
/// match their own style (by default, only the innermost style is
/// used).
///
/// When a path ends in `!`, as in `Attribute!`, no further matching
/// happens for the node's child nodes, and the entire node gets the
/// given style.
///
/// In this notation, node names that contain `/`, `!`, `*`, or `...`
/// must be quoted as JSON strings.
///
/// For example:
///
/// ```javascript
/// parser.withProps(
///   styleTags({
///     // Style Number and BigNumber nodes
///     "Number BigNumber": tags.number,
///     // Style Escape nodes whose parent is String
///     "String/Escape": tags.escape,
///     // Style anything inside Attributes nodes
///     "Attributes!": tags.meta,
///     // Add a style to all content inside Italic nodes
///     "Italic/...": tags.emphasis,
///     // Style InvalidString nodes as both `string` and `invalid`
///     "InvalidString": [tags.string, tags.invalid],
///     // Style the node named "/" as punctuation
///     '"/"': tags.punctuation
///   })
/// )
/// ```
function styleTags(spec) {
    let byName = Object.create(null);
    for (let prop in spec) {
        let tags = spec[prop];
        if (!Array.isArray(tags))
            tags = [tags];
        for (let part of prop.split(" "))
            if (part) {
                let pieces = [], mode = 2 /* Normal */, rest = part;
                for (let pos = 0;;) {
                    if (rest == "..." && pos > 0 && pos + 3 == part.length) {
                        mode = 1 /* Inherit */;
                        break;
                    }
                    let m = /^"(?:[^"\\]|\\.)*?"|[^\/!]+/.exec(rest);
                    if (!m)
                        throw new RangeError("Invalid path: " + part);
                    pieces.push(m[0] == "*" ? "" : m[0][0] == '"' ? JSON.parse(m[0]) : m[0]);
                    pos += m[0].length;
                    if (pos == part.length)
                        break;
                    let next = part[pos++];
                    if (pos == part.length && next == "!") {
                        mode = 0 /* Opaque */;
                        break;
                    }
                    if (next != "/")
                        throw new RangeError("Invalid path: " + part);
                    rest = part.slice(pos);
                }
                let last = pieces.length - 1, inner = pieces[last];
                if (!inner)
                    throw new RangeError("Invalid path: " + part);
                let rule = new Rule(tags, mode, last > 0 ? pieces.slice(0, last) : null);
                byName[inner] = rule.sort(byName[inner]);
            }
    }
    return ruleNodeProp.add(byName);
}
const ruleNodeProp = new common.NodeProp();
class Rule {
    constructor(tags, mode, context, next) {
        this.tags = tags;
        this.mode = mode;
        this.context = context;
        this.next = next;
    }
    sort(other) {
        if (!other || other.depth < this.depth) {
            this.next = other;
            return this;
        }
        other.next = this.sort(other.next);
        return other;
    }
    get depth() { return this.context ? this.context.length : 0; }
}
/// Define a [highlighter](#highlight.Highlighter) from an array of
/// tag/class pairs. Classes associated with more specific tags will
/// take precedence.
function tagHighlighter(tags, options) {
    let map = Object.create(null);
    for (let style of tags) {
        if (!Array.isArray(style.tag))
            map[style.tag.id] = style.class;
        else
            for (let tag of style.tag)
                map[tag.id] = style.class;
    }
    let { scope, all = null } = options || {};
    return {
        style: (tags) => {
            let cls = all;
            for (let tag of tags) {
                for (let sub of tag.set) {
                    let tagClass = map[sub.id];
                    if (tagClass) {
                        cls = cls ? cls + " " + tagClass : tagClass;
                        break;
                    }
                }
            }
            return cls;
        },
        scope: scope
    };
}
function highlightTags(highlighters, tags) {
    let result = null;
    for (let highlighter of highlighters) {
        let value = highlighter.style(tags);
        if (value)
            result = result ? result + " " + value : value;
    }
    return result;
}
/// Highlight the given [tree](#common.Tree) with the given
/// [highlighter](#highlight.Highlighter).
function highlightTree(tree, highlighter, 
/// Assign styling to a region of the text. Will be called, in order
/// of position, for any ranges where more than zero classes apply.
/// `classes` is a space separated string of CSS classes.
putStyle, 
/// The start of the range to highlight.
from = 0, 
/// The end of the range.
to = tree.length) {
    let builder = new HighlightBuilder(from, Array.isArray(highlighter) ? highlighter : [highlighter], putStyle);
    builder.highlightRange(tree.cursor(), from, to, "", builder.highlighters);
    builder.flush(to);
}
class HighlightBuilder {
    constructor(at, highlighters, span) {
        this.at = at;
        this.highlighters = highlighters;
        this.span = span;
        this.class = "";
    }
    startSpan(at, cls) {
        if (cls != this.class) {
            this.flush(at);
            if (at > this.at)
                this.at = at;
            this.class = cls;
        }
    }
    flush(to) {
        if (to > this.at && this.class)
            this.span(this.at, to, this.class);
    }
    highlightRange(cursor, from, to, inheritedClass, highlighters) {
        let { type, from: start, to: end } = cursor;
        if (start >= to || end <= from)
            return;
        if (type.isTop)
            highlighters = this.highlighters.filter(h => !h.scope || h.scope(type));
        let cls = inheritedClass;
        let rule = type.prop(ruleNodeProp), opaque = false;
        while (rule) {
            if (!rule.context || cursor.matchContext(rule.context)) {
                let tagCls = highlightTags(highlighters, rule.tags);
                if (tagCls) {
                    if (cls)
                        cls += " ";
                    cls += tagCls;
                    if (rule.mode == 1 /* Inherit */)
                        inheritedClass += (inheritedClass ? " " : "") + tagCls;
                    else if (rule.mode == 0 /* Opaque */)
                        opaque = true;
                }
                break;
            }
            rule = rule.next;
        }
        this.startSpan(cursor.from, cls);
        if (opaque)
            return;
        let mounted = cursor.tree && cursor.tree.prop(common.NodeProp.mounted);
        if (mounted && mounted.overlay) {
            let inner = cursor.node.enter(mounted.overlay[0].from + start, 1);
            let innerHighlighters = this.highlighters.filter(h => !h.scope || h.scope(mounted.tree.type));
            let hasChild = cursor.firstChild();
            for (let i = 0, pos = start;; i++) {
                let next = i < mounted.overlay.length ? mounted.overlay[i] : null;
                let nextPos = next ? next.from + start : end;
                let rangeFrom = Math.max(from, pos), rangeTo = Math.min(to, nextPos);
                if (rangeFrom < rangeTo && hasChild) {
                    while (cursor.from < rangeTo) {
                        this.highlightRange(cursor, rangeFrom, rangeTo, inheritedClass, highlighters);
                        this.startSpan(Math.min(to, cursor.to), cls);
                        if (cursor.to >= nextPos || !cursor.nextSibling())
                            break;
                    }
                }
                if (!next || nextPos > to)
                    break;
                pos = next.to + start;
                if (pos > from) {
                    this.highlightRange(inner.cursor(), Math.max(from, next.from + start), Math.min(to, pos), inheritedClass, innerHighlighters);
                    this.startSpan(pos, cls);
                }
            }
            if (hasChild)
                cursor.parent();
        }
        else if (cursor.firstChild()) {
            do {
                if (cursor.to <= from)
                    continue;
                if (cursor.from >= to)
                    break;
                this.highlightRange(cursor, from, to, inheritedClass, highlighters);
                this.startSpan(Math.min(to, cursor.to), cls);
            } while (cursor.nextSibling());
            cursor.parent();
        }
    }
}
const t = Tag.define;
const comment = t(), name = t(), typeName = t(name), propertyName = t(name), literal = t(), string = t(literal), number = t(literal), content = t(), heading = t(content), keyword = t(), operator = t(), punctuation = t(), bracket = t(punctuation), meta = t();
/// The default set of highlighting [tags](#highlight.Tag).
///
/// This collection is heavily biased towards programming languages,
/// and necessarily incomplete. A full ontology of syntactic
/// constructs would fill a stack of books, and be impractical to
/// write themes for. So try to make do with this set. If all else
/// fails, [open an
/// issue](https://github.com/codemirror/codemirror.next) to propose a
/// new tag, or [define](#highlight.Tag^define) a local custom tag for
/// your use case.
///
/// Note that it is not obligatory to always attach the most specific
/// tag possible to an elementif your grammar can't easily
/// distinguish a certain type of element (such as a local variable),
/// it is okay to style it as its more general variant (a variable).
/// 
/// For tags that extend some parent tag, the documentation links to
/// the parent.
const tags = {
    /// A comment.
    comment,
    /// A line [comment](#highlight.tags.comment).
    lineComment: t(comment),
    /// A block [comment](#highlight.tags.comment).
    blockComment: t(comment),
    /// A documentation [comment](#highlight.tags.comment).
    docComment: t(comment),
    /// Any kind of identifier.
    name,
    /// The [name](#highlight.tags.name) of a variable.
    variableName: t(name),
    /// A type [name](#highlight.tags.name).
    typeName: typeName,
    /// A tag name (subtag of [`typeName`](#highlight.tags.typeName)).
    tagName: t(typeName),
    /// A property or field [name](#highlight.tags.name).
    propertyName: propertyName,
    /// An attribute name (subtag of [`propertyName`](#highlight.tags.propertyName)).
    attributeName: t(propertyName),
    /// The [name](#highlight.tags.name) of a class.
    className: t(name),
    /// A label [name](#highlight.tags.name).
    labelName: t(name),
    /// A namespace [name](#highlight.tags.name).
    namespace: t(name),
    /// The [name](#highlight.tags.name) of a macro.
    macroName: t(name),
    /// A literal value.
    literal,
    /// A string [literal](#highlight.tags.literal).
    string,
    /// A documentation [string](#highlight.tags.string).
    docString: t(string),
    /// A character literal (subtag of [string](#highlight.tags.string)).
    character: t(string),
    /// An attribute value (subtag of [string](#highlight.tags.string)).
    attributeValue: t(string),
    /// A number [literal](#highlight.tags.literal).
    number,
    /// An integer [number](#highlight.tags.number) literal.
    integer: t(number),
    /// A floating-point [number](#highlight.tags.number) literal.
    float: t(number),
    /// A boolean [literal](#highlight.tags.literal).
    bool: t(literal),
    /// Regular expression [literal](#highlight.tags.literal).
    regexp: t(literal),
    /// An escape [literal](#highlight.tags.literal), for example a
    /// backslash escape in a string.
    escape: t(literal),
    /// A color [literal](#highlight.tags.literal).
    color: t(literal),
    /// A URL [literal](#highlight.tags.literal).
    url: t(literal),
    /// A language keyword.
    keyword,
    /// The [keyword](#highlight.tags.keyword) for the self or this
    /// object.
    self: t(keyword),
    /// The [keyword](#highlight.tags.keyword) for null.
    null: t(keyword),
    /// A [keyword](#highlight.tags.keyword) denoting some atomic value.
    atom: t(keyword),
    /// A [keyword](#highlight.tags.keyword) that represents a unit.
    unit: t(keyword),
    /// A modifier [keyword](#highlight.tags.keyword).
    modifier: t(keyword),
    /// A [keyword](#highlight.tags.keyword) that acts as an operator.
    operatorKeyword: t(keyword),
    /// A control-flow related [keyword](#highlight.tags.keyword).
    controlKeyword: t(keyword),
    /// A [keyword](#highlight.tags.keyword) that defines something.
    definitionKeyword: t(keyword),
    /// A [keyword](#highlight.tags.keyword) related to defining or
    /// interfacing with modules.
    moduleKeyword: t(keyword),
    /// An operator.
    operator,
    /// An [operator](#highlight.tags.operator) that defines something.
    derefOperator: t(operator),
    /// Arithmetic-related [operator](#highlight.tags.operator).
    arithmeticOperator: t(operator),
    /// Logical [operator](#highlight.tags.operator).
    logicOperator: t(operator),
    /// Bit [operator](#highlight.tags.operator).
    bitwiseOperator: t(operator),
    /// Comparison [operator](#highlight.tags.operator).
    compareOperator: t(operator),
    /// [Operator](#highlight.tags.operator) that updates its operand.
    updateOperator: t(operator),
    /// [Operator](#highlight.tags.operator) that defines something.
    definitionOperator: t(operator),
    /// Type-related [operator](#highlight.tags.operator).
    typeOperator: t(operator),
    /// Control-flow [operator](#highlight.tags.operator).
    controlOperator: t(operator),
    /// Program or markup punctuation.
    punctuation,
    /// [Punctuation](#highlight.tags.punctuation) that separates
    /// things.
    separator: t(punctuation),
    /// Bracket-style [punctuation](#highlight.tags.punctuation).
    bracket,
    /// Angle [brackets](#highlight.tags.bracket) (usually `<` and `>`
    /// tokens).
    angleBracket: t(bracket),
    /// Square [brackets](#highlight.tags.bracket) (usually `[` and `]`
    /// tokens).
    squareBracket: t(bracket),
    /// Parentheses (usually `(` and `)` tokens). Subtag of
    /// [bracket](#highlight.tags.bracket).
    paren: t(bracket),
    /// Braces (usually `{` and `}` tokens). Subtag of
    /// [bracket](#highlight.tags.bracket).
    brace: t(bracket),
    /// Content, for example plain text in XML or markup documents.
    content,
    /// [Content](#highlight.tags.content) that represents a heading.
    heading,
    /// A level 1 [heading](#highlight.tags.heading).
    heading1: t(heading),
    /// A level 2 [heading](#highlight.tags.heading).
    heading2: t(heading),
    /// A level 3 [heading](#highlight.tags.heading).
    heading3: t(heading),
    /// A level 4 [heading](#highlight.tags.heading).
    heading4: t(heading),
    /// A level 5 [heading](#highlight.tags.heading).
    heading5: t(heading),
    /// A level 6 [heading](#highlight.tags.heading).
    heading6: t(heading),
    /// A prose separator (such as a horizontal rule).
    contentSeparator: t(content),
    /// [Content](#highlight.tags.content) that represents a list.
    list: t(content),
    /// [Content](#highlight.tags.content) that represents a quote.
    quote: t(content),
    /// [Content](#highlight.tags.content) that is emphasized.
    emphasis: t(content),
    /// [Content](#highlight.tags.content) that is styled strong.
    strong: t(content),
    /// [Content](#highlight.tags.content) that is part of a link.
    link: t(content),
    /// [Content](#highlight.tags.content) that is styled as code or
    /// monospace.
    monospace: t(content),
    /// [Content](#highlight.tags.content) that has a strike-through
    /// style.
    strikethrough: t(content),
    /// Inserted text in a change-tracking format.
    inserted: t(),
    /// Deleted text.
    deleted: t(),
    /// Changed text.
    changed: t(),
    /// An invalid or unsyntactic element.
    invalid: t(),
    /// Metadata or meta-instruction.
    meta,
    /// [Metadata](#highlight.tags.meta) that applies to the entire
    /// document.
    documentMeta: t(meta),
    /// [Metadata](#highlight.tags.meta) that annotates or adds
    /// attributes to a given syntactic element.
    annotation: t(meta),
    /// Processing instruction or preprocessor directive. Subtag of
    /// [meta](#highlight.tags.meta).
    processingInstruction: t(meta),
    /// [Modifier](#highlight.Tag^defineModifier) that indicates that a
    /// given element is being defined. Expected to be used with the
    /// various [name](#highlight.tags.name) tags.
    definition: Tag.defineModifier(),
    /// [Modifier](#highlight.Tag^defineModifier) that indicates that
    /// something is constant. Mostly expected to be used with
    /// [variable names](#highlight.tags.variableName).
    constant: Tag.defineModifier(),
    /// [Modifier](#highlight.Tag^defineModifier) used to indicate that
    /// a [variable](#highlight.tags.variableName) or [property
    /// name](#highlight.tags.propertyName) is being called or defined
    /// as a function.
    function: Tag.defineModifier(),
    /// [Modifier](#highlight.Tag^defineModifier) that can be applied to
    /// [names](#highlight.tags.name) to indicate that they belong to
    /// the language's standard environment.
    standard: Tag.defineModifier(),
    /// [Modifier](#highlight.Tag^defineModifier) that indicates a given
    /// [names](#highlight.tags.name) is local to some scope.
    local: Tag.defineModifier(),
    /// A generic variant [modifier](#highlight.Tag^defineModifier) that
    /// can be used to tag language-specific alternative variants of
    /// some common tag. It is recommended for themes to define special
    /// forms of at least the [string](#highlight.tags.string) and
    /// [variable name](#highlight.tags.variableName) tags, since those
    /// come up a lot.
    special: Tag.defineModifier()
};
/// This is a highlighter that adds stable, predictable classes to
/// tokens, for styling with external CSS.
///
/// The following tags are mapped to their name prefixed with `"tok-"`
/// (for example `"tok-comment"`):
///
/// * [`link`](#highlight.tags.link)
/// * [`heading`](#highlight.tags.heading)
/// * [`emphasis`](#highlight.tags.emphasis)
/// * [`strong`](#highlight.tags.strong)
/// * [`keyword`](#highlight.tags.keyword)
/// * [`atom`](#highlight.tags.atom) [`bool`](#highlight.tags.bool)
/// * [`url`](#highlight.tags.url)
/// * [`labelName`](#highlight.tags.labelName)
/// * [`inserted`](#highlight.tags.inserted)
/// * [`deleted`](#highlight.tags.deleted)
/// * [`literal`](#highlight.tags.literal)
/// * [`string`](#highlight.tags.string)
/// * [`number`](#highlight.tags.number)
/// * [`variableName`](#highlight.tags.variableName)
/// * [`typeName`](#highlight.tags.typeName)
/// * [`namespace`](#highlight.tags.namespace)
/// * [`className`](#highlight.tags.className)
/// * [`macroName`](#highlight.tags.macroName)
/// * [`propertyName`](#highlight.tags.propertyName)
/// * [`operator`](#highlight.tags.operator)
/// * [`comment`](#highlight.tags.comment)
/// * [`meta`](#highlight.tags.meta)
/// * [`punctuation`](#highlight.tags.punctuation)
/// * [`invalid`](#highlight.tags.invalid)
///
/// In addition, these mappings are provided:
///
/// * [`regexp`](#highlight.tags.regexp),
///   [`escape`](#highlight.tags.escape), and
///   [`special`](#highlight.tags.special)[`(string)`](#highlight.tags.string)
///   are mapped to `"tok-string2"`
/// * [`special`](#highlight.tags.special)[`(variableName)`](#highlight.tags.variableName)
///   to `"tok-variableName2"`
/// * [`local`](#highlight.tags.local)[`(variableName)`](#highlight.tags.variableName)
///   to `"tok-variableName tok-local"`
/// * [`definition`](#highlight.tags.definition)[`(variableName)`](#highlight.tags.variableName)
///   to `"tok-variableName tok-definition"`
/// * [`definition`](#highlight.tags.definition)[`(propertyName)`](#highlight.tags.propertyName)
///   to `"tok-propertyName tok-definition"`
const classHighlighter = tagHighlighter([
    { tag: tags.link, class: "tok-link" },
    { tag: tags.heading, class: "tok-heading" },
    { tag: tags.emphasis, class: "tok-emphasis" },
    { tag: tags.strong, class: "tok-strong" },
    { tag: tags.keyword, class: "tok-keyword" },
    { tag: tags.atom, class: "tok-atom" },
    { tag: tags.bool, class: "tok-bool" },
    { tag: tags.url, class: "tok-url" },
    { tag: tags.labelName, class: "tok-labelName" },
    { tag: tags.inserted, class: "tok-inserted" },
    { tag: tags.deleted, class: "tok-deleted" },
    { tag: tags.literal, class: "tok-literal" },
    { tag: tags.string, class: "tok-string" },
    { tag: tags.number, class: "tok-number" },
    { tag: [tags.regexp, tags.escape, tags.special(tags.string)], class: "tok-string2" },
    { tag: tags.variableName, class: "tok-variableName" },
    { tag: tags.local(tags.variableName), class: "tok-variableName tok-local" },
    { tag: tags.definition(tags.variableName), class: "tok-variableName tok-definition" },
    { tag: tags.special(tags.variableName), class: "tok-variableName2" },
    { tag: tags.definition(tags.propertyName), class: "tok-propertyName tok-definition" },
    { tag: tags.typeName, class: "tok-typeName" },
    { tag: tags.namespace, class: "tok-namespace" },
    { tag: tags.className, class: "tok-className" },
    { tag: tags.macroName, class: "tok-macroName" },
    { tag: tags.propertyName, class: "tok-propertyName" },
    { tag: tags.operator, class: "tok-operator" },
    { tag: tags.comment, class: "tok-comment" },
    { tag: tags.meta, class: "tok-meta" },
    { tag: tags.invalid, class: "tok-invalid" },
    { tag: tags.punctuation, class: "tok-punctuation" }
]);

exports.Tag = Tag;
exports.classHighlighter = classHighlighter;
exports.highlightTags = highlightTags;
exports.highlightTree = highlightTree;
exports.styleTags = styleTags;
exports.tagHighlighter = tagHighlighter;
exports.tags = tags;


/***/ }),

/***/ "./node_modules/@lezer/lr/dist/index.cjs":
/*!***********************************************!*\
  !*** ./node_modules/@lezer/lr/dist/index.cjs ***!
  \***********************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({ value: true }));

var common = __webpack_require__(/*! @lezer/common */ "./node_modules/@lezer/common/dist/index.cjs");

/// A parse stack. These are used internally by the parser to track
/// parsing progress. They also provide some properties and methods
/// that external code such as a tokenizer can use to get information
/// about the parse state.
class Stack {
    /// @internal
    constructor(
    /// The parse that this stack is part of @internal
    p, 
    /// Holds state, input pos, buffer index triplets for all but the
    /// top state @internal
    stack, 
    /// The current parse state @internal
    state, 
    // The position at which the next reduce should take place. This
    // can be less than `this.pos` when skipped expressions have been
    // added to the stack (which should be moved outside of the next
    // reduction)
    /// @internal
    reducePos, 
    /// The input position up to which this stack has parsed.
    pos, 
    /// The dynamic score of the stack, including dynamic precedence
    /// and error-recovery penalties
    /// @internal
    score, 
    // The output buffer. Holds (type, start, end, size) quads
    // representing nodes created by the parser, where `size` is
    // amount of buffer array entries covered by this node.
    /// @internal
    buffer, 
    // The base offset of the buffer. When stacks are split, the split
    // instance shared the buffer history with its parent up to
    // `bufferBase`, which is the absolute offset (including the
    // offset of previous splits) into the buffer at which this stack
    // starts writing.
    /// @internal
    bufferBase, 
    /// @internal
    curContext, 
    /// @internal
    lookAhead = 0, 
    // A parent stack from which this was split off, if any. This is
    // set up so that it always points to a stack that has some
    // additional buffer content, never to a stack with an equal
    // `bufferBase`.
    /// @internal
    parent) {
        this.p = p;
        this.stack = stack;
        this.state = state;
        this.reducePos = reducePos;
        this.pos = pos;
        this.score = score;
        this.buffer = buffer;
        this.bufferBase = bufferBase;
        this.curContext = curContext;
        this.lookAhead = lookAhead;
        this.parent = parent;
    }
    /// @internal
    toString() {
        return `[${this.stack.filter((_, i) => i % 3 == 0).concat(this.state)}]@${this.pos}${this.score ? "!" + this.score : ""}`;
    }
    // Start an empty stack
    /// @internal
    static start(p, state, pos = 0) {
        let cx = p.parser.context;
        return new Stack(p, [], state, pos, pos, 0, [], 0, cx ? new StackContext(cx, cx.start) : null, 0, null);
    }
    /// The stack's current [context](#lr.ContextTracker) value, if
    /// any. Its type will depend on the context tracker's type
    /// parameter, or it will be `null` if there is no context
    /// tracker.
    get context() { return this.curContext ? this.curContext.context : null; }
    // Push a state onto the stack, tracking its start position as well
    // as the buffer base at that point.
    /// @internal
    pushState(state, start) {
        this.stack.push(this.state, start, this.bufferBase + this.buffer.length);
        this.state = state;
    }
    // Apply a reduce action
    /// @internal
    reduce(action) {
        let depth = action >> 19 /* ReduceDepthShift */, type = action & 65535 /* ValueMask */;
        let { parser } = this.p;
        let dPrec = parser.dynamicPrecedence(type);
        if (dPrec)
            this.score += dPrec;
        if (depth == 0) {
            this.pushState(parser.getGoto(this.state, type, true), this.reducePos);
            // Zero-depth reductions are a special casethey add stuff to
            // the stack without popping anything off.
            if (type < parser.minRepeatTerm)
                this.storeNode(type, this.reducePos, this.reducePos, 4, true);
            this.reduceContext(type, this.reducePos);
            return;
        }
        // Find the base index into `this.stack`, content after which will
        // be dropped. Note that with `StayFlag` reductions we need to
        // consume two extra frames (the dummy parent node for the skipped
        // expression and the state that we'll be staying in, which should
        // be moved to `this.state`).
        let base = this.stack.length - ((depth - 1) * 3) - (action & 262144 /* StayFlag */ ? 6 : 0);
        let start = this.stack[base - 2];
        let bufferBase = this.stack[base - 1], count = this.bufferBase + this.buffer.length - bufferBase;
        // Store normal terms or `R -> R R` repeat reductions
        if (type < parser.minRepeatTerm || (action & 131072 /* RepeatFlag */)) {
            let pos = parser.stateFlag(this.state, 1 /* Skipped */) ? this.pos : this.reducePos;
            this.storeNode(type, start, pos, count + 4, true);
        }
        if (action & 262144 /* StayFlag */) {
            this.state = this.stack[base];
        }
        else {
            let baseStateID = this.stack[base - 3];
            this.state = parser.getGoto(baseStateID, type, true);
        }
        while (this.stack.length > base)
            this.stack.pop();
        this.reduceContext(type, start);
    }
    // Shift a value into the buffer
    /// @internal
    storeNode(term, start, end, size = 4, isReduce = false) {
        if (term == 0 /* Err */ &&
            (!this.stack.length || this.stack[this.stack.length - 1] < this.buffer.length + this.bufferBase)) {
            // Try to omit/merge adjacent error nodes
            let cur = this, top = this.buffer.length;
            if (top == 0 && cur.parent) {
                top = cur.bufferBase - cur.parent.bufferBase;
                cur = cur.parent;
            }
            if (top > 0 && cur.buffer[top - 4] == 0 /* Err */ && cur.buffer[top - 1] > -1) {
                if (start == end)
                    return;
                if (cur.buffer[top - 2] >= start) {
                    cur.buffer[top - 2] = end;
                    return;
                }
            }
        }
        if (!isReduce || this.pos == end) { // Simple case, just append
            this.buffer.push(term, start, end, size);
        }
        else { // There may be skipped nodes that have to be moved forward
            let index = this.buffer.length;
            if (index > 0 && this.buffer[index - 4] != 0 /* Err */)
                while (index > 0 && this.buffer[index - 2] > end) {
                    // Move this record forward
                    this.buffer[index] = this.buffer[index - 4];
                    this.buffer[index + 1] = this.buffer[index - 3];
                    this.buffer[index + 2] = this.buffer[index - 2];
                    this.buffer[index + 3] = this.buffer[index - 1];
                    index -= 4;
                    if (size > 4)
                        size -= 4;
                }
            this.buffer[index] = term;
            this.buffer[index + 1] = start;
            this.buffer[index + 2] = end;
            this.buffer[index + 3] = size;
        }
    }
    // Apply a shift action
    /// @internal
    shift(action, next, nextEnd) {
        let start = this.pos;
        if (action & 131072 /* GotoFlag */) {
            this.pushState(action & 65535 /* ValueMask */, this.pos);
        }
        else if ((action & 262144 /* StayFlag */) == 0) { // Regular shift
            let nextState = action, { parser } = this.p;
            if (nextEnd > this.pos || next <= parser.maxNode) {
                this.pos = nextEnd;
                if (!parser.stateFlag(nextState, 1 /* Skipped */))
                    this.reducePos = nextEnd;
            }
            this.pushState(nextState, start);
            this.shiftContext(next, start);
            if (next <= parser.maxNode)
                this.buffer.push(next, start, nextEnd, 4);
        }
        else { // Shift-and-stay, which means this is a skipped token
            this.pos = nextEnd;
            this.shiftContext(next, start);
            if (next <= this.p.parser.maxNode)
                this.buffer.push(next, start, nextEnd, 4);
        }
    }
    // Apply an action
    /// @internal
    apply(action, next, nextEnd) {
        if (action & 65536 /* ReduceFlag */)
            this.reduce(action);
        else
            this.shift(action, next, nextEnd);
    }
    // Add a prebuilt (reused) node into the buffer.
    /// @internal
    useNode(value, next) {
        let index = this.p.reused.length - 1;
        if (index < 0 || this.p.reused[index] != value) {
            this.p.reused.push(value);
            index++;
        }
        let start = this.pos;
        this.reducePos = this.pos = start + value.length;
        this.pushState(next, start);
        this.buffer.push(index, start, this.reducePos, -1 /* size == -1 means this is a reused value */);
        if (this.curContext)
            this.updateContext(this.curContext.tracker.reuse(this.curContext.context, value, this, this.p.stream.reset(this.pos - value.length)));
    }
    // Split the stack. Due to the buffer sharing and the fact
    // that `this.stack` tends to stay quite shallow, this isn't very
    // expensive.
    /// @internal
    split() {
        let parent = this;
        let off = parent.buffer.length;
        // Because the top of the buffer (after this.pos) may be mutated
        // to reorder reductions and skipped tokens, and shared buffers
        // should be immutable, this copies any outstanding skipped tokens
        // to the new buffer, and puts the base pointer before them.
        while (off > 0 && parent.buffer[off - 2] > parent.reducePos)
            off -= 4;
        let buffer = parent.buffer.slice(off), base = parent.bufferBase + off;
        // Make sure parent points to an actual parent with content, if there is such a parent.
        while (parent && base == parent.bufferBase)
            parent = parent.parent;
        return new Stack(this.p, this.stack.slice(), this.state, this.reducePos, this.pos, this.score, buffer, base, this.curContext, this.lookAhead, parent);
    }
    // Try to recover from an error by 'deleting' (ignoring) one token.
    /// @internal
    recoverByDelete(next, nextEnd) {
        let isNode = next <= this.p.parser.maxNode;
        if (isNode)
            this.storeNode(next, this.pos, nextEnd, 4);
        this.storeNode(0 /* Err */, this.pos, nextEnd, isNode ? 8 : 4);
        this.pos = this.reducePos = nextEnd;
        this.score -= 190 /* Delete */;
    }
    /// Check if the given term would be able to be shifted (optionally
    /// after some reductions) on this stack. This can be useful for
    /// external tokenizers that want to make sure they only provide a
    /// given token when it applies.
    canShift(term) {
        for (let sim = new SimulatedStack(this);;) {
            let action = this.p.parser.stateSlot(sim.state, 4 /* DefaultReduce */) || this.p.parser.hasAction(sim.state, term);
            if ((action & 65536 /* ReduceFlag */) == 0)
                return true;
            if (action == 0)
                return false;
            sim.reduce(action);
        }
    }
    // Apply up to Recover.MaxNext recovery actions that conceptually
    // inserts some missing token or rule.
    /// @internal
    recoverByInsert(next) {
        if (this.stack.length >= 300 /* MaxInsertStackDepth */)
            return [];
        let nextStates = this.p.parser.nextStates(this.state);
        if (nextStates.length > 4 /* MaxNext */ << 1 || this.stack.length >= 120 /* DampenInsertStackDepth */) {
            let best = [];
            for (let i = 0, s; i < nextStates.length; i += 2) {
                if ((s = nextStates[i + 1]) != this.state && this.p.parser.hasAction(s, next))
                    best.push(nextStates[i], s);
            }
            if (this.stack.length < 120 /* DampenInsertStackDepth */)
                for (let i = 0; best.length < 4 /* MaxNext */ << 1 && i < nextStates.length; i += 2) {
                    let s = nextStates[i + 1];
                    if (!best.some((v, i) => (i & 1) && v == s))
                        best.push(nextStates[i], s);
                }
            nextStates = best;
        }
        let result = [];
        for (let i = 0; i < nextStates.length && result.length < 4 /* MaxNext */; i += 2) {
            let s = nextStates[i + 1];
            if (s == this.state)
                continue;
            let stack = this.split();
            stack.pushState(s, this.pos);
            stack.storeNode(0 /* Err */, stack.pos, stack.pos, 4, true);
            stack.shiftContext(nextStates[i], this.pos);
            stack.score -= 200 /* Insert */;
            result.push(stack);
        }
        return result;
    }
    // Force a reduce, if possible. Return false if that can't
    // be done.
    /// @internal
    forceReduce() {
        let reduce = this.p.parser.stateSlot(this.state, 5 /* ForcedReduce */);
        if ((reduce & 65536 /* ReduceFlag */) == 0)
            return false;
        let { parser } = this.p;
        if (!parser.validAction(this.state, reduce)) {
            let depth = reduce >> 19 /* ReduceDepthShift */, term = reduce & 65535 /* ValueMask */;
            let target = this.stack.length - depth * 3;
            if (target < 0 || parser.getGoto(this.stack[target], term, false) < 0)
                return false;
            this.storeNode(0 /* Err */, this.reducePos, this.reducePos, 4, true);
            this.score -= 100 /* Reduce */;
        }
        this.reducePos = this.pos;
        this.reduce(reduce);
        return true;
    }
    /// @internal
    forceAll() {
        while (!this.p.parser.stateFlag(this.state, 2 /* Accepting */)) {
            if (!this.forceReduce()) {
                this.storeNode(0 /* Err */, this.pos, this.pos, 4, true);
                break;
            }
        }
        return this;
    }
    /// Check whether this state has no further actions (assumed to be a direct descendant of the
    /// top state, since any other states must be able to continue
    /// somehow). @internal
    get deadEnd() {
        if (this.stack.length != 3)
            return false;
        let { parser } = this.p;
        return parser.data[parser.stateSlot(this.state, 1 /* Actions */)] == 65535 /* End */ &&
            !parser.stateSlot(this.state, 4 /* DefaultReduce */);
    }
    /// Restart the stack (put it back in its start state). Only safe
    /// when this.stack.length == 3 (state is directly below the top
    /// state). @internal
    restart() {
        this.state = this.stack[0];
        this.stack.length = 0;
    }
    /// @internal
    sameState(other) {
        if (this.state != other.state || this.stack.length != other.stack.length)
            return false;
        for (let i = 0; i < this.stack.length; i += 3)
            if (this.stack[i] != other.stack[i])
                return false;
        return true;
    }
    /// Get the parser used by this stack.
    get parser() { return this.p.parser; }
    /// Test whether a given dialect (by numeric ID, as exported from
    /// the terms file) is enabled.
    dialectEnabled(dialectID) { return this.p.parser.dialect.flags[dialectID]; }
    shiftContext(term, start) {
        if (this.curContext)
            this.updateContext(this.curContext.tracker.shift(this.curContext.context, term, this, this.p.stream.reset(start)));
    }
    reduceContext(term, start) {
        if (this.curContext)
            this.updateContext(this.curContext.tracker.reduce(this.curContext.context, term, this, this.p.stream.reset(start)));
    }
    /// @internal
    emitContext() {
        let last = this.buffer.length - 1;
        if (last < 0 || this.buffer[last] != -3)
            this.buffer.push(this.curContext.hash, this.reducePos, this.reducePos, -3);
    }
    /// @internal
    emitLookAhead() {
        let last = this.buffer.length - 1;
        if (last < 0 || this.buffer[last] != -4)
            this.buffer.push(this.lookAhead, this.reducePos, this.reducePos, -4);
    }
    updateContext(context) {
        if (context != this.curContext.context) {
            let newCx = new StackContext(this.curContext.tracker, context);
            if (newCx.hash != this.curContext.hash)
                this.emitContext();
            this.curContext = newCx;
        }
    }
    /// @internal
    setLookAhead(lookAhead) {
        if (lookAhead > this.lookAhead) {
            this.emitLookAhead();
            this.lookAhead = lookAhead;
        }
    }
    /// @internal
    close() {
        if (this.curContext && this.curContext.tracker.strict)
            this.emitContext();
        if (this.lookAhead > 0)
            this.emitLookAhead();
    }
}
class StackContext {
    constructor(tracker, context) {
        this.tracker = tracker;
        this.context = context;
        this.hash = tracker.strict ? tracker.hash(context) : 0;
    }
}
var Recover;
(function (Recover) {
    Recover[Recover["Insert"] = 200] = "Insert";
    Recover[Recover["Delete"] = 190] = "Delete";
    Recover[Recover["Reduce"] = 100] = "Reduce";
    Recover[Recover["MaxNext"] = 4] = "MaxNext";
    Recover[Recover["MaxInsertStackDepth"] = 300] = "MaxInsertStackDepth";
    Recover[Recover["DampenInsertStackDepth"] = 120] = "DampenInsertStackDepth";
})(Recover || (Recover = {}));
// Used to cheaply run some reductions to scan ahead without mutating
// an entire stack
class SimulatedStack {
    constructor(start) {
        this.start = start;
        this.state = start.state;
        this.stack = start.stack;
        this.base = this.stack.length;
    }
    reduce(action) {
        let term = action & 65535 /* ValueMask */, depth = action >> 19 /* ReduceDepthShift */;
        if (depth == 0) {
            if (this.stack == this.start.stack)
                this.stack = this.stack.slice();
            this.stack.push(this.state, 0, 0);
            this.base += 3;
        }
        else {
            this.base -= (depth - 1) * 3;
        }
        let goto = this.start.p.parser.getGoto(this.stack[this.base - 3], term, true);
        this.state = goto;
    }
}
// This is given to `Tree.build` to build a buffer, and encapsulates
// the parent-stack-walking necessary to read the nodes.
class StackBufferCursor {
    constructor(stack, pos, index) {
        this.stack = stack;
        this.pos = pos;
        this.index = index;
        this.buffer = stack.buffer;
        if (this.index == 0)
            this.maybeNext();
    }
    static create(stack, pos = stack.bufferBase + stack.buffer.length) {
        return new StackBufferCursor(stack, pos, pos - stack.bufferBase);
    }
    maybeNext() {
        let next = this.stack.parent;
        if (next != null) {
            this.index = this.stack.bufferBase - next.bufferBase;
            this.stack = next;
            this.buffer = next.buffer;
        }
    }
    get id() { return this.buffer[this.index - 4]; }
    get start() { return this.buffer[this.index - 3]; }
    get end() { return this.buffer[this.index - 2]; }
    get size() { return this.buffer[this.index - 1]; }
    next() {
        this.index -= 4;
        this.pos -= 4;
        if (this.index == 0)
            this.maybeNext();
    }
    fork() {
        return new StackBufferCursor(this.stack, this.pos, this.index);
    }
}

class CachedToken {
    constructor() {
        this.start = -1;
        this.value = -1;
        this.end = -1;
        this.extended = -1;
        this.lookAhead = 0;
        this.mask = 0;
        this.context = 0;
    }
}
const nullToken = new CachedToken;
/// [Tokenizers](#lr.ExternalTokenizer) interact with the input
/// through this interface. It presents the input as a stream of
/// characters, tracking lookahead and hiding the complexity of
/// [ranges](#common.Parser.parse^ranges) from tokenizer code.
class InputStream {
    /// @internal
    constructor(
    /// @internal
    input, 
    /// @internal
    ranges) {
        this.input = input;
        this.ranges = ranges;
        /// @internal
        this.chunk = "";
        /// @internal
        this.chunkOff = 0;
        /// Backup chunk
        this.chunk2 = "";
        this.chunk2Pos = 0;
        /// The character code of the next code unit in the input, or -1
        /// when the stream is at the end of the input.
        this.next = -1;
        /// @internal
        this.token = nullToken;
        this.rangeIndex = 0;
        this.pos = this.chunkPos = ranges[0].from;
        this.range = ranges[0];
        this.end = ranges[ranges.length - 1].to;
        this.readNext();
    }
    resolveOffset(offset, assoc) {
        let range = this.range, index = this.rangeIndex;
        let pos = this.pos + offset;
        while (pos < range.from) {
            if (!index)
                return null;
            let next = this.ranges[--index];
            pos -= range.from - next.to;
            range = next;
        }
        while (assoc < 0 ? pos > range.to : pos >= range.to) {
            if (index == this.ranges.length - 1)
                return null;
            let next = this.ranges[++index];
            pos += next.from - range.to;
            range = next;
        }
        return pos;
    }
    /// Look at a code unit near the stream position. `.peek(0)` equals
    /// `.next`, `.peek(-1)` gives you the previous character, and so
    /// on.
    ///
    /// Note that looking around during tokenizing creates dependencies
    /// on potentially far-away content, which may reduce the
    /// effectiveness incremental parsingwhen looking forwardor even
    /// cause invalid reparses when looking backward more than 25 code
    /// units, since the library does not track lookbehind.
    peek(offset) {
        let idx = this.chunkOff + offset, pos, result;
        if (idx >= 0 && idx < this.chunk.length) {
            pos = this.pos + offset;
            result = this.chunk.charCodeAt(idx);
        }
        else {
            let resolved = this.resolveOffset(offset, 1);
            if (resolved == null)
                return -1;
            pos = resolved;
            if (pos >= this.chunk2Pos && pos < this.chunk2Pos + this.chunk2.length) {
                result = this.chunk2.charCodeAt(pos - this.chunk2Pos);
            }
            else {
                let i = this.rangeIndex, range = this.range;
                while (range.to <= pos)
                    range = this.ranges[++i];
                this.chunk2 = this.input.chunk(this.chunk2Pos = pos);
                if (pos + this.chunk2.length > range.to)
                    this.chunk2 = this.chunk2.slice(0, range.to - pos);
                result = this.chunk2.charCodeAt(0);
            }
        }
        if (pos >= this.token.lookAhead)
            this.token.lookAhead = pos + 1;
        return result;
    }
    /// Accept a token. By default, the end of the token is set to the
    /// current stream position, but you can pass an offset (relative to
    /// the stream position) to change that.
    acceptToken(token, endOffset = 0) {
        let end = endOffset ? this.resolveOffset(endOffset, -1) : this.pos;
        if (end == null || end < this.token.start)
            throw new RangeError("Token end out of bounds");
        this.token.value = token;
        this.token.end = end;
    }
    getChunk() {
        if (this.pos >= this.chunk2Pos && this.pos < this.chunk2Pos + this.chunk2.length) {
            let { chunk, chunkPos } = this;
            this.chunk = this.chunk2;
            this.chunkPos = this.chunk2Pos;
            this.chunk2 = chunk;
            this.chunk2Pos = chunkPos;
            this.chunkOff = this.pos - this.chunkPos;
        }
        else {
            this.chunk2 = this.chunk;
            this.chunk2Pos = this.chunkPos;
            let nextChunk = this.input.chunk(this.pos);
            let end = this.pos + nextChunk.length;
            this.chunk = end > this.range.to ? nextChunk.slice(0, this.range.to - this.pos) : nextChunk;
            this.chunkPos = this.pos;
            this.chunkOff = 0;
        }
    }
    readNext() {
        if (this.chunkOff >= this.chunk.length) {
            this.getChunk();
            if (this.chunkOff == this.chunk.length)
                return this.next = -1;
        }
        return this.next = this.chunk.charCodeAt(this.chunkOff);
    }
    /// Move the stream forward N (defaults to 1) code units. Returns
    /// the new value of [`next`](#lr.InputStream.next).
    advance(n = 1) {
        this.chunkOff += n;
        while (this.pos + n >= this.range.to) {
            if (this.rangeIndex == this.ranges.length - 1)
                return this.setDone();
            n -= this.range.to - this.pos;
            this.range = this.ranges[++this.rangeIndex];
            this.pos = this.range.from;
        }
        this.pos += n;
        if (this.pos >= this.token.lookAhead)
            this.token.lookAhead = this.pos + 1;
        return this.readNext();
    }
    setDone() {
        this.pos = this.chunkPos = this.end;
        this.range = this.ranges[this.rangeIndex = this.ranges.length - 1];
        this.chunk = "";
        return this.next = -1;
    }
    /// @internal
    reset(pos, token) {
        if (token) {
            this.token = token;
            token.start = pos;
            token.lookAhead = pos + 1;
            token.value = token.extended = -1;
        }
        else {
            this.token = nullToken;
        }
        if (this.pos != pos) {
            this.pos = pos;
            if (pos == this.end) {
                this.setDone();
                return this;
            }
            while (pos < this.range.from)
                this.range = this.ranges[--this.rangeIndex];
            while (pos >= this.range.to)
                this.range = this.ranges[++this.rangeIndex];
            if (pos >= this.chunkPos && pos < this.chunkPos + this.chunk.length) {
                this.chunkOff = pos - this.chunkPos;
            }
            else {
                this.chunk = "";
                this.chunkOff = 0;
            }
            this.readNext();
        }
        return this;
    }
    /// @internal
    read(from, to) {
        if (from >= this.chunkPos && to <= this.chunkPos + this.chunk.length)
            return this.chunk.slice(from - this.chunkPos, to - this.chunkPos);
        if (from >= this.chunk2Pos && to <= this.chunk2Pos + this.chunk2.length)
            return this.chunk2.slice(from - this.chunk2Pos, to - this.chunk2Pos);
        if (from >= this.range.from && to <= this.range.to)
            return this.input.read(from, to);
        let result = "";
        for (let r of this.ranges) {
            if (r.from >= to)
                break;
            if (r.to > from)
                result += this.input.read(Math.max(r.from, from), Math.min(r.to, to));
        }
        return result;
    }
}
/// @internal
class TokenGroup {
    constructor(data, id) {
        this.data = data;
        this.id = id;
    }
    token(input, stack) { readToken(this.data, input, stack, this.id); }
}
TokenGroup.prototype.contextual = TokenGroup.prototype.fallback = TokenGroup.prototype.extend = false;
/// `@external tokens` declarations in the grammar should resolve to
/// an instance of this class.
class ExternalTokenizer {
    /// Create a tokenizer. The first argument is the function that,
    /// given an input stream, scans for the types of tokens it
    /// recognizes at the stream's position, and calls
    /// [`acceptToken`](#lr.InputStream.acceptToken) when it finds
    /// one.
    constructor(
    /// @internal
    token, options = {}) {
        this.token = token;
        this.contextual = !!options.contextual;
        this.fallback = !!options.fallback;
        this.extend = !!options.extend;
    }
}
// Tokenizer data is stored a big uint16 array containing, for each
// state:
//
//  - A group bitmask, indicating what token groups are reachable from
//    this state, so that paths that can only lead to tokens not in
//    any of the current groups can be cut off early.
//
//  - The position of the end of the state's sequence of accepting
//    tokens
//
//  - The number of outgoing edges for the state
//
//  - The accepting tokens, as (token id, group mask) pairs
//
//  - The outgoing edges, as (start character, end character, state
//    index) triples, with end character being exclusive
//
// This function interprets that data, running through a stream as
// long as new states with the a matching group mask can be reached,
// and updating `token` when it matches a token.
function readToken(data, input, stack, group) {
    let state = 0, groupMask = 1 << group, { parser } = stack.p, { dialect } = parser;
    scan: for (;;) {
        if ((groupMask & data[state]) == 0)
            break;
        let accEnd = data[state + 1];
        // Check whether this state can lead to a token in the current group
        // Accept tokens in this state, possibly overwriting
        // lower-precedence / shorter tokens
        for (let i = state + 3; i < accEnd; i += 2)
            if ((data[i + 1] & groupMask) > 0) {
                let term = data[i];
                if (dialect.allows(term) &&
                    (input.token.value == -1 || input.token.value == term || parser.overrides(term, input.token.value))) {
                    input.acceptToken(term);
                    break;
                }
            }
        // Do a binary search on the state's edges
        for (let next = input.next, low = 0, high = data[state + 2]; low < high;) {
            let mid = (low + high) >> 1;
            let index = accEnd + mid + (mid << 1);
            let from = data[index], to = data[index + 1];
            if (next < from)
                high = mid;
            else if (next >= to)
                low = mid + 1;
            else {
                state = data[index + 2];
                input.advance();
                continue scan;
            }
        }
        break;
    }
}

// See lezer-generator/src/encode.ts for comments about the encoding
// used here
function decodeArray(input, Type = Uint16Array) {
    if (typeof input != "string")
        return input;
    let array = null;
    for (let pos = 0, out = 0; pos < input.length;) {
        let value = 0;
        for (;;) {
            let next = input.charCodeAt(pos++), stop = false;
            if (next == 126 /* BigValCode */) {
                value = 65535 /* BigVal */;
                break;
            }
            if (next >= 92 /* Gap2 */)
                next--;
            if (next >= 34 /* Gap1 */)
                next--;
            let digit = next - 32 /* Start */;
            if (digit >= 46 /* Base */) {
                digit -= 46 /* Base */;
                stop = true;
            }
            value += digit;
            if (stop)
                break;
            value *= 46 /* Base */;
        }
        if (array)
            array[out++] = value;
        else
            array = new Type(value);
    }
    return array;
}

// Environment variable used to control console output
const verbose = typeof process != "undefined" && process.env && /\bparse\b/.test(process.env.LOG);
let stackIDs = null;
var Safety;
(function (Safety) {
    Safety[Safety["Margin"] = 25] = "Margin";
})(Safety || (Safety = {}));
function cutAt(tree, pos, side) {
    let cursor = tree.cursor(common.IterMode.IncludeAnonymous);
    cursor.moveTo(pos);
    for (;;) {
        if (!(side < 0 ? cursor.childBefore(pos) : cursor.childAfter(pos)))
            for (;;) {
                if ((side < 0 ? cursor.to < pos : cursor.from > pos) && !cursor.type.isError)
                    return side < 0 ? Math.max(0, Math.min(cursor.to - 1, pos - 25 /* Margin */))
                        : Math.min(tree.length, Math.max(cursor.from + 1, pos + 25 /* Margin */));
                if (side < 0 ? cursor.prevSibling() : cursor.nextSibling())
                    break;
                if (!cursor.parent())
                    return side < 0 ? 0 : tree.length;
            }
    }
}
class FragmentCursor {
    constructor(fragments, nodeSet) {
        this.fragments = fragments;
        this.nodeSet = nodeSet;
        this.i = 0;
        this.fragment = null;
        this.safeFrom = -1;
        this.safeTo = -1;
        this.trees = [];
        this.start = [];
        this.index = [];
        this.nextFragment();
    }
    nextFragment() {
        let fr = this.fragment = this.i == this.fragments.length ? null : this.fragments[this.i++];
        if (fr) {
            this.safeFrom = fr.openStart ? cutAt(fr.tree, fr.from + fr.offset, 1) - fr.offset : fr.from;
            this.safeTo = fr.openEnd ? cutAt(fr.tree, fr.to + fr.offset, -1) - fr.offset : fr.to;
            while (this.trees.length) {
                this.trees.pop();
                this.start.pop();
                this.index.pop();
            }
            this.trees.push(fr.tree);
            this.start.push(-fr.offset);
            this.index.push(0);
            this.nextStart = this.safeFrom;
        }
        else {
            this.nextStart = 1e9;
        }
    }
    // `pos` must be >= any previously given `pos` for this cursor
    nodeAt(pos) {
        if (pos < this.nextStart)
            return null;
        while (this.fragment && this.safeTo <= pos)
            this.nextFragment();
        if (!this.fragment)
            return null;
        for (;;) {
            let last = this.trees.length - 1;
            if (last < 0) { // End of tree
                this.nextFragment();
                return null;
            }
            let top = this.trees[last], index = this.index[last];
            if (index == top.children.length) {
                this.trees.pop();
                this.start.pop();
                this.index.pop();
                continue;
            }
            let next = top.children[index];
            let start = this.start[last] + top.positions[index];
            if (start > pos) {
                this.nextStart = start;
                return null;
            }
            if (next instanceof common.Tree) {
                if (start == pos) {
                    if (start < this.safeFrom)
                        return null;
                    let end = start + next.length;
                    if (end <= this.safeTo) {
                        let lookAhead = next.prop(common.NodeProp.lookAhead);
                        if (!lookAhead || end + lookAhead < this.fragment.to)
                            return next;
                    }
                }
                this.index[last]++;
                if (start + next.length >= Math.max(this.safeFrom, pos)) { // Enter this node
                    this.trees.push(next);
                    this.start.push(start);
                    this.index.push(0);
                }
            }
            else {
                this.index[last]++;
                this.nextStart = start + next.length;
            }
        }
    }
}
class TokenCache {
    constructor(parser, stream) {
        this.stream = stream;
        this.tokens = [];
        this.mainToken = null;
        this.actions = [];
        this.tokens = parser.tokenizers.map(_ => new CachedToken);
    }
    getActions(stack) {
        let actionIndex = 0;
        let main = null;
        let { parser } = stack.p, { tokenizers } = parser;
        let mask = parser.stateSlot(stack.state, 3 /* TokenizerMask */);
        let context = stack.curContext ? stack.curContext.hash : 0;
        let lookAhead = 0;
        for (let i = 0; i < tokenizers.length; i++) {
            if (((1 << i) & mask) == 0)
                continue;
            let tokenizer = tokenizers[i], token = this.tokens[i];
            if (main && !tokenizer.fallback)
                continue;
            if (tokenizer.contextual || token.start != stack.pos || token.mask != mask || token.context != context) {
                this.updateCachedToken(token, tokenizer, stack);
                token.mask = mask;
                token.context = context;
            }
            if (token.lookAhead > token.end + 25 /* Margin */)
                lookAhead = Math.max(token.lookAhead, lookAhead);
            if (token.value != 0 /* Err */) {
                let startIndex = actionIndex;
                if (token.extended > -1)
                    actionIndex = this.addActions(stack, token.extended, token.end, actionIndex);
                actionIndex = this.addActions(stack, token.value, token.end, actionIndex);
                if (!tokenizer.extend) {
                    main = token;
                    if (actionIndex > startIndex)
                        break;
                }
            }
        }
        while (this.actions.length > actionIndex)
            this.actions.pop();
        if (lookAhead)
            stack.setLookAhead(lookAhead);
        if (!main && stack.pos == this.stream.end) {
            main = new CachedToken;
            main.value = stack.p.parser.eofTerm;
            main.start = main.end = stack.pos;
            actionIndex = this.addActions(stack, main.value, main.end, actionIndex);
        }
        this.mainToken = main;
        return this.actions;
    }
    getMainToken(stack) {
        if (this.mainToken)
            return this.mainToken;
        let main = new CachedToken, { pos, p } = stack;
        main.start = pos;
        main.end = Math.min(pos + 1, p.stream.end);
        main.value = pos == p.stream.end ? p.parser.eofTerm : 0 /* Err */;
        return main;
    }
    updateCachedToken(token, tokenizer, stack) {
        tokenizer.token(this.stream.reset(stack.pos, token), stack);
        if (token.value > -1) {
            let { parser } = stack.p;
            for (let i = 0; i < parser.specialized.length; i++)
                if (parser.specialized[i] == token.value) {
                    let result = parser.specializers[i](this.stream.read(token.start, token.end), stack);
                    if (result >= 0 && stack.p.parser.dialect.allows(result >> 1)) {
                        if ((result & 1) == 0 /* Specialize */)
                            token.value = result >> 1;
                        else
                            token.extended = result >> 1;
                        break;
                    }
                }
        }
        else {
            token.value = 0 /* Err */;
            token.end = Math.min(stack.p.stream.end, stack.pos + 1);
        }
    }
    putAction(action, token, end, index) {
        // Don't add duplicate actions
        for (let i = 0; i < index; i += 3)
            if (this.actions[i] == action)
                return index;
        this.actions[index++] = action;
        this.actions[index++] = token;
        this.actions[index++] = end;
        return index;
    }
    addActions(stack, token, end, index) {
        let { state } = stack, { parser } = stack.p, { data } = parser;
        for (let set = 0; set < 2; set++) {
            for (let i = parser.stateSlot(state, set ? 2 /* Skip */ : 1 /* Actions */);; i += 3) {
                if (data[i] == 65535 /* End */) {
                    if (data[i + 1] == 1 /* Next */) {
                        i = pair(data, i + 2);
                    }
                    else {
                        if (index == 0 && data[i + 1] == 2 /* Other */)
                            index = this.putAction(pair(data, i + 2), token, end, index);
                        break;
                    }
                }
                if (data[i] == token)
                    index = this.putAction(pair(data, i + 1), token, end, index);
            }
        }
        return index;
    }
}
var Rec;
(function (Rec) {
    Rec[Rec["Distance"] = 5] = "Distance";
    Rec[Rec["MaxRemainingPerStep"] = 3] = "MaxRemainingPerStep";
    // When two stacks have been running independently long enough to
    // add this many elements to their buffers, prune one.
    Rec[Rec["MinBufferLengthPrune"] = 500] = "MinBufferLengthPrune";
    Rec[Rec["ForceReduceLimit"] = 10] = "ForceReduceLimit";
    // Once a stack reaches this depth (in .stack.length) force-reduce
    // it back to CutTo to avoid creating trees that overflow the stack
    // on recursive traversal.
    Rec[Rec["CutDepth"] = 15000] = "CutDepth";
    Rec[Rec["CutTo"] = 9000] = "CutTo";
})(Rec || (Rec = {}));
class Parse {
    constructor(parser, input, fragments, ranges) {
        this.parser = parser;
        this.input = input;
        this.ranges = ranges;
        this.recovering = 0;
        this.nextStackID = 0x2654; // , , , , , , , , , , , , , 
        this.minStackPos = 0;
        this.reused = [];
        this.stoppedAt = null;
        this.stream = new InputStream(input, ranges);
        this.tokens = new TokenCache(parser, this.stream);
        this.topTerm = parser.top[1];
        let { from } = ranges[0];
        this.stacks = [Stack.start(this, parser.top[0], from)];
        this.fragments = fragments.length && this.stream.end - from > parser.bufferLength * 4
            ? new FragmentCursor(fragments, parser.nodeSet) : null;
    }
    get parsedPos() {
        return this.minStackPos;
    }
    // Move the parser forward. This will process all parse stacks at
    // `this.pos` and try to advance them to a further position. If no
    // stack for such a position is found, it'll start error-recovery.
    //
    // When the parse is finished, this will return a syntax tree. When
    // not, it returns `null`.
    advance() {
        let stacks = this.stacks, pos = this.minStackPos;
        // This will hold stacks beyond `pos`.
        let newStacks = this.stacks = [];
        let stopped, stoppedTokens;
        // Keep advancing any stacks at `pos` until they either move
        // forward or can't be advanced. Gather stacks that can't be
        // advanced further in `stopped`.
        for (let i = 0; i < stacks.length; i++) {
            let stack = stacks[i];
            for (;;) {
                this.tokens.mainToken = null;
                if (stack.pos > pos) {
                    newStacks.push(stack);
                }
                else if (this.advanceStack(stack, newStacks, stacks)) {
                    continue;
                }
                else {
                    if (!stopped) {
                        stopped = [];
                        stoppedTokens = [];
                    }
                    stopped.push(stack);
                    let tok = this.tokens.getMainToken(stack);
                    stoppedTokens.push(tok.value, tok.end);
                }
                break;
            }
        }
        if (!newStacks.length) {
            let finished = stopped && findFinished(stopped);
            if (finished)
                return this.stackToTree(finished);
            if (this.parser.strict) {
                if (verbose && stopped)
                    console.log("Stuck with token " + (this.tokens.mainToken ? this.parser.getName(this.tokens.mainToken.value) : "none"));
                throw new SyntaxError("No parse at " + pos);
            }
            if (!this.recovering)
                this.recovering = 5 /* Distance */;
        }
        if (this.recovering && stopped) {
            let finished = this.stoppedAt != null && stopped[0].pos > this.stoppedAt ? stopped[0]
                : this.runRecovery(stopped, stoppedTokens, newStacks);
            if (finished)
                return this.stackToTree(finished.forceAll());
        }
        if (this.recovering) {
            let maxRemaining = this.recovering == 1 ? 1 : this.recovering * 3 /* MaxRemainingPerStep */;
            if (newStacks.length > maxRemaining) {
                newStacks.sort((a, b) => b.score - a.score);
                while (newStacks.length > maxRemaining)
                    newStacks.pop();
            }
            if (newStacks.some(s => s.reducePos > pos))
                this.recovering--;
        }
        else if (newStacks.length > 1) {
            // Prune stacks that are in the same state, or that have been
            // running without splitting for a while, to avoid getting stuck
            // with multiple successful stacks running endlessly on.
            outer: for (let i = 0; i < newStacks.length - 1; i++) {
                let stack = newStacks[i];
                for (let j = i + 1; j < newStacks.length; j++) {
                    let other = newStacks[j];
                    if (stack.sameState(other) ||
                        stack.buffer.length > 500 /* MinBufferLengthPrune */ && other.buffer.length > 500 /* MinBufferLengthPrune */) {
                        if (((stack.score - other.score) || (stack.buffer.length - other.buffer.length)) > 0) {
                            newStacks.splice(j--, 1);
                        }
                        else {
                            newStacks.splice(i--, 1);
                            continue outer;
                        }
                    }
                }
            }
        }
        this.minStackPos = newStacks[0].pos;
        for (let i = 1; i < newStacks.length; i++)
            if (newStacks[i].pos < this.minStackPos)
                this.minStackPos = newStacks[i].pos;
        return null;
    }
    stopAt(pos) {
        if (this.stoppedAt != null && this.stoppedAt < pos)
            throw new RangeError("Can't move stoppedAt forward");
        this.stoppedAt = pos;
    }
    // Returns an updated version of the given stack, or null if the
    // stack can't advance normally. When `split` and `stacks` are
    // given, stacks split off by ambiguous operations will be pushed to
    // `split`, or added to `stacks` if they move `pos` forward.
    advanceStack(stack, stacks, split) {
        let start = stack.pos, { parser } = this;
        let base = verbose ? this.stackID(stack) + " -> " : "";
        if (this.stoppedAt != null && start > this.stoppedAt)
            return stack.forceReduce() ? stack : null;
        if (this.fragments) {
            let strictCx = stack.curContext && stack.curContext.tracker.strict, cxHash = strictCx ? stack.curContext.hash : 0;
            for (let cached = this.fragments.nodeAt(start); cached;) {
                let match = this.parser.nodeSet.types[cached.type.id] == cached.type ? parser.getGoto(stack.state, cached.type.id) : -1;
                if (match > -1 && cached.length && (!strictCx || (cached.prop(common.NodeProp.contextHash) || 0) == cxHash)) {
                    stack.useNode(cached, match);
                    if (verbose)
                        console.log(base + this.stackID(stack) + ` (via reuse of ${parser.getName(cached.type.id)})`);
                    return true;
                }
                if (!(cached instanceof common.Tree) || cached.children.length == 0 || cached.positions[0] > 0)
                    break;
                let inner = cached.children[0];
                if (inner instanceof common.Tree && cached.positions[0] == 0)
                    cached = inner;
                else
                    break;
            }
        }
        let defaultReduce = parser.stateSlot(stack.state, 4 /* DefaultReduce */);
        if (defaultReduce > 0) {
            stack.reduce(defaultReduce);
            if (verbose)
                console.log(base + this.stackID(stack) + ` (via always-reduce ${parser.getName(defaultReduce & 65535 /* ValueMask */)})`);
            return true;
        }
        if (stack.stack.length >= 15000 /* CutDepth */) {
            while (stack.stack.length > 9000 /* CutTo */ && stack.forceReduce()) { }
        }
        let actions = this.tokens.getActions(stack);
        for (let i = 0; i < actions.length;) {
            let action = actions[i++], term = actions[i++], end = actions[i++];
            let last = i == actions.length || !split;
            let localStack = last ? stack : stack.split();
            localStack.apply(action, term, end);
            if (verbose)
                console.log(base + this.stackID(localStack) + ` (via ${(action & 65536 /* ReduceFlag */) == 0 ? "shift"
                    : `reduce of ${parser.getName(action & 65535 /* ValueMask */)}`} for ${parser.getName(term)} @ ${start}${localStack == stack ? "" : ", split"})`);
            if (last)
                return true;
            else if (localStack.pos > start)
                stacks.push(localStack);
            else
                split.push(localStack);
        }
        return false;
    }
    // Advance a given stack forward as far as it will go. Returns the
    // (possibly updated) stack if it got stuck, or null if it moved
    // forward and was given to `pushStackDedup`.
    advanceFully(stack, newStacks) {
        let pos = stack.pos;
        for (;;) {
            if (!this.advanceStack(stack, null, null))
                return false;
            if (stack.pos > pos) {
                pushStackDedup(stack, newStacks);
                return true;
            }
        }
    }
    runRecovery(stacks, tokens, newStacks) {
        let finished = null, restarted = false;
        for (let i = 0; i < stacks.length; i++) {
            let stack = stacks[i], token = tokens[i << 1], tokenEnd = tokens[(i << 1) + 1];
            let base = verbose ? this.stackID(stack) + " -> " : "";
            if (stack.deadEnd) {
                if (restarted)
                    continue;
                restarted = true;
                stack.restart();
                if (verbose)
                    console.log(base + this.stackID(stack) + " (restarted)");
                let done = this.advanceFully(stack, newStacks);
                if (done)
                    continue;
            }
            let force = stack.split(), forceBase = base;
            for (let j = 0; force.forceReduce() && j < 10 /* ForceReduceLimit */; j++) {
                if (verbose)
                    console.log(forceBase + this.stackID(force) + " (via force-reduce)");
                let done = this.advanceFully(force, newStacks);
                if (done)
                    break;
                if (verbose)
                    forceBase = this.stackID(force) + " -> ";
            }
            for (let insert of stack.recoverByInsert(token)) {
                if (verbose)
                    console.log(base + this.stackID(insert) + " (via recover-insert)");
                this.advanceFully(insert, newStacks);
            }
            if (this.stream.end > stack.pos) {
                if (tokenEnd == stack.pos) {
                    tokenEnd++;
                    token = 0 /* Err */;
                }
                stack.recoverByDelete(token, tokenEnd);
                if (verbose)
                    console.log(base + this.stackID(stack) + ` (via recover-delete ${this.parser.getName(token)})`);
                pushStackDedup(stack, newStacks);
            }
            else if (!finished || finished.score < stack.score) {
                finished = stack;
            }
        }
        return finished;
    }
    // Convert the stack's buffer to a syntax tree.
    stackToTree(stack) {
        stack.close();
        return common.Tree.build({ buffer: StackBufferCursor.create(stack),
            nodeSet: this.parser.nodeSet,
            topID: this.topTerm,
            maxBufferLength: this.parser.bufferLength,
            reused: this.reused,
            start: this.ranges[0].from,
            length: stack.pos - this.ranges[0].from,
            minRepeatType: this.parser.minRepeatTerm });
    }
    stackID(stack) {
        let id = (stackIDs || (stackIDs = new WeakMap)).get(stack);
        if (!id)
            stackIDs.set(stack, id = String.fromCodePoint(this.nextStackID++));
        return id + stack;
    }
}
function pushStackDedup(stack, newStacks) {
    for (let i = 0; i < newStacks.length; i++) {
        let other = newStacks[i];
        if (other.pos == stack.pos && other.sameState(stack)) {
            if (newStacks[i].score < stack.score)
                newStacks[i] = stack;
            return;
        }
    }
    newStacks.push(stack);
}
class Dialect {
    constructor(source, flags, disabled) {
        this.source = source;
        this.flags = flags;
        this.disabled = disabled;
    }
    allows(term) { return !this.disabled || this.disabled[term] == 0; }
}
const id = x => x;
/// Context trackers are used to track stateful context (such as
/// indentation in the Python grammar, or parent elements in the XML
/// grammar) needed by external tokenizers. You declare them in a
/// grammar file as `@context exportName from "module"`.
///
/// Context values should be immutable, and can be updated (replaced)
/// on shift or reduce actions.
///
/// The export used in a `@context` declaration should be of this
/// type.
class ContextTracker {
    /// Define a context tracker.
    constructor(spec) {
        this.start = spec.start;
        this.shift = spec.shift || id;
        this.reduce = spec.reduce || id;
        this.reuse = spec.reuse || id;
        this.hash = spec.hash || (() => 0);
        this.strict = spec.strict !== false;
    }
}
/// A parser holds the parse tables for a given grammar, as generated
/// by `lezer-generator`.
class LRParser extends common.Parser {
    /// @internal
    constructor(spec) {
        super();
        /// @internal
        this.wrappers = [];
        if (spec.version != 14 /* Version */)
            throw new RangeError(`Parser version (${spec.version}) doesn't match runtime version (${14 /* Version */})`);
        let nodeNames = spec.nodeNames.split(" ");
        this.minRepeatTerm = nodeNames.length;
        for (let i = 0; i < spec.repeatNodeCount; i++)
            nodeNames.push("");
        let topTerms = Object.keys(spec.topRules).map(r => spec.topRules[r][1]);
        let nodeProps = [];
        for (let i = 0; i < nodeNames.length; i++)
            nodeProps.push([]);
        function setProp(nodeID, prop, value) {
            nodeProps[nodeID].push([prop, prop.deserialize(String(value))]);
        }
        if (spec.nodeProps)
            for (let propSpec of spec.nodeProps) {
                let prop = propSpec[0];
                if (typeof prop == "string")
                    prop = common.NodeProp[prop];
                for (let i = 1; i < propSpec.length;) {
                    let next = propSpec[i++];
                    if (next >= 0) {
                        setProp(next, prop, propSpec[i++]);
                    }
                    else {
                        let value = propSpec[i + -next];
                        for (let j = -next; j > 0; j--)
                            setProp(propSpec[i++], prop, value);
                        i++;
                    }
                }
            }
        this.nodeSet = new common.NodeSet(nodeNames.map((name, i) => common.NodeType.define({
            name: i >= this.minRepeatTerm ? undefined : name,
            id: i,
            props: nodeProps[i],
            top: topTerms.indexOf(i) > -1,
            error: i == 0,
            skipped: spec.skippedNodes && spec.skippedNodes.indexOf(i) > -1
        })));
        if (spec.propSources)
            this.nodeSet = this.nodeSet.extend(...spec.propSources);
        this.strict = false;
        this.bufferLength = common.DefaultBufferLength;
        let tokenArray = decodeArray(spec.tokenData);
        this.context = spec.context;
        this.specialized = new Uint16Array(spec.specialized ? spec.specialized.length : 0);
        this.specializers = [];
        if (spec.specialized)
            for (let i = 0; i < spec.specialized.length; i++) {
                this.specialized[i] = spec.specialized[i].term;
                this.specializers[i] = spec.specialized[i].get;
            }
        this.states = decodeArray(spec.states, Uint32Array);
        this.data = decodeArray(spec.stateData);
        this.goto = decodeArray(spec.goto);
        this.maxTerm = spec.maxTerm;
        this.tokenizers = spec.tokenizers.map(value => typeof value == "number" ? new TokenGroup(tokenArray, value) : value);
        this.topRules = spec.topRules;
        this.dialects = spec.dialects || {};
        this.dynamicPrecedences = spec.dynamicPrecedences || null;
        this.tokenPrecTable = spec.tokenPrec;
        this.termNames = spec.termNames || null;
        this.maxNode = this.nodeSet.types.length - 1;
        this.dialect = this.parseDialect();
        this.top = this.topRules[Object.keys(this.topRules)[0]];
    }
    createParse(input, fragments, ranges) {
        let parse = new Parse(this, input, fragments, ranges);
        for (let w of this.wrappers)
            parse = w(parse, input, fragments, ranges);
        return parse;
    }
    /// Get a goto table entry @internal
    getGoto(state, term, loose = false) {
        let table = this.goto;
        if (term >= table[0])
            return -1;
        for (let pos = table[term + 1];;) {
            let groupTag = table[pos++], last = groupTag & 1;
            let target = table[pos++];
            if (last && loose)
                return target;
            for (let end = pos + (groupTag >> 1); pos < end; pos++)
                if (table[pos] == state)
                    return target;
            if (last)
                return -1;
        }
    }
    /// Check if this state has an action for a given terminal @internal
    hasAction(state, terminal) {
        let data = this.data;
        for (let set = 0; set < 2; set++) {
            for (let i = this.stateSlot(state, set ? 2 /* Skip */ : 1 /* Actions */), next;; i += 3) {
                if ((next = data[i]) == 65535 /* End */) {
                    if (data[i + 1] == 1 /* Next */)
                        next = data[i = pair(data, i + 2)];
                    else if (data[i + 1] == 2 /* Other */)
                        return pair(data, i + 2);
                    else
                        break;
                }
                if (next == terminal || next == 0 /* Err */)
                    return pair(data, i + 1);
            }
        }
        return 0;
    }
    /// @internal
    stateSlot(state, slot) {
        return this.states[(state * 6 /* Size */) + slot];
    }
    /// @internal
    stateFlag(state, flag) {
        return (this.stateSlot(state, 0 /* Flags */) & flag) > 0;
    }
    /// @internal
    validAction(state, action) {
        if (action == this.stateSlot(state, 4 /* DefaultReduce */))
            return true;
        for (let i = this.stateSlot(state, 1 /* Actions */);; i += 3) {
            if (this.data[i] == 65535 /* End */) {
                if (this.data[i + 1] == 1 /* Next */)
                    i = pair(this.data, i + 2);
                else
                    return false;
            }
            if (action == pair(this.data, i + 1))
                return true;
        }
    }
    /// Get the states that can follow this one through shift actions or
    /// goto jumps. @internal
    nextStates(state) {
        let result = [];
        for (let i = this.stateSlot(state, 1 /* Actions */);; i += 3) {
            if (this.data[i] == 65535 /* End */) {
                if (this.data[i + 1] == 1 /* Next */)
                    i = pair(this.data, i + 2);
                else
                    break;
            }
            if ((this.data[i + 2] & (65536 /* ReduceFlag */ >> 16)) == 0) {
                let value = this.data[i + 1];
                if (!result.some((v, i) => (i & 1) && v == value))
                    result.push(this.data[i], value);
            }
        }
        return result;
    }
    /// @internal
    overrides(token, prev) {
        let iPrev = findOffset(this.data, this.tokenPrecTable, prev);
        return iPrev < 0 || findOffset(this.data, this.tokenPrecTable, token) < iPrev;
    }
    /// Configure the parser. Returns a new parser instance that has the
    /// given settings modified. Settings not provided in `config` are
    /// kept from the original parser.
    configure(config) {
        // Hideous reflection-based kludge to make it easy to create a
        // slightly modified copy of a parser.
        let copy = Object.assign(Object.create(LRParser.prototype), this);
        if (config.props)
            copy.nodeSet = this.nodeSet.extend(...config.props);
        if (config.top) {
            let info = this.topRules[config.top];
            if (!info)
                throw new RangeError(`Invalid top rule name ${config.top}`);
            copy.top = info;
        }
        if (config.tokenizers)
            copy.tokenizers = this.tokenizers.map(t => {
                let found = config.tokenizers.find(r => r.from == t);
                return found ? found.to : t;
            });
        if (config.contextTracker)
            copy.context = config.contextTracker;
        if (config.dialect)
            copy.dialect = this.parseDialect(config.dialect);
        if (config.strict != null)
            copy.strict = config.strict;
        if (config.wrap)
            copy.wrappers = copy.wrappers.concat(config.wrap);
        if (config.bufferLength != null)
            copy.bufferLength = config.bufferLength;
        return copy;
    }
    /// Tells you whether any [parse wrappers](#lr.ParserConfig.wrap)
    /// are registered for this parser.
    hasWrappers() {
        return this.wrappers.length > 0;
    }
    /// Returns the name associated with a given term. This will only
    /// work for all terms when the parser was generated with the
    /// `--names` option. By default, only the names of tagged terms are
    /// stored.
    getName(term) {
        return this.termNames ? this.termNames[term] : String(term <= this.maxNode && this.nodeSet.types[term].name || term);
    }
    /// The eof term id is always allocated directly after the node
    /// types. @internal
    get eofTerm() { return this.maxNode + 1; }
    /// The type of top node produced by the parser.
    get topNode() { return this.nodeSet.types[this.top[1]]; }
    /// @internal
    dynamicPrecedence(term) {
        let prec = this.dynamicPrecedences;
        return prec == null ? 0 : prec[term] || 0;
    }
    /// @internal
    parseDialect(dialect) {
        let values = Object.keys(this.dialects), flags = values.map(() => false);
        if (dialect)
            for (let part of dialect.split(" ")) {
                let id = values.indexOf(part);
                if (id >= 0)
                    flags[id] = true;
            }
        let disabled = null;
        for (let i = 0; i < values.length; i++)
            if (!flags[i]) {
                for (let j = this.dialects[values[i]], id; (id = this.data[j++]) != 65535 /* End */;)
                    (disabled || (disabled = new Uint8Array(this.maxTerm + 1)))[id] = 1;
            }
        return new Dialect(dialect, flags, disabled);
    }
    /// (used by the output of the parser generator) @internal
    static deserialize(spec) {
        return new LRParser(spec);
    }
}
function pair(data, off) { return data[off] | (data[off + 1] << 16); }
function findOffset(data, start, term) {
    for (let i = start, next; (next = data[i]) != 65535 /* End */; i++)
        if (next == term)
            return i - start;
    return -1;
}
function findFinished(stacks) {
    let best = null;
    for (let stack of stacks) {
        let stopped = stack.p.stoppedAt;
        if ((stack.pos == stack.p.stream.end || stopped != null && stack.pos > stopped) &&
            stack.p.parser.stateFlag(stack.state, 2 /* Accepting */) &&
            (!best || best.score < stack.score))
            best = stack;
    }
    return best;
}

exports.ContextTracker = ContextTracker;
exports.ExternalTokenizer = ExternalTokenizer;
exports.InputStream = InputStream;
exports.LRParser = LRParser;
exports.Stack = Stack;


/***/ }),

/***/ "./node_modules/@lezer/python/dist/index.cjs":
/*!***************************************************!*\
  !*** ./node_modules/@lezer/python/dist/index.cjs ***!
  \***************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({ value: true }));

var lr = __webpack_require__(/*! @lezer/lr */ "./node_modules/@lezer/lr/dist/index.cjs");
var highlight = __webpack_require__(/*! @lezer/highlight */ "./node_modules/@lezer/highlight/dist/index.cjs");

// This file was generated by lezer-generator. You probably shouldn't edit it.
const printKeyword = 1,
  indent = 162,
  dedent = 163,
  newline$1 = 164,
  newlineBracketed = 165,
  newlineEmpty = 166,
  eof = 167,
  ParenL = 22,
  ParenthesizedExpression = 23,
  TupleExpression = 47,
  ComprehensionExpression = 48,
  BracketL = 53,
  ArrayExpression = 54,
  ArrayComprehensionExpression = 55,
  BraceL = 57,
  DictionaryExpression = 58,
  DictionaryComprehensionExpression = 59,
  SetExpression = 60,
  SetComprehensionExpression = 61,
  ArgList = 63,
  subscript = 203,
  FormatReplacement = 71,
  importList = 228,
  ParamList = 121;

const newline = 10, carriageReturn = 13, space = 32, tab = 9, hash = 35, parenOpen = 40, dot = 46;

const bracketed = [
  ParenthesizedExpression, TupleExpression, ComprehensionExpression, importList, ArgList, ParamList,
  ArrayExpression, ArrayComprehensionExpression, subscript,
  SetExpression, SetComprehensionExpression,
  DictionaryExpression, DictionaryComprehensionExpression, FormatReplacement
];

const newlines = new lr.ExternalTokenizer((input, stack) => {
  if (input.next < 0) {
    input.acceptToken(eof);
  } else if (input.next != newline && input.next != carriageReturn) ; else if (stack.context.depth < 0) {
    input.acceptToken(newlineBracketed, 1);
  } else {
    input.advance();
    let spaces = 0;
    while (input.next == space || input.next == tab) { input.advance(); spaces++; }
    let empty = input.next == newline || input.next == carriageReturn || input.next == hash;
    input.acceptToken(empty ? newlineEmpty : newline$1, -spaces);
  }
}, {contextual: true, fallback: true});

const indentation = new lr.ExternalTokenizer((input, stack) => {
  let cDepth = stack.context.depth;
  if (cDepth < 0) return
  let prev = input.peek(-1);
  if ((prev == newline || prev == carriageReturn) && stack.context.depth >= 0) {
    let depth = 0, chars = 0;
    for (;;) {
      if (input.next == space) depth++;
      else if (input.next == tab) depth += 8 - (depth % 8);
      else break
      input.advance();
      chars++;
    }
    if (depth != cDepth &&
        input.next != newline && input.next != carriageReturn && input.next != hash) {
      if (depth < cDepth) input.acceptToken(dedent, -chars);
      else input.acceptToken(indent);
    }
  }
});

function IndentLevel(parent, depth) {
  this.parent = parent;
  // -1 means this is not an actual indent level but a set of brackets
  this.depth = depth;
  this.hash = (parent ? parent.hash + parent.hash << 8 : 0) + depth + (depth << 4);
}

const topIndent = new IndentLevel(null, 0);

function countIndent(space) {
  let depth = 0;
  for (let i = 0; i < space.length; i++)
    depth += space.charCodeAt(i) == tab ? 8 - (depth % 8) : 1;
  return depth
}

const trackIndent = new lr.ContextTracker({
  start: topIndent,
  reduce(context, term) {
    return context.depth < 0 && bracketed.indexOf(term) > -1 ? context.parent : context
  },
  shift(context, term, stack, input) {
    if (term == indent) return new IndentLevel(context, countIndent(input.read(input.pos, stack.pos)))
    if (term == dedent) return context.parent
    if (term == ParenL || term == BracketL || term == BraceL) return new IndentLevel(context, -1)
    return context
  },
  hash(context) { return context.hash }
});

const legacyPrint = new lr.ExternalTokenizer(input => {
  for (let i = 0; i < 5; i++) {
    if (input.next != "print".charCodeAt(i)) return
    input.advance();
  }
  if (/\w/.test(String.fromCharCode(input.next))) return
  for (let off = 0;; off++) {
    let next = input.peek(off);
    if (next == space || next == tab) continue
    if (next != parenOpen && next != dot && next != newline && next != carriageReturn && next != hash)
      input.acceptToken(printKeyword);
    return
  }
});

const pythonHighlighting = highlight.styleTags({
  "async \"*\" \"**\" FormatConversion FormatSpec": highlight.tags.modifier,
  "for while if elif else try except finally return raise break continue with pass assert await yield": highlight.tags.controlKeyword,
  "in not and or is del": highlight.tags.operatorKeyword,
  "from def class global nonlocal lambda": highlight.tags.definitionKeyword,
  import: highlight.tags.moduleKeyword,
  "with as print": highlight.tags.keyword,
  Boolean: highlight.tags.bool,
  None: highlight.tags.null,
  VariableName: highlight.tags.variableName,
  "CallExpression/VariableName": highlight.tags.function(highlight.tags.variableName),
  "FunctionDefinition/VariableName": highlight.tags.function(highlight.tags.definition(highlight.tags.variableName)),
  "ClassDefinition/VariableName": highlight.tags.definition(highlight.tags.className),
  PropertyName: highlight.tags.propertyName,
  "CallExpression/MemberExpression/PropertyName": highlight.tags.function(highlight.tags.propertyName),
  Comment: highlight.tags.lineComment,
  Number: highlight.tags.number,
  String: highlight.tags.string,
  FormatString: highlight.tags.special(highlight.tags.string),
  UpdateOp: highlight.tags.updateOperator,
  ArithOp: highlight.tags.arithmeticOperator,
  BitOp: highlight.tags.bitwiseOperator,
  CompareOp: highlight.tags.compareOperator,
  AssignOp: highlight.tags.definitionOperator,
  Ellipsis: highlight.tags.punctuation,
  At: highlight.tags.meta,
  "( )": highlight.tags.paren,
  "[ ]": highlight.tags.squareBracket,
  "{ }": highlight.tags.brace,
  ".": highlight.tags.derefOperator,
  ", ;": highlight.tags.separator
});

// This file was generated by lezer-generator. You probably shouldn't edit it.
const spec_identifier = {__proto__:null,await:40, or:50, and:52, in:56, not:58, is:60, if:66, else:68, lambda:72, yield:90, from:92, async:98, for:100, None:152, True:154, False:154, del:168, pass:172, break:176, continue:180, return:184, raise:192, import:196, as:198, global:202, nonlocal:204, assert:208, elif:218, while:222, try:228, except:230, finally:232, with:236, def:240, class:250};
const parser = lr.LRParser.deserialize({
  version: 14,
  states: "!?pO`Q$IXOOO%cQ$I[O'#GaOOQ$IS'#Cm'#CmOOQ$IS'#Cn'#CnO'RQ$IWO'#ClO(tQ$I[O'#G`OOQ$IS'#Ga'#GaOOQ$IS'#DS'#DSOOQ$IS'#G`'#G`O)bQ$IWO'#CsO)rQ$IWO'#DdO*SQ$IWO'#DhOOQ$IS'#Ds'#DsO*gO`O'#DsO*oOpO'#DsO*wO!bO'#DtO+SO#tO'#DtO+_O&jO'#DtO+jO,UO'#DtO-lQ$I[O'#GQOOQ$IS'#GQ'#GQO'RQ$IWO'#GPO/OQ$I[O'#GPOOQ$IS'#E]'#E]O/gQ$IWO'#E^OOQ$IS'#GO'#GOO/qQ$IWO'#F}OOQ$IV'#F}'#F}O/|Q$IWO'#FPOOQ$IS'#Fr'#FrO0RQ$IWO'#FOOOQ$IV'#H]'#H]OOQ$IV'#F|'#F|OOQ$IT'#FR'#FRQ`Q$IXOOO'RQ$IWO'#CoO0aQ$IWO'#C{O0hQ$IWO'#DPO0vQ$IWO'#GeO1WQ$I[O'#EQO'RQ$IWO'#EROOQ$IS'#ET'#ETOOQ$IS'#EV'#EVOOQ$IS'#EX'#EXO1lQ$IWO'#EZO2SQ$IWO'#E_O/|Q$IWO'#EaO2gQ$I[O'#EaO/|Q$IWO'#EdO/gQ$IWO'#EgO/gQ$IWO'#EkO/gQ$IWO'#EnO2rQ$IWO'#EpO2yQ$IWO'#EuO3UQ$IWO'#EqO/gQ$IWO'#EuO/|Q$IWO'#EwO/|Q$IWO'#E|OOQ$IS'#Cc'#CcOOQ$IS'#Cd'#CdOOQ$IS'#Ce'#CeOOQ$IS'#Cf'#CfOOQ$IS'#Cg'#CgOOQ$IS'#Ch'#ChOOQ$IS'#Cj'#CjO'RQ$IWO,58|O'RQ$IWO,58|O'RQ$IWO,58|O'RQ$IWO,58|O'RQ$IWO,58|O'RQ$IWO,58|O3ZQ$IWO'#DmOOQ$IS,5:W,5:WO3nQ$IWO'#GoOOQ$IS,5:Z,5:ZO3{Q%1`O,5:ZO4QQ$I[O,59WO0aQ$IWO,59`O0aQ$IWO,59`O0aQ$IWO,59`O6pQ$IWO,59`O6uQ$IWO,59`O6|Q$IWO,59hO7TQ$IWO'#G`O8ZQ$IWO'#G_OOQ$IS'#G_'#G_OOQ$IS'#DY'#DYO8rQ$IWO,59_O'RQ$IWO,59_O9QQ$IWO,59_O9VQ$IWO,5:PO'RQ$IWO,5:POOQ$IS,5:O,5:OO9eQ$IWO,5:OO9jQ$IWO,5:VO'RQ$IWO,5:VO'RQ$IWO,5:TOOQ$IS,5:S,5:SO9{Q$IWO,5:SO:QQ$IWO,5:UOOOO'#FZ'#FZO:VO`O,5:_OOQ$IS,5:_,5:_OOOO'#F['#F[O:_OpO,5:_O:gQ$IWO'#DuOOOO'#F]'#F]O:wO!bO,5:`OOQ$IS,5:`,5:`OOOO'#F`'#F`O;SO#tO,5:`OOOO'#Fa'#FaO;_O&jO,5:`OOOO'#Fb'#FbO;jO,UO,5:`OOQ$IS'#Fc'#FcO;uQ$I[O,5:dO>gQ$I[O,5<kO?QQ%GlO,5<kO?qQ$I[O,5<kOOQ$IS,5:x,5:xO@YQ$IXO'#FkOAiQ$IWO,5;TOOQ$IV,5<i,5<iOAtQ$I[O'#HXOB]Q$IWO,5;kOOQ$IS-E9p-E9pOOQ$IV,5;j,5;jO3PQ$IWO'#EwOOQ$IT-E9P-E9POBeQ$I[O,59ZODlQ$I[O,59gOEVQ$IWO'#GbOEbQ$IWO'#GbO/|Q$IWO'#GbOEmQ$IWO'#DROEuQ$IWO,59kOEzQ$IWO'#GfO'RQ$IWO'#GfO/gQ$IWO,5=POOQ$IS,5=P,5=PO/gQ$IWO'#D|OOQ$IS'#D}'#D}OFiQ$IWO'#FeOFyQ$IWO,58zOFyQ$IWO,58zO)eQ$IWO,5:jOGXQ$I[O'#GhOOQ$IS,5:m,5:mOOQ$IS,5:u,5:uOGlQ$IWO,5:yOG}Q$IWO,5:{OOQ$IS'#Fh'#FhOH]Q$I[O,5:{OHkQ$IWO,5:{OHpQ$IWO'#H[OOQ$IS,5;O,5;OOIOQ$IWO'#HWOOQ$IS,5;R,5;RO3UQ$IWO,5;VO3UQ$IWO,5;YOIaQ$I[O'#H^O'RQ$IWO'#H^OIkQ$IWO,5;[O2rQ$IWO,5;[O/gQ$IWO,5;aO/|Q$IWO,5;cOIpQ$IXO'#ElOJyQ$IZO,5;]ON[Q$IWO'#H_O3UQ$IWO,5;aONgQ$IWO,5;cONlQ$IWO,5;hO!#aQ$I[O1G.hO!#hQ$I[O1G.hO!&XQ$I[O1G.hO!&cQ$I[O1G.hO!(|Q$I[O1G.hO!)aQ$I[O1G.hO!)tQ$IWO'#GnO!*SQ$I[O'#GQO/gQ$IWO'#GnO!*^Q$IWO'#GmOOQ$IS,5:X,5:XO!*fQ$IWO,5:XO!*kQ$IWO'#GpO!*vQ$IWO'#GpO!+ZQ$IWO,5=ZOOQ$IS'#Dq'#DqOOQ$IS1G/u1G/uOOQ$IS1G.z1G.zO!,ZQ$I[O1G.zO!,bQ$I[O1G.zO0aQ$IWO1G.zO!,}Q$IWO1G/SOOQ$IS'#DX'#DXO/gQ$IWO,59rOOQ$IS1G.y1G.yO!-UQ$IWO1G/cO!-fQ$IWO1G/cO!-nQ$IWO1G/dO'RQ$IWO'#GgO!-sQ$IWO'#GgO!-xQ$I[O1G.yO!.YQ$IWO,59gO!/`Q$IWO,5=VO!/pQ$IWO,5=VO!/xQ$IWO1G/kO!/}Q$I[O1G/kOOQ$IS1G/j1G/jO!0_Q$IWO,5=QO!1UQ$IWO,5=QO/gQ$IWO1G/oO!1sQ$IWO1G/qO!1xQ$I[O1G/qO!2YQ$I[O1G/oOOQ$IS1G/n1G/nOOQ$IS1G/p1G/pOOOO-E9X-E9XOOQ$IS1G/y1G/yOOOO-E9Y-E9YO!2jQ$IWO'#G{O/gQ$IWO'#G{O!2xQ$IWO,5:aOOOO-E9Z-E9ZOOQ$IS1G/z1G/zOOOO-E9^-E9^OOOO-E9_-E9_OOOO-E9`-E9`OOQ$IS-E9a-E9aO!3TQ%GlO1G2VO!3tQ$I[O1G2VO'RQ$IWO,5<OOOQ$IS,5<O,5<OOOQ$IS-E9b-E9bOOQ$IS,5<V,5<VOOQ$IS-E9i-E9iOOQ$IV1G0o1G0oO/|Q$IWO'#FgO!4]Q$I[O,5=sOOQ$IS1G1V1G1VO!4tQ$IWO1G1VOOQ$IS'#DT'#DTO/gQ$IWO,5<|OOQ$IS,5<|,5<|O!4yQ$IWO'#FSO!5UQ$IWO,59mO!5^Q$IWO1G/VO!5hQ$I[O,5=QOOQ$IS1G2k1G2kOOQ$IS,5:h,5:hO!6XQ$IWO'#GPOOQ$IS,5<P,5<POOQ$IS-E9c-E9cO!6jQ$IWO1G.fOOQ$IS1G0U1G0UO!6xQ$IWO,5=SO!7YQ$IWO,5=SO/gQ$IWO1G0eO/gQ$IWO1G0eO/|Q$IWO1G0gOOQ$IS-E9f-E9fO!7kQ$IWO1G0gO!7vQ$IWO1G0gO!7{Q$IWO,5=vO!8ZQ$IWO,5=vO!8iQ$IWO,5=rO!9PQ$IWO,5=rO!9bQ$IZO1G0qO!<pQ$IZO1G0tO!?{Q$IWO,5=xO!@VQ$IWO,5=xO!@_Q$I[O,5=xO/gQ$IWO1G0vO!@iQ$IWO1G0vO3UQ$IWO1G0{ONgQ$IWO1G0}OOQ$IV,5;W,5;WO!@nQ$IYO,5;WO!@sQ$IZO1G0wO!DUQ$IWO'#FoO3UQ$IWO1G0wO3UQ$IWO1G0wO!DcQ$IWO,5=yO!DpQ$IWO,5=yO/|Q$IWO,5=yOOQ$IV1G0{1G0{O!DxQ$IWO'#EyO!EZQ%1`O1G0}OOQ$IV1G1S1G1SO3UQ$IWO1G1SOOQ$IS,5=Y,5=YOOQ$IS'#Dn'#DnO/gQ$IWO,5=YO!EcQ$IWO,5=XO!EvQ$IWO,5=XOOQ$IS1G/s1G/sO!FOQ$IWO,5=[O!F`Q$IWO,5=[O!FhQ$IWO,5=[O!F{Q$IWO,5=[O!G]Q$IWO,5=[OOQ$IS1G2u1G2uOOQ$IS7+$f7+$fO!5^Q$IWO7+$nO!IOQ$IWO1G.zO!IVQ$IWO1G.zOOQ$IS1G/^1G/^OOQ$IS,5;p,5;pO'RQ$IWO,5;pOOQ$IS7+$}7+$}O!I^Q$IWO7+$}OOQ$IS-E9S-E9SOOQ$IS7+%O7+%OO!InQ$IWO,5=RO'RQ$IWO,5=ROOQ$IS7+$e7+$eO!IsQ$IWO7+$}O!I{Q$IWO7+%OO!JQQ$IWO1G2qOOQ$IS7+%V7+%VO!JbQ$IWO1G2qO!JjQ$IWO7+%VOOQ$IS,5;o,5;oO'RQ$IWO,5;oO!JoQ$IWO1G2lOOQ$IS-E9R-E9RO!KfQ$IWO7+%ZOOQ$IS7+%]7+%]O!KtQ$IWO1G2lO!LcQ$IWO7+%]O!LhQ$IWO1G2rO!LxQ$IWO1G2rO!MQQ$IWO7+%ZO!MVQ$IWO,5=gO!MmQ$IWO,5=gO!MmQ$IWO,5=gO!M{O!LQO'#DwO!NWOSO'#G|OOOO1G/{1G/{O!N]Q$IWO1G/{O!NeQ%GlO7+'qO# UQ$I[O1G1jP# oQ$IWO'#FdOOQ$IS,5<R,5<ROOQ$IS-E9e-E9eOOQ$IS7+&q7+&qOOQ$IS1G2h1G2hOOQ$IS,5;n,5;nOOQ$IS-E9Q-E9QOOQ$IS7+$q7+$qO# |Q$IWO,5<kO#!gQ$IWO,5<kO#!xQ$I[O,5;qO##]Q$IWO1G2nOOQ$IS-E9T-E9TOOQ$IS7+&P7+&PO##mQ$IWO7+&POOQ$IS7+&R7+&RO##{Q$IWO'#HZO/|Q$IWO'#HYO#$aQ$IWO7+&ROOQ$IS,5<U,5<UO#$lQ$IWO1G3bOOQ$IS-E9h-E9hOOQ$IS,5<Q,5<QO#$zQ$IWO1G3^OOQ$IS-E9d-E9dO#%bQ$IZO7+&]O!DUQ$IWO'#FmO3UQ$IWO7+&]O3UQ$IWO7+&`O#(pQ$I[O,5<YO'RQ$IWO,5<YO#(zQ$IWO1G3dOOQ$IS-E9l-E9lO#)UQ$IWO1G3dO3UQ$IWO7+&bO/gQ$IWO7+&bOOQ$IV7+&g7+&gO!EZQ%1`O7+&iO#)^Q$IXO1G0rOOQ$IV-E9m-E9mO3UQ$IWO7+&cO3UQ$IWO7+&cOOQ$IV,5<Z,5<ZO#+PQ$IWO,5<ZOOQ$IV7+&c7+&cO#+[Q$IZO7+&cO#.gQ$IWO,5<[O#.rQ$IWO1G3eOOQ$IS-E9n-E9nO#/PQ$IWO1G3eO#/XQ$IWO'#HaO#/gQ$IWO'#HaO/|Q$IWO'#HaOOQ$IS'#Ha'#HaO#/rQ$IWO'#H`OOQ$IS,5;e,5;eO#/zQ$IWO,5;eO/gQ$IWO'#E{OOQ$IV7+&i7+&iO3UQ$IWO7+&iOOQ$IV7+&n7+&nOOQ$IS1G2t1G2tOOQ$IS,5;s,5;sO#0PQ$IWO1G2sOOQ$IS-E9V-E9VO#0dQ$IWO,5;tO#0oQ$IWO,5;tO#1SQ$IWO1G2vOOQ$IS-E9W-E9WO#1dQ$IWO1G2vO#1lQ$IWO1G2vO#1|Q$IWO1G2vO#1dQ$IWO1G2vOOQ$IS<<HY<<HYO#2XQ$I[O1G1[OOQ$IS<<Hi<<HiP#2fQ$IWO'#FUO6|Q$IWO1G2mO#2sQ$IWO1G2mO#2xQ$IWO<<HiOOQ$IS<<Hj<<HjO#3YQ$IWO7+(]OOQ$IS<<Hq<<HqO#3jQ$I[O1G1ZP#4ZQ$IWO'#FTO#4hQ$IWO7+(^O#4xQ$IWO7+(^O#5QQ$IWO<<HuO#5VQ$IWO7+(WOOQ$IS<<Hw<<HwO#5|Q$IWO,5;rO'RQ$IWO,5;rOOQ$IS-E9U-E9UOOQ$IS<<Hu<<HuOOQ$IS,5;x,5;xO/gQ$IWO,5;xO#6RQ$IWO1G3ROOQ$IS-E9[-E9[O#6iQ$IWO1G3ROOOO'#F_'#F_O#6wO!LQO,5:cOOOO,5=h,5=hOOOO7+%g7+%gO#7SQ$IWO1G2VO#7mQ$IWO1G2VP'RQ$IWO'#FVO/gQ$IWO<<IkO#8OQ$IWO,5=uO#8aQ$IWO,5=uO/|Q$IWO,5=uO#8rQ$IWO,5=tOOQ$IS<<Im<<ImP/|Q$IWO'#FjP/gQ$IWO'#FfOOQ$IV-E9k-E9kO3UQ$IWO<<IwOOQ$IV,5<X,5<XO3UQ$IWO,5<XOOQ$IV<<Iw<<IwOOQ$IV<<Iz<<IzO#8wQ$I[O1G1tP#9RQ$IWO'#FnO#9YQ$IWO7+)OO#9dQ$IZO<<I|O3UQ$IWO<<I|OOQ$IV<<JT<<JTO3UQ$IWO<<JTOOQ$IV'#Fl'#FlO#<oQ$IZO7+&^OOQ$IV<<I}<<I}O#>hQ$IZO<<I}OOQ$IV1G1u1G1uO/|Q$IWO1G1uO3UQ$IWO<<I}O/|Q$IWO1G1vP/gQ$IWO'#FpO#AsQ$IWO7+)PO#BQQ$IWO7+)POOQ$IS'#Ez'#EzO/gQ$IWO,5={O#BYQ$IWO,5={OOQ$IS,5={,5={O#BeQ$IWO,5=zO#BvQ$IWO,5=zOOQ$IS1G1P1G1POOQ$IS,5;g,5;gP#COQ$IWO'#FXO#C`Q$IWO1G1`O#CsQ$IWO1G1`O#DTQ$IWO1G1`P#D`Q$IWO'#FYO#DmQ$IWO7+(bO#D}Q$IWO7+(bO#D}Q$IWO7+(bO#EVQ$IWO7+(bO#EgQ$IWO7+(XO6|Q$IWO7+(XOOQ$ISAN>TAN>TO#FQQ$IWO<<KxOOQ$ISAN>aAN>aO/gQ$IWO1G1^O#FbQ$I[O1G1^P#FlQ$IWO'#FWOOQ$IS1G1d1G1dP#FyQ$IWO'#F^O#GWQ$IWO7+(mOOOO-E9]-E9]O#GnQ$IWO7+'qOOQ$ISAN?VAN?VO#HXQ$IWO,5<TO#HmQ$IWO1G3aOOQ$IS-E9g-E9gO#IOQ$IWO1G3aOOQ$IS1G3`1G3`OOQ$IVAN?cAN?cOOQ$IV1G1s1G1sO3UQ$IWOAN?hO#IaQ$IZOAN?hOOQ$IVAN?oAN?oOOQ$IV-E9j-E9jOOQ$IV<<Ix<<IxO3UQ$IWOAN?iO3UQ$IWO7+'aOOQ$IVAN?iAN?iOOQ$IS7+'b7+'bO#LlQ$IWO<<LkOOQ$IS1G3g1G3gO/gQ$IWO1G3gOOQ$IS,5<],5<]O#LyQ$IWO1G3fOOQ$IS-E9o-E9oO#M[Q$IWO7+&zO#MlQ$IWO7+&zOOQ$IS7+&z7+&zO#MwQ$IWO<<K|O#NXQ$IWO<<K|O#NXQ$IWO<<K|O#NaQ$IWO'#GiOOQ$IS<<Ks<<KsO#NkQ$IWO<<KsOOQ$IS7+&x7+&xO/|Q$IWO1G1oP/|Q$IWO'#FiO$ UQ$IWO7+({O$ gQ$IWO7+({OOQ$IVG25SG25SO3UQ$IWOG25SOOQ$IVG25TG25TOOQ$IV<<J{<<J{OOQ$IS7+)R7+)RP$ xQ$IWO'#FqOOQ$IS<<Jf<<JfO$!WQ$IWO<<JfO$!hQ$IWOANAhO$!xQ$IWOANAhO$#QQ$IWO'#GjOOQ$IS'#Gj'#GjO0hQ$IWO'#DaO$#kQ$IWO,5=TOOQ$ISANA_ANA_OOQ$IS7+'Z7+'ZO$$SQ$IWO<<LgOOQ$IVLD*nLD*nOOQ$ISAN@QAN@QO$$eQ$IWOG27SO$$uQ$IWO,59{OOQ$IS1G2o1G2oO#NaQ$IWO1G/gOOQ$IS7+%R7+%RO6|Q$IWO'#C{O6|Q$IWO,59`O6|Q$IWO,59`O6|Q$IWO,59`O$$zQ$I[O,5<kO6|Q$IWO1G.zO/gQ$IWO1G/VO/gQ$IWO7+$nP$%_Q$IWO'#FdO'RQ$IWO'#GPO$%lQ$IWO,59`O$%qQ$IWO,59`O$%xQ$IWO,59kO$%}Q$IWO1G/SO0hQ$IWO'#DPO6|Q$IWO,59h",
  stateData: "$&e~O$oOS$lOS$kOSQOS~OPhOTeOdsOfXOmtOq!SOtuO}vO!O!PO!R!VO!S!UO!VYO!ZZO!fdO!mdO!ndO!odO!vxO!xyO!zzO!|{O#O|O#S}O#U!OO#X!QO#Y!QO#[!RO#c!TO#f!WO#j!XO#l!YO#q!ZO#tlO$jqO$zQO${QO%PRO%QVO%f[O%g]O%j^O%m_O%s`O%vaO%xbO~OT!aO]!aO_!bOf!iO!V!kO!d!mO$u![O$v!]O$w!^O$x!_O$y!_O$z!`O${!`O$|!aO$}!aO%O!aO~Oi%TXj%TXk%TXl%TXm%TXn%TXq%TXx%TXy%TX!s%TX#^%TX$j%TX$m%TX%V%TXe%TX!R%TX!S%TX%W%TX!U%TX!Y%TX!O%TX#V%TXr%TX!j%TX~P$_OdsOfXO!VYO!ZZO!fdO!mdO!ndO!odO$zQO${QO%PRO%QVO%f[O%g]O%j^O%m_O%s`O%vaO%xbO~Ox%SXy%SX#^%SX$j%SX$m%SX%V%SX~Oi!pOj!qOk!oOl!oOm!rOn!sOq!tO!s%SX~P(`OT!zOm-dOt-rO}vO~P'ROT!}Om-dOt-rO!U#OO~P'ROT#RO_#SOm-dOt-rO!Y#TO~P'RO%h#WO%i#YO~O%k#ZO%l#YO~O!Z#]O%n#^O%r#`O~O!Z#]O%t#aO%u#`O~O!Z#]O%i#`O%w#cO~O!Z#]O%l#`O%y#eO~OT$tX]$tX_$tXf$tXi$tXj$tXk$tXl$tXm$tXn$tXq$tXx$tX!V$tX!d$tX$u$tX$v$tX$w$tX$x$tX$y$tX$z$tX${$tX$|$tX$}$tX%O$tXe$tX!R$tX!S$tX~O%f[O%g]O%j^O%m_O%s`O%vaO%xbOy$tX!s$tX#^$tX$j$tX$m$tX%V$tX%W$tX!U$tX!Y$tX!O$tX#V$tXr$tX!j$tX~P+uOx#jOy$sX!s$sX#^$sX$j$sX$m$sX%V$sX~Om-dOt-rO~P'RO#^#mO$j#oO$m#oO~O%QVO~O!R#tO#l!YO#q!ZO#tlO~OmtO~P'ROT#yO_#zO%QVOyuP~OT$OOm-dOt-rO!O$PO~P'ROy$RO!s$WO%V$SO#^!tX$j!tX$m!tX~OT$OOm-dOt-rO#^!}X$j!}X$m!}X~P'ROm-dOt-rO#^#RX$j#RX$m#RX~P'RO!d$^O!m$^O%QVO~OT$hO~P'RO!S$jO#j$kO#l$lO~Oy$mO~OT${O_${Oe$}Om-dOt-rO~P'ROm-dOt-rOy%QO~P'RO%e%SO~O_!bOf!iO!V!kO!d!mOT`a]`ai`aj`ak`al`am`an`aq`ax`ay`a!s`a#^`a$j`a$m`a$u`a$v`a$w`a$x`a$y`a$z`a${`a$|`a$}`a%O`a%V`ae`a!R`a!S`a%W`a!U`a!Y`a!O`a#V`ar`a!j`a~Ol%XO~Om%XO~P'ROm-dO~P'ROi-fOj-gOk-eOl-eOm-nOn-oOq-sOe%SX!R%SX!S%SX%W%SX!U%SX!Y%SX!O%SX#V%SX!j%SX~P(`O%W%ZOe%RXx%RX!R%RX!S%RX!U%RXy%RX~Oe%]Ox%^O!R%bO!S%aO~Oe%]O~Ox%eO!R%bO!S%aO!U%_X~O!U%iO~Ox%jOy%lO!R%bO!S%aO!Y%YX~O!Y%pO~O!Y%qO~O%h#WO%i%sO~O%k#ZO%l%sO~OT%vOm-dOt-rO}vO~P'RO!Z#]O%n#^O%r%yO~O!Z#]O%t#aO%u%yO~O!Z#]O%i%yO%w#cO~O!Z#]O%l%yO%y#eO~OT!la]!la_!laf!lai!laj!lak!lal!lam!lan!laq!lax!lay!la!V!la!d!la!s!la#^!la$j!la$m!la$u!la$v!la$w!la$x!la$y!la$z!la${!la$|!la$}!la%O!la%V!lae!la!R!la!S!la%W!la!U!la!Y!la!O!la#V!lar!la!j!la~P#vOx&OOy$sa!s$sa#^$sa$j$sa$m$sa%V$sa~P$_OT&QOmtOtuOy$sa!s$sa#^$sa$j$sa$m$sa%V$sa~P'ROx&OOy$sa!s$sa#^$sa$j$sa$m$sa%V$sa~OPhOTeOmtOtuO}vO!O!PO!vxO!xyO!zzO!|{O#O|O#S}O#U!OO#X!QO#Y!QO#[!RO#^$_X$j$_X$m$_X~P'RO#^#mO$j&VO$m&VO~O!d&WOf%{X$j%{X#V%{X#^%{X$m%{X#U%{X~Of!iO$j&YO~Oicajcakcalcamcancaqcaxcayca!sca#^ca$jca$mca%Vcaeca!Rca!Sca%Wca!Uca!Yca!Oca#Vcarca!jca~P$_Oqoaxoayoa#^oa$joa$moa%Voa~Oi!pOj!qOk!oOl!oOm!rOn!sO!soa~PDTO%V&[Ox%UXy%UX~O%QVOx%UXy%UX~Ox&_OyuX~Oy&aO~Ox%jO#^%YX$j%YX$m%YXe%YXy%YX!Y%YX!j%YX%V%YX~OT-mOm-dOt-rO}vO~P'RO%V$SO#^Sa$jSa$mSa~Ox&jO#^%[X$j%[X$m%[Xl%[X~P$_Ox&mO!O&lO#^#Ra$j#Ra$m#Ra~O#V&nO#^#Ta$j#Ta$m#Ta~O!d$^O!m$^O#U&pO%QVO~O#U&pO~Ox&rO#^&OX$j&OX$m&OX~Ox&tO#^%zX$j%zX$m%zXy%zX~Ox&xOl&QX~P$_Ol&{O~OPhOTeOmtOtuO}vO!O!PO!vxO!xyO!zzO!|{O#O|O#S}O#U!OO#X!QO#Y!QO#[!RO$j'QO~P'ROr'UO#g'SO#h'TOP#eaT#ead#eaf#eam#eaq#eat#ea}#ea!O#ea!R#ea!S#ea!V#ea!Z#ea!f#ea!m#ea!n#ea!o#ea!v#ea!x#ea!z#ea!|#ea#O#ea#S#ea#U#ea#X#ea#Y#ea#[#ea#c#ea#f#ea#j#ea#l#ea#q#ea#t#ea$g#ea$j#ea$z#ea${#ea%P#ea%Q#ea%f#ea%g#ea%j#ea%m#ea%s#ea%v#ea%x#ea$i#ea$m#ea~Ox'VO#V'XOy&RX~Of'ZO~Of!iOy$mO~OT!aO]!aO_!bOf!iO!V!kO!d!mO$w!^O$x!_O$y!_O$z!`O${!`O$|!aO$}!aO%O!aOiUijUikUilUimUinUiqUixUiyUi!sUi#^Ui$jUi$mUi$uUi%VUieUi!RUi!SUi%WUi!UUi!YUi!OUi#VUirUi!jUi~O$v!]O~PNtO$vUi~PNtOT!aO]!aO_!bOf!iO!V!kO!d!mO$z!`O${!`O$|!aO$}!aO%O!aOiUijUikUilUimUinUiqUixUiyUi!sUi#^Ui$jUi$mUi$uUi$vUi$wUi%VUieUi!RUi!SUi%WUi!UUi!YUi!OUi#VUirUi!jUi~O$x!_O$y!_O~P!#oO$xUi$yUi~P!#oO_!bOf!iO!V!kO!d!mOiUijUikUilUimUinUiqUixUiyUi!sUi#^Ui$jUi$mUi$uUi$vUi$wUi$xUi$yUi$zUi${Ui%VUieUi!RUi!SUi%WUi!UUi!YUi!OUi#VUirUi!jUi~OT!aO]!aO$|!aO$}!aO%O!aO~P!&mOTUi]Ui$|Ui$}Ui%OUi~P!&mO!R%bO!S%aOe%bXx%bX~O%V'`O%W'`O~P+uOx'bOe%aX~Oe'dO~Ox'eOy'gO!U%dX~Om-dOt-rOx'eOy'hO!U%dX~P'RO!U'jO~Ok!oOl!oOm!rOn!sOihiqhixhiyhi!shi#^hi$jhi$mhi%Vhi~Oj!qO~P!+`Ojhi~P!+`Oi-fOj-gOk-eOl-eOm-nOn-oO~Or'lO~P!,iOT'qOe'rOm-dOt-rO~P'ROe'rOx'sO~Oe'uO~O!S'wO~Oe'xOx'sO!R%bO!S%aO~P$_Oi-fOj-gOk-eOl-eOm-nOn-oOeoa!Roa!Soa%Woa!Uoa!Yoa!Ooa#Voaroa!joa~PDTOT'qOm-dOt-rO!U%_a~P'ROx'{O!U%_a~O!U'|O~Ox'{O!R%bO!S%aO!U%_a~P$_OT(QOm-dOt-rO!Y%Ya#^%Ya$j%Ya$m%Yae%Yay%Ya!j%Ya%V%Ya~P'ROx(RO!Y%Ya#^%Ya$j%Ya$m%Yae%Yay%Ya!j%Ya%V%Ya~O!Y(UO~Ox(RO!R%bO!S%aO!Y%Ya~P$_Ox(XO!R%bO!S%aO!Y%`a~P$_Ox([Oy%oX!Y%oX!j%oX~Oy(_O!Y(aO!j(bO~OT&QOmtOtuOy$si!s$si#^$si$j$si$m$si%V$si~P'ROx(cOy$si!s$si#^$si$j$si$m$si%V$si~O!d&WOf%{a$j%{a#V%{a#^%{a$m%{a#U%{a~O$j(hO~OT#yO_#zO%QVO~Ox&_Oyua~OmtOtuO~P'ROx(RO#^%Ya$j%Ya$m%Yae%Yay%Ya!Y%Ya!j%Ya%V%Ya~P$_Ox(mO#^$sX$j$sX$m$sX%V$sX~O%V$SO#^Si$jSi$mSi~O#^%[a$j%[a$m%[al%[a~P'ROx(pO#^%[a$j%[a$m%[al%[a~OT(tOf(vO%QVO~O#U(wO~O%QVO#^&Oa$j&Oa$m&Oa~Ox(yO#^&Oa$j&Oa$m&Oa~Om-dOt-rO#^%za$j%za$m%zay%za~P'ROx(|O#^%za$j%za$m%zay%za~Or)QO#a)POP#_iT#_id#_if#_im#_iq#_it#_i}#_i!O#_i!R#_i!S#_i!V#_i!Z#_i!f#_i!m#_i!n#_i!o#_i!v#_i!x#_i!z#_i!|#_i#O#_i#S#_i#U#_i#X#_i#Y#_i#[#_i#c#_i#f#_i#j#_i#l#_i#q#_i#t#_i$g#_i$j#_i$z#_i${#_i%P#_i%Q#_i%f#_i%g#_i%j#_i%m#_i%s#_i%v#_i%x#_i$i#_i$m#_i~Or)ROP#biT#bid#bif#bim#biq#bit#bi}#bi!O#bi!R#bi!S#bi!V#bi!Z#bi!f#bi!m#bi!n#bi!o#bi!v#bi!x#bi!z#bi!|#bi#O#bi#S#bi#U#bi#X#bi#Y#bi#[#bi#c#bi#f#bi#j#bi#l#bi#q#bi#t#bi$g#bi$j#bi$z#bi${#bi%P#bi%Q#bi%f#bi%g#bi%j#bi%m#bi%s#bi%v#bi%x#bi$i#bi$m#bi~OT)TOl&Qa~P'ROx)UOl&Qa~Ox)UOl&Qa~P$_Ol)YO~O$h)]O~Or)`O#g'SO#h)_OP#eiT#eid#eif#eim#eiq#eit#ei}#ei!O#ei!R#ei!S#ei!V#ei!Z#ei!f#ei!m#ei!n#ei!o#ei!v#ei!x#ei!z#ei!|#ei#O#ei#S#ei#U#ei#X#ei#Y#ei#[#ei#c#ei#f#ei#j#ei#l#ei#q#ei#t#ei$g#ei$j#ei$z#ei${#ei%P#ei%Q#ei%f#ei%g#ei%j#ei%m#ei%s#ei%v#ei%x#ei$i#ei$m#ei~Om-dOt-rOy$mO~P'ROm-dOt-rOy&Ra~P'ROx)fOy&Ra~OT)jO_)kOe)nO$|)lO%QVO~Oy$mO&U)pO~OT${O_${Om-dOt-rOe%aa~P'ROx)vOe%aa~Om-dOt-rOy)yO!U%da~P'ROx)zO!U%da~Om-dOt-rOx)zOy)}O!U%da~P'ROm-dOt-rOx)zO!U%da~P'ROx)zOy)}O!U%da~Ok-eOl-eOm-nOn-oOehiihiqhixhi!Rhi!Shi%Whi!Uhiyhi!Yhi#^hi$jhi$mhi!Ohi#Vhirhi!jhi%Vhi~Oj-gO~P!GhOjhi~P!GhOT'qOe*SOm-dOt-rO~P'ROl*UO~Oe*SOx*WO~Oe*XO~OT'qOm-dOt-rO!U%_i~P'ROx*YO!U%_i~O!U*ZO~OT(QOm-dOt-rO!Y%Yi#^%Yi$j%Yi$m%Yie%Yiy%Yi!j%Yi%V%Yi~P'ROx*^O!R%bO!S%aO!Y%`i~Ox*aO!Y%Yi#^%Yi$j%Yi$m%Yie%Yiy%Yi!j%Yi%V%Yi~O!Y*bO~O_*dOm-dOt-rO!Y%`i~P'ROx*^O!Y%`i~O!Y*fO~OT*hOm-dOt-rOy%oa!Y%oa!j%oa~P'ROx*iOy%oa!Y%oa!j%oa~O!Z#]O%q*lO!Y!kX~O!Y*nO~Oy(_O!Y*oO~OT&QOmtOtuOy$sq!s$sq#^$sq$j$sq$m$sq%V$sq~P'ROx$Wiy$Wi!s$Wi#^$Wi$j$Wi$m$Wi%V$Wi~P$_OT&QOmtOtuO~P'ROT&QOm-dOt-rO#^$sa$j$sa$m$sa%V$sa~P'ROx*pO#^$sa$j$sa$m$sa%V$sa~Ox#ya#^#ya$j#ya$m#yal#ya~P$_O#^%[i$j%[i$m%[il%[i~P'ROx*sO#^#Rq$j#Rq$m#Rq~Ox*tO#V*vO#^%}X$j%}X$m%}Xe%}X~OT*xOf(vO%QVO~O%QVO#^&Oi$j&Oi$m&Oi~Om-dOt-rO#^%zi$j%zi$m%ziy%zi~P'ROr*|O#a)POP#_qT#_qd#_qf#_qm#_qq#_qt#_q}#_q!O#_q!R#_q!S#_q!V#_q!Z#_q!f#_q!m#_q!n#_q!o#_q!v#_q!x#_q!z#_q!|#_q#O#_q#S#_q#U#_q#X#_q#Y#_q#[#_q#c#_q#f#_q#j#_q#l#_q#q#_q#t#_q$g#_q$j#_q$z#_q${#_q%P#_q%Q#_q%f#_q%g#_q%j#_q%m#_q%s#_q%v#_q%x#_q$i#_q$m#_q~Ol$bax$ba~P$_OT)TOl&Qi~P'ROx+TOl&Qi~OPhOTeOmtOq!SOtuO}vO!O!PO!R!VO!S!UO!vxO!xyO!zzO!|{O#O|O#S}O#U!OO#X!QO#Y!QO#[!RO#c!TO#f!WO#j!XO#l!YO#q!ZO#tlO~P'ROx+_Oy$mO#V+_O~O#h+`OP#eqT#eqd#eqf#eqm#eqq#eqt#eq}#eq!O#eq!R#eq!S#eq!V#eq!Z#eq!f#eq!m#eq!n#eq!o#eq!v#eq!x#eq!z#eq!|#eq#O#eq#S#eq#U#eq#X#eq#Y#eq#[#eq#c#eq#f#eq#j#eq#l#eq#q#eq#t#eq$g#eq$j#eq$z#eq${#eq%P#eq%Q#eq%f#eq%g#eq%j#eq%m#eq%s#eq%v#eq%x#eq$i#eq$m#eq~O#V+aOx$day$da~Om-dOt-rOy&Ri~P'ROx+cOy&Ri~Oy$RO%V+eOe&TXx&TX~O%QVOe&TXx&TX~Ox+iOe&SX~Oe+kO~OT${O_${Om-dOt-rOe%ai~P'ROy+nOx#|a!U#|a~Om-dOt-rOy+oOx#|a!U#|a~P'ROm-dOt-rOy)yO!U%di~P'ROx+rO!U%di~Om-dOt-rOx+rO!U%di~P'ROx+rOy+uO!U%di~Oe#xix#xi!U#xi~P$_OT'qOm-dOt-rO~P'ROl+wO~OT'qOe+xOm-dOt-rO~P'ROT'qOm-dOt-rO!U%_q~P'ROx#wi!Y#wi#^#wi$j#wi$m#wie#wiy#wi!j#wi%V#wi~P$_OT(QOm-dOt-rO~P'RO_*dOm-dOt-rO!Y%`q~P'ROx+yO!Y%`q~O!Y+zO~OT(QOm-dOt-rO!Y%Yq#^%Yq$j%Yq$m%Yqe%Yqy%Yq!j%Yq%V%Yq~P'ROy+{O~OT*hOm-dOt-rOy%oi!Y%oi!j%oi~P'ROx,QOy%oi!Y%oi!j%oi~O!Z#]O%q*lO!Y!ka~OT&QOm-dOt-rO#^$si$j$si$m$si%V$si~P'ROx,SO#^$si$j$si$m$si%V$si~O%QVO#^%}a$j%}a$m%}ae%}a~Ox,VO#^%}a$j%}a$m%}ae%}a~Oe,YO~Ol$bix$bi~P$_OT)TO~P'ROT)TOl&Qq~P'ROr,]OP#dyT#dyd#dyf#dym#dyq#dyt#dy}#dy!O#dy!R#dy!S#dy!V#dy!Z#dy!f#dy!m#dy!n#dy!o#dy!v#dy!x#dy!z#dy!|#dy#O#dy#S#dy#U#dy#X#dy#Y#dy#[#dy#c#dy#f#dy#j#dy#l#dy#q#dy#t#dy$g#dy$j#dy$z#dy${#dy%P#dy%Q#dy%f#dy%g#dy%j#dy%m#dy%s#dy%v#dy%x#dy$i#dy$m#dy~OPhOTeOmtOq!SOtuO}vO!O!PO!R!VO!S!UO!vxO!xyO!zzO!|{O#O|O#S}O#U!OO#X!QO#Y!QO#[!RO#c!TO#f!WO#j!XO#l!YO#q!ZO#tlO$i,aO$m,aO~P'RO#h,bOP#eyT#eyd#eyf#eym#eyq#eyt#ey}#ey!O#ey!R#ey!S#ey!V#ey!Z#ey!f#ey!m#ey!n#ey!o#ey!v#ey!x#ey!z#ey!|#ey#O#ey#S#ey#U#ey#X#ey#Y#ey#[#ey#c#ey#f#ey#j#ey#l#ey#q#ey#t#ey$g#ey$j#ey$z#ey${#ey%P#ey%Q#ey%f#ey%g#ey%j#ey%m#ey%s#ey%v#ey%x#ey$i#ey$m#ey~Om-dOt-rOy&Rq~P'ROx,fOy&Rq~O%V+eOe&Tax&Ta~OT)jO_)kO$|)lO%QVOe&Sa~Ox,jOe&Sa~OT${O_${Om-dOt-rO~P'ROm-dOt-rOy,lOx#|i!U#|i~P'ROm-dOt-rOx#|i!U#|i~P'ROy,lOx#|i!U#|i~Om-dOt-rOy)yO~P'ROm-dOt-rOy)yO!U%dq~P'ROx,oO!U%dq~Om-dOt-rOx,oO!U%dq~P'ROq,rO!R%bO!S%aOe%Zq!U%Zq!Y%Zqx%Zq~P!,iO_*dOm-dOt-rO!Y%`y~P'ROx#zi!Y#zi~P$_O_*dOm-dOt-rO~P'ROT*hOm-dOt-rO~P'ROT*hOm-dOt-rOy%oq!Y%oq!j%oq~P'ROT&QOm-dOt-rO#^$sq$j$sq$m$sq%V$sq~P'RO#V,vOx$]a#^$]a$j$]a$m$]ae$]a~O%QVO#^%}i$j%}i$m%}ie%}i~Ox,xO#^%}i$j%}i$m%}ie%}i~Or,{OP#d!RT#d!Rd#d!Rf#d!Rm#d!Rq#d!Rt#d!R}#d!R!O#d!R!R#d!R!S#d!R!V#d!R!Z#d!R!f#d!R!m#d!R!n#d!R!o#d!R!v#d!R!x#d!R!z#d!R!|#d!R#O#d!R#S#d!R#U#d!R#X#d!R#Y#d!R#[#d!R#c#d!R#f#d!R#j#d!R#l#d!R#q#d!R#t#d!R$g#d!R$j#d!R$z#d!R${#d!R%P#d!R%Q#d!R%f#d!R%g#d!R%j#d!R%m#d!R%s#d!R%v#d!R%x#d!R$i#d!R$m#d!R~Om-dOt-rOy&Ry~P'ROT)jO_)kO$|)lO%QVOe&Si~Om-dOt-rOx#|q!U#|q~P'ROy-ROx#|q!U#|q~Om-dOt-rOy)yO!U%dy~P'ROx-SO!U%dy~Om-dOt-WO~P'ROq,rO!R%bO!S%aOe%Zy!U%Zy!Y%Zyx%Zy~P!,iO%QVO#^%}q$j%}q$m%}qe%}q~Ox-[O#^%}q$j%}q$m%}qe%}q~OT)jO_)kO$|)lO%QVO~Om-dOt-rOx#|y!U#|y~P'ROm-dOt-rOy)yO!U%d!R~P'ROx-_O!U%d!R~Oe%^Xq%^X!R%^X!S%^X!U%^X!Y%^Xx%^X~P!,iOq,rO!R%bO!S%aOe%]a!U%]a!Y%]ax%]a~O%QVO#^%}y$j%}y$m%}ye%}y~Om-dOt-rOy)yO!U%d!Z~P'ROy-bO~Ox*pO#^$sa$j$sa$m$sa%V$sa~P$_OT&QOm-dOt-rO~P'ROl-iO~Om-iO~P'ROy-jO~Or-kO~P!,iO%g%j%v%x%f!Z%n%t%w%y%m%s%m%Q~",
  goto: "!-g&UPPPP&VP&_)p*V*m+U+n,XP,sP&_-a-a&_PPP&_0rPPPPPP0r3bPP3bP5n5w:zPP:};];`PP&_&_PP;lPP&_&_PP&_&_&_&_&_;p<d&_P<gP<j<j@PP@e&_PPP@i@o&VP&V&VP&VP&VP&VP&VP&V&V&VP&VPP&VPP&VP@uP@|ASP@|P@|@|PPP@|PB{PCUC[CbB{P@|ChPCoCuC{DXDkDqD{EREoEuE{FRF]FcFiFoFuF{G_GiGoGuG{HVH]HcHiHoHyIPIZIaPPPPPPPPPIjIrI{JVJbPPPPPPPPPPPPNw! a!%o!({PP!)T!)c!)l!*b!*X!*k!*q!*t!*w!*z!+S!+pPPPPPPPPPP!+s!+vPPPPPPPPP!+|!,Y!,f!,l!,u!,x!-O!-U!-[!-_]iOr#m$m)]+Z'odOSXYZehrstvx|}!R!S!T!U!X!c!d!e!f!g!h!i!k!o!p!q!s!t!z!}#R#S#]#j#m$O$P$R$T$W$h$j$k$m${%Q%X%[%^%a%e%j%l%v&O&Q&]&a&j&l&m&t&x&{'S'V'a'b'e'g'h'l'q's'w'{(Q(R(X([(c(e(m(p(|)P)T)U)Y)])f)p)v)y)z)}*T*U*W*Y*]*^*a*d*h*i*p*r*s*z+S+T+Z+b+c+f+m+n+o+q+r+u+w+y+{+},P,Q,S,f,h,l,o,r-R-S-_-b-d-e-f-g-i-j-k-l-m-o-sw!cP#i#v$X$g%c%h%n%o&b&z(d(o)S*R*[+R+|-hy!dP#i#v$X$g$s%c%h%n%o&b&z(d(o)S*R*[+R+|-h{!eP#i#v$X$g$s$t%c%h%n%o&b&z(d(o)S*R*[+R+|-h}!fP#i#v$X$g$s$t$u%c%h%n%o&b&z(d(o)S*R*[+R+|-h!P!gP#i#v$X$g$s$t$u$v%c%h%n%o&b&z(d(o)S*R*[+R+|-h!R!hP#i#v$X$g$s$t$u$v$w%c%h%n%o&b&z(d(o)S*R*[+R+|-h!V!hP!n#i#v$X$g$s$t$u$v$w$x%c%h%n%o&b&z(d(o)S*R*[+R+|-h'oSOSXYZehrstvx|}!R!S!T!U!X!c!d!e!f!g!h!i!k!o!p!q!s!t!z!}#R#S#]#j#m$O$P$R$T$W$h$j$k$m${%Q%X%[%^%a%e%j%l%v&O&Q&]&a&j&l&m&t&x&{'S'V'a'b'e'g'h'l'q's'w'{(Q(R(X([(c(e(m(p(|)P)T)U)Y)])f)p)v)y)z)}*T*U*W*Y*]*^*a*d*h*i*p*r*s*z+S+T+Z+b+c+f+m+n+o+q+r+u+w+y+{+},P,Q,S,f,h,l,o,r-R-S-_-b-d-e-f-g-i-j-k-l-m-o-s&ZUOXYZhrtv|}!R!S!T!X!i!k!o!p!q!s!t#]#j#m$P$R$T$W$k$m${%Q%X%[%^%e%j%l%v&O&]&a&l&m&t&{'S'V'a'b'e'g'h'l's'{(R(X([(c(e(m(|)P)Y)])f)p)v)y)z)}*T*U*W*Y*]*^*a*h*i*p*s*z+Z+b+c+f+m+n+o+q+r+u+w+y+{+},P,Q,S,f,h,l,o,r-R-S-_-b-d-e-f-g-i-j-k-l-o-s%eWOXYZhrv|}!R!S!T!X!i!k#]#j#m$P$R$T$W$k$m${%Q%[%^%e%j%l%v&O&]&a&l&m&t&{'S'V'a'b'e'g'h'l's'{(R(X([(c(e(m(|)P)Y)])f)p)v)y)z)}*T*W*Y*]*^*a*h*i*p*s*z+Z+b+c+f+m+n+o+q+r+u+y+{+},P,Q,S,f,h,l,o-R-S-_-j-k-lQ#|uQ-`-WR-p-r'fdOSXYZehrstvx|}!R!S!T!U!X!c!d!e!f!g!h!k!o!p!q!s!t!z!}#R#S#]#j#m$O$P$R$T$W$h$j$k$m${%Q%X%[%^%a%e%j%l%v&O&Q&]&a&j&l&m&t&x&{'S'V'a'e'g'h'l'q's'w'{(Q(R(X([(c(e(m(p(|)P)T)U)Y)])f)p)y)z)}*T*U*W*Y*]*^*a*d*h*i*p*r*s*z+S+T+Z+b+c+f+n+o+q+r+u+w+y+{+},P,Q,S,f,h,l,o,r-R-S-_-b-d-e-f-g-i-j-k-l-m-o-sW#pl!O!P$_W#xu&_-W-rQ$a!QQ$q!YQ$r!ZW$z!i'b)v+mS&^#y#zQ'O$lQ(f&WQ(t&nU(u&p(v(wU(x&r(y*yQ)h'XW)i'Z+i,j-PS+h)j)kY,U*t,V,w,x-[Q,X*vQ,c+_Q,e+aR-Z,vR&]#xi!wXY!S!T%^%e's'{)P*T*W*YR%[!vQ!{XQ%w#]Q&f$TR&i$WT-V,r-b!U!jP!n#i#v$X$g$s$t$u$v$w$x%c%h%n%o&b&z(d(o)S*R*[+R+|-hQ&Z#qR'^$rR'a$zR%T!m'ncOSXYZehrstvx|}!R!S!T!U!X!c!d!e!f!g!h!i!k!o!p!q!s!t!z!}#R#S#]#j#m$O$P$R$T$W$h$j$k$m${%Q%X%[%^%a%e%j%l%v&O&Q&]&a&j&l&m&t&x&{'S'V'a'b'e'g'h'l'q's'w'{(Q(R(X([(c(e(m(p(|)P)T)U)Y)])f)p)v)y)z)}*T*U*W*Y*]*^*a*d*h*i*p*r*s*z+S+T+Z+b+c+f+m+n+o+q+r+u+w+y+{+},P,Q,S,f,h,l,o,r-R-S-_-b-d-e-f-g-i-j-k-l-m-o-sT#gc#hS#^_#_S#a`#bS#ca#dS#eb#fT*l(_*mT(`%w(bQ$VwR+g)iX$Tw$U$V&hZkOr$m)]+ZXoOr)]+ZQ$n!WQ&v$eQ&w$fQ'Y$pQ']$rQ)Z&}Q)a'SQ)c'TQ)d'UQ)q'[Q)s'^Q*})PQ+P)QQ+Q)RQ+U)XS+W)[)rQ+[)_Q+])`Q+^)bQ,Z*|Q,[+OQ,^+VQ,_+XQ,d+`Q,z,]Q,|,bQ,},cR-],{WoOr)]+ZR#snQ'[$qR)['OQ+f)iR,h+gQ)r'[R+X)[ZmOnr)]+ZQrOR#urQ&`#{R(k&`S%k#Q#}S(S%k(VT(V%n&bQ%_!yQ%f!|W't%_%f'y'}Q'y%cR'}%hQ&k$XR(q&kQ(Y%oQ*_(TT*e(Y*_Q'c$|R)w'cS'f%P%QY){'f)|+s,p-TU)|'g'h'iU+s)}*O*PS,p+t+uR-T,qQ#X]R%r#XQ#[^R%t#[Q#__R%x#_Q(]%uS*j(]*kR*k(^Q*m(_R,R*mQ#b`R%z#bQ#daR%{#dQ#fbR%|#fQ#hcR%}#hQ#kfQ&P#iW&S#k&P(n*qQ(n&eR*q-hQ$UwS&g$U&hR&h$VQ&u$cR(}&uQ&X#pR(g&XQ$_!PR&o$_Q*u(uS,W*u,yR,y,XQ&s$aR(z&sQ#njR&U#nQ+Z)]R,`+ZQ)O&vR*{)OQ&y$gS)V&y)WR)W&zQ'R$nR)^'RQ'W$oS)g'W+dR+d)hQ+j)mR,k+jWnOr)]+ZR#rnSqOrT+Y)]+ZWpOr)]+ZR'P$mYjOr$m)]+ZR&T#m[wOr#m$m)]+ZR&f$T&YPOXYZhrtv|}!R!S!T!X!i!k!o!p!q!s!t#]#j#m$P$R$T$W$k$m${%Q%X%[%^%e%j%l%v&O&]&a&l&m&t&{'S'V'a'b'e'g'h'l's'{(R(X([(c(e(m(|)P)Y)])f)p)v)y)z)}*T*U*W*Y*]*^*a*h*i*p*s*z+Z+b+c+f+m+n+o+q+r+u+w+y+{+},P,Q,S,f,h,l,o,r-R-S-_-b-d-e-f-g-i-j-k-l-o-sQ!nSQ#ieQ#vsU$Xx%a'wS$g!U$jQ$s!cQ$t!dQ$u!eQ$v!fQ$w!gQ$x!hQ%c!zQ%h!}Q%n#RQ%o#SQ&b$OQ&z$hQ(d&QU(o&j(p*rW)S&x)U+S+TQ*R'qQ*[(QQ+R)TQ+|*dR-h-mQ!yXQ!|YQ$e!SQ$f!T^'p%^%e's'{*T*W*YR+O)P[fOr#m$m)]+Zh!vXY!S!T%^%e's'{)P*T*W*YQ#QZQ#lhS#}v|Q$[}W$c!R$W&{)YS$o!X$kW$y!i'b)v+mQ%P!kQ%u#]`&R#j&O(c(e(m*p,S-lQ&c$PQ&d$RQ&e$TQ'_${Q'i%QQ'o%[W(P%j(R*]*aQ(T%lQ(^%vQ(i&]S(l&a-jQ(r&lQ(s&mU({&t(|*zQ)b'SY)e'V)f+b+c,fQ)t'a^)x'e)z+q+r,o-S-_Q*O'gQ*P'hS*Q'l-kW*c(X*^+y+}W*g([*i,P,QQ+l)pQ+p)yQ+t)}Q,O*hQ,T*sQ,g+fQ,m+nQ,n+oQ,q+uQ,u+{Q-O,hQ-Q,lR-^-RhTOr#j#m$m&O&a'l(c(e)]+Z$z!uXYZhv|}!R!S!T!X!i!k#]$P$R$T$W$k${%Q%[%^%e%j%l%v&]&l&m&t&{'S'V'a'b'e'g'h's'{(R(X([(m(|)P)Y)f)p)v)y)z)}*T*W*Y*]*^*a*h*i*p*s*z+b+c+f+m+n+o+q+r+u+y+{+},P,Q,S,f,h,l,o-R-S-_-j-k-lQ#wtW%U!o!s-e-oQ%V!pQ%W!qQ%Y!tQ%d-dS'k%X-iQ'm-fQ'n-gQ+v*UQ,t+wS-U,r-bR-q-sU#{u-W-rR(j&_[gOr#m$m)]+ZX!xX#]$T$WQ#VZQ$QvR$Z|Q%`!yQ%g!|Q%m#QQ'_$yQ'z%cQ(O%hQ(W%nQ(Z%oQ*`(TQ,s+vQ-Y,tR-a-XQ$YxQ'v%aR*V'wQ-X,rR-c-bR#PYR#UZR%O!iQ$|!iV)u'b)v+m!V!lP!n#i#v$X$g$s$t$u$v$w$x%c%h%n%o&b&z(d(o)S*R*[+R+|-hR%R!kR%w#]Q(a%wR*o(bQ$d!RQ&i$WQ)X&{R+V)YQ#qlQ$]!OQ$`!PR&q$_Q(t&pR*x(wQ(t&pQ*w(vR*x(wR$b!QXpOr)]+ZQ$i!UR&|$jQ$p!XR&}$kR)o'ZQ)m'ZV,i+i,j-P",
  nodeNames: " print Comment Script AssignStatement * BinaryExpression BitOp BitOp BitOp BitOp ArithOp ArithOp @ ArithOp ** UnaryExpression ArithOp BitOp AwaitExpression await ) ( ParenthesizedExpression BinaryExpression or and CompareOp in not is UnaryExpression ConditionalExpression if else LambdaExpression lambda ParamList VariableName AssignOp , : NamedExpression AssignOp YieldExpression yield from TupleExpression ComprehensionExpression async for LambdaExpression ] [ ArrayExpression ArrayComprehensionExpression } { DictionaryExpression DictionaryComprehensionExpression SetExpression SetComprehensionExpression CallExpression ArgList AssignOp MemberExpression . PropertyName Number String FormatString FormatReplacement FormatConversion FormatSpec ContinuedString Ellipsis None Boolean TypeDef AssignOp UpdateStatement UpdateOp ExpressionStatement DeleteStatement del PassStatement pass BreakStatement break ContinueStatement continue ReturnStatement return YieldStatement PrintStatement RaiseStatement raise ImportStatement import as ScopeStatement global nonlocal AssertStatement assert StatementGroup ; IfStatement Body elif WhileStatement while ForStatement TryStatement try except finally WithStatement with FunctionDefinition def ParamList AssignOp TypeDef ClassDefinition class DecoratedStatement Decorator At",
  maxTerm: 236,
  context: trackIndent,
  nodeProps: [
    ["group", -14,4,80,82,83,85,87,89,91,93,94,95,97,100,103,"Statement Statement",-22,6,16,19,23,38,47,48,54,55,58,59,60,61,62,65,68,69,70,74,75,76,77,"Expression",-9,105,107,110,112,113,117,119,124,126,"Statement"],
    ["openedBy", 21,"(",52,"[",56,"{"],
    ["closedBy", 22,")",53,"]",57,"}"]
  ],
  propSources: [pythonHighlighting],
  skippedNodes: [0,2],
  repeatNodeCount: 32,
  tokenData: "&JdMgR!^OX$}XY!&]Y[$}[]!&]]p$}pq!&]qr!(grs!,^st!IYtu$}uv$5[vw$7nwx$8zxy%'vyz%(|z{%*S{|%,r|}%.O}!O%/U!O!P%1k!P!Q%<q!Q!R%?a!R![%Cc![!]%N_!]!^&!q!^!_&#w!_!`&&g!`!a&'s!a!b$}!b!c&*`!c!d&+n!d!e&-`!e!h&+n!h!i&7[!i!t&+n!t!u&@j!u!w&+n!w!x&5j!x!}&+n!}#O&Bt#O#P!'u#P#Q&Cz#Q#R&EQ#R#S&+n#S#T$}#T#U&+n#U#V&-`#V#Y&+n#Y#Z&7[#Z#f&+n#f#g&@j#g#i&+n#i#j&5j#j#o&+n#o#p&F^#p#q&GS#q#r&H`#r#s&I^#s$g$}$g~&+n<r%`Z%q7[%hS%kW%n`%tp%w!b%y#tOr$}rs&Rsw$}wxHsx#O$}#O#P!$R#P#o$}#o#p!%i#p#q$}#q#r!$g#r~$}<Q&^Z%q7[%hS%n`%w!bOr'PrsFisw'Pwx(Rx#O'P#O#PAe#P#o'P#o#pEu#p#q'P#q#rAy#r~'P<Q'`Z%q7[%hS%kW%n`%w!b%y#tOr'Prs&Rsw'Pwx(Rx#O'P#O#PAe#P#o'P#o#pEu#p#q'P#q#rAy#r~'P;p([Z%q7[%kW%y#tOr(}rs)}sw(}wx={x#O(}#O#P2]#P#o(}#o#p:X#p#q(}#q#r2q#r~(};p)[Z%q7[%hS%kW%w!b%y#tOr(}rs)}sw(}wx(Rx#O(}#O#P2]#P#o(}#o#p:X#p#q(}#q#r2q#r~(};p*WZ%q7[%hS%w!bOr(}rs*ysw(}wx(Rx#O(}#O#P2]#P#o(}#o#p:X#p#q(}#q#r2q#r~(};p+SZ%q7[%hS%w!bOr(}rs+usw(}wx(Rx#O(}#O#P2]#P#o(}#o#p:X#p#q(}#q#r2q#r~(}8r,OX%q7[%hS%w!bOw+uwx,kx#O+u#O#P.]#P#o+u#o#p0d#p#q+u#q#r.q#r~+u8r,pX%q7[Ow+uwx-]x#O+u#O#P.]#P#o+u#o#p0d#p#q+u#q#r.q#r~+u8r-bX%q7[Ow+uwx-}x#O+u#O#P.]#P#o+u#o#p0d#p#q+u#q#r.q#r~+u7[.SR%q7[O#o-}#p#q-}#r~-}8r.bT%q7[O#o+u#o#p.q#p#q+u#q#r.q#r~+u!f.xV%hS%w!bOw.qwx/_x#O.q#O#P0^#P#o.q#o#p0d#p~.q!f/bVOw.qwx/wx#O.q#O#P0^#P#o.q#o#p0d#p~.q!f/zUOw.qx#O.q#O#P0^#P#o.q#o#p0d#p~.q!f0aPO~.q!f0iV%hSOw1Owx1dx#O1O#O#P2V#P#o1O#o#p.q#p~1OS1TT%hSOw1Owx1dx#O1O#O#P2V#P~1OS1gTOw1Owx1vx#O1O#O#P2V#P~1OS1ySOw1Ox#O1O#O#P2V#P~1OS2YPO~1O;p2bT%q7[O#o(}#o#p2q#p#q(}#q#r2q#r~(}%d2|X%hS%kW%w!b%y#tOr2qrs3isw2qwx5Px#O2q#O#P:R#P#o2q#o#p:X#p~2q%d3pX%hS%w!bOr2qrs4]sw2qwx5Px#O2q#O#P:R#P#o2q#o#p:X#p~2q%d4dX%hS%w!bOr2qrs.qsw2qwx5Px#O2q#O#P:R#P#o2q#o#p:X#p~2q%d5WX%kW%y#tOr2qrs3isw2qwx5sx#O2q#O#P:R#P#o2q#o#p:X#p~2q%d5zX%kW%y#tOr2qrs3isw2qwx6gx#O2q#O#P:R#P#o2q#o#p:X#p~2q#|6nV%kW%y#tOr6grs7Ts#O6g#O#P8S#P#o6g#o#p8Y#p~6g#|7WVOr6grs7ms#O6g#O#P8S#P#o6g#o#p8Y#p~6g#|7pUOr6gs#O6g#O#P8S#P#o6g#o#p8Y#p~6g#|8VPO~6g#|8_V%kWOr8trs9Ys#O8t#O#P9{#P#o8t#o#p6g#p~8tW8yT%kWOr8trs9Ys#O8t#O#P9{#P~8tW9]TOr8trs9ls#O8t#O#P9{#P~8tW9oSOr8ts#O8t#O#P9{#P~8tW:OPO~8t%d:UPO~2q%d:`X%hS%kWOr:{rs;isw:{wx<ox#O:{#O#P=u#P#o:{#o#p2q#p~:{[;SV%hS%kWOr:{rs;isw:{wx<ox#O:{#O#P=u#P~:{[;nV%hSOr:{rs<Tsw:{wx<ox#O:{#O#P=u#P~:{[<YV%hSOr:{rs1Osw:{wx<ox#O:{#O#P=u#P~:{[<tV%kWOr:{rs;isw:{wx=Zx#O:{#O#P=u#P~:{[=`V%kWOr:{rs;isw:{wx8tx#O:{#O#P=u#P~:{[=xPO~:{;p>UZ%q7[%kW%y#tOr(}rs)}sw(}wx>wx#O(}#O#P2]#P#o(}#o#p:X#p#q(}#q#r2q#r~(}:Y?QX%q7[%kW%y#tOr>wrs?ms#O>w#O#PAP#P#o>w#o#p8Y#p#q>w#q#r6g#r~>w:Y?rX%q7[Or>wrs@_s#O>w#O#PAP#P#o>w#o#p8Y#p#q>w#q#r6g#r~>w:Y@dX%q7[Or>wrs-}s#O>w#O#PAP#P#o>w#o#p8Y#p#q>w#q#r6g#r~>w:YAUT%q7[O#o>w#o#p6g#p#q>w#q#r6g#r~>w<QAjT%q7[O#o'P#o#pAy#p#q'P#q#rAy#r~'P%tBWX%hS%kW%n`%w!b%y#tOrAyrsBsswAywx5Px#OAy#O#PEo#P#oAy#o#pEu#p~Ay%tB|X%hS%n`%w!bOrAyrsCiswAywx5Px#OAy#O#PEo#P#oAy#o#pEu#p~Ay%tCrX%hS%n`%w!bOrAyrsD_swAywx5Px#OAy#O#PEo#P#oAy#o#pEu#p~Ay!vDhV%hS%n`%w!bOwD_wx/_x#OD_#O#PD}#P#oD_#o#pET#p~D_!vEQPO~D_!vEYV%hSOw1Owx1dx#O1O#O#P2V#P#o1O#o#pD_#p~1O%tErPO~Ay%tE|X%hS%kWOr:{rs;isw:{wx<ox#O:{#O#P=u#P#o:{#o#pAy#p~:{<QFtZ%q7[%hS%n`%w!bOr'PrsGgsw'Pwx(Rx#O'P#O#PAe#P#o'P#o#pEu#p#q'P#q#rAy#r~'P9SGrX%q7[%hS%n`%w!bOwGgwx,kx#OGg#O#PH_#P#oGg#o#pET#p#qGg#q#rD_#r~Gg9SHdT%q7[O#oGg#o#pD_#p#qGg#q#rD_#r~Gg<bIOZ%q7[%kW%tp%y#tOrIqrs)}swIqwx! wx#OIq#O#PJs#P#oIq#o#p! T#p#qIq#q#rKX#r~Iq<bJQZ%q7[%hS%kW%tp%w!b%y#tOrIqrs)}swIqwxHsx#OIq#O#PJs#P#oIq#o#p! T#p#qIq#q#rKX#r~Iq<bJxT%q7[O#oIq#o#pKX#p#qIq#q#rKX#r~Iq&UKfX%hS%kW%tp%w!b%y#tOrKXrs3iswKXwxLRx#OKX#O#PN}#P#oKX#o#p! T#p~KX&UL[X%kW%tp%y#tOrKXrs3iswKXwxLwx#OKX#O#PN}#P#oKX#o#p! T#p~KX&UMQX%kW%tp%y#tOrKXrs3iswKXwxMmx#OKX#O#PN}#P#oKX#o#p! T#p~KX$nMvV%kW%tp%y#tOrMmrs7Ts#OMm#O#PN]#P#oMm#o#pNc#p~Mm$nN`PO~Mm$nNhV%kWOr8trs9Ys#O8t#O#P9{#P#o8t#o#pMm#p~8t&U! QPO~KX&U! [X%hS%kWOr:{rs;isw:{wx<ox#O:{#O#P=u#P#o:{#o#pKX#p~:{<b!!SZ%q7[%kW%tp%y#tOrIqrs)}swIqwx!!ux#OIq#O#PJs#P#oIq#o#p! T#p#qIq#q#rKX#r~Iq:z!#QX%q7[%kW%tp%y#tOr!!urs?ms#O!!u#O#P!#m#P#o!!u#o#pNc#p#q!!u#q#rMm#r~!!u:z!#rT%q7[O#o!!u#o#pMm#p#q!!u#q#rMm#r~!!u<r!$WT%q7[O#o$}#o#p!$g#p#q$}#q#r!$g#r~$}&f!$vX%hS%kW%n`%tp%w!b%y#tOr!$grsBssw!$gwxLRx#O!$g#O#P!%c#P#o!$g#o#p!%i#p~!$g&f!%fPO~!$g&f!%pX%hS%kWOr:{rs;isw:{wx<ox#O:{#O#P=u#P#o:{#o#p!$g#p~:{Mg!&pa%q7[%hS%kW$o1s%n`%tp%w!b%y#tOX$}XY!&]Y[$}[]!&]]p$}pq!&]qr$}rs&Rsw$}wxHsx#O$}#O#P!'u#P#o$}#o#p!%i#p#q$}#q#r!$g#r~$}Mg!'zX%q7[OY$}YZ!&]Z]$}]^!&]^#o$}#o#p!$g#p#q$}#q#r!$g#r~$}<u!(xb%q7[%hS%kW%n`%tp%w!b%y#tOr$}rs&Rsw$}wxHsx!_$}!_!`!*Q!`#O$}#O#P!$R#P#T$}#T#U!+W#U#f$}#f#g!+W#g#h!+W#h#o$}#o#p!%i#p#q$}#q#r!$g#r~$}<u!*eZkR%q7[%hS%kW%n`%tp%w!b%y#tOr$}rs&Rsw$}wxHsx#O$}#O#P!$R#P#o$}#o#p!%i#p#q$}#q#r!$g#r~$}<u!+kZ!jR%q7[%hS%kW%n`%tp%w!b%y#tOr$}rs&Rsw$}wxHsx#O$}#O#P!$R#P#o$}#o#p!%i#p#q$}#q#r!$g#r~$}G{!,m_%up%q7[%hS%f,X%n`%w!bOY!-lYZ'PZ]!-l]^'P^r!-lrs!G^sw!-lwx!/|x#O!-l#O#P!Cp#P#o!-l#o#p!F[#p#q!-l#q#r!DU#r~!-lGZ!-}_%q7[%hS%kW%f,X%n`%w!b%y#tOY!-lYZ'PZ]!-l]^'P^r!-lrs!.|sw!-lwx!/|x#O!-l#O#P!Cp#P#o!-l#o#p!F[#p#q!-l#q#r!DU#r~!-lGZ!/ZZ%q7[%hS%f,X%n`%w!bOr'PrsFisw'Pwx(Rx#O'P#O#PAe#P#o'P#o#pEu#p#q'P#q#rAy#r~'PFy!0X_%q7[%kW%f,X%y#tOY!1WYZ(}Z]!1W]^(}^r!1Wrs!2fsw!1Wwx!@Yx#O!1W#O#P!3d#P#o!1W#o#p!;t#p#q!1W#q#r!3x#r~!1WFy!1g_%q7[%hS%kW%f,X%w!b%y#tOY!1WYZ(}Z]!1W]^(}^r!1Wrs!2fsw!1Wwx!/|x#O!1W#O#P!3d#P#o!1W#o#p!;t#p#q!1W#q#r!3x#r~!1WFy!2qZ%q7[%hS%f,X%w!bOr(}rs*ysw(}wx(Rx#O(}#O#P2]#P#o(}#o#p:X#p#q(}#q#r2q#r~(}Fy!3iT%q7[O#o!1W#o#p!3x#p#q!1W#q#r!3x#r~!1W0m!4V]%hS%kW%f,X%w!b%y#tOY!3xYZ2qZ]!3x]^2q^r!3xrs!5Osw!3xwx!5tx#O!3x#O#P!;n#P#o!3x#o#p!;t#p~!3x0m!5XX%hS%f,X%w!bOr2qrs4]sw2qwx5Px#O2q#O#P:R#P#o2q#o#p:X#p~2q0m!5}]%kW%f,X%y#tOY!3xYZ2qZ]!3x]^2q^r!3xrs!5Osw!3xwx!6vx#O!3x#O#P!;n#P#o!3x#o#p!;t#p~!3x0m!7P]%kW%f,X%y#tOY!3xYZ2qZ]!3x]^2q^r!3xrs!5Osw!3xwx!7xx#O!3x#O#P!;n#P#o!3x#o#p!;t#p~!3x/V!8RZ%kW%f,X%y#tOY!7xYZ6gZ]!7x]^6g^r!7xrs!8ts#O!7x#O#P!9`#P#o!7x#o#p!9f#p~!7x/V!8yV%f,XOr6grs7ms#O6g#O#P8S#P#o6g#o#p8Y#p~6g/V!9cPO~!7x/V!9mZ%kW%f,XOY!:`YZ8tZ]!:`]^8t^r!:`rs!;Ss#O!:`#O#P!;h#P#o!:`#o#p!7x#p~!:`,a!:gX%kW%f,XOY!:`YZ8tZ]!:`]^8t^r!:`rs!;Ss#O!:`#O#P!;h#P~!:`,a!;XT%f,XOr8trs9ls#O8t#O#P9{#P~8t,a!;kPO~!:`0m!;qPO~!3x0m!;}]%hS%kW%f,XOY!<vYZ:{Z]!<v]^:{^r!<vrs!=rsw!<vwx!>`x#O!<v#O#P!@S#P#o!<v#o#p!3x#p~!<v,e!=PZ%hS%kW%f,XOY!<vYZ:{Z]!<v]^:{^r!<vrs!=rsw!<vwx!>`x#O!<v#O#P!@S#P~!<v,e!=yV%hS%f,XOr:{rs<Tsw:{wx<ox#O:{#O#P=u#P~:{,e!>gZ%kW%f,XOY!<vYZ:{Z]!<v]^:{^r!<vrs!=rsw!<vwx!?Yx#O!<v#O#P!@S#P~!<v,e!?aZ%kW%f,XOY!<vYZ:{Z]!<v]^:{^r!<vrs!=rsw!<vwx!:`x#O!<v#O#P!@S#P~!<v,e!@VPO~!<vFy!@e_%q7[%kW%f,X%y#tOY!1WYZ(}Z]!1W]^(}^r!1Wrs!2fsw!1Wwx!Adx#O!1W#O#P!3d#P#o!1W#o#p!;t#p#q!1W#q#r!3x#r~!1WEc!Ao]%q7[%kW%f,X%y#tOY!AdYZ>wZ]!Ad]^>w^r!Adrs!Bhs#O!Ad#O#P!C[#P#o!Ad#o#p!9f#p#q!Ad#q#r!7x#r~!AdEc!BoX%q7[%f,XOr>wrs@_s#O>w#O#PAP#P#o>w#o#p8Y#p#q>w#q#r6g#r~>wEc!CaT%q7[O#o!Ad#o#p!7x#p#q!Ad#q#r!7x#r~!AdGZ!CuT%q7[O#o!-l#o#p!DU#p#q!-l#q#r!DU#r~!-l0}!De]%hS%kW%f,X%n`%w!b%y#tOY!DUYZAyZ]!DU]^Ay^r!DUrs!E^sw!DUwx!5tx#O!DU#O#P!FU#P#o!DU#o#p!F[#p~!DU0}!EiX%hS%f,X%n`%w!bOrAyrsCiswAywx5Px#OAy#O#PEo#P#oAy#o#pEu#p~Ay0}!FXPO~!DU0}!Fe]%hS%kW%f,XOY!<vYZ:{Z]!<v]^:{^r!<vrs!=rsw!<vwx!>`x#O!<v#O#P!@S#P#o!<v#o#p!DU#p~!<vGZ!GkZ%q7[%hS%f,X%n`%w!bOr'Prs!H^sw'Pwx(Rx#O'P#O#PAe#P#o'P#o#pEu#p#q'P#q#rAy#r~'PGZ!HmX%l#|%q7[%hS%j,X%n`%w!bOwGgwx,kx#OGg#O#PH_#P#oGg#o#pET#p#qGg#q#rD_#r~GgMg!Im_Q1s%q7[%hS%kW%n`%tp%w!b%y#tOY!IYYZ$}Z]!IY]^$}^r!IYrs!Jlsw!IYwx$$[x#O!IY#O#P$1v#P#o!IY#o#p$4Y#p#q!IY#q#r$2j#r~!IYLu!Jy_Q1s%q7[%hS%n`%w!bOY!KxYZ'PZ]!Kx]^'P^r!Kxrs$ Usw!Kxwx!MYx#O!Kx#O#P#G^#P#o!Kx#o#p#NS#p#q!Kx#q#r#HQ#r~!KxLu!LZ_Q1s%q7[%hS%kW%n`%w!b%y#tOY!KxYZ'PZ]!Kx]^'P^r!Kxrs!Jlsw!Kxwx!MYx#O!Kx#O#P#G^#P#o!Kx#o#p#NS#p#q!Kx#q#r#HQ#r~!KxLe!Me_Q1s%q7[%kW%y#tOY!NdYZ(}Z]!Nd]^(}^r!Ndrs# rsw!Ndwx#B[x#O!Nd#O#P#/f#P#o!Nd#o#p#<b#p#q!Nd#q#r#0Y#r~!NdLe!Ns_Q1s%q7[%hS%kW%w!b%y#tOY!NdYZ(}Z]!Nd]^(}^r!Ndrs# rsw!Ndwx!MYx#O!Nd#O#P#/f#P#o!Nd#o#p#<b#p#q!Nd#q#r#0Y#r~!NdLe# }_Q1s%q7[%hS%w!bOY!NdYZ(}Z]!Nd]^(}^r!Ndrs#!|sw!Ndwx!MYx#O!Nd#O#P#/f#P#o!Nd#o#p#<b#p#q!Nd#q#r#0Y#r~!NdLe##X_Q1s%q7[%hS%w!bOY!NdYZ(}Z]!Nd]^(}^r!Ndrs#$Wsw!Ndwx!MYx#O!Nd#O#P#/f#P#o!Nd#o#p#<b#p#q!Nd#q#r#0Y#r~!NdIg#$c]Q1s%q7[%hS%w!bOY#$WYZ+uZ]#$W]^+u^w#$Wwx#%[x#O#$W#O#P#(^#P#o#$W#o#p#,Q#p#q#$W#q#r#)Q#r~#$WIg#%c]Q1s%q7[OY#$WYZ+uZ]#$W]^+u^w#$Wwx#&[x#O#$W#O#P#(^#P#o#$W#o#p#,Q#p#q#$W#q#r#)Q#r~#$WIg#&c]Q1s%q7[OY#$WYZ+uZ]#$W]^+u^w#$Wwx#'[x#O#$W#O#P#(^#P#o#$W#o#p#,Q#p#q#$W#q#r#)Q#r~#$WHP#'cXQ1s%q7[OY#'[YZ-}Z]#'[]^-}^#o#'[#o#p#(O#p#q#'[#q#r#(O#r~#'[1s#(TRQ1sOY#(OZ]#(O^~#(OIg#(eXQ1s%q7[OY#$WYZ+uZ]#$W]^+u^#o#$W#o#p#)Q#p#q#$W#q#r#)Q#r~#$W3Z#)ZZQ1s%hS%w!bOY#)QYZ.qZ]#)Q]^.q^w#)Qwx#)|x#O#)Q#O#P#+l#P#o#)Q#o#p#,Q#p~#)Q3Z#*RZQ1sOY#)QYZ.qZ]#)Q]^.q^w#)Qwx#*tx#O#)Q#O#P#+l#P#o#)Q#o#p#,Q#p~#)Q3Z#*yZQ1sOY#)QYZ.qZ]#)Q]^.q^w#)Qwx#(Ox#O#)Q#O#P#+l#P#o#)Q#o#p#,Q#p~#)Q3Z#+qTQ1sOY#)QYZ.qZ]#)Q]^.q^~#)Q3Z#,XZQ1s%hSOY#,zYZ1OZ]#,z]^1O^w#,zwx#-nx#O#,z#O#P#/Q#P#o#,z#o#p#)Q#p~#,z1w#-RXQ1s%hSOY#,zYZ1OZ]#,z]^1O^w#,zwx#-nx#O#,z#O#P#/Q#P~#,z1w#-sXQ1sOY#,zYZ1OZ]#,z]^1O^w#,zwx#.`x#O#,z#O#P#/Q#P~#,z1w#.eXQ1sOY#,zYZ1OZ]#,z]^1O^w#,zwx#(Ox#O#,z#O#P#/Q#P~#,z1w#/VTQ1sOY#,zYZ1OZ]#,z]^1O^~#,zLe#/mXQ1s%q7[OY!NdYZ(}Z]!Nd]^(}^#o!Nd#o#p#0Y#p#q!Nd#q#r#0Y#r~!Nd6X#0g]Q1s%hS%kW%w!b%y#tOY#0YYZ2qZ]#0Y]^2q^r#0Yrs#1`sw#0Ywx#3dx#O#0Y#O#P#;|#P#o#0Y#o#p#<b#p~#0Y6X#1i]Q1s%hS%w!bOY#0YYZ2qZ]#0Y]^2q^r#0Yrs#2bsw#0Ywx#3dx#O#0Y#O#P#;|#P#o#0Y#o#p#<b#p~#0Y6X#2k]Q1s%hS%w!bOY#0YYZ2qZ]#0Y]^2q^r#0Yrs#)Qsw#0Ywx#3dx#O#0Y#O#P#;|#P#o#0Y#o#p#<b#p~#0Y6X#3m]Q1s%kW%y#tOY#0YYZ2qZ]#0Y]^2q^r#0Yrs#1`sw#0Ywx#4fx#O#0Y#O#P#;|#P#o#0Y#o#p#<b#p~#0Y6X#4o]Q1s%kW%y#tOY#0YYZ2qZ]#0Y]^2q^r#0Yrs#1`sw#0Ywx#5hx#O#0Y#O#P#;|#P#o#0Y#o#p#<b#p~#0Y4q#5qZQ1s%kW%y#tOY#5hYZ6gZ]#5h]^6g^r#5hrs#6ds#O#5h#O#P#8S#P#o#5h#o#p#8h#p~#5h4q#6iZQ1sOY#5hYZ6gZ]#5h]^6g^r#5hrs#7[s#O#5h#O#P#8S#P#o#5h#o#p#8h#p~#5h4q#7aZQ1sOY#5hYZ6gZ]#5h]^6g^r#5hrs#(Os#O#5h#O#P#8S#P#o#5h#o#p#8h#p~#5h4q#8XTQ1sOY#5hYZ6gZ]#5h]^6g^~#5h4q#8oZQ1s%kWOY#9bYZ8tZ]#9b]^8t^r#9brs#:Us#O#9b#O#P#;h#P#o#9b#o#p#5h#p~#9b1{#9iXQ1s%kWOY#9bYZ8tZ]#9b]^8t^r#9brs#:Us#O#9b#O#P#;h#P~#9b1{#:ZXQ1sOY#9bYZ8tZ]#9b]^8t^r#9brs#:vs#O#9b#O#P#;h#P~#9b1{#:{XQ1sOY#9bYZ8tZ]#9b]^8t^r#9brs#(Os#O#9b#O#P#;h#P~#9b1{#;mTQ1sOY#9bYZ8tZ]#9b]^8t^~#9b6X#<RTQ1sOY#0YYZ2qZ]#0Y]^2q^~#0Y6X#<k]Q1s%hS%kWOY#=dYZ:{Z]#=d]^:{^r#=drs#>`sw#=dwx#@Sx#O#=d#O#P#Av#P#o#=d#o#p#0Y#p~#=d2P#=mZQ1s%hS%kWOY#=dYZ:{Z]#=d]^:{^r#=drs#>`sw#=dwx#@Sx#O#=d#O#P#Av#P~#=d2P#>gZQ1s%hSOY#=dYZ:{Z]#=d]^:{^r#=drs#?Ysw#=dwx#@Sx#O#=d#O#P#Av#P~#=d2P#?aZQ1s%hSOY#=dYZ:{Z]#=d]^:{^r#=drs#,zsw#=dwx#@Sx#O#=d#O#P#Av#P~#=d2P#@ZZQ1s%kWOY#=dYZ:{Z]#=d]^:{^r#=drs#>`sw#=dwx#@|x#O#=d#O#P#Av#P~#=d2P#ATZQ1s%kWOY#=dYZ:{Z]#=d]^:{^r#=drs#>`sw#=dwx#9bx#O#=d#O#P#Av#P~#=d2P#A{TQ1sOY#=dYZ:{Z]#=d]^:{^~#=dLe#Bg_Q1s%q7[%kW%y#tOY!NdYZ(}Z]!Nd]^(}^r!Ndrs# rsw!Ndwx#Cfx#O!Nd#O#P#/f#P#o!Nd#o#p#<b#p#q!Nd#q#r#0Y#r~!NdJ}#Cq]Q1s%q7[%kW%y#tOY#CfYZ>wZ]#Cf]^>w^r#Cfrs#Djs#O#Cf#O#P#Fj#P#o#Cf#o#p#8h#p#q#Cf#q#r#5h#r~#CfJ}#Dq]Q1s%q7[OY#CfYZ>wZ]#Cf]^>w^r#Cfrs#Ejs#O#Cf#O#P#Fj#P#o#Cf#o#p#8h#p#q#Cf#q#r#5h#r~#CfJ}#Eq]Q1s%q7[OY#CfYZ>wZ]#Cf]^>w^r#Cfrs#'[s#O#Cf#O#P#Fj#P#o#Cf#o#p#8h#p#q#Cf#q#r#5h#r~#CfJ}#FqXQ1s%q7[OY#CfYZ>wZ]#Cf]^>w^#o#Cf#o#p#5h#p#q#Cf#q#r#5h#r~#CfLu#GeXQ1s%q7[OY!KxYZ'PZ]!Kx]^'P^#o!Kx#o#p#HQ#p#q!Kx#q#r#HQ#r~!Kx6i#Ha]Q1s%hS%kW%n`%w!b%y#tOY#HQYZAyZ]#HQ]^Ay^r#HQrs#IYsw#HQwx#3dx#O#HQ#O#P#Mn#P#o#HQ#o#p#NS#p~#HQ6i#Ie]Q1s%hS%n`%w!bOY#HQYZAyZ]#HQ]^Ay^r#HQrs#J^sw#HQwx#3dx#O#HQ#O#P#Mn#P#o#HQ#o#p#NS#p~#HQ6i#Ji]Q1s%hS%n`%w!bOY#HQYZAyZ]#HQ]^Ay^r#HQrs#Kbsw#HQwx#3dx#O#HQ#O#P#Mn#P#o#HQ#o#p#NS#p~#HQ3k#KmZQ1s%hS%n`%w!bOY#KbYZD_Z]#Kb]^D_^w#Kbwx#)|x#O#Kb#O#P#L`#P#o#Kb#o#p#Lt#p~#Kb3k#LeTQ1sOY#KbYZD_Z]#Kb]^D_^~#Kb3k#L{ZQ1s%hSOY#,zYZ1OZ]#,z]^1O^w#,zwx#-nx#O#,z#O#P#/Q#P#o#,z#o#p#Kb#p~#,z6i#MsTQ1sOY#HQYZAyZ]#HQ]^Ay^~#HQ6i#N]]Q1s%hS%kWOY#=dYZ:{Z]#=d]^:{^r#=drs#>`sw#=dwx#@Sx#O#=d#O#P#Av#P#o#=d#o#p#HQ#p~#=dLu$ c_Q1s%q7[%hS%n`%w!bOY!KxYZ'PZ]!Kx]^'P^r!Kxrs$!bsw!Kxwx!MYx#O!Kx#O#P#G^#P#o!Kx#o#p#NS#p#q!Kx#q#r#HQ#r~!KxIw$!o]Q1s%q7[%hS%n`%w!bOY$!bYZGgZ]$!b]^Gg^w$!bwx#%[x#O$!b#O#P$#h#P#o$!b#o#p#Lt#p#q$!b#q#r#Kb#r~$!bIw$#oXQ1s%q7[OY$!bYZGgZ]$!b]^Gg^#o$!b#o#p#Kb#p#q$!b#q#r#Kb#r~$!bMV$$i_Q1s%q7[%kW%tp%y#tOY$%hYZIqZ]$%h]^Iq^r$%hrs# rsw$%hwx$.px#O$%h#O#P$&x#P#o$%h#o#p$-n#p#q$%h#q#r$'l#r~$%hMV$%y_Q1s%q7[%hS%kW%tp%w!b%y#tOY$%hYZIqZ]$%h]^Iq^r$%hrs# rsw$%hwx$$[x#O$%h#O#P$&x#P#o$%h#o#p$-n#p#q$%h#q#r$'l#r~$%hMV$'PXQ1s%q7[OY$%hYZIqZ]$%h]^Iq^#o$%h#o#p$'l#p#q$%h#q#r$'l#r~$%h6y$'{]Q1s%hS%kW%tp%w!b%y#tOY$'lYZKXZ]$'l]^KX^r$'lrs#1`sw$'lwx$(tx#O$'l#O#P$-Y#P#o$'l#o#p$-n#p~$'l6y$)P]Q1s%kW%tp%y#tOY$'lYZKXZ]$'l]^KX^r$'lrs#1`sw$'lwx$)xx#O$'l#O#P$-Y#P#o$'l#o#p$-n#p~$'l6y$*T]Q1s%kW%tp%y#tOY$'lYZKXZ]$'l]^KX^r$'lrs#1`sw$'lwx$*|x#O$'l#O#P$-Y#P#o$'l#o#p$-n#p~$'l5c$+XZQ1s%kW%tp%y#tOY$*|YZMmZ]$*|]^Mm^r$*|rs#6ds#O$*|#O#P$+z#P#o$*|#o#p$,`#p~$*|5c$,PTQ1sOY$*|YZMmZ]$*|]^Mm^~$*|5c$,gZQ1s%kWOY#9bYZ8tZ]#9b]^8t^r#9brs#:Us#O#9b#O#P#;h#P#o#9b#o#p$*|#p~#9b6y$-_TQ1sOY$'lYZKXZ]$'l]^KX^~$'l6y$-w]Q1s%hS%kWOY#=dYZ:{Z]#=d]^:{^r#=drs#>`sw#=dwx#@Sx#O#=d#O#P#Av#P#o#=d#o#p$'l#p~#=dMV$.}_Q1s%q7[%kW%tp%y#tOY$%hYZIqZ]$%h]^Iq^r$%hrs# rsw$%hwx$/|x#O$%h#O#P$&x#P#o$%h#o#p$-n#p#q$%h#q#r$'l#r~$%hKo$0Z]Q1s%q7[%kW%tp%y#tOY$/|YZ!!uZ]$/|]^!!u^r$/|rs#Djs#O$/|#O#P$1S#P#o$/|#o#p$,`#p#q$/|#q#r$*|#r~$/|Ko$1ZXQ1s%q7[OY$/|YZ!!uZ]$/|]^!!u^#o$/|#o#p$*|#p#q$/|#q#r$*|#r~$/|Mg$1}XQ1s%q7[OY!IYYZ$}Z]!IY]^$}^#o!IY#o#p$2j#p#q!IY#q#r$2j#r~!IY7Z$2{]Q1s%hS%kW%n`%tp%w!b%y#tOY$2jYZ!$gZ]$2j]^!$g^r$2jrs#IYsw$2jwx$(tx#O$2j#O#P$3t#P#o$2j#o#p$4Y#p~$2j7Z$3yTQ1sOY$2jYZ!$gZ]$2j]^!$g^~$2j7Z$4c]Q1s%hS%kWOY#=dYZ:{Z]#=d]^:{^r#=drs#>`sw#=dwx#@Sx#O#=d#O#P#Av#P#o#=d#o#p$2j#p~#=dGz$5o]$}Q%q7[%hS%kW%n`%tp%w!b%y#tOr$}rs&Rsw$}wxHsx!_$}!_!`$6h!`#O$}#O#P!$R#P#o$}#o#p!%i#p#q$}#q#r!$g#r~$}Gz$6{Z!s,W%q7[%hS%kW%n`%tp%w!b%y#tOr$}rs&Rsw$}wxHsx#O$}#O#P!$R#P#o$}#o#p!%i#p#q$}#q#r!$g#r~$}Gz$8R]$wQ%q7[%hS%kW%n`%tp%w!b%y#tOr$}rs&Rsw$}wxHsx!_$}!_!`$6h!`#O$}#O#P!$R#P#o$}#o#p!%i#p#q$}#q#r!$g#r~$}G{$9Z_%r`%q7[%kW%f,X%tp%y#tOY$:YYZIqZ]$:Y]^Iq^r$:Yrs$;jsw$:Ywx%%zx#O$:Y#O#P%!^#P#o$:Y#o#p%$x#p#q$:Y#q#r%!r#r~$:YGk$:k_%q7[%hS%kW%f,X%tp%w!b%y#tOY$:YYZIqZ]$:Y]^Iq^r$:Yrs$;jsw$:Ywx% ^x#O$:Y#O#P%!^#P#o$:Y#o#p%$x#p#q$:Y#q#r%!r#r~$:YFy$;u_%q7[%hS%f,X%w!bOY$<tYZ(}Z]$<t]^(}^r$<trs$Kvsw$<twx$>Sx#O$<t#O#P$?Q#P#o$<t#o#p$Gb#p#q$<t#q#r$?f#r~$<tFy$=T_%q7[%hS%kW%f,X%w!b%y#tOY$<tYZ(}Z]$<t]^(}^r$<trs$;jsw$<twx$>Sx#O$<t#O#P$?Q#P#o$<t#o#p$Gb#p#q$<t#q#r$?f#r~$<tFy$>_Z%q7[%kW%f,X%y#tOr(}rs)}sw(}wx={x#O(}#O#P2]#P#o(}#o#p:X#p#q(}#q#r2q#r~(}Fy$?VT%q7[O#o$<t#o#p$?f#p#q$<t#q#r$?f#r~$<t0m$?s]%hS%kW%f,X%w!b%y#tOY$?fYZ2qZ]$?f]^2q^r$?frs$@lsw$?fwx$Ffx#O$?f#O#P$G[#P#o$?f#o#p$Gb#p~$?f0m$@u]%hS%f,X%w!bOY$?fYZ2qZ]$?f]^2q^r$?frs$Answ$?fwx$Ffx#O$?f#O#P$G[#P#o$?f#o#p$Gb#p~$?f0m$Aw]%hS%f,X%w!bOY$?fYZ2qZ]$?f]^2q^r$?frs$Bpsw$?fwx$Ffx#O$?f#O#P$G[#P#o$?f#o#p$Gb#p~$?f-o$ByZ%hS%f,X%w!bOY$BpYZ.qZ]$Bp]^.q^w$Bpwx$Clx#O$Bp#O#P$DW#P#o$Bp#o#p$D^#p~$Bp-o$CqV%f,XOw.qwx/wx#O.q#O#P0^#P#o.q#o#p0d#p~.q-o$DZPO~$Bp-o$DeZ%hS%f,XOY$EWYZ1OZ]$EW]^1O^w$EWwx$Ezx#O$EW#O#P$F`#P#o$EW#o#p$Bp#p~$EW,]$E_X%hS%f,XOY$EWYZ1OZ]$EW]^1O^w$EWwx$Ezx#O$EW#O#P$F`#P~$EW,]$FPT%f,XOw1Owx1vx#O1O#O#P2V#P~1O,]$FcPO~$EW0m$FoX%kW%f,X%y#tOr2qrs3isw2qwx5sx#O2q#O#P:R#P#o2q#o#p:X#p~2q0m$G_PO~$?f0m$Gk]%hS%kW%f,XOY$HdYZ:{Z]$Hd]^:{^r$Hdrs$I`sw$Hdwx$KSx#O$Hd#O#P$Kp#P#o$Hd#o#p$?f#p~$Hd,e$HmZ%hS%kW%f,XOY$HdYZ:{Z]$Hd]^:{^r$Hdrs$I`sw$Hdwx$KSx#O$Hd#O#P$Kp#P~$Hd,e$IgZ%hS%f,XOY$HdYZ:{Z]$Hd]^:{^r$Hdrs$JYsw$Hdwx$KSx#O$Hd#O#P$Kp#P~$Hd,e$JaZ%hS%f,XOY$HdYZ:{Z]$Hd]^:{^r$Hdrs$EWsw$Hdwx$KSx#O$Hd#O#P$Kp#P~$Hd,e$KZV%kW%f,XOr:{rs;isw:{wx=Zx#O:{#O#P=u#P~:{,e$KsPO~$HdFy$LR_%q7[%hS%f,X%w!bOY$<tYZ(}Z]$<t]^(}^r$<trs$MQsw$<twx$>Sx#O$<t#O#P$?Q#P#o$<t#o#p$Gb#p#q$<t#q#r$?f#r~$<tC{$M]]%q7[%hS%f,X%w!bOY$MQYZ+uZ]$MQ]^+u^w$MQwx$NUx#O$MQ#O#P$Nx#P#o$MQ#o#p$D^#p#q$MQ#q#r$Bp#r~$MQC{$N]X%q7[%f,XOw+uwx-]x#O+u#O#P.]#P#o+u#o#p0d#p#q+u#q#r.q#r~+uC{$N}T%q7[O#o$MQ#o#p$Bp#p#q$MQ#q#r$Bp#r~$MQGk% kZ%q7[%kW%f,X%tp%y#tOrIqrs)}swIqwx! wx#OIq#O#PJs#P#oIq#o#p! T#p#qIq#q#rKX#r~IqGk%!cT%q7[O#o$:Y#o#p%!r#p#q$:Y#q#r%!r#r~$:Y1_%#R]%hS%kW%f,X%tp%w!b%y#tOY%!rYZKXZ]%!r]^KX^r%!rrs$@lsw%!rwx%#zx#O%!r#O#P%$r#P#o%!r#o#p%$x#p~%!r1_%$VX%kW%f,X%tp%y#tOrKXrs3iswKXwxLwx#OKX#O#PN}#P#oKX#o#p! T#p~KX1_%$uPO~%!r1_%%R]%hS%kW%f,XOY$HdYZ:{Z]$Hd]^:{^r$Hdrs$I`sw$Hdwx$KSx#O$Hd#O#P$Kp#P#o$Hd#o#p%!r#p~$HdGk%&XZ%q7[%kW%f,X%tp%y#tOrIqrs)}swIqwx%&zx#OIq#O#PJs#P#oIq#o#p! T#p#qIq#q#rKX#r~IqGk%'ZX%i!f%q7[%kW%g,X%tp%y#tOr!!urs?ms#O!!u#O#P!#m#P#o!!u#o#pNc#p#q!!u#q#rMm#r~!!uG{%(ZZf,X%q7[%hS%kW%n`%tp%w!b%y#tOr$}rs&Rsw$}wxHsx#O$}#O#P!$R#P#o$}#o#p!%i#p#q$}#q#r!$g#r~$}<u%)aZeR%q7[%hS%kW%n`%tp%w!b%y#tOr$}rs&Rsw$}wxHsx#O$}#O#P!$R#P#o$}#o#p!%i#p#q$}#q#r!$g#r~$}G{%*g_T,X%q7[%hS%kW%n`%tp%w!b%y#tOr$}rs&Rsw$}wxHsxz$}z{%+f{!_$}!_!`$6h!`#O$}#O#P!$R#P#o$}#o#p!%i#p#q$}#q#r!$g#r~$}G{%+y]_R%q7[%hS%kW%n`%tp%w!b%y#tOr$}rs&Rsw$}wxHsx!_$}!_!`$6h!`#O$}#O#P!$R#P#o$}#o#p!%i#p#q$}#q#r!$g#r~$}G{%-V]$z,X%q7[%hS%kW%n`%tp%w!b%y#tOr$}rs&Rsw$}wxHsx!_$}!_!`$6h!`#O$}#O#P!$R#P#o$}#o#p!%i#p#q$}#q#r!$g#r~$}<u%.cZxR%q7[%hS%kW%n`%tp%w!b%y#tOr$}rs&Rsw$}wxHsx#O$}#O#P!$R#P#o$}#o#p!%i#p#q$}#q#r!$g#r~$}Mg%/i^${,X%q7[%hS%kW%n`%tp%w!b%y#tOr$}rs&Rsw$}wxHsx!_$}!_!`$6h!`!a%0e!a#O$}#O#P!$R#P#o$}#o#p!%i#p#q$}#q#r!$g#r~$}B^%0xZ&U&j%q7[%hS%kW%n`%tp%w!b%y#tOr$}rs&Rsw$}wxHsx#O$}#O#P!$R#P#o$}#o#p!%i#p#q$}#q#r!$g#r~$}G{%2O_!dQ%q7[%hS%kW%n`%tp%w!b%y#tOr$}rs&Rsw$}wxHsx!O$}!O!P%2}!P!Q$}!Q![%5_![#O$}#O#P!$R#P#o$}#o#p!%i#p#q$}#q#r!$g#r~$}G{%3`]%q7[%hS%kW%n`%tp%w!b%y#tOr$}rs&Rsw$}wxHsx!O$}!O!P%4X!P#O$}#O#P!$R#P#o$}#o#p!%i#p#q$}#q#r!$g#r~$}G{%4lZ!m,X%q7[%hS%kW%n`%tp%w!b%y#tOr$}rs&Rsw$}wxHsx#O$}#O#P!$R#P#o$}#o#p!%i#p#q$}#q#r!$g#r~$}Gy%5rg!f,V%q7[%hS%kW%n`%tp%w!b%y#tOr$}rs&Rsw$}wxHsx!Q$}!Q![%5_![!g$}!g!h%7Z!h!l$}!l!m%;k!m#O$}#O#P!$R#P#R$}#R#S%5_#S#X$}#X#Y%7Z#Y#^$}#^#_%;k#_#o$}#o#p!%i#p#q$}#q#r!$g#r~$}Gy%7la%q7[%hS%kW%n`%tp%w!b%y#tOr$}rs&Rsw$}wxHsx{$}{|%8q|}$}}!O%8q!O!Q$}!Q![%9{![#O$}#O#P!$R#P#o$}#o#p!%i#p#q$}#q#r!$g#r~$}Gy%9S]%q7[%hS%kW%n`%tp%w!b%y#tOr$}rs&Rsw$}wxHsx!Q$}!Q![%9{![#O$}#O#P!$R#P#o$}#o#p!%i#p#q$}#q#r!$g#r~$}Gy%:`c!f,V%q7[%hS%kW%n`%tp%w!b%y#tOr$}rs&Rsw$}wxHsx!Q$}!Q![%9{![!l$}!l!m%;k!m#O$}#O#P!$R#P#R$}#R#S%9{#S#^$}#^#_%;k#_#o$}#o#p!%i#p#q$}#q#r!$g#r~$}Gy%<OZ!f,V%q7[%hS%kW%n`%tp%w!b%y#tOr$}rs&Rsw$}wxHsx#O$}#O#P!$R#P#o$}#o#p!%i#p#q$}#q#r!$g#r~$}G{%=U_$|R%q7[%hS%kW%n`%tp%w!b%y#tOr$}rs&Rsw$}wxHsx!P$}!P!Q%>T!Q!_$}!_!`$6h!`#O$}#O#P!$R#P#o$}#o#p!%i#p#q$}#q#r!$g#r~$}Gz%>h]%OQ%q7[%hS%kW%n`%tp%w!b%y#tOr$}rs&Rsw$}wxHsx!_$}!_!`$6h!`#O$}#O#P!$R#P#o$}#o#p!%i#p#q$}#q#r!$g#r~$}Gy%?tu!f,V%q7[%hS%kW%n`%tp%w!b%y#tOr$}rs&Rsw$}wxHsx!O$}!O!P%BX!P!Q$}!Q![%Cc![!d$}!d!e%Ee!e!g$}!g!h%7Z!h!l$}!l!m%;k!m!q$}!q!r%H_!r!z$}!z!{%KR!{#O$}#O#P!$R#P#R$}#R#S%Cc#S#U$}#U#V%Ee#V#X$}#X#Y%7Z#Y#^$}#^#_%;k#_#c$}#c#d%H_#d#l$}#l#m%KR#m#o$}#o#p!%i#p#q$}#q#r!$g#r~$}Gy%Bj]%q7[%hS%kW%n`%tp%w!b%y#tOr$}rs&Rsw$}wxHsx!Q$}!Q![%5_![#O$}#O#P!$R#P#o$}#o#p!%i#p#q$}#q#r!$g#r~$}Gy%Cvi!f,V%q7[%hS%kW%n`%tp%w!b%y#tOr$}rs&Rsw$}wxHsx!O$}!O!P%BX!P!Q$}!Q![%Cc![!g$}!g!h%7Z!h!l$}!l!m%;k!m#O$}#O#P!$R#P#R$}#R#S%Cc#S#X$}#X#Y%7Z#Y#^$}#^#_%;k#_#o$}#o#p!%i#p#q$}#q#r!$g#r~$}Gy%Ev`%q7[%hS%kW%n`%tp%w!b%y#tOr$}rs&Rsw$}wxHsx!Q$}!Q!R%Fx!R!S%Fx!S#O$}#O#P!$R#P#R$}#R#S%Fx#S#o$}#o#p!%i#p#q$}#q#r!$g#r~$}Gy%G]`!f,V%q7[%hS%kW%n`%tp%w!b%y#tOr$}rs&Rsw$}wxHsx!Q$}!Q!R%Fx!R!S%Fx!S#O$}#O#P!$R#P#R$}#R#S%Fx#S#o$}#o#p!%i#p#q$}#q#r!$g#r~$}Gy%Hp_%q7[%hS%kW%n`%tp%w!b%y#tOr$}rs&Rsw$}wxHsx!Q$}!Q!Y%Io!Y#O$}#O#P!$R#P#R$}#R#S%Io#S#o$}#o#p!%i#p#q$}#q#r!$g#r~$}Gy%JS_!f,V%q7[%hS%kW%n`%tp%w!b%y#tOr$}rs&Rsw$}wxHsx!Q$}!Q!Y%Io!Y#O$}#O#P!$R#P#R$}#R#S%Io#S#o$}#o#p!%i#p#q$}#q#r!$g#r~$}Gy%Kdc%q7[%hS%kW%n`%tp%w!b%y#tOr$}rs&Rsw$}wxHsx!Q$}!Q![%Lo![!c$}!c!i%Lo!i#O$}#O#P!$R#P#R$}#R#S%Lo#S#T$}#T#Z%Lo#Z#o$}#o#p!%i#p#q$}#q#r!$g#r~$}Gy%MSc!f,V%q7[%hS%kW%n`%tp%w!b%y#tOr$}rs&Rsw$}wxHsx!Q$}!Q![%Lo![!c$}!c!i%Lo!i#O$}#O#P!$R#P#R$}#R#S%Lo#S#T$}#T#Z%Lo#Z#o$}#o#p!%i#p#q$}#q#r!$g#r~$}Mg%Nr]y1s%q7[%hS%kW%n`%tp%w!b%y#tOr$}rs&Rsw$}wxHsx!_$}!_!`& k!`#O$}#O#P!$R#P#o$}#o#p!%i#p#q$}#q#r!$g#r~$}<u&!OZ%WR%q7[%hS%kW%n`%tp%w!b%y#tOr$}rs&Rsw$}wxHsx#O$}#O#P!$R#P#o$}#o#p!%i#p#q$}#q#r!$g#r~$}G{&#UZ#^,X%q7[%hS%kW%n`%tp%w!b%y#tOr$}rs&Rsw$}wxHsx#O$}#O#P!$R#P#o$}#o#p!%i#p#q$}#q#r!$g#r~$}G{&$[_kR%q7[%hS%kW%n`%tp%w!b%y#tOr$}rs&Rsw$}wxHsx!^$}!^!_&%Z!_!`!*Q!`!a!*Q!a#O$}#O#P!$R#P#o$}#o#p!%i#p#q$}#q#r!$g#r~$}Gz&%n]$xQ%q7[%hS%kW%n`%tp%w!b%y#tOr$}rs&Rsw$}wxHsx!_$}!_!`$6h!`#O$}#O#P!$R#P#o$}#o#p!%i#p#q$}#q#r!$g#r~$}G{&&z]%V,X%q7[%hS%kW%n`%tp%w!b%y#tOr$}rs&Rsw$}wxHsx!_$}!_!`!*Q!`#O$}#O#P!$R#P#o$}#o#p!%i#p#q$}#q#r!$g#r~$}G{&(W^kR%q7[%hS%kW%n`%tp%w!b%y#tOr$}rs&Rsw$}wxHsx!_$}!_!`!*Q!`!a&)S!a#O$}#O#P!$R#P#o$}#o#p!%i#p#q$}#q#r!$g#r~$}Gz&)g]$yQ%q7[%hS%kW%n`%tp%w!b%y#tOr$}rs&Rsw$}wxHsx!_$}!_!`$6h!`#O$}#O#P!$R#P#o$}#o#p!%i#p#q$}#q#r!$g#r~$}G{&*u]]Q#tP%q7[%hS%kW%n`%tp%w!b%y#tOr$}rs&Rsw$}wxHsx!_$}!_!`$6h!`#O$}#O#P!$R#P#o$}#o#p!%i#p#q$}#q#r!$g#r~$}Mg&,Tc%q7[%hS%kW%e&j%n`%tp%w!b%y#t%Q,XOr$}rs&Rsw$}wxHsx!Q$}!Q![&+n![!c$}!c!}&+n!}#O$}#O#P!$R#P#R$}#R#S&+n#S#T$}#T#o&+n#o#p!%i#p#q$}#q#r!$g#r$g$}$g~&+nMg&-ug%q7[%hS%kW%e&j%n`%tp%w!b%y#t%Q,XOr$}rs&/^sw$}wx&2dx!Q$}!Q![&+n![!c$}!c!t&+n!t!u&5j!u!}&+n!}#O$}#O#P!$R#P#R$}#R#S&+n#S#T$}#T#f&+n#f#g&5j#g#o&+n#o#p!%i#p#q$}#q#r!$g#r$g$}$g~&+nGZ&/k_%q7[%hS%f,X%n`%w!bOY!-lYZ'PZ]!-l]^'P^r!-lrs&0jsw!-lwx!/|x#O!-l#O#P!Cp#P#o!-l#o#p!F[#p#q!-l#q#r!DU#r~!-lGZ&0wZ%q7[%hS%f,X%n`%w!bOr'Prs&1jsw'Pwx(Rx#O'P#O#PAe#P#o'P#o#pEu#p#q'P#q#rAy#r~'PD]&1wX%q7[%hS%j,X%n`%w!bOwGgwx,kx#OGg#O#PH_#P#oGg#o#pET#p#qGg#q#rD_#r~GgGk&2q_%q7[%kW%f,X%tp%y#tOY$:YYZIqZ]$:Y]^Iq^r$:Yrs$;jsw$:Ywx&3px#O$:Y#O#P%!^#P#o$:Y#o#p%$x#p#q$:Y#q#r%!r#r~$:YGk&3}Z%q7[%kW%f,X%tp%y#tOrIqrs)}swIqwx&4px#OIq#O#PJs#P#oIq#o#p! T#p#qIq#q#rKX#r~IqFT&4}X%q7[%kW%g,X%tp%y#tOr!!urs?ms#O!!u#O#P!#m#P#o!!u#o#pNc#p#q!!u#q#rMm#r~!!uMg&6Pc%q7[%hS%kW%e&j%n`%tp%w!b%y#t%Q,XOr$}rs&/^sw$}wx&2dx!Q$}!Q![&+n![!c$}!c!}&+n!}#O$}#O#P!$R#P#R$}#R#S&+n#S#T$}#T#o&+n#o#p!%i#p#q$}#q#r!$g#r$g$}$g~&+nMg&7qg%q7[%hS%kW%e&j%n`%tp%w!b%y#t%Q,XOr$}rs&9Ysw$}wx&<Qx!Q$}!Q![&+n![!c$}!c!t&+n!t!u&>x!u!}&+n!}#O$}#O#P!$R#P#R$}#R#S&+n#S#T$}#T#f&+n#f#g&>x#g#o&+n#o#p!%i#p#q$}#q#r!$g#r$g$}$g~&+nGZ&9gZ%q7[%hS%n`%w!b%s,XOr'Prs&:Ysw'Pwx(Rx#O'P#O#PAe#P#o'P#o#pEu#p#q'P#q#rAy#r~'PGZ&:eZ%q7[%hS%n`%w!bOr'Prs&;Wsw'Pwx(Rx#O'P#O#PAe#P#o'P#o#pEu#p#q'P#q#rAy#r~'PD]&;eX%q7[%hS%x,X%n`%w!bOwGgwx,kx#OGg#O#PH_#P#oGg#o#pET#p#qGg#q#rD_#r~GgGk&<_Z%q7[%kW%tp%y#t%m,XOrIqrs)}swIqwx&=Qx#OIq#O#PJs#P#oIq#o#p! T#p#qIq#q#rKX#r~IqGk&=]Z%q7[%kW%tp%y#tOrIqrs)}swIqwx&>Ox#OIq#O#PJs#P#oIq#o#p! T#p#qIq#q#rKX#r~IqFT&>]X%q7[%kW%v,X%tp%y#tOr!!urs?ms#O!!u#O#P!#m#P#o!!u#o#pNc#p#q!!u#q#rMm#r~!!uMg&?_c%q7[%hS%kW%e&j%n`%tp%w!b%y#t%Q,XOr$}rs&9Ysw$}wx&<Qx!Q$}!Q![&+n![!c$}!c!}&+n!}#O$}#O#P!$R#P#R$}#R#S&+n#S#T$}#T#o&+n#o#p!%i#p#q$}#q#r!$g#r$g$}$g~&+nMg&APk%q7[%hS%kW%e&j%n`%tp%w!b%y#t%Q,XOr$}rs&/^sw$}wx&2dx!Q$}!Q![&+n![!c$}!c!h&+n!h!i&>x!i!t&+n!t!u&5j!u!}&+n!}#O$}#O#P!$R#P#R$}#R#S&+n#S#T$}#T#U&+n#U#V&5j#V#Y&+n#Y#Z&>x#Z#o&+n#o#p!%i#p#q$}#q#r!$g#r$g$}$g~&+nG{&CXZ!V,X%q7[%hS%kW%n`%tp%w!b%y#tOr$}rs&Rsw$}wxHsx#O$}#O#P!$R#P#o$}#o#p!%i#p#q$}#q#r!$g#r~$}<u&D_Z!UR%q7[%hS%kW%n`%tp%w!b%y#tOr$}rs&Rsw$}wxHsx#O$}#O#P!$R#P#o$}#o#p!%i#p#q$}#q#r!$g#r~$}Gz&Ee]$vQ%q7[%hS%kW%n`%tp%w!b%y#tOr$}rs&Rsw$}wxHsx!_$}!_!`$6h!`#O$}#O#P!$R#P#o$}#o#p!%i#p#q$}#q#r!$g#r~$}Gy&FgX%hS%kW!ZGmOr:{rs;isw:{wx<ox#O:{#O#P=u#P#o:{#o#p!$g#p~:{Gz&Gg]$uQ%q7[%hS%kW%n`%tp%w!b%y#tOr$}rs&Rsw$}wxHsx!_$}!_!`$6h!`#O$}#O#P!$R#P#o$}#o#p!%i#p#q$}#q#r!$g#r~$}<u&HqX!Y7_%hS%kW%n`%tp%w!b%y#tOr!$grsBssw!$gwxLRx#O!$g#O#P!%c#P#o!$g#o#p!%i#p~!$gGy&IqZ%P,V%q7[%hS%kW%n`%tp%w!b%y#tOr$}rs&Rsw$}wxHsx#O$}#O#P!$R#P#o$}#o#p!%i#p#q$}#q#r!$g#r~$}",
  tokenizers: [legacyPrint, indentation, 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, newlines],
  topRules: {"Script":[0,3]},
  specialized: [{term: 186, get: value => spec_identifier[value] || -1}],
  tokenPrec: 6584
});

exports.parser = parser;


/***/ })

/******/ 	});
/************************************************************************/
/******/ 	// The module cache
/******/ 	var __webpack_module_cache__ = {};
/******/ 	
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/ 		// Check if module is in cache
/******/ 		var cachedModule = __webpack_module_cache__[moduleId];
/******/ 		if (cachedModule !== undefined) {
/******/ 			return cachedModule.exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = __webpack_module_cache__[moduleId] = {
/******/ 			id: moduleId,
/******/ 			// no module.loaded needed
/******/ 			exports: {}
/******/ 		};
/******/ 	
/******/ 		// Execute the module function
/******/ 		__webpack_modules__[moduleId].call(module.exports, module, module.exports, __webpack_require__);
/******/ 	
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/ 	
/******/ 	// expose the modules object (__webpack_modules__)
/******/ 	__webpack_require__.m = __webpack_modules__;
/******/ 	
/************************************************************************/
/******/ 	/* webpack/runtime/compat get default export */
/******/ 	(() => {
/******/ 		// getDefaultExport function for compatibility with non-harmony modules
/******/ 		__webpack_require__.n = (module) => {
/******/ 			var getter = module && module.__esModule ?
/******/ 				() => (module['default']) :
/******/ 				() => (module);
/******/ 			__webpack_require__.d(getter, { a: getter });
/******/ 			return getter;
/******/ 		};
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/define property getters */
/******/ 	(() => {
/******/ 		// define getter functions for harmony exports
/******/ 		__webpack_require__.d = (exports, definition) => {
/******/ 			for(var key in definition) {
/******/ 				if(__webpack_require__.o(definition, key) && !__webpack_require__.o(exports, key)) {
/******/ 					Object.defineProperty(exports, key, { enumerable: true, get: definition[key] });
/******/ 				}
/******/ 			}
/******/ 		};
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/global */
/******/ 	(() => {
/******/ 		__webpack_require__.g = (function() {
/******/ 			if (typeof globalThis === 'object') return globalThis;
/******/ 			try {
/******/ 				return this || new Function('return this')();
/******/ 			} catch (e) {
/******/ 				if (typeof window === 'object') return window;
/******/ 			}
/******/ 		})();
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/hasOwnProperty shorthand */
/******/ 	(() => {
/******/ 		__webpack_require__.o = (obj, prop) => (Object.prototype.hasOwnProperty.call(obj, prop))
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/make namespace object */
/******/ 	(() => {
/******/ 		// define __esModule on exports
/******/ 		__webpack_require__.r = (exports) => {
/******/ 			if(typeof Symbol !== 'undefined' && Symbol.toStringTag) {
/******/ 				Object.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });
/******/ 			}
/******/ 			Object.defineProperty(exports, '__esModule', { value: true });
/******/ 		};
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/jsonp chunk loading */
/******/ 	(() => {
/******/ 		__webpack_require__.b = document.baseURI || self.location.href;
/******/ 		
/******/ 		// object to store loaded and loading chunks
/******/ 		// undefined = chunk not loaded, null = chunk preloaded/prefetched
/******/ 		// [resolve, reject, Promise] = chunk loading, 0 = chunk loaded
/******/ 		var installedChunks = {
/******/ 			"main": 0
/******/ 		};
/******/ 		
/******/ 		// no chunk on demand loading
/******/ 		
/******/ 		// no prefetching
/******/ 		
/******/ 		// no preloaded
/******/ 		
/******/ 		// no HMR
/******/ 		
/******/ 		// no HMR manifest
/******/ 		
/******/ 		// no on chunks loaded
/******/ 		
/******/ 		// no jsonp function
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/nonce */
/******/ 	(() => {
/******/ 		__webpack_require__.nc = undefined;
/******/ 	})();
/******/ 	
/************************************************************************/
/******/ 	
/******/ 	// startup
/******/ 	// Load entry module and return exports
/******/ 	// This entry module is referenced by other modules so it can't be inlined
/******/ 	var __webpack_exports__ = __webpack_require__("./webstart.ts");
/******/ 	
/******/ })()
;
//# sourceMappingURL=data:application/json;charset=utf-8;base64,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O0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLFlBQVk7QUFDWjs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQzs7Ozs7Ozs7Ozs7QUN2SkQ7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsRUFBRSxLQUE0RDtBQUM5RCxFQUFFLENBQ3dEO0FBQzFELENBQUMsc0JBQXNCOztBQUV2QjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0Esc0NBQXNDLEdBQUc7QUFDekM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSx3QkFBd0I7QUFDeEIsZ0RBQWdELGdCQUFnQjtBQUNoRTtBQUNBO0FBQ0E7O0FBRUEsNEJBQTRCOztBQUU1QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsMENBQTBDLFdBQVc7QUFDckQsUUFBUTtBQUNSO0FBQ0E7O0FBRUE7QUFDQTtBQUNB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QztZQUVqRCxNQUFNLENBQUMsSUFBSSxDQUFDLEVBQUUsQ0FBQyxFQUFFLENBQUMsQ0FBQyxDQUFDLEVBQUUsS0FBSyxFQUFFLE9BQU8sRUFBRSxLQUFLLEVBQUUsRUFBRSxFQUFFLENBQUMsQ0FBQztZQUNuRCxJQUFJLENBQUMsUUFBUSxFQUFFLFFBQVEsRUFBRSxPQUFPLEVBQUUsVUFBVSxDQUFDLEdBQUcsaUJBQWlCLENBQUMsQ0FBQyxDQUFDLEdBQUcsRUFBRSxNQUFNLEVBQUUsR0FBRyxDQUFDLENBQUM7WUFDdEYsb0JBQW9CLENBQUMsTUFBTSxFQUFFLEdBQUcsUUFBUSxFQUFFLEVBQUUsQ0FBQyxFQUFFLENBQUMsQ0FBQyxDQUFDLEVBQUUsR0FBRyxFQUFFLFFBQVEsRUFBRSxJQUFJLEVBQUUsWUFBWSxFQUFFLEtBQUssRUFBRSxPQUFPLEVBQUMsRUFBRSxNQUFNLENBQUMsQ0FBQztZQUVoSCxNQUFNLENBQUMsSUFBSSxDQUFDLEVBQUUsQ0FBQyxFQUFFLENBQUMsQ0FBQyxDQUFDLEVBQUUsS0FBSyxFQUFFLE9BQU8sRUFBRSxLQUFLLEVBQUUsRUFBRSxFQUFFLENBQUMsQ0FBQztZQUNuRCxJQUFJLENBQUMsUUFBUSxFQUFFLFFBQVEsRUFBRSxPQUFPLEVBQUUsV0FBVyxDQUFDLEdBQUcsaUJBQWlCLENBQUMsQ0FBQyxDQUFDLEdBQUcsRUFBRSxNQUFNLEVBQUUsR0FBRyxDQUFDLENBQUM7WUFDdkYsb0JBQW9CLENBQUMsTUFBTSxFQUFDLEdBQUcsUUFBUSxFQUFFLEVBQUUsQ0FBQyxFQUFFLENBQUMsQ0FBQyxDQUFDLEVBQUUsR0FBRyxFQUFFLFFBQVEsRUFBRSxJQUFJLEVBQUUsWUFBWSxFQUFFLEtBQUssRUFBRSxPQUFPLEVBQUMsRUFBRSxNQUFNLENBQUMsQ0FBQztZQUUvRyxNQUFNLENBQUMsSUFBSSxDQUFDLEVBQUUsQ0FBQyxFQUFFLENBQUMsQ0FBQyxDQUFDLEVBQUUsS0FBSyxFQUFFLE1BQU0sRUFBRSxLQUFLLEVBQUUsRUFBRSxFQUFFLENBQUMsQ0FBQztZQUNsRCxJQUFJLFlB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QUcsRUFBRSxLQUFLLEVBQUUsS0FBSyxFQUFFLE9BQU8sQ0FBQyxLQUFLLEdBQUcsUUFBUSxDQUFDLEtBQUssRUFBQztZQUU1RSxLQUFLLFdBQUssQ0FBQyxHQUFHLENBQUMsQ0FBQyxPQUFPLEVBQUMsR0FBRyxFQUFFLEtBQUssRUFBRSxLQUFLLEVBQUUsT0FBTyxDQUFDLEtBQUssR0FBRyxRQUFRLENBQUMsS0FBSyxFQUFDO1lBRTFFLEtBQUssV0FBSyxDQUFDLElBQUksQ0FBQyxDQUFDLE9BQU8sRUFBQyxHQUFHLEVBQUUsS0FBSyxFQUFFLEtBQUssRUFBRSxPQUFPLENBQUMsS0FBSyxHQUFHLFFBQVEsQ0FBQyxLQUFLLEVBQUM7WUFFM0UsS0FBSyxXQUFLLENBQUMsR0FBRyxDQUFDLENBQUMsT0FBTyxFQUFDLEdBQUcsRUFBRSxLQUFLLEVBQUUsS0FBSyxFQUFFLE9BQU8sQ0FBQyxLQUFLLEdBQUcsUUFBUSxDQUFDLEtBQUssRUFBQztZQUUxRSxLQUFLLFdBQUssQ0FBQyxFQUFFLENBQUMsQ0FBQyxPQUFPLEVBQUMsR0FBRyxFQUFFLE1BQU0sRUFBRSxLQUFLLEVBQUUsT0FBTyxDQUFDLEtBQUssR0FBRyxRQUFRLENBQUMsS0FBSyxFQUFDO1lBRTFFLEtBQUssV0FBSyxDQUFDLEVBQUUsQ0FBQyxDQUFDLE9BQU8sRUFBQyxHQUFHLEVBQUUsTUFBTSxFQUFFLEtBQUssRUFBRSxPQUFPLENBQUMsS0FBSyxHQUFHLFFBQVEsQ0FBQyxLQUFLLEVBQUM7WUFFMUUsS0FBSyxXQUFLLENBQUMsR0FBRyxDQUFDLENBQUMsT0FBTyxFQUFDLEdBQUcsRUFBRSxNQUFNLEVBQUUsS0FBSyxFQUFFLE9BQU8sQ0FBQyxLQUFLLElBQUksUUFBUSxDQUFDLEtBQUssRUFBQztZQUU1RSxLQUFLLFdBQUssQ0FBQyxHQUFHLENBQUMsQ0FBQyxPQUFPLEVBQUMsR0FBRyxFQUFFLE1BQU0sRUFBRSxLQUFLLEVBQUUsT0FBTyxDQUFDLEtBQUssSUFBSSxRQUFRLENBQUMsS0FBSyxFQUFDO1NBQy9FO0tBQ0o7U0FDSSxJQUFH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QyxHQUFHLENBQUMsVUFBVSxDQUFDLEtBQUssRUFBRSxDQUFDLEdBQUcsS0FBSyxDQUFDLEdBQUcsQ0FBQyxVQUFVLENBQUMsS0FBSyxDQUFDLEVBQUUsUUFBUSxDQUFDLEdBQUcsQ0FBQyxDQUFDLENBQUM7aUJBQzNFLElBQUksQ0FBQyxLQUFLLENBQUMsR0FBRyxDQUFDLFVBQVUsQ0FBQyxLQUFLLENBQUM7Z0JBQ2pDLEtBQUssQ0FBQyxHQUFHLENBQUMsVUFBVSxDQUFDLEtBQUssRUFBRSxDQUFDLFFBQVEsQ0FBQyxHQUFHLENBQUMsQ0FBQyxDQUFDO1lBR2hELElBQUksS0FBSyxDQUFDLEdBQUcsQ0FBQyxVQUFVLENBQUMsS0FBSyxDQUFDLElBQUksQ0FBQyxLQUFLLENBQUMsR0FBRyxDQUFDLFVBQVUsQ0FBQyxLQUFLLENBQUMsQ0FBQyxRQUFRLENBQUMsUUFBUSxDQUFDLEdBQUcsQ0FBQztnQkFDbEYsS0FBSyxDQUFDLEdBQUcsQ0FBQyxVQUFVLENBQUMsS0FBSyxFQUFFLENBQUMsR0FBRyxLQUFLLENBQUMsR0FBRyxDQUFDLFVBQVUsQ0FBQyxLQUFLLENBQUMsRUFBRSxRQUFRLENBQUMsR0FBRyxDQUFDLENBQUMsQ0FBQztpQkFDM0UsSUFBSSxDQUFDLEtBQUssQ0FBQyxHQUFHLENBQUMsVUFBVSxDQUFDLEtBQUssQ0FBQztnQkFDakMsS0FBSyxDQUFDLEdBQUcsQ0FBQyxVQUFVLENBQUMsS0FBSyxFQUFFLENBQUMsUUFBUSxDQUFDLEdBQUcsQ0FBQyxDQUFDLENBQUM7WUFFaEQsd0JBQXdCO1lBQ3hCLElBQUcsS0FBSyxDQUFDLEdBQUcsQ0FBQyxRQUFRLENBQUMsR0FBRyxDQUFDLElBQUksQ0FBQyxLQUFLLENBQUMsR0FBRyxDQUFDLFFBQVEsQ0FBQyxHQUFHLENBQUMsQ0FBQyxRQUFRLENBQUMsVUFBVSxDQUFDLEtBQUssQ0FBQztnQkFDN0UsS0FBSyxDQUFDLEdBQUcsQ0FBQyxRQUFRLENBQUMsR0FBRyxFQUFFLENBQUMsR0FBRyxLQUFLLENBQUMsR0FBRyxDQUFDLFFBQVEsQ0FBQyxHQUFHLENBQUMsRUFBRSxVQUFVLENBQUMsS0FBSyxDQUFDLENBQUMsQ0FBQztpQkFDdkUsSUFBSSxDQUFDLEtBQUssQ0FBQyxHQUFHLENBQUMsUUFBUSxDQUFDLEdBQUcsQ0FBQztnQkFDN0IsS0FBSyxDQUFDLEdBQUcsQ0FBQyxRQUFRLENBQUMsR0FBRyxFQUFFLENBQUMsVUFBVSxDQUFDLEtBQUssQ0FBQyxDQUFDLENBQUM7WUFFaEQsSUFBRyxLQUFLLENBQUMsR0FBRyxDQUFDLFFBQVEsQ0FBQyxHQUFHLENBQUMsSUFBSSxDQUFDLEtBQUssQ0FBQyxHQUFHLENBQUMsUUFBUSxDQUFDLEdBQUcsQ0FBQyxDQUFDLFFBQVEsQ0FBQyxVQUFVLENBQUMsS0FBSyxDQUFDO2dCQUM3RSxLQUFLLENBQUMsR0FBRyxDQUFDLFFBQVEsQ0FBQyxHQUFHLEVBQUUsQ0FBQyxHQUFHLEtBQUssQ0FBQyxHQUFHLENBQUMsUUFBUSxDQUFDLEdBQUcsQ0FBQyxFQUFFLFVBQVUsQ0FBQyxLQUFLLENBQUMsQ0FBQyxDQUFDO2lCQUN2RSxJQUFJLENBQUMsS0FBSyxDQUFDLEdBQUcsQ0FBQyxRQUFRLENBQUMsR0FBRyxDQUFDO2dCQUM3QixLQUFLLENBQUMsR0FBRyxDQUFDLFFBQVEsQ0FBQyxHQUFHLEVBQUUsQ0FBQyxVQUFVLENBQUMsS0FBSyxDQUFDLENBQUMsQ0FBQztTQUNuRDthQUNJLElBQUksUUFBUSxLQUFLLFNBQVMsSUFBSSxRQUFRLENBQUMsR0FBRyxLQUFLLEtBQUssRUFBQztZQUN0RCxzQkFBc0I7WUFDdEIsSUFBSSxLQUFLLENBQUMsR0FBRyxDQUFDLFVBQVUsQ0FBQyxLQUFLLENBQUMsSUFBSSxDQUFDLEtBQUssQ0FBQyxHQUFHLENBQUMsVUFBVSxDQUFDLEtBQUssQ0FBQyxDQUFDLFFBQVEsQ0FBQyxRQUFRLENBQUMsR0FBRyxDQUFDO2dCQUNsRixLQUFLLENBQUMsR0FBRyxDQUFDLFVBQVUsQ0FBQyxLQUFLLEVBQUUsQ0FBQyxHQUFHLEtBQUssQ0FBQyxHQUFHLENBQUMsVUFBVSxDQUFDLEtBQUssQ0FB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QUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3QkFBd0Isa0JBQWtCO0FBQzFDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtREFBbUQ7QUFDbkQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQjtBQUNoQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDLHVCQUF1QixnQkFBZ0IsS0FBSztBQUM3QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7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QixRQUFRO0FBQzNCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0RBQW9EO0FBQ3BEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzQkFBc0I7QUFDdEI7QUFDQTtBQUNBLG9CQUFvQjtBQUNwQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw0Q0FBNEM7QUFDNUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZTtBQUNmO0FBQ0E7QUFDQTtBQUNB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Q0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLGtCQUFrQjtBQUN0QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtDQUFrQztBQUNsQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQkFBa0I7QUFDbEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVLG9CQUFvQjtBQUM5QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYyw2QkFBNkI7QUFDM0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMENBQTBDO0FBQzFDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWM7QUFDZDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwwQkFBMEIsUUFBUTtBQUNsQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNB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QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0JBQWtCLGtCQUFrQjtBQUNwQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7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QUNBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vd2ViLWFzbS1qaXQvLi9ub2RlX21vZHVsZXMvY29kZW1pcnJvci9hZGRvbi9lZGl0L2Nsb3NlYnJhY2tldHMuanMiLCJ3ZWJwYWNrOi8vd2ViLWFzbS1qaXQvLi9ub2RlX21vZHVsZXMvY29kZW1pcnJvci9hZGRvbi9oaW50L3Nob3ctaGludC5qcyIsIndlYnBhY2s6Ly93ZWItYXNtLWppdC8uL25vZGVfbW9kdWxlcy9jb2RlbWlycm9yL2FkZG9uL2xpbnQvbGludC5qcyIsIndlYnBhY2s6Ly93ZWItYXNtLWppdC8uL25vZGVfbW9kdWxlcy9jb2RlbWlycm9yL2FkZG9uL3Njcm9sbC9zaW1wbGVzY3JvbGxiYXJzLmpzIiwid2VicGFjazovL3dlYi1hc20taml0Ly4vbm9kZV9tb2R1bGVzL2NvZGVtaXJyb3IvbGliL2NvZGVtaXJyb3IuanMiLCJ3ZWJwYWNrOi8vd2ViLWFzbS1qaXQvLi9ub2RlX21vZHVsZXMvY29kZW1pcnJvci9tb2RlL3B5dGhvbi9weXRob24uanMiLCJ3ZWJwYWNrOi8vd2ViLWFzbS1qaXQvLi9ub2RlX21vZHVsZXMvY29kZW1pcnJvci9hZGRvbi9oaW50L3Nob3ctaGludC5jc3MiLCJ3ZWJwYWNrOi8vd2ViLWFzbS1qaXQvLi9ub2RlX21vZHVsZXMvY29kZW1pcnJvci9hZGRvbi9saW50L2xpbnQuY3NzIiwid2VicGFjazovL3dlYi1hc20taml0Ly4vbm9kZV9tb2R1bGVzL2NvZGVtaXJyb3IvYWRkb24vc2Nyb2xsL3NpbXBsZXNjcm9sbGJhcnMuY3NzIiwid2VicGFjazovL3dlYi1hc20taml0Ly4vbm9kZV9tb2R1bGVzL2NvZGVtaXJyb3IvbGliL2NvZGVtaXJyb3IuY3NzIiwid2VicGFjazovL3dlYi1hc20taml0Ly4vc3R5bGUuc2NzcyIsIndlYnBhY2s6Ly93ZWItYXNtLWppdC8uL25vZGVfbW9kdWxlcy9jc3MtbG9hZGVyL2Rpc3QvcnVudGltZS9hcGkuanMiLCJ3ZWJwYWNrOi8vd2ViLWFzbS1qaXQvLi9ub2RlX21vZHVsZXMvY3NzLWxvYWRlci9kaXN0L3J1bnRpbWUvZ2V0VXJsLmpzIiwid2VicGFjazovL3dlYi1hc20taml0Ly4vbm9kZV9tb2R1bGVzL2Nzcy1sb2FkZXIvZGlzdC9ydW50aW1lL3NvdXJjZU1hcHMuanMiLCJ3ZWJwYWNrOi8vd2ViLWFzbS1qaXQvLi9ub2RlX21vZHVsZXMvZmlsZS1zYXZlci9kaXN0L0ZpbGVTYXZlci5taW4uanMiLCJ3ZWJwYWNrOi8vd2ViLWFzbS1qaXQvLi9zdHlsZS5zY3NzPzgwYjUiLCJ3ZWJwYWNrOi8vd2ViLWFzbS1qaXQvLi9ub2RlX21vZHVsZXMvc3R5bGUtbG9hZGVyL2Rpc3QvcnVudGltZS9pbmplY3RTdHlsZXNJbnRvU3R5bGVUYWcuanMiLCJ3ZWJwYWNrOi8vd2ViLWFzbS1qaXQvLi9ub2RlX21vZHVsZXMvc3R5bGUtbG9hZGVyL2Rpc3QvcnVudGltZS9pbnNlcnRCeVNlbGVjdG9yLmpzIiwid2VicGFjazovL3dlYi1hc20taml0Ly4vbm9kZV9tb2R1bGVzL3N0eWxlLWxvYWRlci9kaXN0L3J1bnRpbWUvaW5zZXJ0U3R5bGVFbGVtZW50LmpzIiwid2VicGFjazovL3dlYi1hc20taml0Ly4vbm9kZV9tb2R1bGVzL3N0eWxlLWxvYWRlci9kaXN0L3J1bnRpbWUvc2V0QXR0cmlidXRlc1dpdGhvdXRBdHRyaWJ1dGVzLmpzIiwid2VicGFjazovL3dlYi1hc20taml0Ly4vbm9kZV9tb2R1bGVzL3N0eWxlLWxvYWRlci9kaXN0L3J1bnRpbWUvc3R5bGVEb21BUEkuanMiLCJ3ZWJwYWNrOi8vd2ViLWFzbS1qaXQvLi9ub2RlX21vZHVsZXMvc3R5bGUtbG9hZGVyL2Rpc3QvcnVudGltZS9zdHlsZVRhZ1RyYW5zZm9ybS5qcyIsIndlYnBhY2s6Ly93ZWItYXNtLWppdC8uL2FzdC50cyIsIndlYnBhY2s6Ly93ZWItYXNtLWppdC8uL2F1dG9jb21wbGV0ZS50cyIsIndlYnBhY2s6Ly93ZWItYXNtLWppdC8uL2NvbXBpbGVyLnRzIiwid2VicGFjazovL3dlYi1hc20taml0Ly4vY29uc3QudHMiLCJ3ZWJwYWNrOi8vd2ViLWFzbS1qaXQvLi9lcnJvcnMudHMiLCJ3ZWJwYWNrOi8vd2ViLWFzbS1qaXQvLi9sb3dlci50cyIsIndlYnBhY2s6Ly93ZWItYXNtLWppdC8uL21vbm9tb3JwaGl6ZXIudHMiLCJ3ZWJwYWNrOi8vd2ViLWFzbS1qaXQvLi9vcHRpbWl6YXRpb24udHMiLCJ3ZWJwYWNrOi8vd2ViLWFzbS1qaXQvLi9vcHRpbWl6YXRpb25fdXRpbHMudHMiLCJ3ZWJwYWNrOi8vd2ViLWFzbS1qaXQvLi9wYXJzZXIudHMiLCJ3ZWJwYWNrOi8vd2ViLWFzbS1qaXQvLi9yZXBsLnRzIiwid2VicGFjazovL3dlYi1hc20taml0Ly4vcnVubmVyLnRzIiwid2VicGFjazovL3dlYi1hc20taml0Ly4vdHJlZXByaW50ZXIudHMiLCJ3ZWJwYWNrOi8vd2ViLWFzbS1qaXQvLi90eXBlLWNoZWNrLnRzIiwid2VicGFjazovL3dlYi1hc20taml0Ly4vdXRpbHMudHMiLCJ3ZWJwYWNrOi8vd2ViLWFzbS1qaXQvLi93ZWJzdGFydC50cyIsIndlYnBhY2s6Ly93ZWItYXNtLWppdC9leHRlcm5hbCB2YXIgXCJ3YWJ0XCIiLCJ3ZWJwYWNrOi8vd2ViLWFzbS1qaXQvLi9ub2RlX21vZHVsZXMvQGxlemVyL2NvbW1vbi9kaXN0L2luZGV4LmNqcyIsIndlYnBhY2s6Ly93ZWItYXNtLWppdC8uL25vZGVfbW9kdWxlcy9AbGV6ZXIvaGlnaGxpZ2h0L2Rpc3QvaW5kZXguY2pzIiwid2VicGFjazovL3dlYi1hc20taml0Ly4vbm9kZV9tb2R1bGVzL0BsZXplci9sci9kaXN0L2luZGV4LmNqcyIsIndlYnBhY2s6Ly93ZWItYXNtLWppdC8uL25vZGVfbW9kdWxlcy9AbGV6ZXIvcHl0aG9uL2Rpc3QvaW5kZXguY2pzIiwid2VicGFjazovL3dlYi1hc20taml0L3dlYnBhY2svYm9vdHN0cmFwIiwid2VicGFjazovL3dlYi1hc20taml0L3dlYnBhY2svcnVudGltZS9jb21wYXQgZ2V0IGRlZmF1bHQgZXhwb3J0Iiwid2VicGFjazovL3dlYi1hc20taml0L3dlYnBhY2svcnVudGltZS9kZWZpbmUgcHJvcGVydHkgZ2V0dGVycyIsIndlYnBhY2s6Ly93ZWItYXNtLWppdC93ZWJwYWNrL3J1bnRpbWUvZ2xvYmFsIiwid2VicGFjazovL3dlYi1hc20taml0L3dlYnBhY2svcnVudGltZS9oYXNPd25Qcm9wZXJ0eSBzaG9ydGhhbmQiLCJ3ZWJwYWNrOi8vd2ViLWFzbS1qaXQvd2VicGFjay9ydW50aW1lL21ha2UgbmFtZXNwYWNlIG9iamVjdCIsIndlYnBhY2s6Ly93ZWItYXNtLWppdC93ZWJwYWNrL3J1bnRpbWUvanNvbnAgY2h1bmsgbG9hZGluZyIsIndlYnBhY2s6Ly93ZWItYXNtLWppdC93ZWJwYWNrL3J1bnRpbWUvbm9uY2UiLCJ3ZWJwYWNrOi8vd2ViLWFzbS1qaXQvd2VicGFjay9iZWZvcmUtc3RhcnR1cCIsIndlYnBhY2s6Ly93ZWItYXNtLWppdC93ZWJwYWNrL3N0YXJ0dXAiLCJ3ZWJwYWNrOi8vd2ViLWFzbS1qaXQvd2VicGFjay9hZnRlci1zdGFydHVwIl0sInNvdXJjZXNDb250ZW50IjpbIi8vIENvZGVNaXJyb3IsIGNvcHlyaWdodCAoYykgYnkgTWFyaWpuIEhhdmVyYmVrZSBhbmQgb3RoZXJzXG4vLyBEaXN0cmlidXRlZCB1bmRlciBhbiBNSVQgbGljZW5zZTogaHR0cHM6Ly9jb2RlbWlycm9yLm5ldC9MSUNFTlNFXG5cbihmdW5jdGlvbihtb2QpIHtcbiAgaWYgKHR5cGVvZiBleHBvcnRzID09IFwib2JqZWN0XCIgJiYgdHlwZW9mIG1vZHVsZSA9PSBcIm9iamVjdFwiKSAvLyBDb21tb25KU1xuICAgIG1vZChyZXF1aXJlKFwiLi4vLi4vbGliL2NvZGVtaXJyb3JcIikpO1xuICBlbHNlIGlmICh0eXBlb2YgZGVmaW5lID09IFwiZnVuY3Rpb25cIiAmJiBkZWZpbmUuYW1kKSAvLyBBTURcbiAgICBkZWZpbmUoW1wiLi4vLi4vbGliL2NvZGVtaXJyb3JcIl0sIG1vZCk7XG4gIGVsc2UgLy8gUGxhaW4gYnJvd3NlciBlbnZcbiAgICBtb2QoQ29kZU1pcnJvcik7XG59KShmdW5jdGlvbihDb2RlTWlycm9yKSB7XG4gIHZhciBkZWZhdWx0cyA9IHtcbiAgICBwYWlyczogXCIoKVtde30nJ1xcXCJcXFwiXCIsXG4gICAgY2xvc2VCZWZvcmU6IFwiKV19J1xcXCI6Oz5cIixcbiAgICB0cmlwbGVzOiBcIlwiLFxuICAgIGV4cGxvZGU6IFwiW117fVwiXG4gIH07XG5cbiAgdmFyIFBvcyA9IENvZGVNaXJyb3IuUG9zO1xuXG4gIENvZGVNaXJyb3IuZGVmaW5lT3B0aW9uKFwiYXV0b0Nsb3NlQnJhY2tldHNcIiwgZmFsc2UsIGZ1bmN0aW9uKGNtLCB2YWwsIG9sZCkge1xuICAgIGlmIChvbGQgJiYgb2xkICE9IENvZGVNaXJyb3IuSW5pdCkge1xuICAgICAgY20ucmVtb3ZlS2V5TWFwKGtleU1hcCk7XG4gICAgICBjbS5zdGF0ZS5jbG9zZUJyYWNrZXRzID0gbnVsbDtcbiAgICB9XG4gICAgaWYgKHZhbCkge1xuICAgICAgZW5zdXJlQm91bmQoZ2V0T3B0aW9uKHZhbCwgXCJwYWlyc1wiKSlcbiAgICAgIGNtLnN0YXRlLmNsb3NlQnJhY2tldHMgPSB2YWw7XG4gICAgICBjbS5hZGRLZXlNYXAoa2V5TWFwKTtcbiAgICB9XG4gIH0pO1xuXG4gIGZ1bmN0aW9uIGdldE9wdGlvbihjb25mLCBuYW1lKSB7XG4gICAgaWYgKG5hbWUgPT0gXCJwYWlyc1wiICYmIHR5cGVvZiBjb25mID09IFwic3RyaW5nXCIpIHJldHVybiBjb25mO1xuICAgIGlmICh0eXBlb2YgY29uZiA9PSBcIm9iamVjdFwiICYmIGNvbmZbbmFtZV0gIT0gbnVsbCkgcmV0dXJuIGNvbmZbbmFtZV07XG4gICAgcmV0dXJuIGRlZmF1bHRzW25hbWVdO1xuICB9XG5cbiAgdmFyIGtleU1hcCA9IHtCYWNrc3BhY2U6IGhhbmRsZUJhY2tzcGFjZSwgRW50ZXI6IGhhbmRsZUVudGVyfTtcbiAgZnVuY3Rpb24gZW5zdXJlQm91bmQoY2hhcnMpIHtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGNoYXJzLmxlbmd0aDsgaSsrKSB7XG4gICAgICB2YXIgY2ggPSBjaGFycy5jaGFyQXQoaSksIGtleSA9IFwiJ1wiICsgY2ggKyBcIidcIlxuICAgICAgaWYgKCFrZXlNYXBba2V5XSkga2V5TWFwW2tleV0gPSBoYW5kbGVyKGNoKVxuICAgIH1cbiAgfVxuICBlbnN1cmVCb3VuZChkZWZhdWx0cy5wYWlycyArIFwiYFwiKVxuXG4gIGZ1bmN0aW9uIGhhbmRsZXIoY2gpIHtcbiAgICByZXR1cm4gZnVuY3Rpb24oY20pIHsgcmV0dXJuIGhhbmRsZUNoYXIoY20sIGNoKTsgfTtcbiAgfVxuXG4gIGZ1bmN0aW9uIGdldENvbmZpZyhjbSkge1xuICAgIHZhciBkZWZsdCA9IGNtLnN0YXRlLmNsb3NlQnJhY2tldHM7XG4gICAgaWYgKCFkZWZsdCB8fCBkZWZsdC5vdmVycmlkZSkgcmV0dXJuIGRlZmx0O1xuICAgIHZhciBtb2RlID0gY20uZ2V0TW9kZUF0KGNtLmdldEN1cnNvcigpKTtcbiAgICByZXR1cm4gbW9kZS5jbG9zZUJyYWNrZXRzIHx8IGRlZmx0O1xuICB9XG5cbiAgZnVuY3Rpb24gaGFuZGxlQmFja3NwYWNlKGNtKSB7XG4gICAgdmFyIGNvbmYgPSBnZXRDb25maWcoY20pO1xuICAgIGlmICghY29uZiB8fCBjbS5nZXRPcHRpb24oXCJkaXNhYmxlSW5wdXRcIikpIHJldHVybiBDb2RlTWlycm9yLlBhc3M7XG5cbiAgICB2YXIgcGFpcnMgPSBnZXRPcHRpb24oY29uZiwgXCJwYWlyc1wiKTtcbiAgICB2YXIgcmFuZ2VzID0gY20ubGlzdFNlbGVjdGlvbnMoKTtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IHJhbmdlcy5sZW5ndGg7IGkrKykge1xuICAgICAgaWYgKCFyYW5nZXNbaV0uZW1wdHkoKSkgcmV0dXJuIENvZGVNaXJyb3IuUGFzcztcbiAgICAgIHZhciBhcm91bmQgPSBjaGFyc0Fyb3VuZChjbSwgcmFuZ2VzW2ldLmhlYWQpO1xuICAgICAgaWYgKCFhcm91bmQgfHwgcGFpcnMuaW5kZXhPZihhcm91bmQpICUgMiAhPSAwKSByZXR1cm4gQ29kZU1pcnJvci5QYXNzO1xuICAgIH1cbiAgICBmb3IgKHZhciBpID0gcmFuZ2VzLmxlbmd0aCAtIDE7IGkgPj0gMDsgaS0tKSB7XG4gICAgICB2YXIgY3VyID0gcmFuZ2VzW2ldLmhlYWQ7XG4gICAgICBjbS5yZXBsYWNlUmFuZ2UoXCJcIiwgUG9zKGN1ci5saW5lLCBjdXIuY2ggLSAxKSwgUG9zKGN1ci5saW5lLCBjdXIuY2ggKyAxKSwgXCIrZGVsZXRlXCIpO1xuICAgIH1cbiAgfVxuXG4gIGZ1bmN0aW9uIGhhbmRsZUVudGVyKGNtKSB7XG4gICAgdmFyIGNvbmYgPSBnZXRDb25maWcoY20pO1xuICAgIHZhciBleHBsb2RlID0gY29uZiAmJiBnZXRPcHRpb24oY29uZiwgXCJleHBsb2RlXCIpO1xuICAgIGlmICghZXhwbG9kZSB8fCBjbS5nZXRPcHRpb24oXCJkaXNhYmxlSW5wdXRcIikpIHJldHVybiBDb2RlTWlycm9yLlBhc3M7XG5cbiAgICB2YXIgcmFuZ2VzID0gY20ubGlzdFNlbGVjdGlvbnMoKTtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IHJhbmdlcy5sZW5ndGg7IGkrKykge1xuICAgICAgaWYgKCFyYW5nZXNbaV0uZW1wdHkoKSkgcmV0dXJuIENvZGVNaXJyb3IuUGFzcztcbiAgICAgIHZhciBhcm91bmQgPSBjaGFyc0Fyb3VuZChjbSwgcmFuZ2VzW2ldLmhlYWQpO1xuICAgICAgaWYgKCFhcm91bmQgfHwgZXhwbG9kZS5pbmRleE9mKGFyb3VuZCkgJSAyICE9IDApIHJldHVybiBDb2RlTWlycm9yLlBhc3M7XG4gICAgfVxuICAgIGNtLm9wZXJhdGlvbihmdW5jdGlvbigpIHtcbiAgICAgIHZhciBsaW5lc2VwID0gY20ubGluZVNlcGFyYXRvcigpIHx8IFwiXFxuXCI7XG4gICAgICBjbS5yZXBsYWNlU2VsZWN0aW9uKGxpbmVzZXAgKyBsaW5lc2VwLCBudWxsKTtcbiAgICAgIG1vdmVTZWwoY20sIC0xKVxuICAgICAgcmFuZ2VzID0gY20ubGlzdFNlbGVjdGlvbnMoKTtcbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgcmFuZ2VzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIHZhciBsaW5lID0gcmFuZ2VzW2ldLmhlYWQubGluZTtcbiAgICAgICAgY20uaW5kZW50TGluZShsaW5lLCBudWxsLCB0cnVlKTtcbiAgICAgICAgY20uaW5kZW50TGluZShsaW5lICsgMSwgbnVsbCwgdHJ1ZSk7XG4gICAgICB9XG4gICAgfSk7XG4gIH1cblxuICBmdW5jdGlvbiBtb3ZlU2VsKGNtLCBkaXIpIHtcbiAgICB2YXIgbmV3UmFuZ2VzID0gW10sIHJhbmdlcyA9IGNtLmxpc3RTZWxlY3Rpb25zKCksIHByaW1hcnkgPSAwXG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCByYW5nZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgIHZhciByYW5nZSA9IHJhbmdlc1tpXVxuICAgICAgaWYgKHJhbmdlLmhlYWQgPT0gY20uZ2V0Q3Vyc29yKCkpIHByaW1hcnkgPSBpXG4gICAgICB2YXIgcG9zID0gcmFuZ2UuaGVhZC5jaCB8fCBkaXIgPiAwID8ge2xpbmU6IHJhbmdlLmhlYWQubGluZSwgY2g6IHJhbmdlLmhlYWQuY2ggKyBkaXJ9IDoge2xpbmU6IHJhbmdlLmhlYWQubGluZSAtIDF9XG4gICAgICBuZXdSYW5nZXMucHVzaCh7YW5jaG9yOiBwb3MsIGhlYWQ6IHBvc30pXG4gICAgfVxuICAgIGNtLnNldFNlbGVjdGlvbnMobmV3UmFuZ2VzLCBwcmltYXJ5KVxuICB9XG5cbiAgZnVuY3Rpb24gY29udHJhY3RTZWxlY3Rpb24oc2VsKSB7XG4gICAgdmFyIGludmVydGVkID0gQ29kZU1pcnJvci5jbXBQb3Moc2VsLmFuY2hvciwgc2VsLmhlYWQpID4gMDtcbiAgICByZXR1cm4ge2FuY2hvcjogbmV3IFBvcyhzZWwuYW5jaG9yLmxpbmUsIHNlbC5hbmNob3IuY2ggKyAoaW52ZXJ0ZWQgPyAtMSA6IDEpKSxcbiAgICAgICAgICAgIGhlYWQ6IG5ldyBQb3Moc2VsLmhlYWQubGluZSwgc2VsLmhlYWQuY2ggKyAoaW52ZXJ0ZWQgPyAxIDogLTEpKX07XG4gIH1cblxuICBmdW5jdGlvbiBoYW5kbGVDaGFyKGNtLCBjaCkge1xuICAgIHZhciBjb25mID0gZ2V0Q29uZmlnKGNtKTtcbiAgICBpZiAoIWNvbmYgfHwgY20uZ2V0T3B0aW9uKFwiZGlzYWJsZUlucHV0XCIpKSByZXR1cm4gQ29kZU1pcnJvci5QYXNzO1xuXG4gICAgdmFyIHBhaXJzID0gZ2V0T3B0aW9uKGNvbmYsIFwicGFpcnNcIik7XG4gICAgdmFyIHBvcyA9IHBhaXJzLmluZGV4T2YoY2gpO1xuICAgIGlmIChwb3MgPT0gLTEpIHJldHVybiBDb2RlTWlycm9yLlBhc3M7XG5cbiAgICB2YXIgY2xvc2VCZWZvcmUgPSBnZXRPcHRpb24oY29uZixcImNsb3NlQmVmb3JlXCIpO1xuXG4gICAgdmFyIHRyaXBsZXMgPSBnZXRPcHRpb24oY29uZiwgXCJ0cmlwbGVzXCIpO1xuXG4gICAgdmFyIGlkZW50aWNhbCA9IHBhaXJzLmNoYXJBdChwb3MgKyAxKSA9PSBjaDtcbiAgICB2YXIgcmFuZ2VzID0gY20ubGlzdFNlbGVjdGlvbnMoKTtcbiAgICB2YXIgb3BlbmluZyA9IHBvcyAlIDIgPT0gMDtcblxuICAgIHZhciB0eXBlO1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgcmFuZ2VzLmxlbmd0aDsgaSsrKSB7XG4gICAgICB2YXIgcmFuZ2UgPSByYW5nZXNbaV0sIGN1ciA9IHJhbmdlLmhlYWQsIGN1clR5cGU7XG4gICAgICB2YXIgbmV4dCA9IGNtLmdldFJhbmdlKGN1ciwgUG9zKGN1ci5saW5lLCBjdXIuY2ggKyAxKSk7XG4gICAgICBpZiAob3BlbmluZyAmJiAhcmFuZ2UuZW1wdHkoKSkge1xuICAgICAgICBjdXJUeXBlID0gXCJzdXJyb3VuZFwiO1xuICAgICAgfSBlbHNlIGlmICgoaWRlbnRpY2FsIHx8ICFvcGVuaW5nKSAmJiBuZXh0ID09IGNoKSB7XG4gICAgICAgIGlmIChpZGVudGljYWwgJiYgc3RyaW5nU3RhcnRzQWZ0ZXIoY20sIGN1cikpXG4gICAgICAgICAgY3VyVHlwZSA9IFwiYm90aFwiO1xuICAgICAgICBlbHNlIGlmICh0cmlwbGVzLmluZGV4T2YoY2gpID49IDAgJiYgY20uZ2V0UmFuZ2UoY3VyLCBQb3MoY3VyLmxpbmUsIGN1ci5jaCArIDMpKSA9PSBjaCArIGNoICsgY2gpXG4gICAgICAgICAgY3VyVHlwZSA9IFwic2tpcFRocmVlXCI7XG4gICAgICAgIGVsc2VcbiAgICAgICAgICBjdXJUeXBlID0gXCJza2lwXCI7XG4gICAgICB9IGVsc2UgaWYgKGlkZW50aWNhbCAmJiBjdXIuY2ggPiAxICYmIHRyaXBsZXMuaW5kZXhPZihjaCkgPj0gMCAmJlxuICAgICAgICAgICAgICAgICBjbS5nZXRSYW5nZShQb3MoY3VyLmxpbmUsIGN1ci5jaCAtIDIpLCBjdXIpID09IGNoICsgY2gpIHtcbiAgICAgICAgaWYgKGN1ci5jaCA+IDIgJiYgL1xcYnN0cmluZy8udGVzdChjbS5nZXRUb2tlblR5cGVBdChQb3MoY3VyLmxpbmUsIGN1ci5jaCAtIDIpKSkpIHJldHVybiBDb2RlTWlycm9yLlBhc3M7XG4gICAgICAgIGN1clR5cGUgPSBcImFkZEZvdXJcIjtcbiAgICAgIH0gZWxzZSBpZiAoaWRlbnRpY2FsKSB7XG4gICAgICAgIHZhciBwcmV2ID0gY3VyLmNoID09IDAgPyBcIiBcIiA6IGNtLmdldFJhbmdlKFBvcyhjdXIubGluZSwgY3VyLmNoIC0gMSksIGN1cilcbiAgICAgICAgaWYgKCFDb2RlTWlycm9yLmlzV29yZENoYXIobmV4dCkgJiYgcHJldiAhPSBjaCAmJiAhQ29kZU1pcnJvci5pc1dvcmRDaGFyKHByZXYpKSBjdXJUeXBlID0gXCJib3RoXCI7XG4gICAgICAgIGVsc2UgcmV0dXJuIENvZGVNaXJyb3IuUGFzcztcbiAgICAgIH0gZWxzZSBpZiAob3BlbmluZyAmJiAobmV4dC5sZW5ndGggPT09IDAgfHwgL1xccy8udGVzdChuZXh0KSB8fCBjbG9zZUJlZm9yZS5pbmRleE9mKG5leHQpID4gLTEpKSB7XG4gICAgICAgIGN1clR5cGUgPSBcImJvdGhcIjtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHJldHVybiBDb2RlTWlycm9yLlBhc3M7XG4gICAgICB9XG4gICAgICBpZiAoIXR5cGUpIHR5cGUgPSBjdXJUeXBlO1xuICAgICAgZWxzZSBpZiAodHlwZSAhPSBjdXJUeXBlKSByZXR1cm4gQ29kZU1pcnJvci5QYXNzO1xuICAgIH1cblxuICAgIHZhciBsZWZ0ID0gcG9zICUgMiA/IHBhaXJzLmNoYXJBdChwb3MgLSAxKSA6IGNoO1xuICAgIHZhciByaWdodCA9IHBvcyAlIDIgPyBjaCA6IHBhaXJzLmNoYXJBdChwb3MgKyAxKTtcbiAgICBjbS5vcGVyYXRpb24oZnVuY3Rpb24oKSB7XG4gICAgICBpZiAodHlwZSA9PSBcInNraXBcIikge1xuICAgICAgICBtb3ZlU2VsKGNtLCAxKVxuICAgICAgfSBlbHNlIGlmICh0eXBlID09IFwic2tpcFRocmVlXCIpIHtcbiAgICAgICAgbW92ZVNlbChjbSwgMylcbiAgICAgIH0gZWxzZSBpZiAodHlwZSA9PSBcInN1cnJvdW5kXCIpIHtcbiAgICAgICAgdmFyIHNlbHMgPSBjbS5nZXRTZWxlY3Rpb25zKCk7XG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgc2Vscy5sZW5ndGg7IGkrKylcbiAgICAgICAgICBzZWxzW2ldID0gbGVmdCArIHNlbHNbaV0gKyByaWdodDtcbiAgICAgICAgY20ucmVwbGFjZVNlbGVjdGlvbnMoc2VscywgXCJhcm91bmRcIik7XG4gICAgICAgIHNlbHMgPSBjbS5saXN0U2VsZWN0aW9ucygpLnNsaWNlKCk7XG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgc2Vscy5sZW5ndGg7IGkrKylcbiAgICAgICAgICBzZWxzW2ldID0gY29udHJhY3RTZWxlY3Rpb24oc2Vsc1tpXSk7XG4gICAgICAgIGNtLnNldFNlbGVjdGlvbnMoc2Vscyk7XG4gICAgICB9IGVsc2UgaWYgKHR5cGUgPT0gXCJib3RoXCIpIHtcbiAgICAgICAgY20ucmVwbGFjZVNlbGVjdGlvbihsZWZ0ICsgcmlnaHQsIG51bGwpO1xuICAgICAgICBjbS50cmlnZ2VyRWxlY3RyaWMobGVmdCArIHJpZ2h0KTtcbiAgICAgICAgbW92ZVNlbChjbSwgLTEpXG4gICAgICB9IGVsc2UgaWYgKHR5cGUgPT0gXCJhZGRGb3VyXCIpIHtcbiAgICAgICAgY20ucmVwbGFjZVNlbGVjdGlvbihsZWZ0ICsgbGVmdCArIGxlZnQgKyBsZWZ0LCBcImJlZm9yZVwiKTtcbiAgICAgICAgbW92ZVNlbChjbSwgMSlcbiAgICAgIH1cbiAgICB9KTtcbiAgfVxuXG4gIGZ1bmN0aW9uIGNoYXJzQXJvdW5kKGNtLCBwb3MpIHtcbiAgICB2YXIgc3RyID0gY20uZ2V0UmFuZ2UoUG9zKHBvcy5saW5lLCBwb3MuY2ggLSAxKSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgUG9zKHBvcy5saW5lLCBwb3MuY2ggKyAxKSk7XG4gICAgcmV0dXJuIHN0ci5sZW5ndGggPT0gMiA/IHN0ciA6IG51bGw7XG4gIH1cblxuICBmdW5jdGlvbiBzdHJpbmdTdGFydHNBZnRlcihjbSwgcG9zKSB7XG4gICAgdmFyIHRva2VuID0gY20uZ2V0VG9rZW5BdChQb3MocG9zLmxpbmUsIHBvcy5jaCArIDEpKVxuICAgIHJldHVybiAvXFxic3RyaW5nLy50ZXN0KHRva2VuLnR5cGUpICYmIHRva2VuLnN0YXJ0ID09IHBvcy5jaCAmJlxuICAgICAgKHBvcy5jaCA9PSAwIHx8ICEvXFxic3RyaW5nLy50ZXN0KGNtLmdldFRva2VuVHlwZUF0KHBvcykpKVxuICB9XG59KTtcbiIsIi8vIENvZGVNaXJyb3IsIGNvcHlyaWdodCAoYykgYnkgTWFyaWpuIEhhdmVyYmVrZSBhbmQgb3RoZXJzXG4vLyBEaXN0cmlidXRlZCB1bmRlciBhbiBNSVQgbGljZW5zZTogaHR0cHM6Ly9jb2RlbWlycm9yLm5ldC9MSUNFTlNFXG5cbi8vIGRlY2xhcmUgZ2xvYmFsOiBET01SZWN0XG5cbihmdW5jdGlvbihtb2QpIHtcbiAgaWYgKHR5cGVvZiBleHBvcnRzID09IFwib2JqZWN0XCIgJiYgdHlwZW9mIG1vZHVsZSA9PSBcIm9iamVjdFwiKSAvLyBDb21tb25KU1xuICAgIG1vZChyZXF1aXJlKFwiLi4vLi4vbGliL2NvZGVtaXJyb3JcIikpO1xuICBlbHNlIGlmICh0eXBlb2YgZGVmaW5lID09IFwiZnVuY3Rpb25cIiAmJiBkZWZpbmUuYW1kKSAvLyBBTURcbiAgICBkZWZpbmUoW1wiLi4vLi4vbGliL2NvZGVtaXJyb3JcIl0sIG1vZCk7XG4gIGVsc2UgLy8gUGxhaW4gYnJvd3NlciBlbnZcbiAgICBtb2QoQ29kZU1pcnJvcik7XG59KShmdW5jdGlvbihDb2RlTWlycm9yKSB7XG4gIFwidXNlIHN0cmljdFwiO1xuXG4gIHZhciBISU5UX0VMRU1FTlRfQ0xBU1MgICAgICAgID0gXCJDb2RlTWlycm9yLWhpbnRcIjtcbiAgdmFyIEFDVElWRV9ISU5UX0VMRU1FTlRfQ0xBU1MgPSBcIkNvZGVNaXJyb3ItaGludC1hY3RpdmVcIjtcblxuICAvLyBUaGlzIGlzIHRoZSBvbGQgaW50ZXJmYWNlLCBrZXB0IGFyb3VuZCBmb3Igbm93IHRvIHN0YXlcbiAgLy8gYmFja3dhcmRzLWNvbXBhdGlibGUuXG4gIENvZGVNaXJyb3Iuc2hvd0hpbnQgPSBmdW5jdGlvbihjbSwgZ2V0SGludHMsIG9wdGlvbnMpIHtcbiAgICBpZiAoIWdldEhpbnRzKSByZXR1cm4gY20uc2hvd0hpbnQob3B0aW9ucyk7XG4gICAgaWYgKG9wdGlvbnMgJiYgb3B0aW9ucy5hc3luYykgZ2V0SGludHMuYXN5bmMgPSB0cnVlO1xuICAgIHZhciBuZXdPcHRzID0ge2hpbnQ6IGdldEhpbnRzfTtcbiAgICBpZiAob3B0aW9ucykgZm9yICh2YXIgcHJvcCBpbiBvcHRpb25zKSBuZXdPcHRzW3Byb3BdID0gb3B0aW9uc1twcm9wXTtcbiAgICByZXR1cm4gY20uc2hvd0hpbnQobmV3T3B0cyk7XG4gIH07XG5cbiAgQ29kZU1pcnJvci5kZWZpbmVFeHRlbnNpb24oXCJzaG93SGludFwiLCBmdW5jdGlvbihvcHRpb25zKSB7XG4gICAgb3B0aW9ucyA9IHBhcnNlT3B0aW9ucyh0aGlzLCB0aGlzLmdldEN1cnNvcihcInN0YXJ0XCIpLCBvcHRpb25zKTtcbiAgICB2YXIgc2VsZWN0aW9ucyA9IHRoaXMubGlzdFNlbGVjdGlvbnMoKVxuICAgIGlmIChzZWxlY3Rpb25zLmxlbmd0aCA+IDEpIHJldHVybjtcbiAgICAvLyBCeSBkZWZhdWx0LCBkb24ndCBhbGxvdyBjb21wbGV0aW9uIHdoZW4gc29tZXRoaW5nIGlzIHNlbGVjdGVkLlxuICAgIC8vIEEgaGludCBmdW5jdGlvbiBjYW4gaGF2ZSBhIGBzdXBwb3J0c1NlbGVjdGlvbmAgcHJvcGVydHkgdG9cbiAgICAvLyBpbmRpY2F0ZSB0aGF0IGl0IGNhbiBoYW5kbGUgc2VsZWN0aW9ucy5cbiAgICBpZiAodGhpcy5zb21ldGhpbmdTZWxlY3RlZCgpKSB7XG4gICAgICBpZiAoIW9wdGlvbnMuaGludC5zdXBwb3J0c1NlbGVjdGlvbikgcmV0dXJuO1xuICAgICAgLy8gRG9uJ3QgdHJ5IHdpdGggY3Jvc3MtbGluZSBzZWxlY3Rpb25zXG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHNlbGVjdGlvbnMubGVuZ3RoOyBpKyspXG4gICAgICAgIGlmIChzZWxlY3Rpb25zW2ldLmhlYWQubGluZSAhPSBzZWxlY3Rpb25zW2ldLmFuY2hvci5saW5lKSByZXR1cm47XG4gICAgfVxuXG4gICAgaWYgKHRoaXMuc3RhdGUuY29tcGxldGlvbkFjdGl2ZSkgdGhpcy5zdGF0ZS5jb21wbGV0aW9uQWN0aXZlLmNsb3NlKCk7XG4gICAgdmFyIGNvbXBsZXRpb24gPSB0aGlzLnN0YXRlLmNvbXBsZXRpb25BY3RpdmUgPSBuZXcgQ29tcGxldGlvbih0aGlzLCBvcHRpb25zKTtcbiAgICBpZiAoIWNvbXBsZXRpb24ub3B0aW9ucy5oaW50KSByZXR1cm47XG5cbiAgICBDb2RlTWlycm9yLnNpZ25hbCh0aGlzLCBcInN0YXJ0Q29tcGxldGlvblwiLCB0aGlzKTtcbiAgICBjb21wbGV0aW9uLnVwZGF0ZSh0cnVlKTtcbiAgfSk7XG5cbiAgQ29kZU1pcnJvci5kZWZpbmVFeHRlbnNpb24oXCJjbG9zZUhpbnRcIiwgZnVuY3Rpb24oKSB7XG4gICAgaWYgKHRoaXMuc3RhdGUuY29tcGxldGlvbkFjdGl2ZSkgdGhpcy5zdGF0ZS5jb21wbGV0aW9uQWN0aXZlLmNsb3NlKClcbiAgfSlcblxuICBmdW5jdGlvbiBDb21wbGV0aW9uKGNtLCBvcHRpb25zKSB7XG4gICAgdGhpcy5jbSA9IGNtO1xuICAgIHRoaXMub3B0aW9ucyA9IG9wdGlvbnM7XG4gICAgdGhpcy53aWRnZXQgPSBudWxsO1xuICAgIHRoaXMuZGVib3VuY2UgPSAwO1xuICAgIHRoaXMudGljayA9IDA7XG4gICAgdGhpcy5zdGFydFBvcyA9IHRoaXMuY20uZ2V0Q3Vyc29yKFwic3RhcnRcIik7XG4gICAgdGhpcy5zdGFydExlbiA9IHRoaXMuY20uZ2V0TGluZSh0aGlzLnN0YXJ0UG9zLmxpbmUpLmxlbmd0aCAtIHRoaXMuY20uZ2V0U2VsZWN0aW9uKCkubGVuZ3RoO1xuXG4gICAgaWYgKHRoaXMub3B0aW9ucy51cGRhdGVPbkN1cnNvckFjdGl2aXR5KSB7XG4gICAgICB2YXIgc2VsZiA9IHRoaXM7XG4gICAgICBjbS5vbihcImN1cnNvckFjdGl2aXR5XCIsIHRoaXMuYWN0aXZpdHlGdW5jID0gZnVuY3Rpb24oKSB7IHNlbGYuY3Vyc29yQWN0aXZpdHkoKTsgfSk7XG4gICAgfVxuICB9XG5cbiAgdmFyIHJlcXVlc3RBbmltYXRpb25GcmFtZSA9IHdpbmRvdy5yZXF1ZXN0QW5pbWF0aW9uRnJhbWUgfHwgZnVuY3Rpb24oZm4pIHtcbiAgICByZXR1cm4gc2V0VGltZW91dChmbiwgMTAwMC82MCk7XG4gIH07XG4gIHZhciBjYW5jZWxBbmltYXRpb25GcmFtZSA9IHdpbmRvdy5jYW5jZWxBbmltYXRpb25GcmFtZSB8fCBjbGVhclRpbWVvdXQ7XG5cbiAgQ29tcGxldGlvbi5wcm90b3R5cGUgPSB7XG4gICAgY2xvc2U6IGZ1bmN0aW9uKCkge1xuICAgICAgaWYgKCF0aGlzLmFjdGl2ZSgpKSByZXR1cm47XG4gICAgICB0aGlzLmNtLnN0YXRlLmNvbXBsZXRpb25BY3RpdmUgPSBudWxsO1xuICAgICAgdGhpcy50aWNrID0gbnVsbDtcbiAgICAgIGlmICh0aGlzLm9wdGlvbnMudXBkYXRlT25DdXJzb3JBY3Rpdml0eSkge1xuICAgICAgICB0aGlzLmNtLm9mZihcImN1cnNvckFjdGl2aXR5XCIsIHRoaXMuYWN0aXZpdHlGdW5jKTtcbiAgICAgIH1cblxuICAgICAgaWYgKHRoaXMud2lkZ2V0ICYmIHRoaXMuZGF0YSkgQ29kZU1pcnJvci5zaWduYWwodGhpcy5kYXRhLCBcImNsb3NlXCIpO1xuICAgICAgaWYgKHRoaXMud2lkZ2V0KSB0aGlzLndpZGdldC5jbG9zZSgpO1xuICAgICAgQ29kZU1pcnJvci5zaWduYWwodGhpcy5jbSwgXCJlbmRDb21wbGV0aW9uXCIsIHRoaXMuY20pO1xuICAgIH0sXG5cbiAgICBhY3RpdmU6IGZ1bmN0aW9uKCkge1xuICAgICAgcmV0dXJuIHRoaXMuY20uc3RhdGUuY29tcGxldGlvbkFjdGl2ZSA9PSB0aGlzO1xuICAgIH0sXG5cbiAgICBwaWNrOiBmdW5jdGlvbihkYXRhLCBpKSB7XG4gICAgICB2YXIgY29tcGxldGlvbiA9IGRhdGEubGlzdFtpXSwgc2VsZiA9IHRoaXM7XG4gICAgICB0aGlzLmNtLm9wZXJhdGlvbihmdW5jdGlvbigpIHtcbiAgICAgICAgaWYgKGNvbXBsZXRpb24uaGludClcbiAgICAgICAgICBjb21wbGV0aW9uLmhpbnQoc2VsZi5jbSwgZGF0YSwgY29tcGxldGlvbik7XG4gICAgICAgIGVsc2VcbiAgICAgICAgICBzZWxmLmNtLnJlcGxhY2VSYW5nZShnZXRUZXh0KGNvbXBsZXRpb24pLCBjb21wbGV0aW9uLmZyb20gfHwgZGF0YS5mcm9tLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbXBsZXRpb24udG8gfHwgZGF0YS50bywgXCJjb21wbGV0ZVwiKTtcbiAgICAgICAgQ29kZU1pcnJvci5zaWduYWwoZGF0YSwgXCJwaWNrXCIsIGNvbXBsZXRpb24pO1xuICAgICAgICBzZWxmLmNtLnNjcm9sbEludG9WaWV3KCk7XG4gICAgICB9KTtcbiAgICAgIGlmICh0aGlzLm9wdGlvbnMuY2xvc2VPblBpY2spIHtcbiAgICAgICAgdGhpcy5jbG9zZSgpO1xuICAgICAgfVxuICAgIH0sXG5cbiAgICBjdXJzb3JBY3Rpdml0eTogZnVuY3Rpb24oKSB7XG4gICAgICBpZiAodGhpcy5kZWJvdW5jZSkge1xuICAgICAgICBjYW5jZWxBbmltYXRpb25GcmFtZSh0aGlzLmRlYm91bmNlKTtcbiAgICAgICAgdGhpcy5kZWJvdW5jZSA9IDA7XG4gICAgICB9XG5cbiAgICAgIHZhciBpZGVudFN0YXJ0ID0gdGhpcy5zdGFydFBvcztcbiAgICAgIGlmKHRoaXMuZGF0YSkge1xuICAgICAgICBpZGVudFN0YXJ0ID0gdGhpcy5kYXRhLmZyb207XG4gICAgICB9XG5cbiAgICAgIHZhciBwb3MgPSB0aGlzLmNtLmdldEN1cnNvcigpLCBsaW5lID0gdGhpcy5jbS5nZXRMaW5lKHBvcy5saW5lKTtcbiAgICAgIGlmIChwb3MubGluZSAhPSB0aGlzLnN0YXJ0UG9zLmxpbmUgfHwgbGluZS5sZW5ndGggLSBwb3MuY2ggIT0gdGhpcy5zdGFydExlbiAtIHRoaXMuc3RhcnRQb3MuY2ggfHxcbiAgICAgICAgICBwb3MuY2ggPCBpZGVudFN0YXJ0LmNoIHx8IHRoaXMuY20uc29tZXRoaW5nU2VsZWN0ZWQoKSB8fFxuICAgICAgICAgICghcG9zLmNoIHx8IHRoaXMub3B0aW9ucy5jbG9zZUNoYXJhY3RlcnMudGVzdChsaW5lLmNoYXJBdChwb3MuY2ggLSAxKSkpKSB7XG4gICAgICAgIHRoaXMuY2xvc2UoKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHZhciBzZWxmID0gdGhpcztcbiAgICAgICAgdGhpcy5kZWJvdW5jZSA9IHJlcXVlc3RBbmltYXRpb25GcmFtZShmdW5jdGlvbigpIHtzZWxmLnVwZGF0ZSgpO30pO1xuICAgICAgICBpZiAodGhpcy53aWRnZXQpIHRoaXMud2lkZ2V0LmRpc2FibGUoKTtcbiAgICAgIH1cbiAgICB9LFxuXG4gICAgdXBkYXRlOiBmdW5jdGlvbihmaXJzdCkge1xuICAgICAgaWYgKHRoaXMudGljayA9PSBudWxsKSByZXR1cm5cbiAgICAgIHZhciBzZWxmID0gdGhpcywgbXlUaWNrID0gKyt0aGlzLnRpY2tcbiAgICAgIGZldGNoSGludHModGhpcy5vcHRpb25zLmhpbnQsIHRoaXMuY20sIHRoaXMub3B0aW9ucywgZnVuY3Rpb24oZGF0YSkge1xuICAgICAgICBpZiAoc2VsZi50aWNrID09IG15VGljaykgc2VsZi5maW5pc2hVcGRhdGUoZGF0YSwgZmlyc3QpXG4gICAgICB9KVxuICAgIH0sXG5cbiAgICBmaW5pc2hVcGRhdGU6IGZ1bmN0aW9uKGRhdGEsIGZpcnN0KSB7XG4gICAgICBpZiAodGhpcy5kYXRhKSBDb2RlTWlycm9yLnNpZ25hbCh0aGlzLmRhdGEsIFwidXBkYXRlXCIpO1xuXG4gICAgICB2YXIgcGlja2VkID0gKHRoaXMud2lkZ2V0ICYmIHRoaXMud2lkZ2V0LnBpY2tlZCkgfHwgKGZpcnN0ICYmIHRoaXMub3B0aW9ucy5jb21wbGV0ZVNpbmdsZSk7XG4gICAgICBpZiAodGhpcy53aWRnZXQpIHRoaXMud2lkZ2V0LmNsb3NlKCk7XG5cbiAgICAgIHRoaXMuZGF0YSA9IGRhdGE7XG5cbiAgICAgIGlmIChkYXRhICYmIGRhdGEubGlzdC5sZW5ndGgpIHtcbiAgICAgICAgaWYgKHBpY2tlZCAmJiBkYXRhLmxpc3QubGVuZ3RoID09IDEpIHtcbiAgICAgICAgICB0aGlzLnBpY2soZGF0YSwgMCk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgdGhpcy53aWRnZXQgPSBuZXcgV2lkZ2V0KHRoaXMsIGRhdGEpO1xuICAgICAgICAgIENvZGVNaXJyb3Iuc2lnbmFsKGRhdGEsIFwic2hvd25cIik7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gIH07XG5cbiAgZnVuY3Rpb24gcGFyc2VPcHRpb25zKGNtLCBwb3MsIG9wdGlvbnMpIHtcbiAgICB2YXIgZWRpdG9yID0gY20ub3B0aW9ucy5oaW50T3B0aW9ucztcbiAgICB2YXIgb3V0ID0ge307XG4gICAgZm9yICh2YXIgcHJvcCBpbiBkZWZhdWx0T3B0aW9ucykgb3V0W3Byb3BdID0gZGVmYXVsdE9wdGlvbnNbcHJvcF07XG4gICAgaWYgKGVkaXRvcikgZm9yICh2YXIgcHJvcCBpbiBlZGl0b3IpXG4gICAgICBpZiAoZWRpdG9yW3Byb3BdICE9PSB1bmRlZmluZWQpIG91dFtwcm9wXSA9IGVkaXRvcltwcm9wXTtcbiAgICBpZiAob3B0aW9ucykgZm9yICh2YXIgcHJvcCBpbiBvcHRpb25zKVxuICAgICAgaWYgKG9wdGlvbnNbcHJvcF0gIT09IHVuZGVmaW5lZCkgb3V0W3Byb3BdID0gb3B0aW9uc1twcm9wXTtcbiAgICBpZiAob3V0LmhpbnQucmVzb2x2ZSkgb3V0LmhpbnQgPSBvdXQuaGludC5yZXNvbHZlKGNtLCBwb3MpXG4gICAgcmV0dXJuIG91dDtcbiAgfVxuXG4gIGZ1bmN0aW9uIGdldFRleHQoY29tcGxldGlvbikge1xuICAgIGlmICh0eXBlb2YgY29tcGxldGlvbiA9PSBcInN0cmluZ1wiKSByZXR1cm4gY29tcGxldGlvbjtcbiAgICBlbHNlIHJldHVybiBjb21wbGV0aW9uLnRleHQ7XG4gIH1cblxuICBmdW5jdGlvbiBidWlsZEtleU1hcChjb21wbGV0aW9uLCBoYW5kbGUpIHtcbiAgICB2YXIgYmFzZU1hcCA9IHtcbiAgICAgIFVwOiBmdW5jdGlvbigpIHtoYW5kbGUubW92ZUZvY3VzKC0xKTt9LFxuICAgICAgRG93bjogZnVuY3Rpb24oKSB7aGFuZGxlLm1vdmVGb2N1cygxKTt9LFxuICAgICAgUGFnZVVwOiBmdW5jdGlvbigpIHtoYW5kbGUubW92ZUZvY3VzKC1oYW5kbGUubWVudVNpemUoKSArIDEsIHRydWUpO30sXG4gICAgICBQYWdlRG93bjogZnVuY3Rpb24oKSB7aGFuZGxlLm1vdmVGb2N1cyhoYW5kbGUubWVudVNpemUoKSAtIDEsIHRydWUpO30sXG4gICAgICBIb21lOiBmdW5jdGlvbigpIHtoYW5kbGUuc2V0Rm9jdXMoMCk7fSxcbiAgICAgIEVuZDogZnVuY3Rpb24oKSB7aGFuZGxlLnNldEZvY3VzKGhhbmRsZS5sZW5ndGggLSAxKTt9LFxuICAgICAgRW50ZXI6IGhhbmRsZS5waWNrLFxuICAgICAgVGFiOiBoYW5kbGUucGljayxcbiAgICAgIEVzYzogaGFuZGxlLmNsb3NlXG4gICAgfTtcblxuICAgIHZhciBtYWMgPSAvTWFjLy50ZXN0KG5hdmlnYXRvci5wbGF0Zm9ybSk7XG5cbiAgICBpZiAobWFjKSB7XG4gICAgICBiYXNlTWFwW1wiQ3RybC1QXCJdID0gZnVuY3Rpb24oKSB7aGFuZGxlLm1vdmVGb2N1cygtMSk7fTtcbiAgICAgIGJhc2VNYXBbXCJDdHJsLU5cIl0gPSBmdW5jdGlvbigpIHtoYW5kbGUubW92ZUZvY3VzKDEpO307XG4gICAgfVxuXG4gICAgdmFyIGN1c3RvbSA9IGNvbXBsZXRpb24ub3B0aW9ucy5jdXN0b21LZXlzO1xuICAgIHZhciBvdXJNYXAgPSBjdXN0b20gPyB7fSA6IGJhc2VNYXA7XG4gICAgZnVuY3Rpb24gYWRkQmluZGluZyhrZXksIHZhbCkge1xuICAgICAgdmFyIGJvdW5kO1xuICAgICAgaWYgKHR5cGVvZiB2YWwgIT0gXCJzdHJpbmdcIilcbiAgICAgICAgYm91bmQgPSBmdW5jdGlvbihjbSkgeyByZXR1cm4gdmFsKGNtLCBoYW5kbGUpOyB9O1xuICAgICAgLy8gVGhpcyBtZWNoYW5pc20gaXMgZGVwcmVjYXRlZFxuICAgICAgZWxzZSBpZiAoYmFzZU1hcC5oYXNPd25Qcm9wZXJ0eSh2YWwpKVxuICAgICAgICBib3VuZCA9IGJhc2VNYXBbdmFsXTtcbiAgICAgIGVsc2VcbiAgICAgICAgYm91bmQgPSB2YWw7XG4gICAgICBvdXJNYXBba2V5XSA9IGJvdW5kO1xuICAgIH1cbiAgICBpZiAoY3VzdG9tKVxuICAgICAgZm9yICh2YXIga2V5IGluIGN1c3RvbSkgaWYgKGN1c3RvbS5oYXNPd25Qcm9wZXJ0eShrZXkpKVxuICAgICAgICBhZGRCaW5kaW5nKGtleSwgY3VzdG9tW2tleV0pO1xuICAgIHZhciBleHRyYSA9IGNvbXBsZXRpb24ub3B0aW9ucy5leHRyYUtleXM7XG4gICAgaWYgKGV4dHJhKVxuICAgICAgZm9yICh2YXIga2V5IGluIGV4dHJhKSBpZiAoZXh0cmEuaGFzT3duUHJvcGVydHkoa2V5KSlcbiAgICAgICAgYWRkQmluZGluZyhrZXksIGV4dHJhW2tleV0pO1xuICAgIHJldHVybiBvdXJNYXA7XG4gIH1cblxuICBmdW5jdGlvbiBnZXRIaW50RWxlbWVudChoaW50c0VsZW1lbnQsIGVsKSB7XG4gICAgd2hpbGUgKGVsICYmIGVsICE9IGhpbnRzRWxlbWVudCkge1xuICAgICAgaWYgKGVsLm5vZGVOYW1lLnRvVXBwZXJDYXNlKCkgPT09IFwiTElcIiAmJiBlbC5wYXJlbnROb2RlID09IGhpbnRzRWxlbWVudCkgcmV0dXJuIGVsO1xuICAgICAgZWwgPSBlbC5wYXJlbnROb2RlO1xuICAgIH1cbiAgfVxuXG4gIGZ1bmN0aW9uIFdpZGdldChjb21wbGV0aW9uLCBkYXRhKSB7XG4gICAgdGhpcy5pZCA9IFwiY20tY29tcGxldGUtXCIgKyBNYXRoLmZsb29yKE1hdGgucmFuZG9tKDFlNikpXG4gICAgdGhpcy5jb21wbGV0aW9uID0gY29tcGxldGlvbjtcbiAgICB0aGlzLmRhdGEgPSBkYXRhO1xuICAgIHRoaXMucGlja2VkID0gZmFsc2U7XG4gICAgdmFyIHdpZGdldCA9IHRoaXMsIGNtID0gY29tcGxldGlvbi5jbTtcbiAgICB2YXIgb3duZXJEb2N1bWVudCA9IGNtLmdldElucHV0RmllbGQoKS5vd25lckRvY3VtZW50O1xuICAgIHZhciBwYXJlbnRXaW5kb3cgPSBvd25lckRvY3VtZW50LmRlZmF1bHRWaWV3IHx8IG93bmVyRG9jdW1lbnQucGFyZW50V2luZG93O1xuXG4gICAgdmFyIGhpbnRzID0gdGhpcy5oaW50cyA9IG93bmVyRG9jdW1lbnQuY3JlYXRlRWxlbWVudChcInVsXCIpO1xuICAgIGhpbnRzLnNldEF0dHJpYnV0ZShcInJvbGVcIiwgXCJsaXN0Ym94XCIpXG4gICAgaGludHMuc2V0QXR0cmlidXRlKFwiYXJpYS1leHBhbmRlZFwiLCBcInRydWVcIilcbiAgICBoaW50cy5pZCA9IHRoaXMuaWRcbiAgICB2YXIgdGhlbWUgPSBjb21wbGV0aW9uLmNtLm9wdGlvbnMudGhlbWU7XG4gICAgaGludHMuY2xhc3NOYW1lID0gXCJDb2RlTWlycm9yLWhpbnRzIFwiICsgdGhlbWU7XG4gICAgdGhpcy5zZWxlY3RlZEhpbnQgPSBkYXRhLnNlbGVjdGVkSGludCB8fCAwO1xuXG4gICAgdmFyIGNvbXBsZXRpb25zID0gZGF0YS5saXN0O1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgY29tcGxldGlvbnMubGVuZ3RoOyArK2kpIHtcbiAgICAgIHZhciBlbHQgPSBoaW50cy5hcHBlbmRDaGlsZChvd25lckRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJsaVwiKSksIGN1ciA9IGNvbXBsZXRpb25zW2ldO1xuICAgICAgdmFyIGNsYXNzTmFtZSA9IEhJTlRfRUxFTUVOVF9DTEFTUyArIChpICE9IHRoaXMuc2VsZWN0ZWRIaW50ID8gXCJcIiA6IFwiIFwiICsgQUNUSVZFX0hJTlRfRUxFTUVOVF9DTEFTUyk7XG4gICAgICBpZiAoY3VyLmNsYXNzTmFtZSAhPSBudWxsKSBjbGFzc05hbWUgPSBjdXIuY2xhc3NOYW1lICsgXCIgXCIgKyBjbGFzc05hbWU7XG4gICAgICBlbHQuY2xhc3NOYW1lID0gY2xhc3NOYW1lO1xuICAgICAgaWYgKGkgPT0gdGhpcy5zZWxlY3RlZEhpbnQpIGVsdC5zZXRBdHRyaWJ1dGUoXCJhcmlhLXNlbGVjdGVkXCIsIFwidHJ1ZVwiKVxuICAgICAgZWx0LmlkID0gdGhpcy5pZCArIFwiLVwiICsgaVxuICAgICAgZWx0LnNldEF0dHJpYnV0ZShcInJvbGVcIiwgXCJvcHRpb25cIilcbiAgICAgIGlmIChjdXIucmVuZGVyKSBjdXIucmVuZGVyKGVsdCwgZGF0YSwgY3VyKTtcbiAgICAgIGVsc2UgZWx0LmFwcGVuZENoaWxkKG93bmVyRG9jdW1lbnQuY3JlYXRlVGV4dE5vZGUoY3VyLmRpc3BsYXlUZXh0IHx8IGdldFRleHQoY3VyKSkpO1xuICAgICAgZWx0LmhpbnRJZCA9IGk7XG4gICAgfVxuXG4gICAgdmFyIGNvbnRhaW5lciA9IGNvbXBsZXRpb24ub3B0aW9ucy5jb250YWluZXIgfHwgb3duZXJEb2N1bWVudC5ib2R5O1xuICAgIHZhciBwb3MgPSBjbS5jdXJzb3JDb29yZHMoY29tcGxldGlvbi5vcHRpb25zLmFsaWduV2l0aFdvcmQgPyBkYXRhLmZyb20gOiBudWxsKTtcbiAgICB2YXIgbGVmdCA9IHBvcy5sZWZ0LCB0b3AgPSBwb3MuYm90dG9tLCBiZWxvdyA9IHRydWU7XG4gICAgdmFyIG9mZnNldExlZnQgPSAwLCBvZmZzZXRUb3AgPSAwO1xuICAgIGlmIChjb250YWluZXIgIT09IG93bmVyRG9jdW1lbnQuYm9keSkge1xuICAgICAgLy8gV2Ugb2Zmc2V0IHRoZSBjdXJzb3IgcG9zaXRpb24gYmVjYXVzZSBsZWZ0IGFuZCB0b3AgYXJlIHJlbGF0aXZlIHRvIHRoZSBvZmZzZXRQYXJlbnQncyB0b3AgbGVmdCBjb3JuZXIuXG4gICAgICB2YXIgaXNDb250YWluZXJQb3NpdGlvbmVkID0gWydhYnNvbHV0ZScsICdyZWxhdGl2ZScsICdmaXhlZCddLmluZGV4T2YocGFyZW50V2luZG93LmdldENvbXB1dGVkU3R5bGUoY29udGFpbmVyKS5wb3NpdGlvbikgIT09IC0xO1xuICAgICAgdmFyIG9mZnNldFBhcmVudCA9IGlzQ29udGFpbmVyUG9zaXRpb25lZCA/IGNvbnRhaW5lciA6IGNvbnRhaW5lci5vZmZzZXRQYXJlbnQ7XG4gICAgICB2YXIgb2Zmc2V0UGFyZW50UG9zaXRpb24gPSBvZmZzZXRQYXJlbnQuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCk7XG4gICAgICB2YXIgYm9keVBvc2l0aW9uID0gb3duZXJEb2N1bWVudC5ib2R5LmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpO1xuICAgICAgb2Zmc2V0TGVmdCA9IChvZmZzZXRQYXJlbnRQb3NpdGlvbi5sZWZ0IC0gYm9keVBvc2l0aW9uLmxlZnQgLSBvZmZzZXRQYXJlbnQuc2Nyb2xsTGVmdCk7XG4gICAgICBvZmZzZXRUb3AgPSAob2Zmc2V0UGFyZW50UG9zaXRpb24udG9wIC0gYm9keVBvc2l0aW9uLnRvcCAtIG9mZnNldFBhcmVudC5zY3JvbGxUb3ApO1xuICAgIH1cbiAgICBoaW50cy5zdHlsZS5sZWZ0ID0gKGxlZnQgLSBvZmZzZXRMZWZ0KSArIFwicHhcIjtcbiAgICBoaW50cy5zdHlsZS50b3AgPSAodG9wIC0gb2Zmc2V0VG9wKSArIFwicHhcIjtcblxuICAgIC8vIElmIHdlJ3JlIGF0IHRoZSBlZGdlIG9mIHRoZSBzY3JlZW4sIHRoZW4gd2Ugd2FudCB0aGUgbWVudSB0byBhcHBlYXIgb24gdGhlIGxlZnQgb2YgdGhlIGN1cnNvci5cbiAgICB2YXIgd2luVyA9IHBhcmVudFdpbmRvdy5pbm5lcldpZHRoIHx8IE1hdGgubWF4KG93bmVyRG9jdW1lbnQuYm9keS5vZmZzZXRXaWR0aCwgb3duZXJEb2N1bWVudC5kb2N1bWVudEVsZW1lbnQub2Zmc2V0V2lkdGgpO1xuICAgIHZhciB3aW5IID0gcGFyZW50V2luZG93LmlubmVySGVpZ2h0IHx8IE1hdGgubWF4KG93bmVyRG9jdW1lbnQuYm9keS5vZmZzZXRIZWlnaHQsIG93bmVyRG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50Lm9mZnNldEhlaWdodCk7XG4gICAgY29udGFpbmVyLmFwcGVuZENoaWxkKGhpbnRzKTtcbiAgICBjbS5nZXRJbnB1dEZpZWxkKCkuc2V0QXR0cmlidXRlKFwiYXJpYS1hdXRvY29tcGxldGVcIiwgXCJsaXN0XCIpXG4gICAgY20uZ2V0SW5wdXRGaWVsZCgpLnNldEF0dHJpYnV0ZShcImFyaWEtb3duc1wiLCB0aGlzLmlkKVxuICAgIGNtLmdldElucHV0RmllbGQoKS5zZXRBdHRyaWJ1dGUoXCJhcmlhLWFjdGl2ZWRlc2NlbmRhbnRcIiwgdGhpcy5pZCArIFwiLVwiICsgdGhpcy5zZWxlY3RlZEhpbnQpXG5cbiAgICB2YXIgYm94ID0gY29tcGxldGlvbi5vcHRpb25zLm1vdmVPbk92ZXJsYXAgPyBoaW50cy5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKSA6IG5ldyBET01SZWN0KCk7XG4gICAgdmFyIHNjcm9sbHMgPSBjb21wbGV0aW9uLm9wdGlvbnMucGFkZGluZ0ZvclNjcm9sbGJhciA/IGhpbnRzLnNjcm9sbEhlaWdodCA+IGhpbnRzLmNsaWVudEhlaWdodCArIDEgOiBmYWxzZTtcblxuICAgIC8vIENvbXB1dGUgaW4gdGhlIHRpbWVvdXQgdG8gYXZvaWQgcmVmbG93IG9uIGluaXRcbiAgICB2YXIgc3RhcnRTY3JvbGw7XG4gICAgc2V0VGltZW91dChmdW5jdGlvbigpIHsgc3RhcnRTY3JvbGwgPSBjbS5nZXRTY3JvbGxJbmZvKCk7IH0pO1xuXG4gICAgdmFyIG92ZXJsYXBZID0gYm94LmJvdHRvbSAtIHdpbkg7XG4gICAgaWYgKG92ZXJsYXBZID4gMCkge1xuICAgICAgdmFyIGhlaWdodCA9IGJveC5ib3R0b20gLSBib3gudG9wLCBjdXJUb3AgPSBwb3MudG9wIC0gKHBvcy5ib3R0b20gLSBib3gudG9wKTtcbiAgICAgIGlmIChjdXJUb3AgLSBoZWlnaHQgPiAwKSB7IC8vIEZpdHMgYWJvdmUgY3Vyc29yXG4gICAgICAgIGhpbnRzLnN0eWxlLnRvcCA9ICh0b3AgPSBwb3MudG9wIC0gaGVpZ2h0IC0gb2Zmc2V0VG9wKSArIFwicHhcIjtcbiAgICAgICAgYmVsb3cgPSBmYWxzZTtcbiAgICAgIH0gZWxzZSBpZiAoaGVpZ2h0ID4gd2luSCkge1xuICAgICAgICBoaW50cy5zdHlsZS5oZWlnaHQgPSAod2luSCAtIDUpICsgXCJweFwiO1xuICAgICAgICBoaW50cy5zdHlsZS50b3AgPSAodG9wID0gcG9zLmJvdHRvbSAtIGJveC50b3AgLSBvZmZzZXRUb3ApICsgXCJweFwiO1xuICAgICAgICB2YXIgY3Vyc29yID0gY20uZ2V0Q3Vyc29yKCk7XG4gICAgICAgIGlmIChkYXRhLmZyb20uY2ggIT0gY3Vyc29yLmNoKSB7XG4gICAgICAgICAgcG9zID0gY20uY3Vyc29yQ29vcmRzKGN1cnNvcik7XG4gICAgICAgICAgaGludHMuc3R5bGUubGVmdCA9IChsZWZ0ID0gcG9zLmxlZnQgLSBvZmZzZXRMZWZ0KSArIFwicHhcIjtcbiAgICAgICAgICBib3ggPSBoaW50cy5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgICB2YXIgb3ZlcmxhcFggPSBib3gucmlnaHQgLSB3aW5XO1xuICAgIGlmIChzY3JvbGxzKSBvdmVybGFwWCArPSBjbS5kaXNwbGF5Lm5hdGl2ZUJhcldpZHRoO1xuICAgIGlmIChvdmVybGFwWCA+IDApIHtcbiAgICAgIGlmIChib3gucmlnaHQgLSBib3gubGVmdCA+IHdpblcpIHtcbiAgICAgICAgaGludHMuc3R5bGUud2lkdGggPSAod2luVyAtIDUpICsgXCJweFwiO1xuICAgICAgICBvdmVybGFwWCAtPSAoYm94LnJpZ2h0IC0gYm94LmxlZnQpIC0gd2luVztcbiAgICAgIH1cbiAgICAgIGhpbnRzLnN0eWxlLmxlZnQgPSAobGVmdCA9IHBvcy5sZWZ0IC0gb3ZlcmxhcFggLSBvZmZzZXRMZWZ0KSArIFwicHhcIjtcbiAgICB9XG4gICAgaWYgKHNjcm9sbHMpIGZvciAodmFyIG5vZGUgPSBoaW50cy5maXJzdENoaWxkOyBub2RlOyBub2RlID0gbm9kZS5uZXh0U2libGluZylcbiAgICAgIG5vZGUuc3R5bGUucGFkZGluZ1JpZ2h0ID0gY20uZGlzcGxheS5uYXRpdmVCYXJXaWR0aCArIFwicHhcIlxuXG4gICAgY20uYWRkS2V5TWFwKHRoaXMua2V5TWFwID0gYnVpbGRLZXlNYXAoY29tcGxldGlvbiwge1xuICAgICAgbW92ZUZvY3VzOiBmdW5jdGlvbihuLCBhdm9pZFdyYXApIHsgd2lkZ2V0LmNoYW5nZUFjdGl2ZSh3aWRnZXQuc2VsZWN0ZWRIaW50ICsgbiwgYXZvaWRXcmFwKTsgfSxcbiAgICAgIHNldEZvY3VzOiBmdW5jdGlvbihuKSB7IHdpZGdldC5jaGFuZ2VBY3RpdmUobik7IH0sXG4gICAgICBtZW51U2l6ZTogZnVuY3Rpb24oKSB7IHJldHVybiB3aWRnZXQuc2NyZWVuQW1vdW50KCk7IH0sXG4gICAgICBsZW5ndGg6IGNvbXBsZXRpb25zLmxlbmd0aCxcbiAgICAgIGNsb3NlOiBmdW5jdGlvbigpIHsgY29tcGxldGlvbi5jbG9zZSgpOyB9LFxuICAgICAgcGljazogZnVuY3Rpb24oKSB7IHdpZGdldC5waWNrKCk7IH0sXG4gICAgICBkYXRhOiBkYXRhXG4gICAgfSkpO1xuXG4gICAgaWYgKGNvbXBsZXRpb24ub3B0aW9ucy5jbG9zZU9uVW5mb2N1cykge1xuICAgICAgdmFyIGNsb3NpbmdPbkJsdXI7XG4gICAgICBjbS5vbihcImJsdXJcIiwgdGhpcy5vbkJsdXIgPSBmdW5jdGlvbigpIHsgY2xvc2luZ09uQmx1ciA9IHNldFRpbWVvdXQoZnVuY3Rpb24oKSB7IGNvbXBsZXRpb24uY2xvc2UoKTsgfSwgMTAwKTsgfSk7XG4gICAgICBjbS5vbihcImZvY3VzXCIsIHRoaXMub25Gb2N1cyA9IGZ1bmN0aW9uKCkgeyBjbGVhclRpbWVvdXQoY2xvc2luZ09uQmx1cik7IH0pO1xuICAgIH1cblxuICAgIGNtLm9uKFwic2Nyb2xsXCIsIHRoaXMub25TY3JvbGwgPSBmdW5jdGlvbigpIHtcbiAgICAgIHZhciBjdXJTY3JvbGwgPSBjbS5nZXRTY3JvbGxJbmZvKCksIGVkaXRvciA9IGNtLmdldFdyYXBwZXJFbGVtZW50KCkuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCk7XG4gICAgICBpZiAoIXN0YXJ0U2Nyb2xsKSBzdGFydFNjcm9sbCA9IGNtLmdldFNjcm9sbEluZm8oKTtcbiAgICAgIHZhciBuZXdUb3AgPSB0b3AgKyBzdGFydFNjcm9sbC50b3AgLSBjdXJTY3JvbGwudG9wO1xuICAgICAgdmFyIHBvaW50ID0gbmV3VG9wIC0gKHBhcmVudFdpbmRvdy5wYWdlWU9mZnNldCB8fCAob3duZXJEb2N1bWVudC5kb2N1bWVudEVsZW1lbnQgfHwgb3duZXJEb2N1bWVudC5ib2R5KS5zY3JvbGxUb3ApO1xuICAgICAgaWYgKCFiZWxvdykgcG9pbnQgKz0gaGludHMub2Zmc2V0SGVpZ2h0O1xuICAgICAgaWYgKHBvaW50IDw9IGVkaXRvci50b3AgfHwgcG9pbnQgPj0gZWRpdG9yLmJvdHRvbSkgcmV0dXJuIGNvbXBsZXRpb24uY2xvc2UoKTtcbiAgICAgIGhpbnRzLnN0eWxlLnRvcCA9IG5ld1RvcCArIFwicHhcIjtcbiAgICAgIGhpbnRzLnN0eWxlLmxlZnQgPSAobGVmdCArIHN0YXJ0U2Nyb2xsLmxlZnQgLSBjdXJTY3JvbGwubGVmdCkgKyBcInB4XCI7XG4gICAgfSk7XG5cbiAgICBDb2RlTWlycm9yLm9uKGhpbnRzLCBcImRibGNsaWNrXCIsIGZ1bmN0aW9uKGUpIHtcbiAgICAgIHZhciB0ID0gZ2V0SGludEVsZW1lbnQoaGludHMsIGUudGFyZ2V0IHx8IGUuc3JjRWxlbWVudCk7XG4gICAgICBpZiAodCAmJiB0LmhpbnRJZCAhPSBudWxsKSB7d2lkZ2V0LmNoYW5nZUFjdGl2ZSh0LmhpbnRJZCk7IHdpZGdldC5waWNrKCk7fVxuICAgIH0pO1xuXG4gICAgQ29kZU1pcnJvci5vbihoaW50cywgXCJjbGlja1wiLCBmdW5jdGlvbihlKSB7XG4gICAgICB2YXIgdCA9IGdldEhpbnRFbGVtZW50KGhpbnRzLCBlLnRhcmdldCB8fCBlLnNyY0VsZW1lbnQpO1xuICAgICAgaWYgKHQgJiYgdC5oaW50SWQgIT0gbnVsbCkge1xuICAgICAgICB3aWRnZXQuY2hhbmdlQWN0aXZlKHQuaGludElkKTtcbiAgICAgICAgaWYgKGNvbXBsZXRpb24ub3B0aW9ucy5jb21wbGV0ZU9uU2luZ2xlQ2xpY2spIHdpZGdldC5waWNrKCk7XG4gICAgICB9XG4gICAgfSk7XG5cbiAgICBDb2RlTWlycm9yLm9uKGhpbnRzLCBcIm1vdXNlZG93blwiLCBmdW5jdGlvbigpIHtcbiAgICAgIHNldFRpbWVvdXQoZnVuY3Rpb24oKXtjbS5mb2N1cygpO30sIDIwKTtcbiAgICB9KTtcblxuICAgIC8vIFRoZSBmaXJzdCBoaW50IGRvZXNuJ3QgbmVlZCB0byBiZSBzY3JvbGxlZCB0byBvbiBpbml0XG4gICAgdmFyIHNlbGVjdGVkSGludFJhbmdlID0gdGhpcy5nZXRTZWxlY3RlZEhpbnRSYW5nZSgpO1xuICAgIGlmIChzZWxlY3RlZEhpbnRSYW5nZS5mcm9tICE9PSAwIHx8IHNlbGVjdGVkSGludFJhbmdlLnRvICE9PSAwKSB7XG4gICAgICB0aGlzLnNjcm9sbFRvQWN0aXZlKCk7XG4gICAgfVxuXG4gICAgQ29kZU1pcnJvci5zaWduYWwoZGF0YSwgXCJzZWxlY3RcIiwgY29tcGxldGlvbnNbdGhpcy5zZWxlY3RlZEhpbnRdLCBoaW50cy5jaGlsZE5vZGVzW3RoaXMuc2VsZWN0ZWRIaW50XSk7XG4gICAgcmV0dXJuIHRydWU7XG4gIH1cblxuICBXaWRnZXQucHJvdG90eXBlID0ge1xuICAgIGNsb3NlOiBmdW5jdGlvbigpIHtcbiAgICAgIGlmICh0aGlzLmNvbXBsZXRpb24ud2lkZ2V0ICE9IHRoaXMpIHJldHVybjtcbiAgICAgIHRoaXMuY29tcGxldGlvbi53aWRnZXQgPSBudWxsO1xuICAgICAgaWYgKHRoaXMuaGludHMucGFyZW50Tm9kZSkgdGhpcy5oaW50cy5wYXJlbnROb2RlLnJlbW92ZUNoaWxkKHRoaXMuaGludHMpO1xuICAgICAgdGhpcy5jb21wbGV0aW9uLmNtLnJlbW92ZUtleU1hcCh0aGlzLmtleU1hcCk7XG4gICAgICB2YXIgaW5wdXQgPSB0aGlzLmNvbXBsZXRpb24uY20uZ2V0SW5wdXRGaWVsZCgpXG4gICAgICBpbnB1dC5yZW1vdmVBdHRyaWJ1dGUoXCJhcmlhLWFjdGl2ZWRlc2NlbmRhbnRcIilcbiAgICAgIGlucHV0LnJlbW92ZUF0dHJpYnV0ZShcImFyaWEtb3duc1wiKVxuXG4gICAgICB2YXIgY20gPSB0aGlzLmNvbXBsZXRpb24uY207XG4gICAgICBpZiAodGhpcy5jb21wbGV0aW9uLm9wdGlvbnMuY2xvc2VPblVuZm9jdXMpIHtcbiAgICAgICAgY20ub2ZmKFwiYmx1clwiLCB0aGlzLm9uQmx1cik7XG4gICAgICAgIGNtLm9mZihcImZvY3VzXCIsIHRoaXMub25Gb2N1cyk7XG4gICAgICB9XG4gICAgICBjbS5vZmYoXCJzY3JvbGxcIiwgdGhpcy5vblNjcm9sbCk7XG4gICAgfSxcblxuICAgIGRpc2FibGU6IGZ1bmN0aW9uKCkge1xuICAgICAgdGhpcy5jb21wbGV0aW9uLmNtLnJlbW92ZUtleU1hcCh0aGlzLmtleU1hcCk7XG4gICAgICB2YXIgd2lkZ2V0ID0gdGhpcztcbiAgICAgIHRoaXMua2V5TWFwID0ge0VudGVyOiBmdW5jdGlvbigpIHsgd2lkZ2V0LnBpY2tlZCA9IHRydWU7IH19O1xuICAgICAgdGhpcy5jb21wbGV0aW9uLmNtLmFkZEtleU1hcCh0aGlzLmtleU1hcCk7XG4gICAgfSxcblxuICAgIHBpY2s6IGZ1bmN0aW9uKCkge1xuICAgICAgdGhpcy5jb21wbGV0aW9uLnBpY2sodGhpcy5kYXRhLCB0aGlzLnNlbGVjdGVkSGludCk7XG4gICAgfSxcblxuICAgIGNoYW5nZUFjdGl2ZTogZnVuY3Rpb24oaSwgYXZvaWRXcmFwKSB7XG4gICAgICBpZiAoaSA+PSB0aGlzLmRhdGEubGlzdC5sZW5ndGgpXG4gICAgICAgIGkgPSBhdm9pZFdyYXAgPyB0aGlzLmRhdGEubGlzdC5sZW5ndGggLSAxIDogMDtcbiAgICAgIGVsc2UgaWYgKGkgPCAwKVxuICAgICAgICBpID0gYXZvaWRXcmFwID8gMCAgOiB0aGlzLmRhdGEubGlzdC5sZW5ndGggLSAxO1xuICAgICAgaWYgKHRoaXMuc2VsZWN0ZWRIaW50ID09IGkpIHJldHVybjtcbiAgICAgIHZhciBub2RlID0gdGhpcy5oaW50cy5jaGlsZE5vZGVzW3RoaXMuc2VsZWN0ZWRIaW50XTtcbiAgICAgIGlmIChub2RlKSB7XG4gICAgICAgIG5vZGUuY2xhc3NOYW1lID0gbm9kZS5jbGFzc05hbWUucmVwbGFjZShcIiBcIiArIEFDVElWRV9ISU5UX0VMRU1FTlRfQ0xBU1MsIFwiXCIpO1xuICAgICAgICBub2RlLnJlbW92ZUF0dHJpYnV0ZShcImFyaWEtc2VsZWN0ZWRcIilcbiAgICAgIH1cbiAgICAgIG5vZGUgPSB0aGlzLmhpbnRzLmNoaWxkTm9kZXNbdGhpcy5zZWxlY3RlZEhpbnQgPSBpXTtcbiAgICAgIG5vZGUuY2xhc3NOYW1lICs9IFwiIFwiICsgQUNUSVZFX0hJTlRfRUxFTUVOVF9DTEFTUztcbiAgICAgIG5vZGUuc2V0QXR0cmlidXRlKFwiYXJpYS1zZWxlY3RlZFwiLCBcInRydWVcIilcbiAgICAgIHRoaXMuY29tcGxldGlvbi5jbS5nZXRJbnB1dEZpZWxkKCkuc2V0QXR0cmlidXRlKFwiYXJpYS1hY3RpdmVkZXNjZW5kYW50XCIsIG5vZGUuaWQpXG4gICAgICB0aGlzLnNjcm9sbFRvQWN0aXZlKClcbiAgICAgIENvZGVNaXJyb3Iuc2lnbmFsKHRoaXMuZGF0YSwgXCJzZWxlY3RcIiwgdGhpcy5kYXRhLmxpc3RbdGhpcy5zZWxlY3RlZEhpbnRdLCBub2RlKTtcbiAgICB9LFxuXG4gICAgc2Nyb2xsVG9BY3RpdmU6IGZ1bmN0aW9uKCkge1xuICAgICAgdmFyIHNlbGVjdGVkSGludFJhbmdlID0gdGhpcy5nZXRTZWxlY3RlZEhpbnRSYW5nZSgpO1xuICAgICAgdmFyIG5vZGUxID0gdGhpcy5oaW50cy5jaGlsZE5vZGVzW3NlbGVjdGVkSGludFJhbmdlLmZyb21dO1xuICAgICAgdmFyIG5vZGUyID0gdGhpcy5oaW50cy5jaGlsZE5vZGVzW3NlbGVjdGVkSGludFJhbmdlLnRvXTtcbiAgICAgIHZhciBmaXJzdE5vZGUgPSB0aGlzLmhpbnRzLmZpcnN0Q2hpbGQ7XG4gICAgICBpZiAobm9kZTEub2Zmc2V0VG9wIDwgdGhpcy5oaW50cy5zY3JvbGxUb3ApXG4gICAgICAgIHRoaXMuaGludHMuc2Nyb2xsVG9wID0gbm9kZTEub2Zmc2V0VG9wIC0gZmlyc3ROb2RlLm9mZnNldFRvcDtcbiAgICAgIGVsc2UgaWYgKG5vZGUyLm9mZnNldFRvcCArIG5vZGUyLm9mZnNldEhlaWdodCA+IHRoaXMuaGludHMuc2Nyb2xsVG9wICsgdGhpcy5oaW50cy5jbGllbnRIZWlnaHQpXG4gICAgICAgIHRoaXMuaGludHMuc2Nyb2xsVG9wID0gbm9kZTIub2Zmc2V0VG9wICsgbm9kZTIub2Zmc2V0SGVpZ2h0IC0gdGhpcy5oaW50cy5jbGllbnRIZWlnaHQgKyBmaXJzdE5vZGUub2Zmc2V0VG9wO1xuICAgIH0sXG5cbiAgICBzY3JlZW5BbW91bnQ6IGZ1bmN0aW9uKCkge1xuICAgICAgcmV0dXJuIE1hdGguZmxvb3IodGhpcy5oaW50cy5jbGllbnRIZWlnaHQgLyB0aGlzLmhpbnRzLmZpcnN0Q2hpbGQub2Zmc2V0SGVpZ2h0KSB8fCAxO1xuICAgIH0sXG5cbiAgICBnZXRTZWxlY3RlZEhpbnRSYW5nZTogZnVuY3Rpb24oKSB7XG4gICAgICB2YXIgbWFyZ2luID0gdGhpcy5jb21wbGV0aW9uLm9wdGlvbnMuc2Nyb2xsTWFyZ2luIHx8IDA7XG4gICAgICByZXR1cm4ge1xuICAgICAgICBmcm9tOiBNYXRoLm1heCgwLCB0aGlzLnNlbGVjdGVkSGludCAtIG1hcmdpbiksXG4gICAgICAgIHRvOiBNYXRoLm1pbih0aGlzLmRhdGEubGlzdC5sZW5ndGggLSAxLCB0aGlzLnNlbGVjdGVkSGludCArIG1hcmdpbiksXG4gICAgICB9O1xuICAgIH1cbiAgfTtcblxuICBmdW5jdGlvbiBhcHBsaWNhYmxlSGVscGVycyhjbSwgaGVscGVycykge1xuICAgIGlmICghY20uc29tZXRoaW5nU2VsZWN0ZWQoKSkgcmV0dXJuIGhlbHBlcnNcbiAgICB2YXIgcmVzdWx0ID0gW11cbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGhlbHBlcnMubGVuZ3RoOyBpKyspXG4gICAgICBpZiAoaGVscGVyc1tpXS5zdXBwb3J0c1NlbGVjdGlvbikgcmVzdWx0LnB1c2goaGVscGVyc1tpXSlcbiAgICByZXR1cm4gcmVzdWx0XG4gIH1cblxuICBmdW5jdGlvbiBmZXRjaEhpbnRzKGhpbnQsIGNtLCBvcHRpb25zLCBjYWxsYmFjaykge1xuICAgIGlmIChoaW50LmFzeW5jKSB7XG4gICAgICBoaW50KGNtLCBjYWxsYmFjaywgb3B0aW9ucylcbiAgICB9IGVsc2Uge1xuICAgICAgdmFyIHJlc3VsdCA9IGhpbnQoY20sIG9wdGlvbnMpXG4gICAgICBpZiAocmVzdWx0ICYmIHJlc3VsdC50aGVuKSByZXN1bHQudGhlbihjYWxsYmFjaylcbiAgICAgIGVsc2UgY2FsbGJhY2socmVzdWx0KVxuICAgIH1cbiAgfVxuXG4gIGZ1bmN0aW9uIHJlc29sdmVBdXRvSGludHMoY20sIHBvcykge1xuICAgIHZhciBoZWxwZXJzID0gY20uZ2V0SGVscGVycyhwb3MsIFwiaGludFwiKSwgd29yZHNcbiAgICBpZiAoaGVscGVycy5sZW5ndGgpIHtcbiAgICAgIHZhciByZXNvbHZlZCA9IGZ1bmN0aW9uKGNtLCBjYWxsYmFjaywgb3B0aW9ucykge1xuICAgICAgICB2YXIgYXBwID0gYXBwbGljYWJsZUhlbHBlcnMoY20sIGhlbHBlcnMpO1xuICAgICAgICBmdW5jdGlvbiBydW4oaSkge1xuICAgICAgICAgIGlmIChpID09IGFwcC5sZW5ndGgpIHJldHVybiBjYWxsYmFjayhudWxsKVxuICAgICAgICAgIGZldGNoSGludHMoYXBwW2ldLCBjbSwgb3B0aW9ucywgZnVuY3Rpb24ocmVzdWx0KSB7XG4gICAgICAgICAgICBpZiAocmVzdWx0ICYmIHJlc3VsdC5saXN0Lmxlbmd0aCA+IDApIGNhbGxiYWNrKHJlc3VsdClcbiAgICAgICAgICAgIGVsc2UgcnVuKGkgKyAxKVxuICAgICAgICAgIH0pXG4gICAgICAgIH1cbiAgICAgICAgcnVuKDApXG4gICAgICB9XG4gICAgICByZXNvbHZlZC5hc3luYyA9IHRydWVcbiAgICAgIHJlc29sdmVkLnN1cHBvcnRzU2VsZWN0aW9uID0gdHJ1ZVxuICAgICAgcmV0dXJuIHJlc29sdmVkXG4gICAgfSBlbHNlIGlmICh3b3JkcyA9IGNtLmdldEhlbHBlcihjbS5nZXRDdXJzb3IoKSwgXCJoaW50V29yZHNcIikpIHtcbiAgICAgIHJldHVybiBmdW5jdGlvbihjbSkgeyByZXR1cm4gQ29kZU1pcnJvci5oaW50LmZyb21MaXN0KGNtLCB7d29yZHM6IHdvcmRzfSkgfVxuICAgIH0gZWxzZSBpZiAoQ29kZU1pcnJvci5oaW50LmFueXdvcmQpIHtcbiAgICAgIHJldHVybiBmdW5jdGlvbihjbSwgb3B0aW9ucykgeyByZXR1cm4gQ29kZU1pcnJvci5oaW50LmFueXdvcmQoY20sIG9wdGlvbnMpIH1cbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuIGZ1bmN0aW9uKCkge31cbiAgICB9XG4gIH1cblxuICBDb2RlTWlycm9yLnJlZ2lzdGVySGVscGVyKFwiaGludFwiLCBcImF1dG9cIiwge1xuICAgIHJlc29sdmU6IHJlc29sdmVBdXRvSGludHNcbiAgfSk7XG5cbiAgQ29kZU1pcnJvci5yZWdpc3RlckhlbHBlcihcImhpbnRcIiwgXCJmcm9tTGlzdFwiLCBmdW5jdGlvbihjbSwgb3B0aW9ucykge1xuICAgIHZhciBjdXIgPSBjbS5nZXRDdXJzb3IoKSwgdG9rZW4gPSBjbS5nZXRUb2tlbkF0KGN1cilcbiAgICB2YXIgdGVybSwgZnJvbSA9IENvZGVNaXJyb3IuUG9zKGN1ci5saW5lLCB0b2tlbi5zdGFydCksIHRvID0gY3VyXG4gICAgaWYgKHRva2VuLnN0YXJ0IDwgY3VyLmNoICYmIC9cXHcvLnRlc3QodG9rZW4uc3RyaW5nLmNoYXJBdChjdXIuY2ggLSB0b2tlbi5zdGFydCAtIDEpKSkge1xuICAgICAgdGVybSA9IHRva2VuLnN0cmluZy5zdWJzdHIoMCwgY3VyLmNoIC0gdG9rZW4uc3RhcnQpXG4gICAgfSBlbHNlIHtcbiAgICAgIHRlcm0gPSBcIlwiXG4gICAgICBmcm9tID0gY3VyXG4gICAgfVxuICAgIHZhciBmb3VuZCA9IFtdO1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgb3B0aW9ucy53b3Jkcy5sZW5ndGg7IGkrKykge1xuICAgICAgdmFyIHdvcmQgPSBvcHRpb25zLndvcmRzW2ldO1xuICAgICAgaWYgKHdvcmQuc2xpY2UoMCwgdGVybS5sZW5ndGgpID09IHRlcm0pXG4gICAgICAgIGZvdW5kLnB1c2god29yZCk7XG4gICAgfVxuXG4gICAgaWYgKGZvdW5kLmxlbmd0aCkgcmV0dXJuIHtsaXN0OiBmb3VuZCwgZnJvbTogZnJvbSwgdG86IHRvfTtcbiAgfSk7XG5cbiAgQ29kZU1pcnJvci5jb21tYW5kcy5hdXRvY29tcGxldGUgPSBDb2RlTWlycm9yLnNob3dIaW50O1xuXG4gIHZhciBkZWZhdWx0T3B0aW9ucyA9IHtcbiAgICBoaW50OiBDb2RlTWlycm9yLmhpbnQuYXV0byxcbiAgICBjb21wbGV0ZVNpbmdsZTogdHJ1ZSxcbiAgICBhbGlnbldpdGhXb3JkOiB0cnVlLFxuICAgIGNsb3NlQ2hhcmFjdGVyczogL1tcXHMoKVxcW1xcXXt9Ozo+LF0vLFxuICAgIGNsb3NlT25QaWNrOiB0cnVlLFxuICAgIGNsb3NlT25VbmZvY3VzOiB0cnVlLFxuICAgIHVwZGF0ZU9uQ3Vyc29yQWN0aXZpdHk6IHRydWUsXG4gICAgY29tcGxldGVPblNpbmdsZUNsaWNrOiB0cnVlLFxuICAgIGNvbnRhaW5lcjogbnVsbCxcbiAgICBjdXN0b21LZXlzOiBudWxsLFxuICAgIGV4dHJhS2V5czogbnVsbCxcbiAgICBwYWRkaW5nRm9yU2Nyb2xsYmFyOiB0cnVlLFxuICAgIG1vdmVPbk92ZXJsYXA6IHRydWUsXG4gIH07XG5cbiAgQ29kZU1pcnJvci5kZWZpbmVPcHRpb24oXCJoaW50T3B0aW9uc1wiLCBudWxsKTtcbn0pO1xuIiwiLy8gQ29kZU1pcnJvciwgY29weXJpZ2h0IChjKSBieSBNYXJpam4gSGF2ZXJiZWtlIGFuZCBvdGhlcnNcbi8vIERpc3RyaWJ1dGVkIHVuZGVyIGFuIE1JVCBsaWNlbnNlOiBodHRwczovL2NvZGVtaXJyb3IubmV0L0xJQ0VOU0VcblxuKGZ1bmN0aW9uKG1vZCkge1xuICBpZiAodHlwZW9mIGV4cG9ydHMgPT0gXCJvYmplY3RcIiAmJiB0eXBlb2YgbW9kdWxlID09IFwib2JqZWN0XCIpIC8vIENvbW1vbkpTXG4gICAgbW9kKHJlcXVpcmUoXCIuLi8uLi9saWIvY29kZW1pcnJvclwiKSk7XG4gIGVsc2UgaWYgKHR5cGVvZiBkZWZpbmUgPT0gXCJmdW5jdGlvblwiICYmIGRlZmluZS5hbWQpIC8vIEFNRFxuICAgIGRlZmluZShbXCIuLi8uLi9saWIvY29kZW1pcnJvclwiXSwgbW9kKTtcbiAgZWxzZSAvLyBQbGFpbiBicm93c2VyIGVudlxuICAgIG1vZChDb2RlTWlycm9yKTtcbn0pKGZ1bmN0aW9uKENvZGVNaXJyb3IpIHtcbiAgXCJ1c2Ugc3RyaWN0XCI7XG4gIHZhciBHVVRURVJfSUQgPSBcIkNvZGVNaXJyb3ItbGludC1tYXJrZXJzXCI7XG4gIHZhciBMSU5UX0xJTkVfSUQgPSBcIkNvZGVNaXJyb3ItbGludC1saW5lLVwiO1xuXG4gIGZ1bmN0aW9uIHNob3dUb29sdGlwKGNtLCBlLCBjb250ZW50KSB7XG4gICAgdmFyIHR0ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcImRpdlwiKTtcbiAgICB0dC5jbGFzc05hbWUgPSBcIkNvZGVNaXJyb3ItbGludC10b29sdGlwIGNtLXMtXCIgKyBjbS5vcHRpb25zLnRoZW1lO1xuICAgIHR0LmFwcGVuZENoaWxkKGNvbnRlbnQuY2xvbmVOb2RlKHRydWUpKTtcbiAgICBpZiAoY20uc3RhdGUubGludC5vcHRpb25zLnNlbGZDb250YWluKVxuICAgICAgY20uZ2V0V3JhcHBlckVsZW1lbnQoKS5hcHBlbmRDaGlsZCh0dCk7XG4gICAgZWxzZVxuICAgICAgZG9jdW1lbnQuYm9keS5hcHBlbmRDaGlsZCh0dCk7XG5cbiAgICBmdW5jdGlvbiBwb3NpdGlvbihlKSB7XG4gICAgICBpZiAoIXR0LnBhcmVudE5vZGUpIHJldHVybiBDb2RlTWlycm9yLm9mZihkb2N1bWVudCwgXCJtb3VzZW1vdmVcIiwgcG9zaXRpb24pO1xuICAgICAgdHQuc3R5bGUudG9wID0gTWF0aC5tYXgoMCwgZS5jbGllbnRZIC0gdHQub2Zmc2V0SGVpZ2h0IC0gNSkgKyBcInB4XCI7XG4gICAgICB0dC5zdHlsZS5sZWZ0ID0gKGUuY2xpZW50WCArIDUpICsgXCJweFwiO1xuICAgIH1cbiAgICBDb2RlTWlycm9yLm9uKGRvY3VtZW50LCBcIm1vdXNlbW92ZVwiLCBwb3NpdGlvbik7XG4gICAgcG9zaXRpb24oZSk7XG4gICAgaWYgKHR0LnN0eWxlLm9wYWNpdHkgIT0gbnVsbCkgdHQuc3R5bGUub3BhY2l0eSA9IDE7XG4gICAgcmV0dXJuIHR0O1xuICB9XG4gIGZ1bmN0aW9uIHJtKGVsdCkge1xuICAgIGlmIChlbHQucGFyZW50Tm9kZSkgZWx0LnBhcmVudE5vZGUucmVtb3ZlQ2hpbGQoZWx0KTtcbiAgfVxuICBmdW5jdGlvbiBoaWRlVG9vbHRpcCh0dCkge1xuICAgIGlmICghdHQucGFyZW50Tm9kZSkgcmV0dXJuO1xuICAgIGlmICh0dC5zdHlsZS5vcGFjaXR5ID09IG51bGwpIHJtKHR0KTtcbiAgICB0dC5zdHlsZS5vcGFjaXR5ID0gMDtcbiAgICBzZXRUaW1lb3V0KGZ1bmN0aW9uKCkgeyBybSh0dCk7IH0sIDYwMCk7XG4gIH1cblxuICBmdW5jdGlvbiBzaG93VG9vbHRpcEZvcihjbSwgZSwgY29udGVudCwgbm9kZSkge1xuICAgIHZhciB0b29sdGlwID0gc2hvd1Rvb2x0aXAoY20sIGUsIGNvbnRlbnQpO1xuICAgIGZ1bmN0aW9uIGhpZGUoKSB7XG4gICAgICBDb2RlTWlycm9yLm9mZihub2RlLCBcIm1vdXNlb3V0XCIsIGhpZGUpO1xuICAgICAgaWYgKHRvb2x0aXApIHsgaGlkZVRvb2x0aXAodG9vbHRpcCk7IHRvb2x0aXAgPSBudWxsOyB9XG4gICAgfVxuICAgIHZhciBwb2xsID0gc2V0SW50ZXJ2YWwoZnVuY3Rpb24oKSB7XG4gICAgICBpZiAodG9vbHRpcCkgZm9yICh2YXIgbiA9IG5vZGU7OyBuID0gbi5wYXJlbnROb2RlKSB7XG4gICAgICAgIGlmIChuICYmIG4ubm9kZVR5cGUgPT0gMTEpIG4gPSBuLmhvc3Q7XG4gICAgICAgIGlmIChuID09IGRvY3VtZW50LmJvZHkpIHJldHVybjtcbiAgICAgICAgaWYgKCFuKSB7IGhpZGUoKTsgYnJlYWs7IH1cbiAgICAgIH1cbiAgICAgIGlmICghdG9vbHRpcCkgcmV0dXJuIGNsZWFySW50ZXJ2YWwocG9sbCk7XG4gICAgfSwgNDAwKTtcbiAgICBDb2RlTWlycm9yLm9uKG5vZGUsIFwibW91c2VvdXRcIiwgaGlkZSk7XG4gIH1cblxuICBmdW5jdGlvbiBMaW50U3RhdGUoY20sIGNvbmYsIGhhc0d1dHRlcikge1xuICAgIHRoaXMubWFya2VkID0gW107XG4gICAgaWYgKGNvbmYgaW5zdGFuY2VvZiBGdW5jdGlvbikgY29uZiA9IHtnZXRBbm5vdGF0aW9uczogY29uZn07XG4gICAgaWYgKCFjb25mIHx8IGNvbmYgPT09IHRydWUpIGNvbmYgPSB7fTtcbiAgICB0aGlzLm9wdGlvbnMgPSB7fTtcbiAgICB0aGlzLmxpbnRlck9wdGlvbnMgPSBjb25mLm9wdGlvbnMgfHwge307XG4gICAgZm9yICh2YXIgcHJvcCBpbiBkZWZhdWx0cykgdGhpcy5vcHRpb25zW3Byb3BdID0gZGVmYXVsdHNbcHJvcF07XG4gICAgZm9yICh2YXIgcHJvcCBpbiBjb25mKSB7XG4gICAgICBpZiAoZGVmYXVsdHMuaGFzT3duUHJvcGVydHkocHJvcCkpIHtcbiAgICAgICAgaWYgKGNvbmZbcHJvcF0gIT0gbnVsbCkgdGhpcy5vcHRpb25zW3Byb3BdID0gY29uZltwcm9wXTtcbiAgICAgIH0gZWxzZSBpZiAoIWNvbmYub3B0aW9ucykge1xuICAgICAgICB0aGlzLmxpbnRlck9wdGlvbnNbcHJvcF0gPSBjb25mW3Byb3BdO1xuICAgICAgfVxuICAgIH1cbiAgICB0aGlzLnRpbWVvdXQgPSBudWxsO1xuICAgIHRoaXMuaGFzR3V0dGVyID0gaGFzR3V0dGVyO1xuICAgIHRoaXMub25Nb3VzZU92ZXIgPSBmdW5jdGlvbihlKSB7IG9uTW91c2VPdmVyKGNtLCBlKTsgfTtcbiAgICB0aGlzLndhaXRpbmdGb3IgPSAwXG4gIH1cblxuICB2YXIgZGVmYXVsdHMgPSB7XG4gICAgaGlnaGxpZ2h0TGluZXM6IGZhbHNlLFxuICAgIHRvb2x0aXBzOiB0cnVlLFxuICAgIGRlbGF5OiA1MDAsXG4gICAgbGludE9uQ2hhbmdlOiB0cnVlLFxuICAgIGdldEFubm90YXRpb25zOiBudWxsLFxuICAgIGFzeW5jOiBmYWxzZSxcbiAgICBzZWxmQ29udGFpbjogbnVsbCxcbiAgICBmb3JtYXRBbm5vdGF0aW9uOiBudWxsLFxuICAgIG9uVXBkYXRlTGludGluZzogbnVsbFxuICB9XG5cbiAgZnVuY3Rpb24gY2xlYXJNYXJrcyhjbSkge1xuICAgIHZhciBzdGF0ZSA9IGNtLnN0YXRlLmxpbnQ7XG4gICAgaWYgKHN0YXRlLmhhc0d1dHRlcikgY20uY2xlYXJHdXR0ZXIoR1VUVEVSX0lEKTtcbiAgICBpZiAoc3RhdGUub3B0aW9ucy5oaWdobGlnaHRMaW5lcykgY2xlYXJFcnJvckxpbmVzKGNtKTtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IHN0YXRlLm1hcmtlZC5sZW5ndGg7ICsraSlcbiAgICAgIHN0YXRlLm1hcmtlZFtpXS5jbGVhcigpO1xuICAgIHN0YXRlLm1hcmtlZC5sZW5ndGggPSAwO1xuICB9XG5cbiAgZnVuY3Rpb24gY2xlYXJFcnJvckxpbmVzKGNtKSB7XG4gICAgY20uZWFjaExpbmUoZnVuY3Rpb24obGluZSkge1xuICAgICAgdmFyIGhhcyA9IGxpbmUud3JhcENsYXNzICYmIC9cXGJDb2RlTWlycm9yLWxpbnQtbGluZS1cXHcrXFxiLy5leGVjKGxpbmUud3JhcENsYXNzKTtcbiAgICAgIGlmIChoYXMpIGNtLnJlbW92ZUxpbmVDbGFzcyhsaW5lLCBcIndyYXBcIiwgaGFzWzBdKTtcbiAgICB9KVxuICB9XG5cbiAgZnVuY3Rpb24gbWFrZU1hcmtlcihjbSwgbGFiZWxzLCBzZXZlcml0eSwgbXVsdGlwbGUsIHRvb2x0aXBzKSB7XG4gICAgdmFyIG1hcmtlciA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJkaXZcIiksIGlubmVyID0gbWFya2VyO1xuICAgIG1hcmtlci5jbGFzc05hbWUgPSBcIkNvZGVNaXJyb3ItbGludC1tYXJrZXIgQ29kZU1pcnJvci1saW50LW1hcmtlci1cIiArIHNldmVyaXR5O1xuICAgIGlmIChtdWx0aXBsZSkge1xuICAgICAgaW5uZXIgPSBtYXJrZXIuYXBwZW5kQ2hpbGQoZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcImRpdlwiKSk7XG4gICAgICBpbm5lci5jbGFzc05hbWUgPSBcIkNvZGVNaXJyb3ItbGludC1tYXJrZXIgQ29kZU1pcnJvci1saW50LW1hcmtlci1tdWx0aXBsZVwiO1xuICAgIH1cblxuICAgIGlmICh0b29sdGlwcyAhPSBmYWxzZSkgQ29kZU1pcnJvci5vbihpbm5lciwgXCJtb3VzZW92ZXJcIiwgZnVuY3Rpb24oZSkge1xuICAgICAgc2hvd1Rvb2x0aXBGb3IoY20sIGUsIGxhYmVscywgaW5uZXIpO1xuICAgIH0pO1xuXG4gICAgcmV0dXJuIG1hcmtlcjtcbiAgfVxuXG4gIGZ1bmN0aW9uIGdldE1heFNldmVyaXR5KGEsIGIpIHtcbiAgICBpZiAoYSA9PSBcImVycm9yXCIpIHJldHVybiBhO1xuICAgIGVsc2UgcmV0dXJuIGI7XG4gIH1cblxuICBmdW5jdGlvbiBncm91cEJ5TGluZShhbm5vdGF0aW9ucykge1xuICAgIHZhciBsaW5lcyA9IFtdO1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgYW5ub3RhdGlvbnMubGVuZ3RoOyArK2kpIHtcbiAgICAgIHZhciBhbm4gPSBhbm5vdGF0aW9uc1tpXSwgbGluZSA9IGFubi5mcm9tLmxpbmU7XG4gICAgICAobGluZXNbbGluZV0gfHwgKGxpbmVzW2xpbmVdID0gW10pKS5wdXNoKGFubik7XG4gICAgfVxuICAgIHJldHVybiBsaW5lcztcbiAgfVxuXG4gIGZ1bmN0aW9uIGFubm90YXRpb25Ub29sdGlwKGFubikge1xuICAgIHZhciBzZXZlcml0eSA9IGFubi5zZXZlcml0eTtcbiAgICBpZiAoIXNldmVyaXR5KSBzZXZlcml0eSA9IFwiZXJyb3JcIjtcbiAgICB2YXIgdGlwID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcImRpdlwiKTtcbiAgICB0aXAuY2xhc3NOYW1lID0gXCJDb2RlTWlycm9yLWxpbnQtbWVzc2FnZSBDb2RlTWlycm9yLWxpbnQtbWVzc2FnZS1cIiArIHNldmVyaXR5O1xuICAgIGlmICh0eXBlb2YgYW5uLm1lc3NhZ2VIVE1MICE9ICd1bmRlZmluZWQnKSB7XG4gICAgICB0aXAuaW5uZXJIVE1MID0gYW5uLm1lc3NhZ2VIVE1MO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aXAuYXBwZW5kQ2hpbGQoZG9jdW1lbnQuY3JlYXRlVGV4dE5vZGUoYW5uLm1lc3NhZ2UpKTtcbiAgICB9XG4gICAgcmV0dXJuIHRpcDtcbiAgfVxuXG4gIGZ1bmN0aW9uIGxpbnRBc3luYyhjbSwgZ2V0QW5ub3RhdGlvbnMpIHtcbiAgICB2YXIgc3RhdGUgPSBjbS5zdGF0ZS5saW50XG4gICAgdmFyIGlkID0gKytzdGF0ZS53YWl0aW5nRm9yXG4gICAgZnVuY3Rpb24gYWJvcnQoKSB7XG4gICAgICBpZCA9IC0xXG4gICAgICBjbS5vZmYoXCJjaGFuZ2VcIiwgYWJvcnQpXG4gICAgfVxuICAgIGNtLm9uKFwiY2hhbmdlXCIsIGFib3J0KVxuICAgIGdldEFubm90YXRpb25zKGNtLmdldFZhbHVlKCksIGZ1bmN0aW9uKGFubm90YXRpb25zLCBhcmcyKSB7XG4gICAgICBjbS5vZmYoXCJjaGFuZ2VcIiwgYWJvcnQpXG4gICAgICBpZiAoc3RhdGUud2FpdGluZ0ZvciAhPSBpZCkgcmV0dXJuXG4gICAgICBpZiAoYXJnMiAmJiBhbm5vdGF0aW9ucyBpbnN0YW5jZW9mIENvZGVNaXJyb3IpIGFubm90YXRpb25zID0gYXJnMlxuICAgICAgY20ub3BlcmF0aW9uKGZ1bmN0aW9uKCkge3VwZGF0ZUxpbnRpbmcoY20sIGFubm90YXRpb25zKX0pXG4gICAgfSwgc3RhdGUubGludGVyT3B0aW9ucywgY20pO1xuICB9XG5cbiAgZnVuY3Rpb24gc3RhcnRMaW50aW5nKGNtKSB7XG4gICAgdmFyIHN0YXRlID0gY20uc3RhdGUubGludDtcbiAgICBpZiAoIXN0YXRlKSByZXR1cm47XG4gICAgdmFyIG9wdGlvbnMgPSBzdGF0ZS5vcHRpb25zO1xuICAgIC8qXG4gICAgICogUGFzc2luZyBydWxlcyBpbiBgb3B0aW9uc2AgcHJvcGVydHkgcHJldmVudHMgSlNIaW50IChhbmQgb3RoZXIgbGludGVycykgZnJvbSBjb21wbGFpbmluZ1xuICAgICAqIGFib3V0IHVucmVjb2duaXplZCBydWxlcyBsaWtlIGBvblVwZGF0ZUxpbnRpbmdgLCBgZGVsYXlgLCBgbGludE9uQ2hhbmdlYCwgZXRjLlxuICAgICAqL1xuICAgIHZhciBnZXRBbm5vdGF0aW9ucyA9IG9wdGlvbnMuZ2V0QW5ub3RhdGlvbnMgfHwgY20uZ2V0SGVscGVyKENvZGVNaXJyb3IuUG9zKDAsIDApLCBcImxpbnRcIik7XG4gICAgaWYgKCFnZXRBbm5vdGF0aW9ucykgcmV0dXJuO1xuICAgIGlmIChvcHRpb25zLmFzeW5jIHx8IGdldEFubm90YXRpb25zLmFzeW5jKSB7XG4gICAgICBsaW50QXN5bmMoY20sIGdldEFubm90YXRpb25zKVxuICAgIH0gZWxzZSB7XG4gICAgICB2YXIgYW5ub3RhdGlvbnMgPSBnZXRBbm5vdGF0aW9ucyhjbS5nZXRWYWx1ZSgpLCBzdGF0ZS5saW50ZXJPcHRpb25zLCBjbSk7XG4gICAgICBpZiAoIWFubm90YXRpb25zKSByZXR1cm47XG4gICAgICBpZiAoYW5ub3RhdGlvbnMudGhlbikgYW5ub3RhdGlvbnMudGhlbihmdW5jdGlvbihpc3N1ZXMpIHtcbiAgICAgICAgY20ub3BlcmF0aW9uKGZ1bmN0aW9uKCkge3VwZGF0ZUxpbnRpbmcoY20sIGlzc3Vlcyl9KVxuICAgICAgfSk7XG4gICAgICBlbHNlIGNtLm9wZXJhdGlvbihmdW5jdGlvbigpIHt1cGRhdGVMaW50aW5nKGNtLCBhbm5vdGF0aW9ucyl9KVxuICAgIH1cbiAgfVxuXG4gIGZ1bmN0aW9uIHVwZGF0ZUxpbnRpbmcoY20sIGFubm90YXRpb25zTm90U29ydGVkKSB7XG4gICAgdmFyIHN0YXRlID0gY20uc3RhdGUubGludDtcbiAgICBpZiAoIXN0YXRlKSByZXR1cm47XG4gICAgdmFyIG9wdGlvbnMgPSBzdGF0ZS5vcHRpb25zO1xuICAgIGNsZWFyTWFya3MoY20pO1xuXG4gICAgdmFyIGFubm90YXRpb25zID0gZ3JvdXBCeUxpbmUoYW5ub3RhdGlvbnNOb3RTb3J0ZWQpO1xuXG4gICAgZm9yICh2YXIgbGluZSA9IDA7IGxpbmUgPCBhbm5vdGF0aW9ucy5sZW5ndGg7ICsrbGluZSkge1xuICAgICAgdmFyIGFubnMgPSBhbm5vdGF0aW9uc1tsaW5lXTtcbiAgICAgIGlmICghYW5ucykgY29udGludWU7XG5cbiAgICAgIC8vIGZpbHRlciBvdXQgZHVwbGljYXRlIG1lc3NhZ2VzXG4gICAgICB2YXIgbWVzc2FnZSA9IFtdO1xuICAgICAgYW5ucyA9IGFubnMuZmlsdGVyKGZ1bmN0aW9uKGl0ZW0pIHsgcmV0dXJuIG1lc3NhZ2UuaW5kZXhPZihpdGVtLm1lc3NhZ2UpID4gLTEgPyBmYWxzZSA6IG1lc3NhZ2UucHVzaChpdGVtLm1lc3NhZ2UpIH0pO1xuXG4gICAgICB2YXIgbWF4U2V2ZXJpdHkgPSBudWxsO1xuICAgICAgdmFyIHRpcExhYmVsID0gc3RhdGUuaGFzR3V0dGVyICYmIGRvY3VtZW50LmNyZWF0ZURvY3VtZW50RnJhZ21lbnQoKTtcblxuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBhbm5zLmxlbmd0aDsgKytpKSB7XG4gICAgICAgIHZhciBhbm4gPSBhbm5zW2ldO1xuICAgICAgICB2YXIgc2V2ZXJpdHkgPSBhbm4uc2V2ZXJpdHk7XG4gICAgICAgIGlmICghc2V2ZXJpdHkpIHNldmVyaXR5ID0gXCJlcnJvclwiO1xuICAgICAgICBtYXhTZXZlcml0eSA9IGdldE1heFNldmVyaXR5KG1heFNldmVyaXR5LCBzZXZlcml0eSk7XG5cbiAgICAgICAgaWYgKG9wdGlvbnMuZm9ybWF0QW5ub3RhdGlvbikgYW5uID0gb3B0aW9ucy5mb3JtYXRBbm5vdGF0aW9uKGFubik7XG4gICAgICAgIGlmIChzdGF0ZS5oYXNHdXR0ZXIpIHRpcExhYmVsLmFwcGVuZENoaWxkKGFubm90YXRpb25Ub29sdGlwKGFubikpO1xuXG4gICAgICAgIGlmIChhbm4udG8pIHN0YXRlLm1hcmtlZC5wdXNoKGNtLm1hcmtUZXh0KGFubi5mcm9tLCBhbm4udG8sIHtcbiAgICAgICAgICBjbGFzc05hbWU6IFwiQ29kZU1pcnJvci1saW50LW1hcmsgQ29kZU1pcnJvci1saW50LW1hcmstXCIgKyBzZXZlcml0eSxcbiAgICAgICAgICBfX2Fubm90YXRpb246IGFublxuICAgICAgICB9KSk7XG4gICAgICB9XG4gICAgICAvLyB1c2Ugb3JpZ2luYWwgYW5ub3RhdGlvbnNbbGluZV0gdG8gc2hvdyBtdWx0aXBsZSBtZXNzYWdlc1xuICAgICAgaWYgKHN0YXRlLmhhc0d1dHRlcilcbiAgICAgICAgY20uc2V0R3V0dGVyTWFya2VyKGxpbmUsIEdVVFRFUl9JRCwgbWFrZU1hcmtlcihjbSwgdGlwTGFiZWwsIG1heFNldmVyaXR5LCBhbm5vdGF0aW9uc1tsaW5lXS5sZW5ndGggPiAxLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG9wdGlvbnMudG9vbHRpcHMpKTtcblxuICAgICAgaWYgKG9wdGlvbnMuaGlnaGxpZ2h0TGluZXMpXG4gICAgICAgIGNtLmFkZExpbmVDbGFzcyhsaW5lLCBcIndyYXBcIiwgTElOVF9MSU5FX0lEICsgbWF4U2V2ZXJpdHkpO1xuICAgIH1cbiAgICBpZiAob3B0aW9ucy5vblVwZGF0ZUxpbnRpbmcpIG9wdGlvbnMub25VcGRhdGVMaW50aW5nKGFubm90YXRpb25zTm90U29ydGVkLCBhbm5vdGF0aW9ucywgY20pO1xuICB9XG5cbiAgZnVuY3Rpb24gb25DaGFuZ2UoY20pIHtcbiAgICB2YXIgc3RhdGUgPSBjbS5zdGF0ZS5saW50O1xuICAgIGlmICghc3RhdGUpIHJldHVybjtcbiAgICBjbGVhclRpbWVvdXQoc3RhdGUudGltZW91dCk7XG4gICAgc3RhdGUudGltZW91dCA9IHNldFRpbWVvdXQoZnVuY3Rpb24oKXtzdGFydExpbnRpbmcoY20pO30sIHN0YXRlLm9wdGlvbnMuZGVsYXkpO1xuICB9XG5cbiAgZnVuY3Rpb24gcG9wdXBUb29sdGlwcyhjbSwgYW5ub3RhdGlvbnMsIGUpIHtcbiAgICB2YXIgdGFyZ2V0ID0gZS50YXJnZXQgfHwgZS5zcmNFbGVtZW50O1xuICAgIHZhciB0b29sdGlwID0gZG9jdW1lbnQuY3JlYXRlRG9jdW1lbnRGcmFnbWVudCgpO1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgYW5ub3RhdGlvbnMubGVuZ3RoOyBpKyspIHtcbiAgICAgIHZhciBhbm4gPSBhbm5vdGF0aW9uc1tpXTtcbiAgICAgIHRvb2x0aXAuYXBwZW5kQ2hpbGQoYW5ub3RhdGlvblRvb2x0aXAoYW5uKSk7XG4gICAgfVxuICAgIHNob3dUb29sdGlwRm9yKGNtLCBlLCB0b29sdGlwLCB0YXJnZXQpO1xuICB9XG5cbiAgZnVuY3Rpb24gb25Nb3VzZU92ZXIoY20sIGUpIHtcbiAgICB2YXIgdGFyZ2V0ID0gZS50YXJnZXQgfHwgZS5zcmNFbGVtZW50O1xuICAgIGlmICghL1xcYkNvZGVNaXJyb3ItbGludC1tYXJrLS8udGVzdCh0YXJnZXQuY2xhc3NOYW1lKSkgcmV0dXJuO1xuICAgIHZhciBib3ggPSB0YXJnZXQuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCksIHggPSAoYm94LmxlZnQgKyBib3gucmlnaHQpIC8gMiwgeSA9IChib3gudG9wICsgYm94LmJvdHRvbSkgLyAyO1xuICAgIHZhciBzcGFucyA9IGNtLmZpbmRNYXJrc0F0KGNtLmNvb3Jkc0NoYXIoe2xlZnQ6IHgsIHRvcDogeX0sIFwiY2xpZW50XCIpKTtcblxuICAgIHZhciBhbm5vdGF0aW9ucyA9IFtdO1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgc3BhbnMubGVuZ3RoOyArK2kpIHtcbiAgICAgIHZhciBhbm4gPSBzcGFuc1tpXS5fX2Fubm90YXRpb247XG4gICAgICBpZiAoYW5uKSBhbm5vdGF0aW9ucy5wdXNoKGFubik7XG4gICAgfVxuICAgIGlmIChhbm5vdGF0aW9ucy5sZW5ndGgpIHBvcHVwVG9vbHRpcHMoY20sIGFubm90YXRpb25zLCBlKTtcbiAgfVxuXG4gIENvZGVNaXJyb3IuZGVmaW5lT3B0aW9uKFwibGludFwiLCBmYWxzZSwgZnVuY3Rpb24oY20sIHZhbCwgb2xkKSB7XG4gICAgaWYgKG9sZCAmJiBvbGQgIT0gQ29kZU1pcnJvci5Jbml0KSB7XG4gICAgICBjbGVhck1hcmtzKGNtKTtcbiAgICAgIGlmIChjbS5zdGF0ZS5saW50Lm9wdGlvbnMubGludE9uQ2hhbmdlICE9PSBmYWxzZSlcbiAgICAgICAgY20ub2ZmKFwiY2hhbmdlXCIsIG9uQ2hhbmdlKTtcbiAgICAgIENvZGVNaXJyb3Iub2ZmKGNtLmdldFdyYXBwZXJFbGVtZW50KCksIFwibW91c2VvdmVyXCIsIGNtLnN0YXRlLmxpbnQub25Nb3VzZU92ZXIpO1xuICAgICAgY2xlYXJUaW1lb3V0KGNtLnN0YXRlLmxpbnQudGltZW91dCk7XG4gICAgICBkZWxldGUgY20uc3RhdGUubGludDtcbiAgICB9XG5cbiAgICBpZiAodmFsKSB7XG4gICAgICB2YXIgZ3V0dGVycyA9IGNtLmdldE9wdGlvbihcImd1dHRlcnNcIiksIGhhc0xpbnRHdXR0ZXIgPSBmYWxzZTtcbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgZ3V0dGVycy5sZW5ndGg7ICsraSkgaWYgKGd1dHRlcnNbaV0gPT0gR1VUVEVSX0lEKSBoYXNMaW50R3V0dGVyID0gdHJ1ZTtcbiAgICAgIHZhciBzdGF0ZSA9IGNtLnN0YXRlLmxpbnQgPSBuZXcgTGludFN0YXRlKGNtLCB2YWwsIGhhc0xpbnRHdXR0ZXIpO1xuICAgICAgaWYgKHN0YXRlLm9wdGlvbnMubGludE9uQ2hhbmdlKVxuICAgICAgICBjbS5vbihcImNoYW5nZVwiLCBvbkNoYW5nZSk7XG4gICAgICBpZiAoc3RhdGUub3B0aW9ucy50b29sdGlwcyAhPSBmYWxzZSAmJiBzdGF0ZS5vcHRpb25zLnRvb2x0aXBzICE9IFwiZ3V0dGVyXCIpXG4gICAgICAgIENvZGVNaXJyb3Iub24oY20uZ2V0V3JhcHBlckVsZW1lbnQoKSwgXCJtb3VzZW92ZXJcIiwgc3RhdGUub25Nb3VzZU92ZXIpO1xuXG4gICAgICBzdGFydExpbnRpbmcoY20pO1xuICAgIH1cbiAgfSk7XG5cbiAgQ29kZU1pcnJvci5kZWZpbmVFeHRlbnNpb24oXCJwZXJmb3JtTGludFwiLCBmdW5jdGlvbigpIHtcbiAgICBzdGFydExpbnRpbmcodGhpcyk7XG4gIH0pO1xufSk7XG4iLCIvLyBDb2RlTWlycm9yLCBjb3B5cmlnaHQgKGMpIGJ5IE1hcmlqbiBIYXZlcmJla2UgYW5kIG90aGVyc1xuLy8gRGlzdHJpYnV0ZWQgdW5kZXIgYW4gTUlUIGxpY2Vuc2U6IGh0dHBzOi8vY29kZW1pcnJvci5uZXQvTElDRU5TRVxuXG4oZnVuY3Rpb24obW9kKSB7XG4gIGlmICh0eXBlb2YgZXhwb3J0cyA9PSBcIm9iamVjdFwiICYmIHR5cGVvZiBtb2R1bGUgPT0gXCJvYmplY3RcIikgLy8gQ29tbW9uSlNcbiAgICBtb2QocmVxdWlyZShcIi4uLy4uL2xpYi9jb2RlbWlycm9yXCIpKTtcbiAgZWxzZSBpZiAodHlwZW9mIGRlZmluZSA9PSBcImZ1bmN0aW9uXCIgJiYgZGVmaW5lLmFtZCkgLy8gQU1EXG4gICAgZGVmaW5lKFtcIi4uLy4uL2xpYi9jb2RlbWlycm9yXCJdLCBtb2QpO1xuICBlbHNlIC8vIFBsYWluIGJyb3dzZXIgZW52XG4gICAgbW9kKENvZGVNaXJyb3IpO1xufSkoZnVuY3Rpb24oQ29kZU1pcnJvcikge1xuICBcInVzZSBzdHJpY3RcIjtcblxuICBmdW5jdGlvbiBCYXIoY2xzLCBvcmllbnRhdGlvbiwgc2Nyb2xsKSB7XG4gICAgdGhpcy5vcmllbnRhdGlvbiA9IG9yaWVudGF0aW9uO1xuICAgIHRoaXMuc2Nyb2xsID0gc2Nyb2xsO1xuICAgIHRoaXMuc2NyZWVuID0gdGhpcy50b3RhbCA9IHRoaXMuc2l6ZSA9IDE7XG4gICAgdGhpcy5wb3MgPSAwO1xuXG4gICAgdGhpcy5ub2RlID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcImRpdlwiKTtcbiAgICB0aGlzLm5vZGUuY2xhc3NOYW1lID0gY2xzICsgXCItXCIgKyBvcmllbnRhdGlvbjtcbiAgICB0aGlzLmlubmVyID0gdGhpcy5ub2RlLmFwcGVuZENoaWxkKGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJkaXZcIikpO1xuXG4gICAgdmFyIHNlbGYgPSB0aGlzO1xuICAgIENvZGVNaXJyb3Iub24odGhpcy5pbm5lciwgXCJtb3VzZWRvd25cIiwgZnVuY3Rpb24oZSkge1xuICAgICAgaWYgKGUud2hpY2ggIT0gMSkgcmV0dXJuO1xuICAgICAgQ29kZU1pcnJvci5lX3ByZXZlbnREZWZhdWx0KGUpO1xuICAgICAgdmFyIGF4aXMgPSBzZWxmLm9yaWVudGF0aW9uID09IFwiaG9yaXpvbnRhbFwiID8gXCJwYWdlWFwiIDogXCJwYWdlWVwiO1xuICAgICAgdmFyIHN0YXJ0ID0gZVtheGlzXSwgc3RhcnRwb3MgPSBzZWxmLnBvcztcbiAgICAgIGZ1bmN0aW9uIGRvbmUoKSB7XG4gICAgICAgIENvZGVNaXJyb3Iub2ZmKGRvY3VtZW50LCBcIm1vdXNlbW92ZVwiLCBtb3ZlKTtcbiAgICAgICAgQ29kZU1pcnJvci5vZmYoZG9jdW1lbnQsIFwibW91c2V1cFwiLCBkb25lKTtcbiAgICAgIH1cbiAgICAgIGZ1bmN0aW9uIG1vdmUoZSkge1xuICAgICAgICBpZiAoZS53aGljaCAhPSAxKSByZXR1cm4gZG9uZSgpO1xuICAgICAgICBzZWxmLm1vdmVUbyhzdGFydHBvcyArIChlW2F4aXNdIC0gc3RhcnQpICogKHNlbGYudG90YWwgLyBzZWxmLnNpemUpKTtcbiAgICAgIH1cbiAgICAgIENvZGVNaXJyb3Iub24oZG9jdW1lbnQsIFwibW91c2Vtb3ZlXCIsIG1vdmUpO1xuICAgICAgQ29kZU1pcnJvci5vbihkb2N1bWVudCwgXCJtb3VzZXVwXCIsIGRvbmUpO1xuICAgIH0pO1xuXG4gICAgQ29kZU1pcnJvci5vbih0aGlzLm5vZGUsIFwiY2xpY2tcIiwgZnVuY3Rpb24oZSkge1xuICAgICAgQ29kZU1pcnJvci5lX3ByZXZlbnREZWZhdWx0KGUpO1xuICAgICAgdmFyIGlubmVyQm94ID0gc2VsZi5pbm5lci5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKSwgd2hlcmU7XG4gICAgICBpZiAoc2VsZi5vcmllbnRhdGlvbiA9PSBcImhvcml6b250YWxcIilcbiAgICAgICAgd2hlcmUgPSBlLmNsaWVudFggPCBpbm5lckJveC5sZWZ0ID8gLTEgOiBlLmNsaWVudFggPiBpbm5lckJveC5yaWdodCA/IDEgOiAwO1xuICAgICAgZWxzZVxuICAgICAgICB3aGVyZSA9IGUuY2xpZW50WSA8IGlubmVyQm94LnRvcCA/IC0xIDogZS5jbGllbnRZID4gaW5uZXJCb3guYm90dG9tID8gMSA6IDA7XG4gICAgICBzZWxmLm1vdmVUbyhzZWxmLnBvcyArIHdoZXJlICogc2VsZi5zY3JlZW4pO1xuICAgIH0pO1xuXG4gICAgZnVuY3Rpb24gb25XaGVlbChlKSB7XG4gICAgICB2YXIgbW92ZWQgPSBDb2RlTWlycm9yLndoZWVsRXZlbnRQaXhlbHMoZSlbc2VsZi5vcmllbnRhdGlvbiA9PSBcImhvcml6b250YWxcIiA/IFwieFwiIDogXCJ5XCJdO1xuICAgICAgdmFyIG9sZFBvcyA9IHNlbGYucG9zO1xuICAgICAgc2VsZi5tb3ZlVG8oc2VsZi5wb3MgKyBtb3ZlZCk7XG4gICAgICBpZiAoc2VsZi5wb3MgIT0gb2xkUG9zKSBDb2RlTWlycm9yLmVfcHJldmVudERlZmF1bHQoZSk7XG4gICAgfVxuICAgIENvZGVNaXJyb3Iub24odGhpcy5ub2RlLCBcIm1vdXNld2hlZWxcIiwgb25XaGVlbCk7XG4gICAgQ29kZU1pcnJvci5vbih0aGlzLm5vZGUsIFwiRE9NTW91c2VTY3JvbGxcIiwgb25XaGVlbCk7XG4gIH1cblxuICBCYXIucHJvdG90eXBlLnNldFBvcyA9IGZ1bmN0aW9uKHBvcywgZm9yY2UpIHtcbiAgICBpZiAocG9zIDwgMCkgcG9zID0gMDtcbiAgICBpZiAocG9zID4gdGhpcy50b3RhbCAtIHRoaXMuc2NyZWVuKSBwb3MgPSB0aGlzLnRvdGFsIC0gdGhpcy5zY3JlZW47XG4gICAgaWYgKCFmb3JjZSAmJiBwb3MgPT0gdGhpcy5wb3MpIHJldHVybiBmYWxzZTtcbiAgICB0aGlzLnBvcyA9IHBvcztcbiAgICB0aGlzLmlubmVyLnN0eWxlW3RoaXMub3JpZW50YXRpb24gPT0gXCJob3Jpem9udGFsXCIgPyBcImxlZnRcIiA6IFwidG9wXCJdID1cbiAgICAgIChwb3MgKiAodGhpcy5zaXplIC8gdGhpcy50b3RhbCkpICsgXCJweFwiO1xuICAgIHJldHVybiB0cnVlXG4gIH07XG5cbiAgQmFyLnByb3RvdHlwZS5tb3ZlVG8gPSBmdW5jdGlvbihwb3MpIHtcbiAgICBpZiAodGhpcy5zZXRQb3MocG9zKSkgdGhpcy5zY3JvbGwocG9zLCB0aGlzLm9yaWVudGF0aW9uKTtcbiAgfVxuXG4gIHZhciBtaW5CdXR0b25TaXplID0gMTA7XG5cbiAgQmFyLnByb3RvdHlwZS51cGRhdGUgPSBmdW5jdGlvbihzY3JvbGxTaXplLCBjbGllbnRTaXplLCBiYXJTaXplKSB7XG4gICAgdmFyIHNpemVDaGFuZ2VkID0gdGhpcy5zY3JlZW4gIT0gY2xpZW50U2l6ZSB8fCB0aGlzLnRvdGFsICE9IHNjcm9sbFNpemUgfHwgdGhpcy5zaXplICE9IGJhclNpemVcbiAgICBpZiAoc2l6ZUNoYW5nZWQpIHtcbiAgICAgIHRoaXMuc2NyZWVuID0gY2xpZW50U2l6ZTtcbiAgICAgIHRoaXMudG90YWwgPSBzY3JvbGxTaXplO1xuICAgICAgdGhpcy5zaXplID0gYmFyU2l6ZTtcbiAgICB9XG5cbiAgICB2YXIgYnV0dG9uU2l6ZSA9IHRoaXMuc2NyZWVuICogKHRoaXMuc2l6ZSAvIHRoaXMudG90YWwpO1xuICAgIGlmIChidXR0b25TaXplIDwgbWluQnV0dG9uU2l6ZSkge1xuICAgICAgdGhpcy5zaXplIC09IG1pbkJ1dHRvblNpemUgLSBidXR0b25TaXplO1xuICAgICAgYnV0dG9uU2l6ZSA9IG1pbkJ1dHRvblNpemU7XG4gICAgfVxuICAgIHRoaXMuaW5uZXIuc3R5bGVbdGhpcy5vcmllbnRhdGlvbiA9PSBcImhvcml6b250YWxcIiA/IFwid2lkdGhcIiA6IFwiaGVpZ2h0XCJdID1cbiAgICAgIGJ1dHRvblNpemUgKyBcInB4XCI7XG4gICAgdGhpcy5zZXRQb3ModGhpcy5wb3MsIHNpemVDaGFuZ2VkKTtcbiAgfTtcblxuICBmdW5jdGlvbiBTaW1wbGVTY3JvbGxiYXJzKGNscywgcGxhY2UsIHNjcm9sbCkge1xuICAgIHRoaXMuYWRkQ2xhc3MgPSBjbHM7XG4gICAgdGhpcy5ob3JpeiA9IG5ldyBCYXIoY2xzLCBcImhvcml6b250YWxcIiwgc2Nyb2xsKTtcbiAgICBwbGFjZSh0aGlzLmhvcml6Lm5vZGUpO1xuICAgIHRoaXMudmVydCA9IG5ldyBCYXIoY2xzLCBcInZlcnRpY2FsXCIsIHNjcm9sbCk7XG4gICAgcGxhY2UodGhpcy52ZXJ0Lm5vZGUpO1xuICAgIHRoaXMud2lkdGggPSBudWxsO1xuICB9XG5cbiAgU2ltcGxlU2Nyb2xsYmFycy5wcm90b3R5cGUudXBkYXRlID0gZnVuY3Rpb24obWVhc3VyZSkge1xuICAgIGlmICh0aGlzLndpZHRoID09IG51bGwpIHtcbiAgICAgIHZhciBzdHlsZSA9IHdpbmRvdy5nZXRDb21wdXRlZFN0eWxlID8gd2luZG93LmdldENvbXB1dGVkU3R5bGUodGhpcy5ob3Jpei5ub2RlKSA6IHRoaXMuaG9yaXoubm9kZS5jdXJyZW50U3R5bGU7XG4gICAgICBpZiAoc3R5bGUpIHRoaXMud2lkdGggPSBwYXJzZUludChzdHlsZS5oZWlnaHQpO1xuICAgIH1cbiAgICB2YXIgd2lkdGggPSB0aGlzLndpZHRoIHx8IDA7XG5cbiAgICB2YXIgbmVlZHNIID0gbWVhc3VyZS5zY3JvbGxXaWR0aCA+IG1lYXN1cmUuY2xpZW50V2lkdGggKyAxO1xuICAgIHZhciBuZWVkc1YgPSBtZWFzdXJlLnNjcm9sbEhlaWdodCA+IG1lYXN1cmUuY2xpZW50SGVpZ2h0ICsgMTtcbiAgICB0aGlzLnZlcnQubm9kZS5zdHlsZS5kaXNwbGF5ID0gbmVlZHNWID8gXCJibG9ja1wiIDogXCJub25lXCI7XG4gICAgdGhpcy5ob3Jpei5ub2RlLnN0eWxlLmRpc3BsYXkgPSBuZWVkc0ggPyBcImJsb2NrXCIgOiBcIm5vbmVcIjtcblxuICAgIGlmIChuZWVkc1YpIHtcbiAgICAgIHRoaXMudmVydC51cGRhdGUobWVhc3VyZS5zY3JvbGxIZWlnaHQsIG1lYXN1cmUuY2xpZW50SGVpZ2h0LFxuICAgICAgICAgICAgICAgICAgICAgICBtZWFzdXJlLnZpZXdIZWlnaHQgLSAobmVlZHNIID8gd2lkdGggOiAwKSk7XG4gICAgICB0aGlzLnZlcnQubm9kZS5zdHlsZS5ib3R0b20gPSBuZWVkc0ggPyB3aWR0aCArIFwicHhcIiA6IFwiMFwiO1xuICAgIH1cbiAgICBpZiAobmVlZHNIKSB7XG4gICAgICB0aGlzLmhvcml6LnVwZGF0ZShtZWFzdXJlLnNjcm9sbFdpZHRoLCBtZWFzdXJlLmNsaWVudFdpZHRoLFxuICAgICAgICAgICAgICAgICAgICAgICAgbWVhc3VyZS52aWV3V2lkdGggLSAobmVlZHNWID8gd2lkdGggOiAwKSAtIG1lYXN1cmUuYmFyTGVmdCk7XG4gICAgICB0aGlzLmhvcml6Lm5vZGUuc3R5bGUucmlnaHQgPSBuZWVkc1YgPyB3aWR0aCArIFwicHhcIiA6IFwiMFwiO1xuICAgICAgdGhpcy5ob3Jpei5ub2RlLnN0eWxlLmxlZnQgPSBtZWFzdXJlLmJhckxlZnQgKyBcInB4XCI7XG4gICAgfVxuXG4gICAgcmV0dXJuIHtyaWdodDogbmVlZHNWID8gd2lkdGggOiAwLCBib3R0b206IG5lZWRzSCA/IHdpZHRoIDogMH07XG4gIH07XG5cbiAgU2ltcGxlU2Nyb2xsYmFycy5wcm90b3R5cGUuc2V0U2Nyb2xsVG9wID0gZnVuY3Rpb24ocG9zKSB7XG4gICAgdGhpcy52ZXJ0LnNldFBvcyhwb3MpO1xuICB9O1xuXG4gIFNpbXBsZVNjcm9sbGJhcnMucHJvdG90eXBlLnNldFNjcm9sbExlZnQgPSBmdW5jdGlvbihwb3MpIHtcbiAgICB0aGlzLmhvcml6LnNldFBvcyhwb3MpO1xuICB9O1xuXG4gIFNpbXBsZVNjcm9sbGJhcnMucHJvdG90eXBlLmNsZWFyID0gZnVuY3Rpb24oKSB7XG4gICAgdmFyIHBhcmVudCA9IHRoaXMuaG9yaXoubm9kZS5wYXJlbnROb2RlO1xuICAgIHBhcmVudC5yZW1vdmVDaGlsZCh0aGlzLmhvcml6Lm5vZGUpO1xuICAgIHBhcmVudC5yZW1vdmVDaGlsZCh0aGlzLnZlcnQubm9kZSk7XG4gIH07XG5cbiAgQ29kZU1pcnJvci5zY3JvbGxiYXJNb2RlbC5zaW1wbGUgPSBmdW5jdGlvbihwbGFjZSwgc2Nyb2xsKSB7XG4gICAgcmV0dXJuIG5ldyBTaW1wbGVTY3JvbGxiYXJzKFwiQ29kZU1pcnJvci1zaW1wbGVzY3JvbGxcIiwgcGxhY2UsIHNjcm9sbCk7XG4gIH07XG4gIENvZGVNaXJyb3Iuc2Nyb2xsYmFyTW9kZWwub3ZlcmxheSA9IGZ1bmN0aW9uKHBsYWNlLCBzY3JvbGwpIHtcbiAgICByZXR1cm4gbmV3IFNpbXBsZVNjcm9sbGJhcnMoXCJDb2RlTWlycm9yLW92ZXJsYXlzY3JvbGxcIiwgcGxhY2UsIHNjcm9sbCk7XG4gIH07XG59KTtcbiIsIi8vIENvZGVNaXJyb3IsIGNvcHlyaWdodCAoYykgYnkgTWFyaWpuIEhhdmVyYmVrZSBhbmQgb3RoZXJzXG4vLyBEaXN0cmlidXRlZCB1bmRlciBhbiBNSVQgbGljZW5zZTogaHR0cHM6Ly9jb2RlbWlycm9yLm5ldC9MSUNFTlNFXG5cbi8vIFRoaXMgaXMgQ29kZU1pcnJvciAoaHR0cHM6Ly9jb2RlbWlycm9yLm5ldCksIGEgY29kZSBlZGl0b3Jcbi8vIGltcGxlbWVudGVkIGluIEphdmFTY3JpcHQgb24gdG9wIG9mIHRoZSBicm93c2VyJ3MgRE9NLlxuLy9cbi8vIFlvdSBjYW4gZmluZCBzb21lIHRlY2huaWNhbCBiYWNrZ3JvdW5kIGZvciBzb21lIG9mIHRoZSBjb2RlIGJlbG93XG4vLyBhdCBodHRwOi8vbWFyaWpuaGF2ZXJiZWtlLm5sL2Jsb2cvI2NtLWludGVybmFscyAuXG5cbihmdW5jdGlvbiAoZ2xvYmFsLCBmYWN0b3J5KSB7XG4gIHR5cGVvZiBleHBvcnRzID09PSAnb2JqZWN0JyAmJiB0eXBlb2YgbW9kdWxlICE9PSAndW5kZWZpbmVkJyA/IG1vZHVsZS5leHBvcnRzID0gZmFjdG9yeSgpIDpcbiAgdHlwZW9mIGRlZmluZSA9PT0gJ2Z1bmN0aW9uJyAmJiBkZWZpbmUuYW1kID8gZGVmaW5lKGZhY3RvcnkpIDpcbiAgKGdsb2JhbCA9IGdsb2JhbCB8fCBzZWxmLCBnbG9iYWwuQ29kZU1pcnJvciA9IGZhY3RvcnkoKSk7XG59KHRoaXMsIChmdW5jdGlvbiAoKSB7ICd1c2Ugc3RyaWN0JztcblxuICAvLyBLbHVkZ2VzIGZvciBidWdzIGFuZCBiZWhhdmlvciBkaWZmZXJlbmNlcyB0aGF0IGNhbid0IGJlIGZlYXR1cmVcbiAgLy8gZGV0ZWN0ZWQgYXJlIGVuYWJsZWQgYmFzZWQgb24gdXNlckFnZW50IGV0YyBzbmlmZmluZy5cbiAgdmFyIHVzZXJBZ2VudCA9IG5hdmlnYXRvci51c2VyQWdlbnQ7XG4gIHZhciBwbGF0Zm9ybSA9IG5hdmlnYXRvci5wbGF0Zm9ybTtcblxuICB2YXIgZ2Vja28gPSAvZ2Vja29cXC9cXGQvaS50ZXN0KHVzZXJBZ2VudCk7XG4gIHZhciBpZV91cHRvMTAgPSAvTVNJRSBcXGQvLnRlc3QodXNlckFnZW50KTtcbiAgdmFyIGllXzExdXAgPSAvVHJpZGVudFxcLyg/Ols3LTldfFxcZHsyLH0pXFwuLipydjooXFxkKykvLmV4ZWModXNlckFnZW50KTtcbiAgdmFyIGVkZ2UgPSAvRWRnZVxcLyhcXGQrKS8uZXhlYyh1c2VyQWdlbnQpO1xuICB2YXIgaWUgPSBpZV91cHRvMTAgfHwgaWVfMTF1cCB8fCBlZGdlO1xuICB2YXIgaWVfdmVyc2lvbiA9IGllICYmIChpZV91cHRvMTAgPyBkb2N1bWVudC5kb2N1bWVudE1vZGUgfHwgNiA6ICsoZWRnZSB8fCBpZV8xMXVwKVsxXSk7XG4gIHZhciB3ZWJraXQgPSAhZWRnZSAmJiAvV2ViS2l0XFwvLy50ZXN0KHVzZXJBZ2VudCk7XG4gIHZhciBxdHdlYmtpdCA9IHdlYmtpdCAmJiAvUXRcXC9cXGQrXFwuXFxkKy8udGVzdCh1c2VyQWdlbnQpO1xuICB2YXIgY2hyb21lID0gIWVkZ2UgJiYgL0Nocm9tZVxcLy8udGVzdCh1c2VyQWdlbnQpO1xuICB2YXIgcHJlc3RvID0gL09wZXJhXFwvLy50ZXN0KHVzZXJBZ2VudCk7XG4gIHZhciBzYWZhcmkgPSAvQXBwbGUgQ29tcHV0ZXIvLnRlc3QobmF2aWdhdG9yLnZlbmRvcik7XG4gIHZhciBtYWNfZ2VNb3VudGFpbkxpb24gPSAvTWFjIE9TIFggMVxcZFxcRChbOC05XXxcXGRcXGQpXFxELy50ZXN0KHVzZXJBZ2VudCk7XG4gIHZhciBwaGFudG9tID0gL1BoYW50b21KUy8udGVzdCh1c2VyQWdlbnQpO1xuXG4gIHZhciBpb3MgPSBzYWZhcmkgJiYgKC9Nb2JpbGVcXC9cXHcrLy50ZXN0KHVzZXJBZ2VudCkgfHwgbmF2aWdhdG9yLm1heFRvdWNoUG9pbnRzID4gMik7XG4gIHZhciBhbmRyb2lkID0gL0FuZHJvaWQvLnRlc3QodXNlckFnZW50KTtcbiAgLy8gVGhpcyBpcyB3b2VmdWxseSBpbmNvbXBsZXRlLiBTdWdnZXN0aW9ucyBmb3IgYWx0ZXJuYXRpdmUgbWV0aG9kcyB3ZWxjb21lLlxuICB2YXIgbW9iaWxlID0gaW9zIHx8IGFuZHJvaWQgfHwgL3dlYk9TfEJsYWNrQmVycnl8T3BlcmEgTWluaXxPcGVyYSBNb2JpfElFTW9iaWxlL2kudGVzdCh1c2VyQWdlbnQpO1xuICB2YXIgbWFjID0gaW9zIHx8IC9NYWMvLnRlc3QocGxhdGZvcm0pO1xuICB2YXIgY2hyb21lT1MgPSAvXFxiQ3JPU1xcYi8udGVzdCh1c2VyQWdlbnQpO1xuICB2YXIgd2luZG93cyA9IC93aW4vaS50ZXN0KHBsYXRmb3JtKTtcblxuICB2YXIgcHJlc3RvX3ZlcnNpb24gPSBwcmVzdG8gJiYgdXNlckFnZW50Lm1hdGNoKC9WZXJzaW9uXFwvKFxcZCpcXC5cXGQqKS8pO1xuICBpZiAocHJlc3RvX3ZlcnNpb24pIHsgcHJlc3RvX3ZlcnNpb24gPSBOdW1iZXIocHJlc3RvX3ZlcnNpb25bMV0pOyB9XG4gIGlmIChwcmVzdG9fdmVyc2lvbiAmJiBwcmVzdG9fdmVyc2lvbiA+PSAxNSkgeyBwcmVzdG8gPSBmYWxzZTsgd2Via2l0ID0gdHJ1ZTsgfVxuICAvLyBTb21lIGJyb3dzZXJzIHVzZSB0aGUgd3JvbmcgZXZlbnQgcHJvcGVydGllcyB0byBzaWduYWwgY21kL2N0cmwgb24gT1MgWFxuICB2YXIgZmxpcEN0cmxDbWQgPSBtYWMgJiYgKHF0d2Via2l0IHx8IHByZXN0byAmJiAocHJlc3RvX3ZlcnNpb24gPT0gbnVsbCB8fCBwcmVzdG9fdmVyc2lvbiA8IDEyLjExKSk7XG4gIHZhciBjYXB0dXJlUmlnaHRDbGljayA9IGdlY2tvIHx8IChpZSAmJiBpZV92ZXJzaW9uID49IDkpO1xuXG4gIGZ1bmN0aW9uIGNsYXNzVGVzdChjbHMpIHsgcmV0dXJuIG5ldyBSZWdFeHAoXCIoXnxcXFxccylcIiArIGNscyArIFwiKD86JHxcXFxccylcXFxccypcIikgfVxuXG4gIHZhciBybUNsYXNzID0gZnVuY3Rpb24obm9kZSwgY2xzKSB7XG4gICAgdmFyIGN1cnJlbnQgPSBub2RlLmNsYXNzTmFtZTtcbiAgICB2YXIgbWF0Y2ggPSBjbGFzc1Rlc3QoY2xzKS5leGVjKGN1cnJlbnQpO1xuICAgIGlmIChtYXRjaCkge1xuICAgICAgdmFyIGFmdGVyID0gY3VycmVudC5zbGljZShtYXRjaC5pbmRleCArIG1hdGNoWzBdLmxlbmd0aCk7XG4gICAgICBub2RlLmNsYXNzTmFtZSA9IGN1cnJlbnQuc2xpY2UoMCwgbWF0Y2guaW5kZXgpICsgKGFmdGVyID8gbWF0Y2hbMV0gKyBhZnRlciA6IFwiXCIpO1xuICAgIH1cbiAgfTtcblxuICBmdW5jdGlvbiByZW1vdmVDaGlsZHJlbihlKSB7XG4gICAgZm9yICh2YXIgY291bnQgPSBlLmNoaWxkTm9kZXMubGVuZ3RoOyBjb3VudCA+IDA7IC0tY291bnQpXG4gICAgICB7IGUucmVtb3ZlQ2hpbGQoZS5maXJzdENoaWxkKTsgfVxuICAgIHJldHVybiBlXG4gIH1cblxuICBmdW5jdGlvbiByZW1vdmVDaGlsZHJlbkFuZEFkZChwYXJlbnQsIGUpIHtcbiAgICByZXR1cm4gcmVtb3ZlQ2hpbGRyZW4ocGFyZW50KS5hcHBlbmRDaGlsZChlKVxuICB9XG5cbiAgZnVuY3Rpb24gZWx0KHRhZywgY29udGVudCwgY2xhc3NOYW1lLCBzdHlsZSkge1xuICAgIHZhciBlID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCh0YWcpO1xuICAgIGlmIChjbGFzc05hbWUpIHsgZS5jbGFzc05hbWUgPSBjbGFzc05hbWU7IH1cbiAgICBpZiAoc3R5bGUpIHsgZS5zdHlsZS5jc3NUZXh0ID0gc3R5bGU7IH1cbiAgICBpZiAodHlwZW9mIGNvbnRlbnQgPT0gXCJzdHJpbmdcIikgeyBlLmFwcGVuZENoaWxkKGRvY3VtZW50LmNyZWF0ZVRleHROb2RlKGNvbnRlbnQpKTsgfVxuICAgIGVsc2UgaWYgKGNvbnRlbnQpIHsgZm9yICh2YXIgaSA9IDA7IGkgPCBjb250ZW50Lmxlbmd0aDsgKytpKSB7IGUuYXBwZW5kQ2hpbGQoY29udGVudFtpXSk7IH0gfVxuICAgIHJldHVybiBlXG4gIH1cbiAgLy8gd3JhcHBlciBmb3IgZWx0LCB3aGljaCByZW1vdmVzIHRoZSBlbHQgZnJvbSB0aGUgYWNjZXNzaWJpbGl0eSB0cmVlXG4gIGZ1bmN0aW9uIGVsdFAodGFnLCBjb250ZW50LCBjbGFzc05hbWUsIHN0eWxlKSB7XG4gICAgdmFyIGUgPSBlbHQodGFnLCBjb250ZW50LCBjbGFzc05hbWUsIHN0eWxlKTtcbiAgICBlLnNldEF0dHJpYnV0ZShcInJvbGVcIiwgXCJwcmVzZW50YXRpb25cIik7XG4gICAgcmV0dXJuIGVcbiAgfVxuXG4gIHZhciByYW5nZTtcbiAgaWYgKGRvY3VtZW50LmNyZWF0ZVJhbmdlKSB7IHJhbmdlID0gZnVuY3Rpb24obm9kZSwgc3RhcnQsIGVuZCwgZW5kTm9kZSkge1xuICAgIHZhciByID0gZG9jdW1lbnQuY3JlYXRlUmFuZ2UoKTtcbiAgICByLnNldEVuZChlbmROb2RlIHx8IG5vZGUsIGVuZCk7XG4gICAgci5zZXRTdGFydChub2RlLCBzdGFydCk7XG4gICAgcmV0dXJuIHJcbiAgfTsgfVxuICBlbHNlIHsgcmFuZ2UgPSBmdW5jdGlvbihub2RlLCBzdGFydCwgZW5kKSB7XG4gICAgdmFyIHIgPSBkb2N1bWVudC5ib2R5LmNyZWF0ZVRleHRSYW5nZSgpO1xuICAgIHRyeSB7IHIubW92ZVRvRWxlbWVudFRleHQobm9kZS5wYXJlbnROb2RlKTsgfVxuICAgIGNhdGNoKGUpIHsgcmV0dXJuIHIgfVxuICAgIHIuY29sbGFwc2UodHJ1ZSk7XG4gICAgci5tb3ZlRW5kKFwiY2hhcmFjdGVyXCIsIGVuZCk7XG4gICAgci5tb3ZlU3RhcnQoXCJjaGFyYWN0ZXJcIiwgc3RhcnQpO1xuICAgIHJldHVybiByXG4gIH07IH1cblxuICBmdW5jdGlvbiBjb250YWlucyhwYXJlbnQsIGNoaWxkKSB7XG4gICAgaWYgKGNoaWxkLm5vZGVUeXBlID09IDMpIC8vIEFuZHJvaWQgYnJvd3NlciBhbHdheXMgcmV0dXJucyBmYWxzZSB3aGVuIGNoaWxkIGlzIGEgdGV4dG5vZGVcbiAgICAgIHsgY2hpbGQgPSBjaGlsZC5wYXJlbnROb2RlOyB9XG4gICAgaWYgKHBhcmVudC5jb250YWlucylcbiAgICAgIHsgcmV0dXJuIHBhcmVudC5jb250YWlucyhjaGlsZCkgfVxuICAgIGRvIHtcbiAgICAgIGlmIChjaGlsZC5ub2RlVHlwZSA9PSAxMSkgeyBjaGlsZCA9IGNoaWxkLmhvc3Q7IH1cbiAgICAgIGlmIChjaGlsZCA9PSBwYXJlbnQpIHsgcmV0dXJuIHRydWUgfVxuICAgIH0gd2hpbGUgKGNoaWxkID0gY2hpbGQucGFyZW50Tm9kZSlcbiAgfVxuXG4gIGZ1bmN0aW9uIGFjdGl2ZUVsdCgpIHtcbiAgICAvLyBJRSBhbmQgRWRnZSBtYXkgdGhyb3cgYW4gXCJVbnNwZWNpZmllZCBFcnJvclwiIHdoZW4gYWNjZXNzaW5nIGRvY3VtZW50LmFjdGl2ZUVsZW1lbnQuXG4gICAgLy8gSUUgPCAxMCB3aWxsIHRocm93IHdoZW4gYWNjZXNzZWQgd2hpbGUgdGhlIHBhZ2UgaXMgbG9hZGluZyBvciBpbiBhbiBpZnJhbWUuXG4gICAgLy8gSUUgPiA5IGFuZCBFZGdlIHdpbGwgdGhyb3cgd2hlbiBhY2Nlc3NlZCBpbiBhbiBpZnJhbWUgaWYgZG9jdW1lbnQuYm9keSBpcyB1bmF2YWlsYWJsZS5cbiAgICB2YXIgYWN0aXZlRWxlbWVudDtcbiAgICB0cnkge1xuICAgICAgYWN0aXZlRWxlbWVudCA9IGRvY3VtZW50LmFjdGl2ZUVsZW1lbnQ7XG4gICAgfSBjYXRjaChlKSB7XG4gICAgICBhY3RpdmVFbGVtZW50ID0gZG9jdW1lbnQuYm9keSB8fCBudWxsO1xuICAgIH1cbiAgICB3aGlsZSAoYWN0aXZlRWxlbWVudCAmJiBhY3RpdmVFbGVtZW50LnNoYWRvd1Jvb3QgJiYgYWN0aXZlRWxlbWVudC5zaGFkb3dSb290LmFjdGl2ZUVsZW1lbnQpXG4gICAgICB7IGFjdGl2ZUVsZW1lbnQgPSBhY3RpdmVFbGVtZW50LnNoYWRvd1Jvb3QuYWN0aXZlRWxlbWVudDsgfVxuICAgIHJldHVybiBhY3RpdmVFbGVtZW50XG4gIH1cblxuICBmdW5jdGlvbiBhZGRDbGFzcyhub2RlLCBjbHMpIHtcbiAgICB2YXIgY3VycmVudCA9IG5vZGUuY2xhc3NOYW1lO1xuICAgIGlmICghY2xhc3NUZXN0KGNscykudGVzdChjdXJyZW50KSkgeyBub2RlLmNsYXNzTmFtZSArPSAoY3VycmVudCA/IFwiIFwiIDogXCJcIikgKyBjbHM7IH1cbiAgfVxuICBmdW5jdGlvbiBqb2luQ2xhc3NlcyhhLCBiKSB7XG4gICAgdmFyIGFzID0gYS5zcGxpdChcIiBcIik7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBhcy5sZW5ndGg7IGkrKylcbiAgICAgIHsgaWYgKGFzW2ldICYmICFjbGFzc1Rlc3QoYXNbaV0pLnRlc3QoYikpIHsgYiArPSBcIiBcIiArIGFzW2ldOyB9IH1cbiAgICByZXR1cm4gYlxuICB9XG5cbiAgdmFyIHNlbGVjdElucHV0ID0gZnVuY3Rpb24obm9kZSkgeyBub2RlLnNlbGVjdCgpOyB9O1xuICBpZiAoaW9zKSAvLyBNb2JpbGUgU2FmYXJpIGFwcGFyZW50bHkgaGFzIGEgYnVnIHdoZXJlIHNlbGVjdCgpIGlzIGJyb2tlbi5cbiAgICB7IHNlbGVjdElucHV0ID0gZnVuY3Rpb24obm9kZSkgeyBub2RlLnNlbGVjdGlvblN0YXJ0ID0gMDsgbm9kZS5zZWxlY3Rpb25FbmQgPSBub2RlLnZhbHVlLmxlbmd0aDsgfTsgfVxuICBlbHNlIGlmIChpZSkgLy8gU3VwcHJlc3MgbXlzdGVyaW91cyBJRTEwIGVycm9yc1xuICAgIHsgc2VsZWN0SW5wdXQgPSBmdW5jdGlvbihub2RlKSB7IHRyeSB7IG5vZGUuc2VsZWN0KCk7IH0gY2F0Y2goX2UpIHt9IH07IH1cblxuICBmdW5jdGlvbiBiaW5kKGYpIHtcbiAgICB2YXIgYXJncyA9IEFycmF5LnByb3RvdHlwZS5zbGljZS5jYWxsKGFyZ3VtZW50cywgMSk7XG4gICAgcmV0dXJuIGZ1bmN0aW9uKCl7cmV0dXJuIGYuYXBwbHkobnVsbCwgYXJncyl9XG4gIH1cblxuICBmdW5jdGlvbiBjb3B5T2JqKG9iaiwgdGFyZ2V0LCBvdmVyd3JpdGUpIHtcbiAgICBpZiAoIXRhcmdldCkgeyB0YXJnZXQgPSB7fTsgfVxuICAgIGZvciAodmFyIHByb3AgaW4gb2JqKVxuICAgICAgeyBpZiAob2JqLmhhc093blByb3BlcnR5KHByb3ApICYmIChvdmVyd3JpdGUgIT09IGZhbHNlIHx8ICF0YXJnZXQuaGFzT3duUHJvcGVydHkocHJvcCkpKVxuICAgICAgICB7IHRhcmdldFtwcm9wXSA9IG9ialtwcm9wXTsgfSB9XG4gICAgcmV0dXJuIHRhcmdldFxuICB9XG5cbiAgLy8gQ291bnRzIHRoZSBjb2x1bW4gb2Zmc2V0IGluIGEgc3RyaW5nLCB0YWtpbmcgdGFicyBpbnRvIGFjY291bnQuXG4gIC8vIFVzZWQgbW9zdGx5IHRvIGZpbmQgaW5kZW50YXRpb24uXG4gIGZ1bmN0aW9uIGNvdW50Q29sdW1uKHN0cmluZywgZW5kLCB0YWJTaXplLCBzdGFydEluZGV4LCBzdGFydFZhbHVlKSB7XG4gICAgaWYgKGVuZCA9PSBudWxsKSB7XG4gICAgICBlbmQgPSBzdHJpbmcuc2VhcmNoKC9bXlxcc1xcdTAwYTBdLyk7XG4gICAgICBpZiAoZW5kID09IC0xKSB7IGVuZCA9IHN0cmluZy5sZW5ndGg7IH1cbiAgICB9XG4gICAgZm9yICh2YXIgaSA9IHN0YXJ0SW5kZXggfHwgMCwgbiA9IHN0YXJ0VmFsdWUgfHwgMDs7KSB7XG4gICAgICB2YXIgbmV4dFRhYiA9IHN0cmluZy5pbmRleE9mKFwiXFx0XCIsIGkpO1xuICAgICAgaWYgKG5leHRUYWIgPCAwIHx8IG5leHRUYWIgPj0gZW5kKVxuICAgICAgICB7IHJldHVybiBuICsgKGVuZCAtIGkpIH1cbiAgICAgIG4gKz0gbmV4dFRhYiAtIGk7XG4gICAgICBuICs9IHRhYlNpemUgLSAobiAlIHRhYlNpemUpO1xuICAgICAgaSA9IG5leHRUYWIgKyAxO1xuICAgIH1cbiAgfVxuXG4gIHZhciBEZWxheWVkID0gZnVuY3Rpb24oKSB7XG4gICAgdGhpcy5pZCA9IG51bGw7XG4gICAgdGhpcy5mID0gbnVsbDtcbiAgICB0aGlzLnRpbWUgPSAwO1xuICAgIHRoaXMuaGFuZGxlciA9IGJpbmQodGhpcy5vblRpbWVvdXQsIHRoaXMpO1xuICB9O1xuICBEZWxheWVkLnByb3RvdHlwZS5vblRpbWVvdXQgPSBmdW5jdGlvbiAoc2VsZikge1xuICAgIHNlbGYuaWQgPSAwO1xuICAgIGlmIChzZWxmLnRpbWUgPD0gK25ldyBEYXRlKSB7XG4gICAgICBzZWxmLmYoKTtcbiAgICB9IGVsc2Uge1xuICAgICAgc2V0VGltZW91dChzZWxmLmhhbmRsZXIsIHNlbGYudGltZSAtICtuZXcgRGF0ZSk7XG4gICAgfVxuICB9O1xuICBEZWxheWVkLnByb3RvdHlwZS5zZXQgPSBmdW5jdGlvbiAobXMsIGYpIHtcbiAgICB0aGlzLmYgPSBmO1xuICAgIHZhciB0aW1lID0gK25ldyBEYXRlICsgbXM7XG4gICAgaWYgKCF0aGlzLmlkIHx8IHRpbWUgPCB0aGlzLnRpbWUpIHtcbiAgICAgIGNsZWFyVGltZW91dCh0aGlzLmlkKTtcbiAgICAgIHRoaXMuaWQgPSBzZXRUaW1lb3V0KHRoaXMuaGFuZGxlciwgbXMpO1xuICAgICAgdGhpcy50aW1lID0gdGltZTtcbiAgICB9XG4gIH07XG5cbiAgZnVuY3Rpb24gaW5kZXhPZihhcnJheSwgZWx0KSB7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBhcnJheS5sZW5ndGg7ICsraSlcbiAgICAgIHsgaWYgKGFycmF5W2ldID09IGVsdCkgeyByZXR1cm4gaSB9IH1cbiAgICByZXR1cm4gLTFcbiAgfVxuXG4gIC8vIE51bWJlciBvZiBwaXhlbHMgYWRkZWQgdG8gc2Nyb2xsZXIgYW5kIHNpemVyIHRvIGhpZGUgc2Nyb2xsYmFyXG4gIHZhciBzY3JvbGxlckdhcCA9IDUwO1xuXG4gIC8vIFJldHVybmVkIG9yIHRocm93biBieSB2YXJpb3VzIHByb3RvY29scyB0byBzaWduYWwgJ0knbSBub3RcbiAgLy8gaGFuZGxpbmcgdGhpcycuXG4gIHZhciBQYXNzID0ge3RvU3RyaW5nOiBmdW5jdGlvbigpe3JldHVybiBcIkNvZGVNaXJyb3IuUGFzc1wifX07XG5cbiAgLy8gUmV1c2VkIG9wdGlvbiBvYmplY3RzIGZvciBzZXRTZWxlY3Rpb24gJiBmcmllbmRzXG4gIHZhciBzZWxfZG9udFNjcm9sbCA9IHtzY3JvbGw6IGZhbHNlfSwgc2VsX21vdXNlID0ge29yaWdpbjogXCIqbW91c2VcIn0sIHNlbF9tb3ZlID0ge29yaWdpbjogXCIrbW92ZVwifTtcblxuICAvLyBUaGUgaW52ZXJzZSBvZiBjb3VudENvbHVtbiAtLSBmaW5kIHRoZSBvZmZzZXQgdGhhdCBjb3JyZXNwb25kcyB0b1xuICAvLyBhIHBhcnRpY3VsYXIgY29sdW1uLlxuICBmdW5jdGlvbiBmaW5kQ29sdW1uKHN0cmluZywgZ29hbCwgdGFiU2l6ZSkge1xuICAgIGZvciAodmFyIHBvcyA9IDAsIGNvbCA9IDA7Oykge1xuICAgICAgdmFyIG5leHRUYWIgPSBzdHJpbmcuaW5kZXhPZihcIlxcdFwiLCBwb3MpO1xuICAgICAgaWYgKG5leHRUYWIgPT0gLTEpIHsgbmV4dFRhYiA9IHN0cmluZy5sZW5ndGg7IH1cbiAgICAgIHZhciBza2lwcGVkID0gbmV4dFRhYiAtIHBvcztcbiAgICAgIGlmIChuZXh0VGFiID09IHN0cmluZy5sZW5ndGggfHwgY29sICsgc2tpcHBlZCA+PSBnb2FsKVxuICAgICAgICB7IHJldHVybiBwb3MgKyBNYXRoLm1pbihza2lwcGVkLCBnb2FsIC0gY29sKSB9XG4gICAgICBjb2wgKz0gbmV4dFRhYiAtIHBvcztcbiAgICAgIGNvbCArPSB0YWJTaXplIC0gKGNvbCAlIHRhYlNpemUpO1xuICAgICAgcG9zID0gbmV4dFRhYiArIDE7XG4gICAgICBpZiAoY29sID49IGdvYWwpIHsgcmV0dXJuIHBvcyB9XG4gICAgfVxuICB9XG5cbiAgdmFyIHNwYWNlU3RycyA9IFtcIlwiXTtcbiAgZnVuY3Rpb24gc3BhY2VTdHIobikge1xuICAgIHdoaWxlIChzcGFjZVN0cnMubGVuZ3RoIDw9IG4pXG4gICAgICB7IHNwYWNlU3Rycy5wdXNoKGxzdChzcGFjZVN0cnMpICsgXCIgXCIpOyB9XG4gICAgcmV0dXJuIHNwYWNlU3Ryc1tuXVxuICB9XG5cbiAgZnVuY3Rpb24gbHN0KGFycikgeyByZXR1cm4gYXJyW2Fyci5sZW5ndGgtMV0gfVxuXG4gIGZ1bmN0aW9uIG1hcChhcnJheSwgZikge1xuICAgIHZhciBvdXQgPSBbXTtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGFycmF5Lmxlbmd0aDsgaSsrKSB7IG91dFtpXSA9IGYoYXJyYXlbaV0sIGkpOyB9XG4gICAgcmV0dXJuIG91dFxuICB9XG5cbiAgZnVuY3Rpb24gaW5zZXJ0U29ydGVkKGFycmF5LCB2YWx1ZSwgc2NvcmUpIHtcbiAgICB2YXIgcG9zID0gMCwgcHJpb3JpdHkgPSBzY29yZSh2YWx1ZSk7XG4gICAgd2hpbGUgKHBvcyA8IGFycmF5Lmxlbmd0aCAmJiBzY29yZShhcnJheVtwb3NdKSA8PSBwcmlvcml0eSkgeyBwb3MrKzsgfVxuICAgIGFycmF5LnNwbGljZShwb3MsIDAsIHZhbHVlKTtcbiAgfVxuXG4gIGZ1bmN0aW9uIG5vdGhpbmcoKSB7fVxuXG4gIGZ1bmN0aW9uIGNyZWF0ZU9iaihiYXNlLCBwcm9wcykge1xuICAgIHZhciBpbnN0O1xuICAgIGlmIChPYmplY3QuY3JlYXRlKSB7XG4gICAgICBpbnN0ID0gT2JqZWN0LmNyZWF0ZShiYXNlKTtcbiAgICB9IGVsc2Uge1xuICAgICAgbm90aGluZy5wcm90b3R5cGUgPSBiYXNlO1xuICAgICAgaW5zdCA9IG5ldyBub3RoaW5nKCk7XG4gICAgfVxuICAgIGlmIChwcm9wcykgeyBjb3B5T2JqKHByb3BzLCBpbnN0KTsgfVxuICAgIHJldHVybiBpbnN0XG4gIH1cblxuICB2YXIgbm9uQVNDSUlTaW5nbGVDYXNlV29yZENoYXIgPSAvW1xcdTAwZGZcXHUwNTg3XFx1MDU5MC1cXHUwNWY0XFx1MDYwMC1cXHUwNmZmXFx1MzA0MC1cXHUzMDlmXFx1MzBhMC1cXHUzMGZmXFx1MzQwMC1cXHU0ZGI1XFx1NGUwMC1cXHU5ZmNjXFx1YWMwMC1cXHVkN2FmXS87XG4gIGZ1bmN0aW9uIGlzV29yZENoYXJCYXNpYyhjaCkge1xuICAgIHJldHVybiAvXFx3Ly50ZXN0KGNoKSB8fCBjaCA+IFwiXFx4ODBcIiAmJlxuICAgICAgKGNoLnRvVXBwZXJDYXNlKCkgIT0gY2gudG9Mb3dlckNhc2UoKSB8fCBub25BU0NJSVNpbmdsZUNhc2VXb3JkQ2hhci50ZXN0KGNoKSlcbiAgfVxuICBmdW5jdGlvbiBpc1dvcmRDaGFyKGNoLCBoZWxwZXIpIHtcbiAgICBpZiAoIWhlbHBlcikgeyByZXR1cm4gaXNXb3JkQ2hhckJhc2ljKGNoKSB9XG4gICAgaWYgKGhlbHBlci5zb3VyY2UuaW5kZXhPZihcIlxcXFx3XCIpID4gLTEgJiYgaXNXb3JkQ2hhckJhc2ljKGNoKSkgeyByZXR1cm4gdHJ1ZSB9XG4gICAgcmV0dXJuIGhlbHBlci50ZXN0KGNoKVxuICB9XG5cbiAgZnVuY3Rpb24gaXNFbXB0eShvYmopIHtcbiAgICBmb3IgKHZhciBuIGluIG9iaikgeyBpZiAob2JqLmhhc093blByb3BlcnR5KG4pICYmIG9ialtuXSkgeyByZXR1cm4gZmFsc2UgfSB9XG4gICAgcmV0dXJuIHRydWVcbiAgfVxuXG4gIC8vIEV4dGVuZGluZyB1bmljb2RlIGNoYXJhY3RlcnMuIEEgc2VyaWVzIG9mIGEgbm9uLWV4dGVuZGluZyBjaGFyICtcbiAgLy8gYW55IG51bWJlciBvZiBleHRlbmRpbmcgY2hhcnMgaXMgdHJlYXRlZCBhcyBhIHNpbmdsZSB1bml0IGFzIGZhclxuICAvLyBhcyBlZGl0aW5nIGFuZCBtZWFzdXJpbmcgaXMgY29uY2VybmVkLiBUaGlzIGlzIG5vdCBmdWxseSBjb3JyZWN0LFxuICAvLyBzaW5jZSBzb21lIHNjcmlwdHMvZm9udHMvYnJvd3NlcnMgYWxzbyB0cmVhdCBvdGhlciBjb25maWd1cmF0aW9uc1xuICAvLyBvZiBjb2RlIHBvaW50cyBhcyBhIGdyb3VwLlxuICB2YXIgZXh0ZW5kaW5nQ2hhcnMgPSAvW1xcdTAzMDAtXFx1MDM2ZlxcdTA0ODMtXFx1MDQ4OVxcdTA1OTEtXFx1MDViZFxcdTA1YmZcXHUwNWMxXFx1MDVjMlxcdTA1YzRcXHUwNWM1XFx1MDVjN1xcdTA2MTAtXFx1MDYxYVxcdTA2NGItXFx1MDY1ZVxcdTA2NzBcXHUwNmQ2LVxcdTA2ZGNcXHUwNmRlLVxcdTA2ZTRcXHUwNmU3XFx1MDZlOFxcdTA2ZWEtXFx1MDZlZFxcdTA3MTFcXHUwNzMwLVxcdTA3NGFcXHUwN2E2LVxcdTA3YjBcXHUwN2ViLVxcdTA3ZjNcXHUwODE2LVxcdTA4MTlcXHUwODFiLVxcdTA4MjNcXHUwODI1LVxcdTA4MjdcXHUwODI5LVxcdTA4MmRcXHUwOTAwLVxcdTA5MDJcXHUwOTNjXFx1MDk0MS1cXHUwOTQ4XFx1MDk0ZFxcdTA5NTEtXFx1MDk1NVxcdTA5NjJcXHUwOTYzXFx1MDk4MVxcdTA5YmNcXHUwOWJlXFx1MDljMS1cXHUwOWM0XFx1MDljZFxcdTA5ZDdcXHUwOWUyXFx1MDllM1xcdTBhMDFcXHUwYTAyXFx1MGEzY1xcdTBhNDFcXHUwYTQyXFx1MGE0N1xcdTBhNDhcXHUwYTRiLVxcdTBhNGRcXHUwYTUxXFx1MGE3MFxcdTBhNzFcXHUwYTc1XFx1MGE4MVxcdTBhODJcXHUwYWJjXFx1MGFjMS1cXHUwYWM1XFx1MGFjN1xcdTBhYzhcXHUwYWNkXFx1MGFlMlxcdTBhZTNcXHUwYjAxXFx1MGIzY1xcdTBiM2VcXHUwYjNmXFx1MGI0MS1cXHUwYjQ0XFx1MGI0ZFxcdTBiNTZcXHUwYjU3XFx1MGI2MlxcdTBiNjNcXHUwYjgyXFx1MGJiZVxcdTBiYzBcXHUwYmNkXFx1MGJkN1xcdTBjM2UtXFx1MGM0MFxcdTBjNDYtXFx1MGM0OFxcdTBjNGEtXFx1MGM0ZFxcdTBjNTVcXHUwYzU2XFx1MGM2MlxcdTBjNjNcXHUwY2JjXFx1MGNiZlxcdTBjYzJcXHUwY2M2XFx1MGNjY1xcdTBjY2RcXHUwY2Q1XFx1MGNkNlxcdTBjZTJcXHUwY2UzXFx1MGQzZVxcdTBkNDEtXFx1MGQ0NFxcdTBkNGRcXHUwZDU3XFx1MGQ2MlxcdTBkNjNcXHUwZGNhXFx1MGRjZlxcdTBkZDItXFx1MGRkNFxcdTBkZDZcXHUwZGRmXFx1MGUzMVxcdTBlMzQtXFx1MGUzYVxcdTBlNDctXFx1MGU0ZVxcdTBlYjFcXHUwZWI0LVxcdTBlYjlcXHUwZWJiXFx1MGViY1xcdTBlYzgtXFx1MGVjZFxcdTBmMThcXHUwZjE5XFx1MGYzNVxcdTBmMzdcXHUwZjM5XFx1MGY3MS1cXHUwZjdlXFx1MGY4MC1cXHUwZjg0XFx1MGY4NlxcdTBmODdcXHUwZjkwLVxcdTBmOTdcXHUwZjk5LVxcdTBmYmNcXHUwZmM2XFx1MTAyZC1cXHUxMDMwXFx1MTAzMi1cXHUxMDM3XFx1MTAzOVxcdTEwM2FcXHUxMDNkXFx1MTAzZVxcdTEwNThcXHUxMDU5XFx1MTA1ZS1cXHUxMDYwXFx1MTA3MS1cXHUxMDc0XFx1MTA4MlxcdTEwODVcXHUxMDg2XFx1MTA4ZFxcdTEwOWRcXHUxMzVmXFx1MTcxMi1cXHUxNzE0XFx1MTczMi1cXHUxNzM0XFx1MTc1MlxcdTE3NTNcXHUxNzcyXFx1MTc3M1xcdTE3YjctXFx1MTdiZFxcdTE3YzZcXHUxN2M5LVxcdTE3ZDNcXHUxN2RkXFx1MTgwYi1cXHUxODBkXFx1MThhOVxcdTE5MjAtXFx1MTkyMlxcdTE5MjdcXHUxOTI4XFx1MTkzMlxcdTE5MzktXFx1MTkzYlxcdTFhMTdcXHUxYTE4XFx1MWE1NlxcdTFhNTgtXFx1MWE1ZVxcdTFhNjBcXHUxYTYyXFx1MWE2NS1cXHUxYTZjXFx1MWE3My1cXHUxYTdjXFx1MWE3ZlxcdTFiMDAtXFx1MWIwM1xcdTFiMzRcXHUxYjM2LVxcdTFiM2FcXHUxYjNjXFx1MWI0MlxcdTFiNmItXFx1MWI3M1xcdTFiODBcXHUxYjgxXFx1MWJhMi1cXHUxYmE1XFx1MWJhOFxcdTFiYTlcXHUxYzJjLVxcdTFjMzNcXHUxYzM2XFx1MWMzN1xcdTFjZDAtXFx1MWNkMlxcdTFjZDQtXFx1MWNlMFxcdTFjZTItXFx1MWNlOFxcdTFjZWRcXHUxZGMwLVxcdTFkZTZcXHUxZGZkLVxcdTFkZmZcXHUyMDBjXFx1MjAwZFxcdTIwZDAtXFx1MjBmMFxcdTJjZWYtXFx1MmNmMVxcdTJkZTAtXFx1MmRmZlxcdTMwMmEtXFx1MzAyZlxcdTMwOTlcXHUzMDlhXFx1YTY2Zi1cXHVhNjcyXFx1YTY3Y1xcdWE2N2RcXHVhNmYwXFx1YTZmMVxcdWE4MDJcXHVhODA2XFx1YTgwYlxcdWE4MjVcXHVhODI2XFx1YThjNFxcdWE4ZTAtXFx1YThmMVxcdWE5MjYtXFx1YTkyZFxcdWE5NDctXFx1YTk1MVxcdWE5ODAtXFx1YTk4MlxcdWE5YjNcXHVhOWI2LVxcdWE5YjlcXHVhOWJjXFx1YWEyOS1cXHVhYTJlXFx1YWEzMVxcdWFhMzJcXHVhYTM1XFx1YWEzNlxcdWFhNDNcXHVhYTRjXFx1YWFiMFxcdWFhYjItXFx1YWFiNFxcdWFhYjdcXHVhYWI4XFx1YWFiZVxcdWFhYmZcXHVhYWMxXFx1YWJlNVxcdWFiZThcXHVhYmVkXFx1ZGMwMC1cXHVkZmZmXFx1ZmIxZVxcdWZlMDAtXFx1ZmUwZlxcdWZlMjAtXFx1ZmUyNlxcdWZmOWVcXHVmZjlmXS87XG4gIGZ1bmN0aW9uIGlzRXh0ZW5kaW5nQ2hhcihjaCkgeyByZXR1cm4gY2guY2hhckNvZGVBdCgwKSA+PSA3NjggJiYgZXh0ZW5kaW5nQ2hhcnMudGVzdChjaCkgfVxuXG4gIC8vIFJldHVybnMgYSBudW1iZXIgZnJvbSB0aGUgcmFuZ2UgW2AwYDsgYHN0ci5sZW5ndGhgXSB1bmxlc3MgYHBvc2AgaXMgb3V0c2lkZSB0aGF0IHJhbmdlLlxuICBmdW5jdGlvbiBza2lwRXh0ZW5kaW5nQ2hhcnMoc3RyLCBwb3MsIGRpcikge1xuICAgIHdoaWxlICgoZGlyIDwgMCA/IHBvcyA+IDAgOiBwb3MgPCBzdHIubGVuZ3RoKSAmJiBpc0V4dGVuZGluZ0NoYXIoc3RyLmNoYXJBdChwb3MpKSkgeyBwb3MgKz0gZGlyOyB9XG4gICAgcmV0dXJuIHBvc1xuICB9XG5cbiAgLy8gUmV0dXJucyB0aGUgdmFsdWUgZnJvbSB0aGUgcmFuZ2UgW2Bmcm9tYDsgYHRvYF0gdGhhdCBzYXRpc2ZpZXNcbiAgLy8gYHByZWRgIGFuZCBpcyBjbG9zZXN0IHRvIGBmcm9tYC4gQXNzdW1lcyB0aGF0IGF0IGxlYXN0IGB0b2BcbiAgLy8gc2F0aXNmaWVzIGBwcmVkYC4gU3VwcG9ydHMgYGZyb21gIGJlaW5nIGdyZWF0ZXIgdGhhbiBgdG9gLlxuICBmdW5jdGlvbiBmaW5kRmlyc3QocHJlZCwgZnJvbSwgdG8pIHtcbiAgICAvLyBBdCBhbnkgcG9pbnQgd2UgYXJlIGNlcnRhaW4gYHRvYCBzYXRpc2ZpZXMgYHByZWRgLCBkb24ndCBrbm93XG4gICAgLy8gd2hldGhlciBgZnJvbWAgZG9lcy5cbiAgICB2YXIgZGlyID0gZnJvbSA+IHRvID8gLTEgOiAxO1xuICAgIGZvciAoOzspIHtcbiAgICAgIGlmIChmcm9tID09IHRvKSB7IHJldHVybiBmcm9tIH1cbiAgICAgIHZhciBtaWRGID0gKGZyb20gKyB0bykgLyAyLCBtaWQgPSBkaXIgPCAwID8gTWF0aC5jZWlsKG1pZEYpIDogTWF0aC5mbG9vcihtaWRGKTtcbiAgICAgIGlmIChtaWQgPT0gZnJvbSkgeyByZXR1cm4gcHJlZChtaWQpID8gZnJvbSA6IHRvIH1cbiAgICAgIGlmIChwcmVkKG1pZCkpIHsgdG8gPSBtaWQ7IH1cbiAgICAgIGVsc2UgeyBmcm9tID0gbWlkICsgZGlyOyB9XG4gICAgfVxuICB9XG5cbiAgLy8gQklESSBIRUxQRVJTXG5cbiAgZnVuY3Rpb24gaXRlcmF0ZUJpZGlTZWN0aW9ucyhvcmRlciwgZnJvbSwgdG8sIGYpIHtcbiAgICBpZiAoIW9yZGVyKSB7IHJldHVybiBmKGZyb20sIHRvLCBcImx0clwiLCAwKSB9XG4gICAgdmFyIGZvdW5kID0gZmFsc2U7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBvcmRlci5sZW5ndGg7ICsraSkge1xuICAgICAgdmFyIHBhcnQgPSBvcmRlcltpXTtcbiAgICAgIGlmIChwYXJ0LmZyb20gPCB0byAmJiBwYXJ0LnRvID4gZnJvbSB8fCBmcm9tID09IHRvICYmIHBhcnQudG8gPT0gZnJvbSkge1xuICAgICAgICBmKE1hdGgubWF4KHBhcnQuZnJvbSwgZnJvbSksIE1hdGgubWluKHBhcnQudG8sIHRvKSwgcGFydC5sZXZlbCA9PSAxID8gXCJydGxcIiA6IFwibHRyXCIsIGkpO1xuICAgICAgICBmb3VuZCA9IHRydWU7XG4gICAgICB9XG4gICAgfVxuICAgIGlmICghZm91bmQpIHsgZihmcm9tLCB0bywgXCJsdHJcIik7IH1cbiAgfVxuXG4gIHZhciBiaWRpT3RoZXIgPSBudWxsO1xuICBmdW5jdGlvbiBnZXRCaWRpUGFydEF0KG9yZGVyLCBjaCwgc3RpY2t5KSB7XG4gICAgdmFyIGZvdW5kO1xuICAgIGJpZGlPdGhlciA9IG51bGw7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBvcmRlci5sZW5ndGg7ICsraSkge1xuICAgICAgdmFyIGN1ciA9IG9yZGVyW2ldO1xuICAgICAgaWYgKGN1ci5mcm9tIDwgY2ggJiYgY3VyLnRvID4gY2gpIHsgcmV0dXJuIGkgfVxuICAgICAgaWYgKGN1ci50byA9PSBjaCkge1xuICAgICAgICBpZiAoY3VyLmZyb20gIT0gY3VyLnRvICYmIHN0aWNreSA9PSBcImJlZm9yZVwiKSB7IGZvdW5kID0gaTsgfVxuICAgICAgICBlbHNlIHsgYmlkaU90aGVyID0gaTsgfVxuICAgICAgfVxuICAgICAgaWYgKGN1ci5mcm9tID09IGNoKSB7XG4gICAgICAgIGlmIChjdXIuZnJvbSAhPSBjdXIudG8gJiYgc3RpY2t5ICE9IFwiYmVmb3JlXCIpIHsgZm91bmQgPSBpOyB9XG4gICAgICAgIGVsc2UgeyBiaWRpT3RoZXIgPSBpOyB9XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiBmb3VuZCAhPSBudWxsID8gZm91bmQgOiBiaWRpT3RoZXJcbiAgfVxuXG4gIC8vIEJpZGlyZWN0aW9uYWwgb3JkZXJpbmcgYWxnb3JpdGhtXG4gIC8vIFNlZSBodHRwOi8vdW5pY29kZS5vcmcvcmVwb3J0cy90cjkvdHI5LTEzLmh0bWwgZm9yIHRoZSBhbGdvcml0aG1cbiAgLy8gdGhhdCB0aGlzIChwYXJ0aWFsbHkpIGltcGxlbWVudHMuXG5cbiAgLy8gT25lLWNoYXIgY29kZXMgdXNlZCBmb3IgY2hhcmFjdGVyIHR5cGVzOlxuICAvLyBMIChMKTogICBMZWZ0LXRvLVJpZ2h0XG4gIC8vIFIgKFIpOiAgIFJpZ2h0LXRvLUxlZnRcbiAgLy8gciAoQUwpOiAgUmlnaHQtdG8tTGVmdCBBcmFiaWNcbiAgLy8gMSAoRU4pOiAgRXVyb3BlYW4gTnVtYmVyXG4gIC8vICsgKEVTKTogIEV1cm9wZWFuIE51bWJlciBTZXBhcmF0b3JcbiAgLy8gJSAoRVQpOiAgRXVyb3BlYW4gTnVtYmVyIFRlcm1pbmF0b3JcbiAgLy8gbiAoQU4pOiAgQXJhYmljIE51bWJlclxuICAvLyAsIChDUyk6ICBDb21tb24gTnVtYmVyIFNlcGFyYXRvclxuICAvLyBtIChOU00pOiBOb24tU3BhY2luZyBNYXJrXG4gIC8vIGIgKEJOKTogIEJvdW5kYXJ5IE5ldXRyYWxcbiAgLy8gcyAoQik6ICAgUGFyYWdyYXBoIFNlcGFyYXRvclxuICAvLyB0IChTKTogICBTZWdtZW50IFNlcGFyYXRvclxuICAvLyB3IChXUyk6ICBXaGl0ZXNwYWNlXG4gIC8vIE4gKE9OKTogIE90aGVyIE5ldXRyYWxzXG5cbiAgLy8gUmV0dXJucyBudWxsIGlmIGNoYXJhY3RlcnMgYXJlIG9yZGVyZWQgYXMgdGhleSBhcHBlYXJcbiAgLy8gKGxlZnQtdG8tcmlnaHQpLCBvciBhbiBhcnJheSBvZiBzZWN0aW9ucyAoe2Zyb20sIHRvLCBsZXZlbH1cbiAgLy8gb2JqZWN0cykgaW4gdGhlIG9yZGVyIGluIHdoaWNoIHRoZXkgb2NjdXIgdmlzdWFsbHkuXG4gIHZhciBiaWRpT3JkZXJpbmcgPSAoZnVuY3Rpb24oKSB7XG4gICAgLy8gQ2hhcmFjdGVyIHR5cGVzIGZvciBjb2RlcG9pbnRzIDAgdG8gMHhmZlxuICAgIHZhciBsb3dUeXBlcyA9IFwiYmJiYmJiYmJidHN0d3NiYmJiYmJiYmJiYmJiYnNzc3R3Tk4lJSVOTk5OTk4sTixOMTExMTExMTExMU5OTk5OTk5MTExMTExMTExMTExMTExMTExMTExMTExMTE5OTk5OTkxMTExMTExMTExMTExMTExMTExMTExMTExMTk5OTmJiYmJiYnNiYmJiYmJiYmJiYmJiYmJiYmJiYmJiYmJiYixOJSUlJU5OTk5MTk5OTk4lJTExTkxOTk4xTE5OTk5OTExMTExMTExMTExMTExMTExMTExMTExOTExMTExMTExMTExMTExMTExMTExMTExMTExMTExMTE5cIjtcbiAgICAvLyBDaGFyYWN0ZXIgdHlwZXMgZm9yIGNvZGVwb2ludHMgMHg2MDAgdG8gMHg2ZjlcbiAgICB2YXIgYXJhYmljVHlwZXMgPSBcIm5ubm5ubk5OciUlcixyTk5tbW1tbW1tbW1tbXJycnJycnJycnJycnJycnJycnJycnJycnJycnJycnJycnJycnJycnJycnJycnJycm1tbW1tbW1tbW1tbW1tbW1tbW1tbW5ubm5ubm5ubm4lbm5ycnJtcnJycnJycnJycnJycnJycnJycnJycnJycnJycnJycnJycnJycnJycnJycnJycnJycnJycnJycnJycnJycnJycnJycnJycnJycnJycnJycnJycnJycnJycnJycnJycnJycnJycnJtbW1tbW1tbk5tbW1tbW1ycm1tTm1tbW1ycjExMTExMTExMTFcIjtcbiAgICBmdW5jdGlvbiBjaGFyVHlwZShjb2RlKSB7XG4gICAgICBpZiAoY29kZSA8PSAweGY3KSB7IHJldHVybiBsb3dUeXBlcy5jaGFyQXQoY29kZSkgfVxuICAgICAgZWxzZSBpZiAoMHg1OTAgPD0gY29kZSAmJiBjb2RlIDw9IDB4NWY0KSB7IHJldHVybiBcIlJcIiB9XG4gICAgICBlbHNlIGlmICgweDYwMCA8PSBjb2RlICYmIGNvZGUgPD0gMHg2ZjkpIHsgcmV0dXJuIGFyYWJpY1R5cGVzLmNoYXJBdChjb2RlIC0gMHg2MDApIH1cbiAgICAgIGVsc2UgaWYgKDB4NmVlIDw9IGNvZGUgJiYgY29kZSA8PSAweDhhYykgeyByZXR1cm4gXCJyXCIgfVxuICAgICAgZWxzZSBpZiAoMHgyMDAwIDw9IGNvZGUgJiYgY29kZSA8PSAweDIwMGIpIHsgcmV0dXJuIFwid1wiIH1cbiAgICAgIGVsc2UgaWYgKGNvZGUgPT0gMHgyMDBjKSB7IHJldHVybiBcImJcIiB9XG4gICAgICBlbHNlIHsgcmV0dXJuIFwiTFwiIH1cbiAgICB9XG5cbiAgICB2YXIgYmlkaVJFID0gL1tcXHUwNTkwLVxcdTA1ZjRcXHUwNjAwLVxcdTA2ZmZcXHUwNzAwLVxcdTA4YWNdLztcbiAgICB2YXIgaXNOZXV0cmFsID0gL1tzdHdOXS8sIGlzU3Ryb25nID0gL1tMUnJdLywgY291bnRzQXNMZWZ0ID0gL1tMYjFuXS8sIGNvdW50c0FzTnVtID0gL1sxbl0vO1xuXG4gICAgZnVuY3Rpb24gQmlkaVNwYW4obGV2ZWwsIGZyb20sIHRvKSB7XG4gICAgICB0aGlzLmxldmVsID0gbGV2ZWw7XG4gICAgICB0aGlzLmZyb20gPSBmcm9tOyB0aGlzLnRvID0gdG87XG4gICAgfVxuXG4gICAgcmV0dXJuIGZ1bmN0aW9uKHN0ciwgZGlyZWN0aW9uKSB7XG4gICAgICB2YXIgb3V0ZXJUeXBlID0gZGlyZWN0aW9uID09IFwibHRyXCIgPyBcIkxcIiA6IFwiUlwiO1xuXG4gICAgICBpZiAoc3RyLmxlbmd0aCA9PSAwIHx8IGRpcmVjdGlvbiA9PSBcImx0clwiICYmICFiaWRpUkUudGVzdChzdHIpKSB7IHJldHVybiBmYWxzZSB9XG4gICAgICB2YXIgbGVuID0gc3RyLmxlbmd0aCwgdHlwZXMgPSBbXTtcbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbGVuOyArK2kpXG4gICAgICAgIHsgdHlwZXMucHVzaChjaGFyVHlwZShzdHIuY2hhckNvZGVBdChpKSkpOyB9XG5cbiAgICAgIC8vIFcxLiBFeGFtaW5lIGVhY2ggbm9uLXNwYWNpbmcgbWFyayAoTlNNKSBpbiB0aGUgbGV2ZWwgcnVuLCBhbmRcbiAgICAgIC8vIGNoYW5nZSB0aGUgdHlwZSBvZiB0aGUgTlNNIHRvIHRoZSB0eXBlIG9mIHRoZSBwcmV2aW91c1xuICAgICAgLy8gY2hhcmFjdGVyLiBJZiB0aGUgTlNNIGlzIGF0IHRoZSBzdGFydCBvZiB0aGUgbGV2ZWwgcnVuLCBpdCB3aWxsXG4gICAgICAvLyBnZXQgdGhlIHR5cGUgb2Ygc29yLlxuICAgICAgZm9yICh2YXIgaSQxID0gMCwgcHJldiA9IG91dGVyVHlwZTsgaSQxIDwgbGVuOyArK2kkMSkge1xuICAgICAgICB2YXIgdHlwZSA9IHR5cGVzW2kkMV07XG4gICAgICAgIGlmICh0eXBlID09IFwibVwiKSB7IHR5cGVzW2kkMV0gPSBwcmV2OyB9XG4gICAgICAgIGVsc2UgeyBwcmV2ID0gdHlwZTsgfVxuICAgICAgfVxuXG4gICAgICAvLyBXMi4gU2VhcmNoIGJhY2t3YXJkcyBmcm9tIGVhY2ggaW5zdGFuY2Ugb2YgYSBFdXJvcGVhbiBudW1iZXJcbiAgICAgIC8vIHVudGlsIHRoZSBmaXJzdCBzdHJvbmcgdHlwZSAoUiwgTCwgQUwsIG9yIHNvcikgaXMgZm91bmQuIElmIGFuXG4gICAgICAvLyBBTCBpcyBmb3VuZCwgY2hhbmdlIHRoZSB0eXBlIG9mIHRoZSBFdXJvcGVhbiBudW1iZXIgdG8gQXJhYmljXG4gICAgICAvLyBudW1iZXIuXG4gICAgICAvLyBXMy4gQ2hhbmdlIGFsbCBBTHMgdG8gUi5cbiAgICAgIGZvciAodmFyIGkkMiA9IDAsIGN1ciA9IG91dGVyVHlwZTsgaSQyIDwgbGVuOyArK2kkMikge1xuICAgICAgICB2YXIgdHlwZSQxID0gdHlwZXNbaSQyXTtcbiAgICAgICAgaWYgKHR5cGUkMSA9PSBcIjFcIiAmJiBjdXIgPT0gXCJyXCIpIHsgdHlwZXNbaSQyXSA9IFwiblwiOyB9XG4gICAgICAgIGVsc2UgaWYgKGlzU3Ryb25nLnRlc3QodHlwZSQxKSkgeyBjdXIgPSB0eXBlJDE7IGlmICh0eXBlJDEgPT0gXCJyXCIpIHsgdHlwZXNbaSQyXSA9IFwiUlwiOyB9IH1cbiAgICAgIH1cblxuICAgICAgLy8gVzQuIEEgc2luZ2xlIEV1cm9wZWFuIHNlcGFyYXRvciBiZXR3ZWVuIHR3byBFdXJvcGVhbiBudW1iZXJzXG4gICAgICAvLyBjaGFuZ2VzIHRvIGEgRXVyb3BlYW4gbnVtYmVyLiBBIHNpbmdsZSBjb21tb24gc2VwYXJhdG9yIGJldHdlZW5cbiAgICAgIC8vIHR3byBudW1iZXJzIG9mIHRoZSBzYW1lIHR5cGUgY2hhbmdlcyB0byB0aGF0IHR5cGUuXG4gICAgICBmb3IgKHZhciBpJDMgPSAxLCBwcmV2JDEgPSB0eXBlc1swXTsgaSQzIDwgbGVuIC0gMTsgKytpJDMpIHtcbiAgICAgICAgdmFyIHR5cGUkMiA9IHR5cGVzW2kkM107XG4gICAgICAgIGlmICh0eXBlJDIgPT0gXCIrXCIgJiYgcHJldiQxID09IFwiMVwiICYmIHR5cGVzW2kkMysxXSA9PSBcIjFcIikgeyB0eXBlc1tpJDNdID0gXCIxXCI7IH1cbiAgICAgICAgZWxzZSBpZiAodHlwZSQyID09IFwiLFwiICYmIHByZXYkMSA9PSB0eXBlc1tpJDMrMV0gJiZcbiAgICAgICAgICAgICAgICAgKHByZXYkMSA9PSBcIjFcIiB8fCBwcmV2JDEgPT0gXCJuXCIpKSB7IHR5cGVzW2kkM10gPSBwcmV2JDE7IH1cbiAgICAgICAgcHJldiQxID0gdHlwZSQyO1xuICAgICAgfVxuXG4gICAgICAvLyBXNS4gQSBzZXF1ZW5jZSBvZiBFdXJvcGVhbiB0ZXJtaW5hdG9ycyBhZGphY2VudCB0byBFdXJvcGVhblxuICAgICAgLy8gbnVtYmVycyBjaGFuZ2VzIHRvIGFsbCBFdXJvcGVhbiBudW1iZXJzLlxuICAgICAgLy8gVzYuIE90aGVyd2lzZSwgc2VwYXJhdG9ycyBhbmQgdGVybWluYXRvcnMgY2hhbmdlIHRvIE90aGVyXG4gICAgICAvLyBOZXV0cmFsLlxuICAgICAgZm9yICh2YXIgaSQ0ID0gMDsgaSQ0IDwgbGVuOyArK2kkNCkge1xuICAgICAgICB2YXIgdHlwZSQzID0gdHlwZXNbaSQ0XTtcbiAgICAgICAgaWYgKHR5cGUkMyA9PSBcIixcIikgeyB0eXBlc1tpJDRdID0gXCJOXCI7IH1cbiAgICAgICAgZWxzZSBpZiAodHlwZSQzID09IFwiJVwiKSB7XG4gICAgICAgICAgdmFyIGVuZCA9ICh2b2lkIDApO1xuICAgICAgICAgIGZvciAoZW5kID0gaSQ0ICsgMTsgZW5kIDwgbGVuICYmIHR5cGVzW2VuZF0gPT0gXCIlXCI7ICsrZW5kKSB7fVxuICAgICAgICAgIHZhciByZXBsYWNlID0gKGkkNCAmJiB0eXBlc1tpJDQtMV0gPT0gXCIhXCIpIHx8IChlbmQgPCBsZW4gJiYgdHlwZXNbZW5kXSA9PSBcIjFcIikgPyBcIjFcIiA6IFwiTlwiO1xuICAgICAgICAgIGZvciAodmFyIGogPSBpJDQ7IGogPCBlbmQ7ICsraikgeyB0eXBlc1tqXSA9IHJlcGxhY2U7IH1cbiAgICAgICAgICBpJDQgPSBlbmQgLSAxO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIC8vIFc3LiBTZWFyY2ggYmFja3dhcmRzIGZyb20gZWFjaCBpbnN0YW5jZSBvZiBhIEV1cm9wZWFuIG51bWJlclxuICAgICAgLy8gdW50aWwgdGhlIGZpcnN0IHN0cm9uZyB0eXBlIChSLCBMLCBvciBzb3IpIGlzIGZvdW5kLiBJZiBhbiBMIGlzXG4gICAgICAvLyBmb3VuZCwgdGhlbiBjaGFuZ2UgdGhlIHR5cGUgb2YgdGhlIEV1cm9wZWFuIG51bWJlciB0byBMLlxuICAgICAgZm9yICh2YXIgaSQ1ID0gMCwgY3VyJDEgPSBvdXRlclR5cGU7IGkkNSA8IGxlbjsgKytpJDUpIHtcbiAgICAgICAgdmFyIHR5cGUkNCA9IHR5cGVzW2kkNV07XG4gICAgICAgIGlmIChjdXIkMSA9PSBcIkxcIiAmJiB0eXBlJDQgPT0gXCIxXCIpIHsgdHlwZXNbaSQ1XSA9IFwiTFwiOyB9XG4gICAgICAgIGVsc2UgaWYgKGlzU3Ryb25nLnRlc3QodHlwZSQ0KSkgeyBjdXIkMSA9IHR5cGUkNDsgfVxuICAgICAgfVxuXG4gICAgICAvLyBOMS4gQSBzZXF1ZW5jZSBvZiBuZXV0cmFscyB0YWtlcyB0aGUgZGlyZWN0aW9uIG9mIHRoZVxuICAgICAgLy8gc3Vycm91bmRpbmcgc3Ryb25nIHRleHQgaWYgdGhlIHRleHQgb24gYm90aCBzaWRlcyBoYXMgdGhlIHNhbWVcbiAgICAgIC8vIGRpcmVjdGlvbi4gRXVyb3BlYW4gYW5kIEFyYWJpYyBudW1iZXJzIGFjdCBhcyBpZiB0aGV5IHdlcmUgUiBpblxuICAgICAgLy8gdGVybXMgb2YgdGhlaXIgaW5mbHVlbmNlIG9uIG5ldXRyYWxzLiBTdGFydC1vZi1sZXZlbC1ydW4gKHNvcilcbiAgICAgIC8vIGFuZCBlbmQtb2YtbGV2ZWwtcnVuIChlb3IpIGFyZSB1c2VkIGF0IGxldmVsIHJ1biBib3VuZGFyaWVzLlxuICAgICAgLy8gTjIuIEFueSByZW1haW5pbmcgbmV1dHJhbHMgdGFrZSB0aGUgZW1iZWRkaW5nIGRpcmVjdGlvbi5cbiAgICAgIGZvciAodmFyIGkkNiA9IDA7IGkkNiA8IGxlbjsgKytpJDYpIHtcbiAgICAgICAgaWYgKGlzTmV1dHJhbC50ZXN0KHR5cGVzW2kkNl0pKSB7XG4gICAgICAgICAgdmFyIGVuZCQxID0gKHZvaWQgMCk7XG4gICAgICAgICAgZm9yIChlbmQkMSA9IGkkNiArIDE7IGVuZCQxIDwgbGVuICYmIGlzTmV1dHJhbC50ZXN0KHR5cGVzW2VuZCQxXSk7ICsrZW5kJDEpIHt9XG4gICAgICAgICAgdmFyIGJlZm9yZSA9IChpJDYgPyB0eXBlc1tpJDYtMV0gOiBvdXRlclR5cGUpID09IFwiTFwiO1xuICAgICAgICAgIHZhciBhZnRlciA9IChlbmQkMSA8IGxlbiA/IHR5cGVzW2VuZCQxXSA6IG91dGVyVHlwZSkgPT0gXCJMXCI7XG4gICAgICAgICAgdmFyIHJlcGxhY2UkMSA9IGJlZm9yZSA9PSBhZnRlciA/IChiZWZvcmUgPyBcIkxcIiA6IFwiUlwiKSA6IG91dGVyVHlwZTtcbiAgICAgICAgICBmb3IgKHZhciBqJDEgPSBpJDY7IGokMSA8IGVuZCQxOyArK2okMSkgeyB0eXBlc1tqJDFdID0gcmVwbGFjZSQxOyB9XG4gICAgICAgICAgaSQ2ID0gZW5kJDEgLSAxO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIC8vIEhlcmUgd2UgZGVwYXJ0IGZyb20gdGhlIGRvY3VtZW50ZWQgYWxnb3JpdGhtLCBpbiBvcmRlciB0byBhdm9pZFxuICAgICAgLy8gYnVpbGRpbmcgdXAgYW4gYWN0dWFsIGxldmVscyBhcnJheS4gU2luY2UgdGhlcmUgYXJlIG9ubHkgdGhyZWVcbiAgICAgIC8vIGxldmVscyAoMCwgMSwgMikgaW4gYW4gaW1wbGVtZW50YXRpb24gdGhhdCBkb2Vzbid0IHRha2VcbiAgICAgIC8vIGV4cGxpY2l0IGVtYmVkZGluZyBpbnRvIGFjY291bnQsIHdlIGNhbiBidWlsZCB1cCB0aGUgb3JkZXIgb25cbiAgICAgIC8vIHRoZSBmbHksIHdpdGhvdXQgZm9sbG93aW5nIHRoZSBsZXZlbC1iYXNlZCBhbGdvcml0aG0uXG4gICAgICB2YXIgb3JkZXIgPSBbXSwgbTtcbiAgICAgIGZvciAodmFyIGkkNyA9IDA7IGkkNyA8IGxlbjspIHtcbiAgICAgICAgaWYgKGNvdW50c0FzTGVmdC50ZXN0KHR5cGVzW2kkN10pKSB7XG4gICAgICAgICAgdmFyIHN0YXJ0ID0gaSQ3O1xuICAgICAgICAgIGZvciAoKytpJDc7IGkkNyA8IGxlbiAmJiBjb3VudHNBc0xlZnQudGVzdCh0eXBlc1tpJDddKTsgKytpJDcpIHt9XG4gICAgICAgICAgb3JkZXIucHVzaChuZXcgQmlkaVNwYW4oMCwgc3RhcnQsIGkkNykpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHZhciBwb3MgPSBpJDcsIGF0ID0gb3JkZXIubGVuZ3RoLCBpc1JUTCA9IGRpcmVjdGlvbiA9PSBcInJ0bFwiID8gMSA6IDA7XG4gICAgICAgICAgZm9yICgrK2kkNzsgaSQ3IDwgbGVuICYmIHR5cGVzW2kkN10gIT0gXCJMXCI7ICsraSQ3KSB7fVxuICAgICAgICAgIGZvciAodmFyIGokMiA9IHBvczsgaiQyIDwgaSQ3Oykge1xuICAgICAgICAgICAgaWYgKGNvdW50c0FzTnVtLnRlc3QodHlwZXNbaiQyXSkpIHtcbiAgICAgICAgICAgICAgaWYgKHBvcyA8IGokMikgeyBvcmRlci5zcGxpY2UoYXQsIDAsIG5ldyBCaWRpU3BhbigxLCBwb3MsIGokMikpOyBhdCArPSBpc1JUTDsgfVxuICAgICAgICAgICAgICB2YXIgbnN0YXJ0ID0gaiQyO1xuICAgICAgICAgICAgICBmb3IgKCsraiQyOyBqJDIgPCBpJDcgJiYgY291bnRzQXNOdW0udGVzdCh0eXBlc1tqJDJdKTsgKytqJDIpIHt9XG4gICAgICAgICAgICAgIG9yZGVyLnNwbGljZShhdCwgMCwgbmV3IEJpZGlTcGFuKDIsIG5zdGFydCwgaiQyKSk7XG4gICAgICAgICAgICAgIGF0ICs9IGlzUlRMO1xuICAgICAgICAgICAgICBwb3MgPSBqJDI7XG4gICAgICAgICAgICB9IGVsc2UgeyArK2okMjsgfVxuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAocG9zIDwgaSQ3KSB7IG9yZGVyLnNwbGljZShhdCwgMCwgbmV3IEJpZGlTcGFuKDEsIHBvcywgaSQ3KSk7IH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgaWYgKGRpcmVjdGlvbiA9PSBcImx0clwiKSB7XG4gICAgICAgIGlmIChvcmRlclswXS5sZXZlbCA9PSAxICYmIChtID0gc3RyLm1hdGNoKC9eXFxzKy8pKSkge1xuICAgICAgICAgIG9yZGVyWzBdLmZyb20gPSBtWzBdLmxlbmd0aDtcbiAgICAgICAgICBvcmRlci51bnNoaWZ0KG5ldyBCaWRpU3BhbigwLCAwLCBtWzBdLmxlbmd0aCkpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChsc3Qob3JkZXIpLmxldmVsID09IDEgJiYgKG0gPSBzdHIubWF0Y2goL1xccyskLykpKSB7XG4gICAgICAgICAgbHN0KG9yZGVyKS50byAtPSBtWzBdLmxlbmd0aDtcbiAgICAgICAgICBvcmRlci5wdXNoKG5ldyBCaWRpU3BhbigwLCBsZW4gLSBtWzBdLmxlbmd0aCwgbGVuKSk7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgcmV0dXJuIGRpcmVjdGlvbiA9PSBcInJ0bFwiID8gb3JkZXIucmV2ZXJzZSgpIDogb3JkZXJcbiAgICB9XG4gIH0pKCk7XG5cbiAgLy8gR2V0IHRoZSBiaWRpIG9yZGVyaW5nIGZvciB0aGUgZ2l2ZW4gbGluZSAoYW5kIGNhY2hlIGl0KS4gUmV0dXJuc1xuICAvLyBmYWxzZSBmb3IgbGluZXMgdGhhdCBhcmUgZnVsbHkgbGVmdC10by1yaWdodCwgYW5kIGFuIGFycmF5IG9mXG4gIC8vIEJpZGlTcGFuIG9iamVjdHMgb3RoZXJ3aXNlLlxuICBmdW5jdGlvbiBnZXRPcmRlcihsaW5lLCBkaXJlY3Rpb24pIHtcbiAgICB2YXIgb3JkZXIgPSBsaW5lLm9yZGVyO1xuICAgIGlmIChvcmRlciA9PSBudWxsKSB7IG9yZGVyID0gbGluZS5vcmRlciA9IGJpZGlPcmRlcmluZyhsaW5lLnRleHQsIGRpcmVjdGlvbik7IH1cbiAgICByZXR1cm4gb3JkZXJcbiAgfVxuXG4gIC8vIEVWRU5UIEhBTkRMSU5HXG5cbiAgLy8gTGlnaHR3ZWlnaHQgZXZlbnQgZnJhbWV3b3JrLiBvbi9vZmYgYWxzbyB3b3JrIG9uIERPTSBub2RlcyxcbiAgLy8gcmVnaXN0ZXJpbmcgbmF0aXZlIERPTSBoYW5kbGVycy5cblxuICB2YXIgbm9IYW5kbGVycyA9IFtdO1xuXG4gIHZhciBvbiA9IGZ1bmN0aW9uKGVtaXR0ZXIsIHR5cGUsIGYpIHtcbiAgICBpZiAoZW1pdHRlci5hZGRFdmVudExpc3RlbmVyKSB7XG4gICAgICBlbWl0dGVyLmFkZEV2ZW50TGlzdGVuZXIodHlwZSwgZiwgZmFsc2UpO1xuICAgIH0gZWxzZSBpZiAoZW1pdHRlci5hdHRhY2hFdmVudCkge1xuICAgICAgZW1pdHRlci5hdHRhY2hFdmVudChcIm9uXCIgKyB0eXBlLCBmKTtcbiAgICB9IGVsc2Uge1xuICAgICAgdmFyIG1hcCA9IGVtaXR0ZXIuX2hhbmRsZXJzIHx8IChlbWl0dGVyLl9oYW5kbGVycyA9IHt9KTtcbiAgICAgIG1hcFt0eXBlXSA9IChtYXBbdHlwZV0gfHwgbm9IYW5kbGVycykuY29uY2F0KGYpO1xuICAgIH1cbiAgfTtcblxuICBmdW5jdGlvbiBnZXRIYW5kbGVycyhlbWl0dGVyLCB0eXBlKSB7XG4gICAgcmV0dXJuIGVtaXR0ZXIuX2hhbmRsZXJzICYmIGVtaXR0ZXIuX2hhbmRsZXJzW3R5cGVdIHx8IG5vSGFuZGxlcnNcbiAgfVxuXG4gIGZ1bmN0aW9uIG9mZihlbWl0dGVyLCB0eXBlLCBmKSB7XG4gICAgaWYgKGVtaXR0ZXIucmVtb3ZlRXZlbnRMaXN0ZW5lcikge1xuICAgICAgZW1pdHRlci5yZW1vdmVFdmVudExpc3RlbmVyKHR5cGUsIGYsIGZhbHNlKTtcbiAgICB9IGVsc2UgaWYgKGVtaXR0ZXIuZGV0YWNoRXZlbnQpIHtcbiAgICAgIGVtaXR0ZXIuZGV0YWNoRXZlbnQoXCJvblwiICsgdHlwZSwgZik7XG4gICAgfSBlbHNlIHtcbiAgICAgIHZhciBtYXAgPSBlbWl0dGVyLl9oYW5kbGVycywgYXJyID0gbWFwICYmIG1hcFt0eXBlXTtcbiAgICAgIGlmIChhcnIpIHtcbiAgICAgICAgdmFyIGluZGV4ID0gaW5kZXhPZihhcnIsIGYpO1xuICAgICAgICBpZiAoaW5kZXggPiAtMSlcbiAgICAgICAgICB7IG1hcFt0eXBlXSA9IGFyci5zbGljZSgwLCBpbmRleCkuY29uY2F0KGFyci5zbGljZShpbmRleCArIDEpKTsgfVxuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIGZ1bmN0aW9uIHNpZ25hbChlbWl0dGVyLCB0eXBlIC8qLCB2YWx1ZXMuLi4qLykge1xuICAgIHZhciBoYW5kbGVycyA9IGdldEhhbmRsZXJzKGVtaXR0ZXIsIHR5cGUpO1xuICAgIGlmICghaGFuZGxlcnMubGVuZ3RoKSB7IHJldHVybiB9XG4gICAgdmFyIGFyZ3MgPSBBcnJheS5wcm90b3R5cGUuc2xpY2UuY2FsbChhcmd1bWVudHMsIDIpO1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgaGFuZGxlcnMubGVuZ3RoOyArK2kpIHsgaGFuZGxlcnNbaV0uYXBwbHkobnVsbCwgYXJncyk7IH1cbiAgfVxuXG4gIC8vIFRoZSBET00gZXZlbnRzIHRoYXQgQ29kZU1pcnJvciBoYW5kbGVzIGNhbiBiZSBvdmVycmlkZGVuIGJ5XG4gIC8vIHJlZ2lzdGVyaW5nIGEgKG5vbi1ET00pIGhhbmRsZXIgb24gdGhlIGVkaXRvciBmb3IgdGhlIGV2ZW50IG5hbWUsXG4gIC8vIGFuZCBwcmV2ZW50RGVmYXVsdC1pbmcgdGhlIGV2ZW50IGluIHRoYXQgaGFuZGxlci5cbiAgZnVuY3Rpb24gc2lnbmFsRE9NRXZlbnQoY20sIGUsIG92ZXJyaWRlKSB7XG4gICAgaWYgKHR5cGVvZiBlID09IFwic3RyaW5nXCIpXG4gICAgICB7IGUgPSB7dHlwZTogZSwgcHJldmVudERlZmF1bHQ6IGZ1bmN0aW9uKCkgeyB0aGlzLmRlZmF1bHRQcmV2ZW50ZWQgPSB0cnVlOyB9fTsgfVxuICAgIHNpZ25hbChjbSwgb3ZlcnJpZGUgfHwgZS50eXBlLCBjbSwgZSk7XG4gICAgcmV0dXJuIGVfZGVmYXVsdFByZXZlbnRlZChlKSB8fCBlLmNvZGVtaXJyb3JJZ25vcmVcbiAgfVxuXG4gIGZ1bmN0aW9uIHNpZ25hbEN1cnNvckFjdGl2aXR5KGNtKSB7XG4gICAgdmFyIGFyciA9IGNtLl9oYW5kbGVycyAmJiBjbS5faGFuZGxlcnMuY3Vyc29yQWN0aXZpdHk7XG4gICAgaWYgKCFhcnIpIHsgcmV0dXJuIH1cbiAgICB2YXIgc2V0ID0gY20uY3VyT3AuY3Vyc29yQWN0aXZpdHlIYW5kbGVycyB8fCAoY20uY3VyT3AuY3Vyc29yQWN0aXZpdHlIYW5kbGVycyA9IFtdKTtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGFyci5sZW5ndGg7ICsraSkgeyBpZiAoaW5kZXhPZihzZXQsIGFycltpXSkgPT0gLTEpXG4gICAgICB7IHNldC5wdXNoKGFycltpXSk7IH0gfVxuICB9XG5cbiAgZnVuY3Rpb24gaGFzSGFuZGxlcihlbWl0dGVyLCB0eXBlKSB7XG4gICAgcmV0dXJuIGdldEhhbmRsZXJzKGVtaXR0ZXIsIHR5cGUpLmxlbmd0aCA+IDBcbiAgfVxuXG4gIC8vIEFkZCBvbiBhbmQgb2ZmIG1ldGhvZHMgdG8gYSBjb25zdHJ1Y3RvcidzIHByb3RvdHlwZSwgdG8gbWFrZVxuICAvLyByZWdpc3RlcmluZyBldmVudHMgb24gc3VjaCBvYmplY3RzIG1vcmUgY29udmVuaWVudC5cbiAgZnVuY3Rpb24gZXZlbnRNaXhpbihjdG9yKSB7XG4gICAgY3Rvci5wcm90b3R5cGUub24gPSBmdW5jdGlvbih0eXBlLCBmKSB7b24odGhpcywgdHlwZSwgZik7fTtcbiAgICBjdG9yLnByb3RvdHlwZS5vZmYgPSBmdW5jdGlvbih0eXBlLCBmKSB7b2ZmKHRoaXMsIHR5cGUsIGYpO307XG4gIH1cblxuICAvLyBEdWUgdG8gdGhlIGZhY3QgdGhhdCB3ZSBzdGlsbCBzdXBwb3J0IGp1cmFzc2ljIElFIHZlcnNpb25zLCBzb21lXG4gIC8vIGNvbXBhdGliaWxpdHkgd3JhcHBlcnMgYXJlIG5lZWRlZC5cblxuICBmdW5jdGlvbiBlX3ByZXZlbnREZWZhdWx0KGUpIHtcbiAgICBpZiAoZS5wcmV2ZW50RGVmYXVsdCkgeyBlLnByZXZlbnREZWZhdWx0KCk7IH1cbiAgICBlbHNlIHsgZS5yZXR1cm5WYWx1ZSA9IGZhbHNlOyB9XG4gIH1cbiAgZnVuY3Rpb24gZV9zdG9wUHJvcGFnYXRpb24oZSkge1xuICAgIGlmIChlLnN0b3BQcm9wYWdhdGlvbikgeyBlLnN0b3BQcm9wYWdhdGlvbigpOyB9XG4gICAgZWxzZSB7IGUuY2FuY2VsQnViYmxlID0gdHJ1ZTsgfVxuICB9XG4gIGZ1bmN0aW9uIGVfZGVmYXVsdFByZXZlbnRlZChlKSB7XG4gICAgcmV0dXJuIGUuZGVmYXVsdFByZXZlbnRlZCAhPSBudWxsID8gZS5kZWZhdWx0UHJldmVudGVkIDogZS5yZXR1cm5WYWx1ZSA9PSBmYWxzZVxuICB9XG4gIGZ1bmN0aW9uIGVfc3RvcChlKSB7ZV9wcmV2ZW50RGVmYXVsdChlKTsgZV9zdG9wUHJvcGFnYXRpb24oZSk7fVxuXG4gIGZ1bmN0aW9uIGVfdGFyZ2V0KGUpIHtyZXR1cm4gZS50YXJnZXQgfHwgZS5zcmNFbGVtZW50fVxuICBmdW5jdGlvbiBlX2J1dHRvbihlKSB7XG4gICAgdmFyIGIgPSBlLndoaWNoO1xuICAgIGlmIChiID09IG51bGwpIHtcbiAgICAgIGlmIChlLmJ1dHRvbiAmIDEpIHsgYiA9IDE7IH1cbiAgICAgIGVsc2UgaWYgKGUuYnV0dG9uICYgMikgeyBiID0gMzsgfVxuICAgICAgZWxzZSBpZiAoZS5idXR0b24gJiA0KSB7IGIgPSAyOyB9XG4gICAgfVxuICAgIGlmIChtYWMgJiYgZS5jdHJsS2V5ICYmIGIgPT0gMSkgeyBiID0gMzsgfVxuICAgIHJldHVybiBiXG4gIH1cblxuICAvLyBEZXRlY3QgZHJhZy1hbmQtZHJvcFxuICB2YXIgZHJhZ0FuZERyb3AgPSBmdW5jdGlvbigpIHtcbiAgICAvLyBUaGVyZSBpcyAqc29tZSoga2luZCBvZiBkcmFnLWFuZC1kcm9wIHN1cHBvcnQgaW4gSUU2LTgsIGJ1dCBJXG4gICAgLy8gY291bGRuJ3QgZ2V0IGl0IHRvIHdvcmsgeWV0LlxuICAgIGlmIChpZSAmJiBpZV92ZXJzaW9uIDwgOSkgeyByZXR1cm4gZmFsc2UgfVxuICAgIHZhciBkaXYgPSBlbHQoJ2RpdicpO1xuICAgIHJldHVybiBcImRyYWdnYWJsZVwiIGluIGRpdiB8fCBcImRyYWdEcm9wXCIgaW4gZGl2XG4gIH0oKTtcblxuICB2YXIgendzcFN1cHBvcnRlZDtcbiAgZnVuY3Rpb24gemVyb1dpZHRoRWxlbWVudChtZWFzdXJlKSB7XG4gICAgaWYgKHp3c3BTdXBwb3J0ZWQgPT0gbnVsbCkge1xuICAgICAgdmFyIHRlc3QgPSBlbHQoXCJzcGFuXCIsIFwiXFx1MjAwYlwiKTtcbiAgICAgIHJlbW92ZUNoaWxkcmVuQW5kQWRkKG1lYXN1cmUsIGVsdChcInNwYW5cIiwgW3Rlc3QsIGRvY3VtZW50LmNyZWF0ZVRleHROb2RlKFwieFwiKV0pKTtcbiAgICAgIGlmIChtZWFzdXJlLmZpcnN0Q2hpbGQub2Zmc2V0SGVpZ2h0ICE9IDApXG4gICAgICAgIHsgendzcFN1cHBvcnRlZCA9IHRlc3Qub2Zmc2V0V2lkdGggPD0gMSAmJiB0ZXN0Lm9mZnNldEhlaWdodCA+IDIgJiYgIShpZSAmJiBpZV92ZXJzaW9uIDwgOCk7IH1cbiAgICB9XG4gICAgdmFyIG5vZGUgPSB6d3NwU3VwcG9ydGVkID8gZWx0KFwic3BhblwiLCBcIlxcdTIwMGJcIikgOlxuICAgICAgZWx0KFwic3BhblwiLCBcIlxcdTAwYTBcIiwgbnVsbCwgXCJkaXNwbGF5OiBpbmxpbmUtYmxvY2s7IHdpZHRoOiAxcHg7IG1hcmdpbi1yaWdodDogLTFweFwiKTtcbiAgICBub2RlLnNldEF0dHJpYnV0ZShcImNtLXRleHRcIiwgXCJcIik7XG4gICAgcmV0dXJuIG5vZGVcbiAgfVxuXG4gIC8vIEZlYXR1cmUtZGV0ZWN0IElFJ3MgY3J1bW15IGNsaWVudCByZWN0IHJlcG9ydGluZyBmb3IgYmlkaSB0ZXh0XG4gIHZhciBiYWRCaWRpUmVjdHM7XG4gIGZ1bmN0aW9uIGhhc0JhZEJpZGlSZWN0cyhtZWFzdXJlKSB7XG4gICAgaWYgKGJhZEJpZGlSZWN0cyAhPSBudWxsKSB7IHJldHVybiBiYWRCaWRpUmVjdHMgfVxuICAgIHZhciB0eHQgPSByZW1vdmVDaGlsZHJlbkFuZEFkZChtZWFzdXJlLCBkb2N1bWVudC5jcmVhdGVUZXh0Tm9kZShcIkFcXHUwNjJlQVwiKSk7XG4gICAgdmFyIHIwID0gcmFuZ2UodHh0LCAwLCAxKS5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKTtcbiAgICB2YXIgcjEgPSByYW5nZSh0eHQsIDEsIDIpLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpO1xuICAgIHJlbW92ZUNoaWxkcmVuKG1lYXN1cmUpO1xuICAgIGlmICghcjAgfHwgcjAubGVmdCA9PSByMC5yaWdodCkgeyByZXR1cm4gZmFsc2UgfSAvLyBTYWZhcmkgcmV0dXJucyBudWxsIGluIHNvbWUgY2FzZXMgKCMyNzgwKVxuICAgIHJldHVybiBiYWRCaWRpUmVjdHMgPSAocjEucmlnaHQgLSByMC5yaWdodCA8IDMpXG4gIH1cblxuICAvLyBTZWUgaWYgXCJcIi5zcGxpdCBpcyB0aGUgYnJva2VuIElFIHZlcnNpb24sIGlmIHNvLCBwcm92aWRlIGFuXG4gIC8vIGFsdGVybmF0aXZlIHdheSB0byBzcGxpdCBsaW5lcy5cbiAgdmFyIHNwbGl0TGluZXNBdXRvID0gXCJcXG5cXG5iXCIuc3BsaXQoL1xcbi8pLmxlbmd0aCAhPSAzID8gZnVuY3Rpb24gKHN0cmluZykge1xuICAgIHZhciBwb3MgPSAwLCByZXN1bHQgPSBbXSwgbCA9IHN0cmluZy5sZW5ndGg7XG4gICAgd2hpbGUgKHBvcyA8PSBsKSB7XG4gICAgICB2YXIgbmwgPSBzdHJpbmcuaW5kZXhPZihcIlxcblwiLCBwb3MpO1xuICAgICAgaWYgKG5sID09IC0xKSB7IG5sID0gc3RyaW5nLmxlbmd0aDsgfVxuICAgICAgdmFyIGxpbmUgPSBzdHJpbmcuc2xpY2UocG9zLCBzdHJpbmcuY2hhckF0KG5sIC0gMSkgPT0gXCJcXHJcIiA/IG5sIC0gMSA6IG5sKTtcbiAgICAgIHZhciBydCA9IGxpbmUuaW5kZXhPZihcIlxcclwiKTtcbiAgICAgIGlmIChydCAhPSAtMSkge1xuICAgICAgICByZXN1bHQucHVzaChsaW5lLnNsaWNlKDAsIHJ0KSk7XG4gICAgICAgIHBvcyArPSBydCArIDE7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICByZXN1bHQucHVzaChsaW5lKTtcbiAgICAgICAgcG9zID0gbmwgKyAxO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gcmVzdWx0XG4gIH0gOiBmdW5jdGlvbiAoc3RyaW5nKSB7IHJldHVybiBzdHJpbmcuc3BsaXQoL1xcclxcbj98XFxuLyk7IH07XG5cbiAgdmFyIGhhc1NlbGVjdGlvbiA9IHdpbmRvdy5nZXRTZWxlY3Rpb24gPyBmdW5jdGlvbiAodGUpIHtcbiAgICB0cnkgeyByZXR1cm4gdGUuc2VsZWN0aW9uU3RhcnQgIT0gdGUuc2VsZWN0aW9uRW5kIH1cbiAgICBjYXRjaChlKSB7IHJldHVybiBmYWxzZSB9XG4gIH0gOiBmdW5jdGlvbiAodGUpIHtcbiAgICB2YXIgcmFuZ2U7XG4gICAgdHJ5IHtyYW5nZSA9IHRlLm93bmVyRG9jdW1lbnQuc2VsZWN0aW9uLmNyZWF0ZVJhbmdlKCk7fVxuICAgIGNhdGNoKGUpIHt9XG4gICAgaWYgKCFyYW5nZSB8fCByYW5nZS5wYXJlbnRFbGVtZW50KCkgIT0gdGUpIHsgcmV0dXJuIGZhbHNlIH1cbiAgICByZXR1cm4gcmFuZ2UuY29tcGFyZUVuZFBvaW50cyhcIlN0YXJ0VG9FbmRcIiwgcmFuZ2UpICE9IDBcbiAgfTtcblxuICB2YXIgaGFzQ29weUV2ZW50ID0gKGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgZSA9IGVsdChcImRpdlwiKTtcbiAgICBpZiAoXCJvbmNvcHlcIiBpbiBlKSB7IHJldHVybiB0cnVlIH1cbiAgICBlLnNldEF0dHJpYnV0ZShcIm9uY29weVwiLCBcInJldHVybjtcIik7XG4gICAgcmV0dXJuIHR5cGVvZiBlLm9uY29weSA9PSBcImZ1bmN0aW9uXCJcbiAgfSkoKTtcblxuICB2YXIgYmFkWm9vbWVkUmVjdHMgPSBudWxsO1xuICBmdW5jdGlvbiBoYXNCYWRab29tZWRSZWN0cyhtZWFzdXJlKSB7XG4gICAgaWYgKGJhZFpvb21lZFJlY3RzICE9IG51bGwpIHsgcmV0dXJuIGJhZFpvb21lZFJlY3RzIH1cbiAgICB2YXIgbm9kZSA9IHJlbW92ZUNoaWxkcmVuQW5kQWRkKG1lYXN1cmUsIGVsdChcInNwYW5cIiwgXCJ4XCIpKTtcbiAgICB2YXIgbm9ybWFsID0gbm9kZS5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKTtcbiAgICB2YXIgZnJvbVJhbmdlID0gcmFuZ2Uobm9kZSwgMCwgMSkuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCk7XG4gICAgcmV0dXJuIGJhZFpvb21lZFJlY3RzID0gTWF0aC5hYnMobm9ybWFsLmxlZnQgLSBmcm9tUmFuZ2UubGVmdCkgPiAxXG4gIH1cblxuICAvLyBLbm93biBtb2RlcywgYnkgbmFtZSBhbmQgYnkgTUlNRVxuICB2YXIgbW9kZXMgPSB7fSwgbWltZU1vZGVzID0ge307XG5cbiAgLy8gRXh0cmEgYXJndW1lbnRzIGFyZSBzdG9yZWQgYXMgdGhlIG1vZGUncyBkZXBlbmRlbmNpZXMsIHdoaWNoIGlzXG4gIC8vIHVzZWQgYnkgKGxlZ2FjeSkgbWVjaGFuaXNtcyBsaWtlIGxvYWRtb2RlLmpzIHRvIGF1dG9tYXRpY2FsbHlcbiAgLy8gbG9hZCBhIG1vZGUuIChQcmVmZXJyZWQgbWVjaGFuaXNtIGlzIHRoZSByZXF1aXJlL2RlZmluZSBjYWxscy4pXG4gIGZ1bmN0aW9uIGRlZmluZU1vZGUobmFtZSwgbW9kZSkge1xuICAgIGlmIChhcmd1bWVudHMubGVuZ3RoID4gMilcbiAgICAgIHsgbW9kZS5kZXBlbmRlbmNpZXMgPSBBcnJheS5wcm90b3R5cGUuc2xpY2UuY2FsbChhcmd1bWVudHMsIDIpOyB9XG4gICAgbW9kZXNbbmFtZV0gPSBtb2RlO1xuICB9XG5cbiAgZnVuY3Rpb24gZGVmaW5lTUlNRShtaW1lLCBzcGVjKSB7XG4gICAgbWltZU1vZGVzW21pbWVdID0gc3BlYztcbiAgfVxuXG4gIC8vIEdpdmVuIGEgTUlNRSB0eXBlLCBhIHtuYW1lLCAuLi5vcHRpb25zfSBjb25maWcgb2JqZWN0LCBvciBhIG5hbWVcbiAgLy8gc3RyaW5nLCByZXR1cm4gYSBtb2RlIGNvbmZpZyBvYmplY3QuXG4gIGZ1bmN0aW9uIHJlc29sdmVNb2RlKHNwZWMpIHtcbiAgICBpZiAodHlwZW9mIHNwZWMgPT0gXCJzdHJpbmdcIiAmJiBtaW1lTW9kZXMuaGFzT3duUHJvcGVydHkoc3BlYykpIHtcbiAgICAgIHNwZWMgPSBtaW1lTW9kZXNbc3BlY107XG4gICAgfSBlbHNlIGlmIChzcGVjICYmIHR5cGVvZiBzcGVjLm5hbWUgPT0gXCJzdHJpbmdcIiAmJiBtaW1lTW9kZXMuaGFzT3duUHJvcGVydHkoc3BlYy5uYW1lKSkge1xuICAgICAgdmFyIGZvdW5kID0gbWltZU1vZGVzW3NwZWMubmFtZV07XG4gICAgICBpZiAodHlwZW9mIGZvdW5kID09IFwic3RyaW5nXCIpIHsgZm91bmQgPSB7bmFtZTogZm91bmR9OyB9XG4gICAgICBzcGVjID0gY3JlYXRlT2JqKGZvdW5kLCBzcGVjKTtcbiAgICAgIHNwZWMubmFtZSA9IGZvdW5kLm5hbWU7XG4gICAgfSBlbHNlIGlmICh0eXBlb2Ygc3BlYyA9PSBcInN0cmluZ1wiICYmIC9eW1xcd1xcLV0rXFwvW1xcd1xcLV0rXFwreG1sJC8udGVzdChzcGVjKSkge1xuICAgICAgcmV0dXJuIHJlc29sdmVNb2RlKFwiYXBwbGljYXRpb24veG1sXCIpXG4gICAgfSBlbHNlIGlmICh0eXBlb2Ygc3BlYyA9PSBcInN0cmluZ1wiICYmIC9eW1xcd1xcLV0rXFwvW1xcd1xcLV0rXFwranNvbiQvLnRlc3Qoc3BlYykpIHtcbiAgICAgIHJldHVybiByZXNvbHZlTW9kZShcImFwcGxpY2F0aW9uL2pzb25cIilcbiAgICB9XG4gICAgaWYgKHR5cGVvZiBzcGVjID09IFwic3RyaW5nXCIpIHsgcmV0dXJuIHtuYW1lOiBzcGVjfSB9XG4gICAgZWxzZSB7IHJldHVybiBzcGVjIHx8IHtuYW1lOiBcIm51bGxcIn0gfVxuICB9XG5cbiAgLy8gR2l2ZW4gYSBtb2RlIHNwZWMgKGFueXRoaW5nIHRoYXQgcmVzb2x2ZU1vZGUgYWNjZXB0cyksIGZpbmQgYW5kXG4gIC8vIGluaXRpYWxpemUgYW4gYWN0dWFsIG1vZGUgb2JqZWN0LlxuICBmdW5jdGlvbiBnZXRNb2RlKG9wdGlvbnMsIHNwZWMpIHtcbiAgICBzcGVjID0gcmVzb2x2ZU1vZGUoc3BlYyk7XG4gICAgdmFyIG1mYWN0b3J5ID0gbW9kZXNbc3BlYy5uYW1lXTtcbiAgICBpZiAoIW1mYWN0b3J5KSB7IHJldHVybiBnZXRNb2RlKG9wdGlvbnMsIFwidGV4dC9wbGFpblwiKSB9XG4gICAgdmFyIG1vZGVPYmogPSBtZmFjdG9yeShvcHRpb25zLCBzcGVjKTtcbiAgICBpZiAobW9kZUV4dGVuc2lvbnMuaGFzT3duUHJvcGVydHkoc3BlYy5uYW1lKSkge1xuICAgICAgdmFyIGV4dHMgPSBtb2RlRXh0ZW5zaW9uc1tzcGVjLm5hbWVdO1xuICAgICAgZm9yICh2YXIgcHJvcCBpbiBleHRzKSB7XG4gICAgICAgIGlmICghZXh0cy5oYXNPd25Qcm9wZXJ0eShwcm9wKSkgeyBjb250aW51ZSB9XG4gICAgICAgIGlmIChtb2RlT2JqLmhhc093blByb3BlcnR5KHByb3ApKSB7IG1vZGVPYmpbXCJfXCIgKyBwcm9wXSA9IG1vZGVPYmpbcHJvcF07IH1cbiAgICAgICAgbW9kZU9ialtwcm9wXSA9IGV4dHNbcHJvcF07XG4gICAgICB9XG4gICAgfVxuICAgIG1vZGVPYmoubmFtZSA9IHNwZWMubmFtZTtcbiAgICBpZiAoc3BlYy5oZWxwZXJUeXBlKSB7IG1vZGVPYmouaGVscGVyVHlwZSA9IHNwZWMuaGVscGVyVHlwZTsgfVxuICAgIGlmIChzcGVjLm1vZGVQcm9wcykgeyBmb3IgKHZhciBwcm9wJDEgaW4gc3BlYy5tb2RlUHJvcHMpXG4gICAgICB7IG1vZGVPYmpbcHJvcCQxXSA9IHNwZWMubW9kZVByb3BzW3Byb3AkMV07IH0gfVxuXG4gICAgcmV0dXJuIG1vZGVPYmpcbiAgfVxuXG4gIC8vIFRoaXMgY2FuIGJlIHVzZWQgdG8gYXR0YWNoIHByb3BlcnRpZXMgdG8gbW9kZSBvYmplY3RzIGZyb21cbiAgLy8gb3V0c2lkZSB0aGUgYWN0dWFsIG1vZGUgZGVmaW5pdGlvbi5cbiAgdmFyIG1vZGVFeHRlbnNpb25zID0ge307XG4gIGZ1bmN0aW9uIGV4dGVuZE1vZGUobW9kZSwgcHJvcGVydGllcykge1xuICAgIHZhciBleHRzID0gbW9kZUV4dGVuc2lvbnMuaGFzT3duUHJvcGVydHkobW9kZSkgPyBtb2RlRXh0ZW5zaW9uc1ttb2RlXSA6IChtb2RlRXh0ZW5zaW9uc1ttb2RlXSA9IHt9KTtcbiAgICBjb3B5T2JqKHByb3BlcnRpZXMsIGV4dHMpO1xuICB9XG5cbiAgZnVuY3Rpb24gY29weVN0YXRlKG1vZGUsIHN0YXRlKSB7XG4gICAgaWYgKHN0YXRlID09PSB0cnVlKSB7IHJldHVybiBzdGF0ZSB9XG4gICAgaWYgKG1vZGUuY29weVN0YXRlKSB7IHJldHVybiBtb2RlLmNvcHlTdGF0ZShzdGF0ZSkgfVxuICAgIHZhciBuc3RhdGUgPSB7fTtcbiAgICBmb3IgKHZhciBuIGluIHN0YXRlKSB7XG4gICAgICB2YXIgdmFsID0gc3RhdGVbbl07XG4gICAgICBpZiAodmFsIGluc3RhbmNlb2YgQXJyYXkpIHsgdmFsID0gdmFsLmNvbmNhdChbXSk7IH1cbiAgICAgIG5zdGF0ZVtuXSA9IHZhbDtcbiAgICB9XG4gICAgcmV0dXJuIG5zdGF0ZVxuICB9XG5cbiAgLy8gR2l2ZW4gYSBtb2RlIGFuZCBhIHN0YXRlIChmb3IgdGhhdCBtb2RlKSwgZmluZCB0aGUgaW5uZXIgbW9kZSBhbmRcbiAgLy8gc3RhdGUgYXQgdGhlIHBvc2l0aW9uIHRoYXQgdGhlIHN0YXRlIHJlZmVycyB0by5cbiAgZnVuY3Rpb24gaW5uZXJNb2RlKG1vZGUsIHN0YXRlKSB7XG4gICAgdmFyIGluZm87XG4gICAgd2hpbGUgKG1vZGUuaW5uZXJNb2RlKSB7XG4gICAgICBpbmZvID0gbW9kZS5pbm5lck1vZGUoc3RhdGUpO1xuICAgICAgaWYgKCFpbmZvIHx8IGluZm8ubW9kZSA9PSBtb2RlKSB7IGJyZWFrIH1cbiAgICAgIHN0YXRlID0gaW5mby5zdGF0ZTtcbiAgICAgIG1vZGUgPSBpbmZvLm1vZGU7XG4gICAgfVxuICAgIHJldHVybiBpbmZvIHx8IHttb2RlOiBtb2RlLCBzdGF0ZTogc3RhdGV9XG4gIH1cblxuICBmdW5jdGlvbiBzdGFydFN0YXRlKG1vZGUsIGExLCBhMikge1xuICAgIHJldHVybiBtb2RlLnN0YXJ0U3RhdGUgPyBtb2RlLnN0YXJ0U3RhdGUoYTEsIGEyKSA6IHRydWVcbiAgfVxuXG4gIC8vIFNUUklORyBTVFJFQU1cblxuICAvLyBGZWQgdG8gdGhlIG1vZGUgcGFyc2VycywgcHJvdmlkZXMgaGVscGVyIGZ1bmN0aW9ucyB0byBtYWtlXG4gIC8vIHBhcnNlcnMgbW9yZSBzdWNjaW5jdC5cblxuICB2YXIgU3RyaW5nU3RyZWFtID0gZnVuY3Rpb24oc3RyaW5nLCB0YWJTaXplLCBsaW5lT3JhY2xlKSB7XG4gICAgdGhpcy5wb3MgPSB0aGlzLnN0YXJ0ID0gMDtcbiAgICB0aGlzLnN0cmluZyA9IHN0cmluZztcbiAgICB0aGlzLnRhYlNpemUgPSB0YWJTaXplIHx8IDg7XG4gICAgdGhpcy5sYXN0Q29sdW1uUG9zID0gdGhpcy5sYXN0Q29sdW1uVmFsdWUgPSAwO1xuICAgIHRoaXMubGluZVN0YXJ0ID0gMDtcbiAgICB0aGlzLmxpbmVPcmFjbGUgPSBsaW5lT3JhY2xlO1xuICB9O1xuXG4gIFN0cmluZ1N0cmVhbS5wcm90b3R5cGUuZW9sID0gZnVuY3Rpb24gKCkge3JldHVybiB0aGlzLnBvcyA+PSB0aGlzLnN0cmluZy5sZW5ndGh9O1xuICBTdHJpbmdTdHJlYW0ucHJvdG90eXBlLnNvbCA9IGZ1bmN0aW9uICgpIHtyZXR1cm4gdGhpcy5wb3MgPT0gdGhpcy5saW5lU3RhcnR9O1xuICBTdHJpbmdTdHJlYW0ucHJvdG90eXBlLnBlZWsgPSBmdW5jdGlvbiAoKSB7cmV0dXJuIHRoaXMuc3RyaW5nLmNoYXJBdCh0aGlzLnBvcykgfHwgdW5kZWZpbmVkfTtcbiAgU3RyaW5nU3RyZWFtLnByb3RvdHlwZS5uZXh0ID0gZnVuY3Rpb24gKCkge1xuICAgIGlmICh0aGlzLnBvcyA8IHRoaXMuc3RyaW5nLmxlbmd0aClcbiAgICAgIHsgcmV0dXJuIHRoaXMuc3RyaW5nLmNoYXJBdCh0aGlzLnBvcysrKSB9XG4gIH07XG4gIFN0cmluZ1N0cmVhbS5wcm90b3R5cGUuZWF0ID0gZnVuY3Rpb24gKG1hdGNoKSB7XG4gICAgdmFyIGNoID0gdGhpcy5zdHJpbmcuY2hhckF0KHRoaXMucG9zKTtcbiAgICB2YXIgb2s7XG4gICAgaWYgKHR5cGVvZiBtYXRjaCA9PSBcInN0cmluZ1wiKSB7IG9rID0gY2ggPT0gbWF0Y2g7IH1cbiAgICBlbHNlIHsgb2sgPSBjaCAmJiAobWF0Y2gudGVzdCA/IG1hdGNoLnRlc3QoY2gpIDogbWF0Y2goY2gpKTsgfVxuICAgIGlmIChvaykgeysrdGhpcy5wb3M7IHJldHVybiBjaH1cbiAgfTtcbiAgU3RyaW5nU3RyZWFtLnByb3RvdHlwZS5lYXRXaGlsZSA9IGZ1bmN0aW9uIChtYXRjaCkge1xuICAgIHZhciBzdGFydCA9IHRoaXMucG9zO1xuICAgIHdoaWxlICh0aGlzLmVhdChtYXRjaCkpe31cbiAgICByZXR1cm4gdGhpcy5wb3MgPiBzdGFydFxuICB9O1xuICBTdHJpbmdTdHJlYW0ucHJvdG90eXBlLmVhdFNwYWNlID0gZnVuY3Rpb24gKCkge1xuICAgIHZhciBzdGFydCA9IHRoaXMucG9zO1xuICAgIHdoaWxlICgvW1xcc1xcdTAwYTBdLy50ZXN0KHRoaXMuc3RyaW5nLmNoYXJBdCh0aGlzLnBvcykpKSB7ICsrdGhpcy5wb3M7IH1cbiAgICByZXR1cm4gdGhpcy5wb3MgPiBzdGFydFxuICB9O1xuICBTdHJpbmdTdHJlYW0ucHJvdG90eXBlLnNraXBUb0VuZCA9IGZ1bmN0aW9uICgpIHt0aGlzLnBvcyA9IHRoaXMuc3RyaW5nLmxlbmd0aDt9O1xuICBTdHJpbmdTdHJlYW0ucHJvdG90eXBlLnNraXBUbyA9IGZ1bmN0aW9uIChjaCkge1xuICAgIHZhciBmb3VuZCA9IHRoaXMuc3RyaW5nLmluZGV4T2YoY2gsIHRoaXMucG9zKTtcbiAgICBpZiAoZm91bmQgPiAtMSkge3RoaXMucG9zID0gZm91bmQ7IHJldHVybiB0cnVlfVxuICB9O1xuICBTdHJpbmdTdHJlYW0ucHJvdG90eXBlLmJhY2tVcCA9IGZ1bmN0aW9uIChuKSB7dGhpcy5wb3MgLT0gbjt9O1xuICBTdHJpbmdTdHJlYW0ucHJvdG90eXBlLmNvbHVtbiA9IGZ1bmN0aW9uICgpIHtcbiAgICBpZiAodGhpcy5sYXN0Q29sdW1uUG9zIDwgdGhpcy5zdGFydCkge1xuICAgICAgdGhpcy5sYXN0Q29sdW1uVmFsdWUgPSBjb3VudENvbHVtbih0aGlzLnN0cmluZywgdGhpcy5zdGFydCwgdGhpcy50YWJTaXplLCB0aGlzLmxhc3RDb2x1bW5Qb3MsIHRoaXMubGFzdENvbHVtblZhbHVlKTtcbiAgICAgIHRoaXMubGFzdENvbHVtblBvcyA9IHRoaXMuc3RhcnQ7XG4gICAgfVxuICAgIHJldHVybiB0aGlzLmxhc3RDb2x1bW5WYWx1ZSAtICh0aGlzLmxpbmVTdGFydCA/IGNvdW50Q29sdW1uKHRoaXMuc3RyaW5nLCB0aGlzLmxpbmVTdGFydCwgdGhpcy50YWJTaXplKSA6IDApXG4gIH07XG4gIFN0cmluZ1N0cmVhbS5wcm90b3R5cGUuaW5kZW50YXRpb24gPSBmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIGNvdW50Q29sdW1uKHRoaXMuc3RyaW5nLCBudWxsLCB0aGlzLnRhYlNpemUpIC1cbiAgICAgICh0aGlzLmxpbmVTdGFydCA/IGNvdW50Q29sdW1uKHRoaXMuc3RyaW5nLCB0aGlzLmxpbmVTdGFydCwgdGhpcy50YWJTaXplKSA6IDApXG4gIH07XG4gIFN0cmluZ1N0cmVhbS5wcm90b3R5cGUubWF0Y2ggPSBmdW5jdGlvbiAocGF0dGVybiwgY29uc3VtZSwgY2FzZUluc2Vuc2l0aXZlKSB7XG4gICAgaWYgKHR5cGVvZiBwYXR0ZXJuID09IFwic3RyaW5nXCIpIHtcbiAgICAgIHZhciBjYXNlZCA9IGZ1bmN0aW9uIChzdHIpIHsgcmV0dXJuIGNhc2VJbnNlbnNpdGl2ZSA/IHN0ci50b0xvd2VyQ2FzZSgpIDogc3RyOyB9O1xuICAgICAgdmFyIHN1YnN0ciA9IHRoaXMuc3RyaW5nLnN1YnN0cih0aGlzLnBvcywgcGF0dGVybi5sZW5ndGgpO1xuICAgICAgaWYgKGNhc2VkKHN1YnN0cikgPT0gY2FzZWQocGF0dGVybikpIHtcbiAgICAgICAgaWYgKGNvbnN1bWUgIT09IGZhbHNlKSB7IHRoaXMucG9zICs9IHBhdHRlcm4ubGVuZ3RoOyB9XG4gICAgICAgIHJldHVybiB0cnVlXG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIHZhciBtYXRjaCA9IHRoaXMuc3RyaW5nLnNsaWNlKHRoaXMucG9zKS5tYXRjaChwYXR0ZXJuKTtcbiAgICAgIGlmIChtYXRjaCAmJiBtYXRjaC5pbmRleCA+IDApIHsgcmV0dXJuIG51bGwgfVxuICAgICAgaWYgKG1hdGNoICYmIGNvbnN1bWUgIT09IGZhbHNlKSB7IHRoaXMucG9zICs9IG1hdGNoWzBdLmxlbmd0aDsgfVxuICAgICAgcmV0dXJuIG1hdGNoXG4gICAgfVxuICB9O1xuICBTdHJpbmdTdHJlYW0ucHJvdG90eXBlLmN1cnJlbnQgPSBmdW5jdGlvbiAoKXtyZXR1cm4gdGhpcy5zdHJpbmcuc2xpY2UodGhpcy5zdGFydCwgdGhpcy5wb3MpfTtcbiAgU3RyaW5nU3RyZWFtLnByb3RvdHlwZS5oaWRlRmlyc3RDaGFycyA9IGZ1bmN0aW9uIChuLCBpbm5lcikge1xuICAgIHRoaXMubGluZVN0YXJ0ICs9IG47XG4gICAgdHJ5IHsgcmV0dXJuIGlubmVyKCkgfVxuICAgIGZpbmFsbHkgeyB0aGlzLmxpbmVTdGFydCAtPSBuOyB9XG4gIH07XG4gIFN0cmluZ1N0cmVhbS5wcm90b3R5cGUubG9va0FoZWFkID0gZnVuY3Rpb24gKG4pIHtcbiAgICB2YXIgb3JhY2xlID0gdGhpcy5saW5lT3JhY2xlO1xuICAgIHJldHVybiBvcmFjbGUgJiYgb3JhY2xlLmxvb2tBaGVhZChuKVxuICB9O1xuICBTdHJpbmdTdHJlYW0ucHJvdG90eXBlLmJhc2VUb2tlbiA9IGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgb3JhY2xlID0gdGhpcy5saW5lT3JhY2xlO1xuICAgIHJldHVybiBvcmFjbGUgJiYgb3JhY2xlLmJhc2VUb2tlbih0aGlzLnBvcylcbiAgfTtcblxuICAvLyBGaW5kIHRoZSBsaW5lIG9iamVjdCBjb3JyZXNwb25kaW5nIHRvIHRoZSBnaXZlbiBsaW5lIG51bWJlci5cbiAgZnVuY3Rpb24gZ2V0TGluZShkb2MsIG4pIHtcbiAgICBuIC09IGRvYy5maXJzdDtcbiAgICBpZiAobiA8IDAgfHwgbiA+PSBkb2Muc2l6ZSkgeyB0aHJvdyBuZXcgRXJyb3IoXCJUaGVyZSBpcyBubyBsaW5lIFwiICsgKG4gKyBkb2MuZmlyc3QpICsgXCIgaW4gdGhlIGRvY3VtZW50LlwiKSB9XG4gICAgdmFyIGNodW5rID0gZG9jO1xuICAgIHdoaWxlICghY2h1bmsubGluZXMpIHtcbiAgICAgIGZvciAodmFyIGkgPSAwOzsgKytpKSB7XG4gICAgICAgIHZhciBjaGlsZCA9IGNodW5rLmNoaWxkcmVuW2ldLCBzeiA9IGNoaWxkLmNodW5rU2l6ZSgpO1xuICAgICAgICBpZiAobiA8IHN6KSB7IGNodW5rID0gY2hpbGQ7IGJyZWFrIH1cbiAgICAgICAgbiAtPSBzejtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIGNodW5rLmxpbmVzW25dXG4gIH1cblxuICAvLyBHZXQgdGhlIHBhcnQgb2YgYSBkb2N1bWVudCBiZXR3ZWVuIHR3byBwb3NpdGlvbnMsIGFzIGFuIGFycmF5IG9mXG4gIC8vIHN0cmluZ3MuXG4gIGZ1bmN0aW9uIGdldEJldHdlZW4oZG9jLCBzdGFydCwgZW5kKSB7XG4gICAgdmFyIG91dCA9IFtdLCBuID0gc3RhcnQubGluZTtcbiAgICBkb2MuaXRlcihzdGFydC5saW5lLCBlbmQubGluZSArIDEsIGZ1bmN0aW9uIChsaW5lKSB7XG4gICAgICB2YXIgdGV4dCA9IGxpbmUudGV4dDtcbiAgICAgIGlmIChuID09IGVuZC5saW5lKSB7IHRleHQgPSB0ZXh0LnNsaWNlKDAsIGVuZC5jaCk7IH1cbiAgICAgIGlmIChuID09IHN0YXJ0LmxpbmUpIHsgdGV4dCA9IHRleHQuc2xpY2Uoc3RhcnQuY2gpOyB9XG4gICAgICBvdXQucHVzaCh0ZXh0KTtcbiAgICAgICsrbjtcbiAgICB9KTtcbiAgICByZXR1cm4gb3V0XG4gIH1cbiAgLy8gR2V0IHRoZSBsaW5lcyBiZXR3ZWVuIGZyb20gYW5kIHRvLCBhcyBhcnJheSBvZiBzdHJpbmdzLlxuICBmdW5jdGlvbiBnZXRMaW5lcyhkb2MsIGZyb20sIHRvKSB7XG4gICAgdmFyIG91dCA9IFtdO1xuICAgIGRvYy5pdGVyKGZyb20sIHRvLCBmdW5jdGlvbiAobGluZSkgeyBvdXQucHVzaChsaW5lLnRleHQpOyB9KTsgLy8gaXRlciBhYm9ydHMgd2hlbiBjYWxsYmFjayByZXR1cm5zIHRydXRoeSB2YWx1ZVxuICAgIHJldHVybiBvdXRcbiAgfVxuXG4gIC8vIFVwZGF0ZSB0aGUgaGVpZ2h0IG9mIGEgbGluZSwgcHJvcGFnYXRpbmcgdGhlIGhlaWdodCBjaGFuZ2VcbiAgLy8gdXB3YXJkcyB0byBwYXJlbnQgbm9kZXMuXG4gIGZ1bmN0aW9uIHVwZGF0ZUxpbmVIZWlnaHQobGluZSwgaGVpZ2h0KSB7XG4gICAgdmFyIGRpZmYgPSBoZWlnaHQgLSBsaW5lLmhlaWdodDtcbiAgICBpZiAoZGlmZikgeyBmb3IgKHZhciBuID0gbGluZTsgbjsgbiA9IG4ucGFyZW50KSB7IG4uaGVpZ2h0ICs9IGRpZmY7IH0gfVxuICB9XG5cbiAgLy8gR2l2ZW4gYSBsaW5lIG9iamVjdCwgZmluZCBpdHMgbGluZSBudW1iZXIgYnkgd2Fsa2luZyB1cCB0aHJvdWdoXG4gIC8vIGl0cyBwYXJlbnQgbGlua3MuXG4gIGZ1bmN0aW9uIGxpbmVObyhsaW5lKSB7XG4gICAgaWYgKGxpbmUucGFyZW50ID09IG51bGwpIHsgcmV0dXJuIG51bGwgfVxuICAgIHZhciBjdXIgPSBsaW5lLnBhcmVudCwgbm8gPSBpbmRleE9mKGN1ci5saW5lcywgbGluZSk7XG4gICAgZm9yICh2YXIgY2h1bmsgPSBjdXIucGFyZW50OyBjaHVuazsgY3VyID0gY2h1bmssIGNodW5rID0gY2h1bmsucGFyZW50KSB7XG4gICAgICBmb3IgKHZhciBpID0gMDs7ICsraSkge1xuICAgICAgICBpZiAoY2h1bmsuY2hpbGRyZW5baV0gPT0gY3VyKSB7IGJyZWFrIH1cbiAgICAgICAgbm8gKz0gY2h1bmsuY2hpbGRyZW5baV0uY2h1bmtTaXplKCk7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiBubyArIGN1ci5maXJzdFxuICB9XG5cbiAgLy8gRmluZCB0aGUgbGluZSBhdCB0aGUgZ2l2ZW4gdmVydGljYWwgcG9zaXRpb24sIHVzaW5nIHRoZSBoZWlnaHRcbiAgLy8gaW5mb3JtYXRpb24gaW4gdGhlIGRvY3VtZW50IHRyZWUuXG4gIGZ1bmN0aW9uIGxpbmVBdEhlaWdodChjaHVuaywgaCkge1xuICAgIHZhciBuID0gY2h1bmsuZmlyc3Q7XG4gICAgb3V0ZXI6IGRvIHtcbiAgICAgIGZvciAodmFyIGkkMSA9IDA7IGkkMSA8IGNodW5rLmNoaWxkcmVuLmxlbmd0aDsgKytpJDEpIHtcbiAgICAgICAgdmFyIGNoaWxkID0gY2h1bmsuY2hpbGRyZW5baSQxXSwgY2ggPSBjaGlsZC5oZWlnaHQ7XG4gICAgICAgIGlmIChoIDwgY2gpIHsgY2h1bmsgPSBjaGlsZDsgY29udGludWUgb3V0ZXIgfVxuICAgICAgICBoIC09IGNoO1xuICAgICAgICBuICs9IGNoaWxkLmNodW5rU2l6ZSgpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIG5cbiAgICB9IHdoaWxlICghY2h1bmsubGluZXMpXG4gICAgdmFyIGkgPSAwO1xuICAgIGZvciAoOyBpIDwgY2h1bmsubGluZXMubGVuZ3RoOyArK2kpIHtcbiAgICAgIHZhciBsaW5lID0gY2h1bmsubGluZXNbaV0sIGxoID0gbGluZS5oZWlnaHQ7XG4gICAgICBpZiAoaCA8IGxoKSB7IGJyZWFrIH1cbiAgICAgIGggLT0gbGg7XG4gICAgfVxuICAgIHJldHVybiBuICsgaVxuICB9XG5cbiAgZnVuY3Rpb24gaXNMaW5lKGRvYywgbCkge3JldHVybiBsID49IGRvYy5maXJzdCAmJiBsIDwgZG9jLmZpcnN0ICsgZG9jLnNpemV9XG5cbiAgZnVuY3Rpb24gbGluZU51bWJlckZvcihvcHRpb25zLCBpKSB7XG4gICAgcmV0dXJuIFN0cmluZyhvcHRpb25zLmxpbmVOdW1iZXJGb3JtYXR0ZXIoaSArIG9wdGlvbnMuZmlyc3RMaW5lTnVtYmVyKSlcbiAgfVxuXG4gIC8vIEEgUG9zIGluc3RhbmNlIHJlcHJlc2VudHMgYSBwb3NpdGlvbiB3aXRoaW4gdGhlIHRleHQuXG4gIGZ1bmN0aW9uIFBvcyhsaW5lLCBjaCwgc3RpY2t5KSB7XG4gICAgaWYgKCBzdGlja3kgPT09IHZvaWQgMCApIHN0aWNreSA9IG51bGw7XG5cbiAgICBpZiAoISh0aGlzIGluc3RhbmNlb2YgUG9zKSkgeyByZXR1cm4gbmV3IFBvcyhsaW5lLCBjaCwgc3RpY2t5KSB9XG4gICAgdGhpcy5saW5lID0gbGluZTtcbiAgICB0aGlzLmNoID0gY2g7XG4gICAgdGhpcy5zdGlja3kgPSBzdGlja3k7XG4gIH1cblxuICAvLyBDb21wYXJlIHR3byBwb3NpdGlvbnMsIHJldHVybiAwIGlmIHRoZXkgYXJlIHRoZSBzYW1lLCBhIG5lZ2F0aXZlXG4gIC8vIG51bWJlciB3aGVuIGEgaXMgbGVzcywgYW5kIGEgcG9zaXRpdmUgbnVtYmVyIG90aGVyd2lzZS5cbiAgZnVuY3Rpb24gY21wKGEsIGIpIHsgcmV0dXJuIGEubGluZSAtIGIubGluZSB8fCBhLmNoIC0gYi5jaCB9XG5cbiAgZnVuY3Rpb24gZXF1YWxDdXJzb3JQb3MoYSwgYikgeyByZXR1cm4gYS5zdGlja3kgPT0gYi5zdGlja3kgJiYgY21wKGEsIGIpID09IDAgfVxuXG4gIGZ1bmN0aW9uIGNvcHlQb3MoeCkge3JldHVybiBQb3MoeC5saW5lLCB4LmNoKX1cbiAgZnVuY3Rpb24gbWF4UG9zKGEsIGIpIHsgcmV0dXJuIGNtcChhLCBiKSA8IDAgPyBiIDogYSB9XG4gIGZ1bmN0aW9uIG1pblBvcyhhLCBiKSB7IHJldHVybiBjbXAoYSwgYikgPCAwID8gYSA6IGIgfVxuXG4gIC8vIE1vc3Qgb2YgdGhlIGV4dGVybmFsIEFQSSBjbGlwcyBnaXZlbiBwb3NpdGlvbnMgdG8gbWFrZSBzdXJlIHRoZXlcbiAgLy8gYWN0dWFsbHkgZXhpc3Qgd2l0aGluIHRoZSBkb2N1bWVudC5cbiAgZnVuY3Rpb24gY2xpcExpbmUoZG9jLCBuKSB7cmV0dXJuIE1hdGgubWF4KGRvYy5maXJzdCwgTWF0aC5taW4obiwgZG9jLmZpcnN0ICsgZG9jLnNpemUgLSAxKSl9XG4gIGZ1bmN0aW9uIGNsaXBQb3MoZG9jLCBwb3MpIHtcbiAgICBpZiAocG9zLmxpbmUgPCBkb2MuZmlyc3QpIHsgcmV0dXJuIFBvcyhkb2MuZmlyc3QsIDApIH1cbiAgICB2YXIgbGFzdCA9IGRvYy5maXJzdCArIGRvYy5zaXplIC0gMTtcbiAgICBpZiAocG9zLmxpbmUgPiBsYXN0KSB7IHJldHVybiBQb3MobGFzdCwgZ2V0TGluZShkb2MsIGxhc3QpLnRleHQubGVuZ3RoKSB9XG4gICAgcmV0dXJuIGNsaXBUb0xlbihwb3MsIGdldExpbmUoZG9jLCBwb3MubGluZSkudGV4dC5sZW5ndGgpXG4gIH1cbiAgZnVuY3Rpb24gY2xpcFRvTGVuKHBvcywgbGluZWxlbikge1xuICAgIHZhciBjaCA9IHBvcy5jaDtcbiAgICBpZiAoY2ggPT0gbnVsbCB8fCBjaCA+IGxpbmVsZW4pIHsgcmV0dXJuIFBvcyhwb3MubGluZSwgbGluZWxlbikgfVxuICAgIGVsc2UgaWYgKGNoIDwgMCkgeyByZXR1cm4gUG9zKHBvcy5saW5lLCAwKSB9XG4gICAgZWxzZSB7IHJldHVybiBwb3MgfVxuICB9XG4gIGZ1bmN0aW9uIGNsaXBQb3NBcnJheShkb2MsIGFycmF5KSB7XG4gICAgdmFyIG91dCA9IFtdO1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgYXJyYXkubGVuZ3RoOyBpKyspIHsgb3V0W2ldID0gY2xpcFBvcyhkb2MsIGFycmF5W2ldKTsgfVxuICAgIHJldHVybiBvdXRcbiAgfVxuXG4gIHZhciBTYXZlZENvbnRleHQgPSBmdW5jdGlvbihzdGF0ZSwgbG9va0FoZWFkKSB7XG4gICAgdGhpcy5zdGF0ZSA9IHN0YXRlO1xuICAgIHRoaXMubG9va0FoZWFkID0gbG9va0FoZWFkO1xuICB9O1xuXG4gIHZhciBDb250ZXh0ID0gZnVuY3Rpb24oZG9jLCBzdGF0ZSwgbGluZSwgbG9va0FoZWFkKSB7XG4gICAgdGhpcy5zdGF0ZSA9IHN0YXRlO1xuICAgIHRoaXMuZG9jID0gZG9jO1xuICAgIHRoaXMubGluZSA9IGxpbmU7XG4gICAgdGhpcy5tYXhMb29rQWhlYWQgPSBsb29rQWhlYWQgfHwgMDtcbiAgICB0aGlzLmJhc2VUb2tlbnMgPSBudWxsO1xuICAgIHRoaXMuYmFzZVRva2VuUG9zID0gMTtcbiAgfTtcblxuICBDb250ZXh0LnByb3RvdHlwZS5sb29rQWhlYWQgPSBmdW5jdGlvbiAobikge1xuICAgIHZhciBsaW5lID0gdGhpcy5kb2MuZ2V0TGluZSh0aGlzLmxpbmUgKyBuKTtcbiAgICBpZiAobGluZSAhPSBudWxsICYmIG4gPiB0aGlzLm1heExvb2tBaGVhZCkgeyB0aGlzLm1heExvb2tBaGVhZCA9IG47IH1cbiAgICByZXR1cm4gbGluZVxuICB9O1xuXG4gIENvbnRleHQucHJvdG90eXBlLmJhc2VUb2tlbiA9IGZ1bmN0aW9uIChuKSB7XG4gICAgaWYgKCF0aGlzLmJhc2VUb2tlbnMpIHsgcmV0dXJuIG51bGwgfVxuICAgIHdoaWxlICh0aGlzLmJhc2VUb2tlbnNbdGhpcy5iYXNlVG9rZW5Qb3NdIDw9IG4pXG4gICAgICB7IHRoaXMuYmFzZVRva2VuUG9zICs9IDI7IH1cbiAgICB2YXIgdHlwZSA9IHRoaXMuYmFzZVRva2Vuc1t0aGlzLmJhc2VUb2tlblBvcyArIDFdO1xuICAgIHJldHVybiB7dHlwZTogdHlwZSAmJiB0eXBlLnJlcGxhY2UoLyggfF4pb3ZlcmxheSAuKi8sIFwiXCIpLFxuICAgICAgICAgICAgc2l6ZTogdGhpcy5iYXNlVG9rZW5zW3RoaXMuYmFzZVRva2VuUG9zXSAtIG59XG4gIH07XG5cbiAgQ29udGV4dC5wcm90b3R5cGUubmV4dExpbmUgPSBmdW5jdGlvbiAoKSB7XG4gICAgdGhpcy5saW5lKys7XG4gICAgaWYgKHRoaXMubWF4TG9va0FoZWFkID4gMCkgeyB0aGlzLm1heExvb2tBaGVhZC0tOyB9XG4gIH07XG5cbiAgQ29udGV4dC5mcm9tU2F2ZWQgPSBmdW5jdGlvbiAoZG9jLCBzYXZlZCwgbGluZSkge1xuICAgIGlmIChzYXZlZCBpbnN0YW5jZW9mIFNhdmVkQ29udGV4dClcbiAgICAgIHsgcmV0dXJuIG5ldyBDb250ZXh0KGRvYywgY29weVN0YXRlKGRvYy5tb2RlLCBzYXZlZC5zdGF0ZSksIGxpbmUsIHNhdmVkLmxvb2tBaGVhZCkgfVxuICAgIGVsc2VcbiAgICAgIHsgcmV0dXJuIG5ldyBDb250ZXh0KGRvYywgY29weVN0YXRlKGRvYy5tb2RlLCBzYXZlZCksIGxpbmUpIH1cbiAgfTtcblxuICBDb250ZXh0LnByb3RvdHlwZS5zYXZlID0gZnVuY3Rpb24gKGNvcHkpIHtcbiAgICB2YXIgc3RhdGUgPSBjb3B5ICE9PSBmYWxzZSA/IGNvcHlTdGF0ZSh0aGlzLmRvYy5tb2RlLCB0aGlzLnN0YXRlKSA6IHRoaXMuc3RhdGU7XG4gICAgcmV0dXJuIHRoaXMubWF4TG9va0FoZWFkID4gMCA/IG5ldyBTYXZlZENvbnRleHQoc3RhdGUsIHRoaXMubWF4TG9va0FoZWFkKSA6IHN0YXRlXG4gIH07XG5cblxuICAvLyBDb21wdXRlIGEgc3R5bGUgYXJyYXkgKGFuIGFycmF5IHN0YXJ0aW5nIHdpdGggYSBtb2RlIGdlbmVyYXRpb25cbiAgLy8gLS0gZm9yIGludmFsaWRhdGlvbiAtLSBmb2xsb3dlZCBieSBwYWlycyBvZiBlbmQgcG9zaXRpb25zIGFuZFxuICAvLyBzdHlsZSBzdHJpbmdzKSwgd2hpY2ggaXMgdXNlZCB0byBoaWdobGlnaHQgdGhlIHRva2VucyBvbiB0aGVcbiAgLy8gbGluZS5cbiAgZnVuY3Rpb24gaGlnaGxpZ2h0TGluZShjbSwgbGluZSwgY29udGV4dCwgZm9yY2VUb0VuZCkge1xuICAgIC8vIEEgc3R5bGVzIGFycmF5IGFsd2F5cyBzdGFydHMgd2l0aCBhIG51bWJlciBpZGVudGlmeWluZyB0aGVcbiAgICAvLyBtb2RlL292ZXJsYXlzIHRoYXQgaXQgaXMgYmFzZWQgb24gKGZvciBlYXN5IGludmFsaWRhdGlvbikuXG4gICAgdmFyIHN0ID0gW2NtLnN0YXRlLm1vZGVHZW5dLCBsaW5lQ2xhc3NlcyA9IHt9O1xuICAgIC8vIENvbXB1dGUgdGhlIGJhc2UgYXJyYXkgb2Ygc3R5bGVzXG4gICAgcnVuTW9kZShjbSwgbGluZS50ZXh0LCBjbS5kb2MubW9kZSwgY29udGV4dCwgZnVuY3Rpb24gKGVuZCwgc3R5bGUpIHsgcmV0dXJuIHN0LnB1c2goZW5kLCBzdHlsZSk7IH0sXG4gICAgICAgICAgICBsaW5lQ2xhc3NlcywgZm9yY2VUb0VuZCk7XG4gICAgdmFyIHN0YXRlID0gY29udGV4dC5zdGF0ZTtcblxuICAgIC8vIFJ1biBvdmVybGF5cywgYWRqdXN0IHN0eWxlIGFycmF5LlxuICAgIHZhciBsb29wID0gZnVuY3Rpb24gKCBvICkge1xuICAgICAgY29udGV4dC5iYXNlVG9rZW5zID0gc3Q7XG4gICAgICB2YXIgb3ZlcmxheSA9IGNtLnN0YXRlLm92ZXJsYXlzW29dLCBpID0gMSwgYXQgPSAwO1xuICAgICAgY29udGV4dC5zdGF0ZSA9IHRydWU7XG4gICAgICBydW5Nb2RlKGNtLCBsaW5lLnRleHQsIG92ZXJsYXkubW9kZSwgY29udGV4dCwgZnVuY3Rpb24gKGVuZCwgc3R5bGUpIHtcbiAgICAgICAgdmFyIHN0YXJ0ID0gaTtcbiAgICAgICAgLy8gRW5zdXJlIHRoZXJlJ3MgYSB0b2tlbiBlbmQgYXQgdGhlIGN1cnJlbnQgcG9zaXRpb24sIGFuZCB0aGF0IGkgcG9pbnRzIGF0IGl0XG4gICAgICAgIHdoaWxlIChhdCA8IGVuZCkge1xuICAgICAgICAgIHZhciBpX2VuZCA9IHN0W2ldO1xuICAgICAgICAgIGlmIChpX2VuZCA+IGVuZClcbiAgICAgICAgICAgIHsgc3Quc3BsaWNlKGksIDEsIGVuZCwgc3RbaSsxXSwgaV9lbmQpOyB9XG4gICAgICAgICAgaSArPSAyO1xuICAgICAgICAgIGF0ID0gTWF0aC5taW4oZW5kLCBpX2VuZCk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCFzdHlsZSkgeyByZXR1cm4gfVxuICAgICAgICBpZiAob3ZlcmxheS5vcGFxdWUpIHtcbiAgICAgICAgICBzdC5zcGxpY2Uoc3RhcnQsIGkgLSBzdGFydCwgZW5kLCBcIm92ZXJsYXkgXCIgKyBzdHlsZSk7XG4gICAgICAgICAgaSA9IHN0YXJ0ICsgMjtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBmb3IgKDsgc3RhcnQgPCBpOyBzdGFydCArPSAyKSB7XG4gICAgICAgICAgICB2YXIgY3VyID0gc3Rbc3RhcnQrMV07XG4gICAgICAgICAgICBzdFtzdGFydCsxXSA9IChjdXIgPyBjdXIgKyBcIiBcIiA6IFwiXCIpICsgXCJvdmVybGF5IFwiICsgc3R5bGU7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9LCBsaW5lQ2xhc3Nlcyk7XG4gICAgICBjb250ZXh0LnN0YXRlID0gc3RhdGU7XG4gICAgICBjb250ZXh0LmJhc2VUb2tlbnMgPSBudWxsO1xuICAgICAgY29udGV4dC5iYXNlVG9rZW5Qb3MgPSAxO1xuICAgIH07XG5cbiAgICBmb3IgKHZhciBvID0gMDsgbyA8IGNtLnN0YXRlLm92ZXJsYXlzLmxlbmd0aDsgKytvKSBsb29wKCBvICk7XG5cbiAgICByZXR1cm4ge3N0eWxlczogc3QsIGNsYXNzZXM6IGxpbmVDbGFzc2VzLmJnQ2xhc3MgfHwgbGluZUNsYXNzZXMudGV4dENsYXNzID8gbGluZUNsYXNzZXMgOiBudWxsfVxuICB9XG5cbiAgZnVuY3Rpb24gZ2V0TGluZVN0eWxlcyhjbSwgbGluZSwgdXBkYXRlRnJvbnRpZXIpIHtcbiAgICBpZiAoIWxpbmUuc3R5bGVzIHx8IGxpbmUuc3R5bGVzWzBdICE9IGNtLnN0YXRlLm1vZGVHZW4pIHtcbiAgICAgIHZhciBjb250ZXh0ID0gZ2V0Q29udGV4dEJlZm9yZShjbSwgbGluZU5vKGxpbmUpKTtcbiAgICAgIHZhciByZXNldFN0YXRlID0gbGluZS50ZXh0Lmxlbmd0aCA+IGNtLm9wdGlvbnMubWF4SGlnaGxpZ2h0TGVuZ3RoICYmIGNvcHlTdGF0ZShjbS5kb2MubW9kZSwgY29udGV4dC5zdGF0ZSk7XG4gICAgICB2YXIgcmVzdWx0ID0gaGlnaGxpZ2h0TGluZShjbSwgbGluZSwgY29udGV4dCk7XG4gICAgICBpZiAocmVzZXRTdGF0ZSkgeyBjb250ZXh0LnN0YXRlID0gcmVzZXRTdGF0ZTsgfVxuICAgICAgbGluZS5zdGF0ZUFmdGVyID0gY29udGV4dC5zYXZlKCFyZXNldFN0YXRlKTtcbiAgICAgIGxpbmUuc3R5bGVzID0gcmVzdWx0LnN0eWxlcztcbiAgICAgIGlmIChyZXN1bHQuY2xhc3NlcykgeyBsaW5lLnN0eWxlQ2xhc3NlcyA9IHJlc3VsdC5jbGFzc2VzOyB9XG4gICAgICBlbHNlIGlmIChsaW5lLnN0eWxlQ2xhc3NlcykgeyBsaW5lLnN0eWxlQ2xhc3NlcyA9IG51bGw7IH1cbiAgICAgIGlmICh1cGRhdGVGcm9udGllciA9PT0gY20uZG9jLmhpZ2hsaWdodEZyb250aWVyKVxuICAgICAgICB7IGNtLmRvYy5tb2RlRnJvbnRpZXIgPSBNYXRoLm1heChjbS5kb2MubW9kZUZyb250aWVyLCArK2NtLmRvYy5oaWdobGlnaHRGcm9udGllcik7IH1cbiAgICB9XG4gICAgcmV0dXJuIGxpbmUuc3R5bGVzXG4gIH1cblxuICBmdW5jdGlvbiBnZXRDb250ZXh0QmVmb3JlKGNtLCBuLCBwcmVjaXNlKSB7XG4gICAgdmFyIGRvYyA9IGNtLmRvYywgZGlzcGxheSA9IGNtLmRpc3BsYXk7XG4gICAgaWYgKCFkb2MubW9kZS5zdGFydFN0YXRlKSB7IHJldHVybiBuZXcgQ29udGV4dChkb2MsIHRydWUsIG4pIH1cbiAgICB2YXIgc3RhcnQgPSBmaW5kU3RhcnRMaW5lKGNtLCBuLCBwcmVjaXNlKTtcbiAgICB2YXIgc2F2ZWQgPSBzdGFydCA+IGRvYy5maXJzdCAmJiBnZXRMaW5lKGRvYywgc3RhcnQgLSAxKS5zdGF0ZUFmdGVyO1xuICAgIHZhciBjb250ZXh0ID0gc2F2ZWQgPyBDb250ZXh0LmZyb21TYXZlZChkb2MsIHNhdmVkLCBzdGFydCkgOiBuZXcgQ29udGV4dChkb2MsIHN0YXJ0U3RhdGUoZG9jLm1vZGUpLCBzdGFydCk7XG5cbiAgICBkb2MuaXRlcihzdGFydCwgbiwgZnVuY3Rpb24gKGxpbmUpIHtcbiAgICAgIHByb2Nlc3NMaW5lKGNtLCBsaW5lLnRleHQsIGNvbnRleHQpO1xuICAgICAgdmFyIHBvcyA9IGNvbnRleHQubGluZTtcbiAgICAgIGxpbmUuc3RhdGVBZnRlciA9IHBvcyA9PSBuIC0gMSB8fCBwb3MgJSA1ID09IDAgfHwgcG9zID49IGRpc3BsYXkudmlld0Zyb20gJiYgcG9zIDwgZGlzcGxheS52aWV3VG8gPyBjb250ZXh0LnNhdmUoKSA6IG51bGw7XG4gICAgICBjb250ZXh0Lm5leHRMaW5lKCk7XG4gICAgfSk7XG4gICAgaWYgKHByZWNpc2UpIHsgZG9jLm1vZGVGcm9udGllciA9IGNvbnRleHQubGluZTsgfVxuICAgIHJldHVybiBjb250ZXh0XG4gIH1cblxuICAvLyBMaWdodHdlaWdodCBmb3JtIG9mIGhpZ2hsaWdodCAtLSBwcm9jZWVkIG92ZXIgdGhpcyBsaW5lIGFuZFxuICAvLyB1cGRhdGUgc3RhdGUsIGJ1dCBkb24ndCBzYXZlIGEgc3R5bGUgYXJyYXkuIFVzZWQgZm9yIGxpbmVzIHRoYXRcbiAgLy8gYXJlbid0IGN1cnJlbnRseSB2aXNpYmxlLlxuICBmdW5jdGlvbiBwcm9jZXNzTGluZShjbSwgdGV4dCwgY29udGV4dCwgc3RhcnRBdCkge1xuICAgIHZhciBtb2RlID0gY20uZG9jLm1vZGU7XG4gICAgdmFyIHN0cmVhbSA9IG5ldyBTdHJpbmdTdHJlYW0odGV4dCwgY20ub3B0aW9ucy50YWJTaXplLCBjb250ZXh0KTtcbiAgICBzdHJlYW0uc3RhcnQgPSBzdHJlYW0ucG9zID0gc3RhcnRBdCB8fCAwO1xuICAgIGlmICh0ZXh0ID09IFwiXCIpIHsgY2FsbEJsYW5rTGluZShtb2RlLCBjb250ZXh0LnN0YXRlKTsgfVxuICAgIHdoaWxlICghc3RyZWFtLmVvbCgpKSB7XG4gICAgICByZWFkVG9rZW4obW9kZSwgc3RyZWFtLCBjb250ZXh0LnN0YXRlKTtcbiAgICAgIHN0cmVhbS5zdGFydCA9IHN0cmVhbS5wb3M7XG4gICAgfVxuICB9XG5cbiAgZnVuY3Rpb24gY2FsbEJsYW5rTGluZShtb2RlLCBzdGF0ZSkge1xuICAgIGlmIChtb2RlLmJsYW5rTGluZSkgeyByZXR1cm4gbW9kZS5ibGFua0xpbmUoc3RhdGUpIH1cbiAgICBpZiAoIW1vZGUuaW5uZXJNb2RlKSB7IHJldHVybiB9XG4gICAgdmFyIGlubmVyID0gaW5uZXJNb2RlKG1vZGUsIHN0YXRlKTtcbiAgICBpZiAoaW5uZXIubW9kZS5ibGFua0xpbmUpIHsgcmV0dXJuIGlubmVyLm1vZGUuYmxhbmtMaW5lKGlubmVyLnN0YXRlKSB9XG4gIH1cblxuICBmdW5jdGlvbiByZWFkVG9rZW4obW9kZSwgc3RyZWFtLCBzdGF0ZSwgaW5uZXIpIHtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IDEwOyBpKyspIHtcbiAgICAgIGlmIChpbm5lcikgeyBpbm5lclswXSA9IGlubmVyTW9kZShtb2RlLCBzdGF0ZSkubW9kZTsgfVxuICAgICAgdmFyIHN0eWxlID0gbW9kZS50b2tlbihzdHJlYW0sIHN0YXRlKTtcbiAgICAgIGlmIChzdHJlYW0ucG9zID4gc3RyZWFtLnN0YXJ0KSB7IHJldHVybiBzdHlsZSB9XG4gICAgfVxuICAgIHRocm93IG5ldyBFcnJvcihcIk1vZGUgXCIgKyBtb2RlLm5hbWUgKyBcIiBmYWlsZWQgdG8gYWR2YW5jZSBzdHJlYW0uXCIpXG4gIH1cblxuICB2YXIgVG9rZW4gPSBmdW5jdGlvbihzdHJlYW0sIHR5cGUsIHN0YXRlKSB7XG4gICAgdGhpcy5zdGFydCA9IHN0cmVhbS5zdGFydDsgdGhpcy5lbmQgPSBzdHJlYW0ucG9zO1xuICAgIHRoaXMuc3RyaW5nID0gc3RyZWFtLmN1cnJlbnQoKTtcbiAgICB0aGlzLnR5cGUgPSB0eXBlIHx8IG51bGw7XG4gICAgdGhpcy5zdGF0ZSA9IHN0YXRlO1xuICB9O1xuXG4gIC8vIFV0aWxpdHkgZm9yIGdldFRva2VuQXQgYW5kIGdldExpbmVUb2tlbnNcbiAgZnVuY3Rpb24gdGFrZVRva2VuKGNtLCBwb3MsIHByZWNpc2UsIGFzQXJyYXkpIHtcbiAgICB2YXIgZG9jID0gY20uZG9jLCBtb2RlID0gZG9jLm1vZGUsIHN0eWxlO1xuICAgIHBvcyA9IGNsaXBQb3MoZG9jLCBwb3MpO1xuICAgIHZhciBsaW5lID0gZ2V0TGluZShkb2MsIHBvcy5saW5lKSwgY29udGV4dCA9IGdldENvbnRleHRCZWZvcmUoY20sIHBvcy5saW5lLCBwcmVjaXNlKTtcbiAgICB2YXIgc3RyZWFtID0gbmV3IFN0cmluZ1N0cmVhbShsaW5lLnRleHQsIGNtLm9wdGlvbnMudGFiU2l6ZSwgY29udGV4dCksIHRva2VucztcbiAgICBpZiAoYXNBcnJheSkgeyB0b2tlbnMgPSBbXTsgfVxuICAgIHdoaWxlICgoYXNBcnJheSB8fCBzdHJlYW0ucG9zIDwgcG9zLmNoKSAmJiAhc3RyZWFtLmVvbCgpKSB7XG4gICAgICBzdHJlYW0uc3RhcnQgPSBzdHJlYW0ucG9zO1xuICAgICAgc3R5bGUgPSByZWFkVG9rZW4obW9kZSwgc3RyZWFtLCBjb250ZXh0LnN0YXRlKTtcbiAgICAgIGlmIChhc0FycmF5KSB7IHRva2Vucy5wdXNoKG5ldyBUb2tlbihzdHJlYW0sIHN0eWxlLCBjb3B5U3RhdGUoZG9jLm1vZGUsIGNvbnRleHQuc3RhdGUpKSk7IH1cbiAgICB9XG4gICAgcmV0dXJuIGFzQXJyYXkgPyB0b2tlbnMgOiBuZXcgVG9rZW4oc3RyZWFtLCBzdHlsZSwgY29udGV4dC5zdGF0ZSlcbiAgfVxuXG4gIGZ1bmN0aW9uIGV4dHJhY3RMaW5lQ2xhc3Nlcyh0eXBlLCBvdXRwdXQpIHtcbiAgICBpZiAodHlwZSkgeyBmb3IgKDs7KSB7XG4gICAgICB2YXIgbGluZUNsYXNzID0gdHlwZS5tYXRjaCgvKD86XnxcXHMrKWxpbmUtKGJhY2tncm91bmQtKT8oXFxTKykvKTtcbiAgICAgIGlmICghbGluZUNsYXNzKSB7IGJyZWFrIH1cbiAgICAgIHR5cGUgPSB0eXBlLnNsaWNlKDAsIGxpbmVDbGFzcy5pbmRleCkgKyB0eXBlLnNsaWNlKGxpbmVDbGFzcy5pbmRleCArIGxpbmVDbGFzc1swXS5sZW5ndGgpO1xuICAgICAgdmFyIHByb3AgPSBsaW5lQ2xhc3NbMV0gPyBcImJnQ2xhc3NcIiA6IFwidGV4dENsYXNzXCI7XG4gICAgICBpZiAob3V0cHV0W3Byb3BdID09IG51bGwpXG4gICAgICAgIHsgb3V0cHV0W3Byb3BdID0gbGluZUNsYXNzWzJdOyB9XG4gICAgICBlbHNlIGlmICghKG5ldyBSZWdFeHAoXCIoPzpefFxcXFxzKVwiICsgbGluZUNsYXNzWzJdICsgXCIoPzokfFxcXFxzKVwiKSkudGVzdChvdXRwdXRbcHJvcF0pKVxuICAgICAgICB7IG91dHB1dFtwcm9wXSArPSBcIiBcIiArIGxpbmVDbGFzc1syXTsgfVxuICAgIH0gfVxuICAgIHJldHVybiB0eXBlXG4gIH1cblxuICAvLyBSdW4gdGhlIGdpdmVuIG1vZGUncyBwYXJzZXIgb3ZlciBhIGxpbmUsIGNhbGxpbmcgZiBmb3IgZWFjaCB0b2tlbi5cbiAgZnVuY3Rpb24gcnVuTW9kZShjbSwgdGV4dCwgbW9kZSwgY29udGV4dCwgZiwgbGluZUNsYXNzZXMsIGZvcmNlVG9FbmQpIHtcbiAgICB2YXIgZmxhdHRlblNwYW5zID0gbW9kZS5mbGF0dGVuU3BhbnM7XG4gICAgaWYgKGZsYXR0ZW5TcGFucyA9PSBudWxsKSB7IGZsYXR0ZW5TcGFucyA9IGNtLm9wdGlvbnMuZmxhdHRlblNwYW5zOyB9XG4gICAgdmFyIGN1clN0YXJ0ID0gMCwgY3VyU3R5bGUgPSBudWxsO1xuICAgIHZhciBzdHJlYW0gPSBuZXcgU3RyaW5nU3RyZWFtKHRleHQsIGNtLm9wdGlvbnMudGFiU2l6ZSwgY29udGV4dCksIHN0eWxlO1xuICAgIHZhciBpbm5lciA9IGNtLm9wdGlvbnMuYWRkTW9kZUNsYXNzICYmIFtudWxsXTtcbiAgICBpZiAodGV4dCA9PSBcIlwiKSB7IGV4dHJhY3RMaW5lQ2xhc3NlcyhjYWxsQmxhbmtMaW5lKG1vZGUsIGNvbnRleHQuc3RhdGUpLCBsaW5lQ2xhc3Nlcyk7IH1cbiAgICB3aGlsZSAoIXN0cmVhbS5lb2woKSkge1xuICAgICAgaWYgKHN0cmVhbS5wb3MgPiBjbS5vcHRpb25zLm1heEhpZ2hsaWdodExlbmd0aCkge1xuICAgICAgICBmbGF0dGVuU3BhbnMgPSBmYWxzZTtcbiAgICAgICAgaWYgKGZvcmNlVG9FbmQpIHsgcHJvY2Vzc0xpbmUoY20sIHRleHQsIGNvbnRleHQsIHN0cmVhbS5wb3MpOyB9XG4gICAgICAgIHN0cmVhbS5wb3MgPSB0ZXh0Lmxlbmd0aDtcbiAgICAgICAgc3R5bGUgPSBudWxsO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgc3R5bGUgPSBleHRyYWN0TGluZUNsYXNzZXMocmVhZFRva2VuKG1vZGUsIHN0cmVhbSwgY29udGV4dC5zdGF0ZSwgaW5uZXIpLCBsaW5lQ2xhc3Nlcyk7XG4gICAgICB9XG4gICAgICBpZiAoaW5uZXIpIHtcbiAgICAgICAgdmFyIG1OYW1lID0gaW5uZXJbMF0ubmFtZTtcbiAgICAgICAgaWYgKG1OYW1lKSB7IHN0eWxlID0gXCJtLVwiICsgKHN0eWxlID8gbU5hbWUgKyBcIiBcIiArIHN0eWxlIDogbU5hbWUpOyB9XG4gICAgICB9XG4gICAgICBpZiAoIWZsYXR0ZW5TcGFucyB8fCBjdXJTdHlsZSAhPSBzdHlsZSkge1xuICAgICAgICB3aGlsZSAoY3VyU3RhcnQgPCBzdHJlYW0uc3RhcnQpIHtcbiAgICAgICAgICBjdXJTdGFydCA9IE1hdGgubWluKHN0cmVhbS5zdGFydCwgY3VyU3RhcnQgKyA1MDAwKTtcbiAgICAgICAgICBmKGN1clN0YXJ0LCBjdXJTdHlsZSk7XG4gICAgICAgIH1cbiAgICAgICAgY3VyU3R5bGUgPSBzdHlsZTtcbiAgICAgIH1cbiAgICAgIHN0cmVhbS5zdGFydCA9IHN0cmVhbS5wb3M7XG4gICAgfVxuICAgIHdoaWxlIChjdXJTdGFydCA8IHN0cmVhbS5wb3MpIHtcbiAgICAgIC8vIFdlYmtpdCBzZWVtcyB0byByZWZ1c2UgdG8gcmVuZGVyIHRleHQgbm9kZXMgbG9uZ2VyIHRoYW4gNTc0NDRcbiAgICAgIC8vIGNoYXJhY3RlcnMsIGFuZCByZXR1cm5zIGluYWNjdXJhdGUgbWVhc3VyZW1lbnRzIGluIG5vZGVzXG4gICAgICAvLyBzdGFydGluZyBhcm91bmQgNTAwMCBjaGFycy5cbiAgICAgIHZhciBwb3MgPSBNYXRoLm1pbihzdHJlYW0ucG9zLCBjdXJTdGFydCArIDUwMDApO1xuICAgICAgZihwb3MsIGN1clN0eWxlKTtcbiAgICAgIGN1clN0YXJ0ID0gcG9zO1xuICAgIH1cbiAgfVxuXG4gIC8vIEZpbmRzIHRoZSBsaW5lIHRvIHN0YXJ0IHdpdGggd2hlbiBzdGFydGluZyBhIHBhcnNlLiBUcmllcyB0b1xuICAvLyBmaW5kIGEgbGluZSB3aXRoIGEgc3RhdGVBZnRlciwgc28gdGhhdCBpdCBjYW4gc3RhcnQgd2l0aCBhXG4gIC8vIHZhbGlkIHN0YXRlLiBJZiB0aGF0IGZhaWxzLCBpdCByZXR1cm5zIHRoZSBsaW5lIHdpdGggdGhlXG4gIC8vIHNtYWxsZXN0IGluZGVudGF0aW9uLCB3aGljaCB0ZW5kcyB0byBuZWVkIHRoZSBsZWFzdCBjb250ZXh0IHRvXG4gIC8vIHBhcnNlIGNvcnJlY3RseS5cbiAgZnVuY3Rpb24gZmluZFN0YXJ0TGluZShjbSwgbiwgcHJlY2lzZSkge1xuICAgIHZhciBtaW5pbmRlbnQsIG1pbmxpbmUsIGRvYyA9IGNtLmRvYztcbiAgICB2YXIgbGltID0gcHJlY2lzZSA/IC0xIDogbiAtIChjbS5kb2MubW9kZS5pbm5lck1vZGUgPyAxMDAwIDogMTAwKTtcbiAgICBmb3IgKHZhciBzZWFyY2ggPSBuOyBzZWFyY2ggPiBsaW07IC0tc2VhcmNoKSB7XG4gICAgICBpZiAoc2VhcmNoIDw9IGRvYy5maXJzdCkgeyByZXR1cm4gZG9jLmZpcnN0IH1cbiAgICAgIHZhciBsaW5lID0gZ2V0TGluZShkb2MsIHNlYXJjaCAtIDEpLCBhZnRlciA9IGxpbmUuc3RhdGVBZnRlcjtcbiAgICAgIGlmIChhZnRlciAmJiAoIXByZWNpc2UgfHwgc2VhcmNoICsgKGFmdGVyIGluc3RhbmNlb2YgU2F2ZWRDb250ZXh0ID8gYWZ0ZXIubG9va0FoZWFkIDogMCkgPD0gZG9jLm1vZGVGcm9udGllcikpXG4gICAgICAgIHsgcmV0dXJuIHNlYXJjaCB9XG4gICAgICB2YXIgaW5kZW50ZWQgPSBjb3VudENvbHVtbihsaW5lLnRleHQsIG51bGwsIGNtLm9wdGlvbnMudGFiU2l6ZSk7XG4gICAgICBpZiAobWlubGluZSA9PSBudWxsIHx8IG1pbmluZGVudCA+IGluZGVudGVkKSB7XG4gICAgICAgIG1pbmxpbmUgPSBzZWFyY2ggLSAxO1xuICAgICAgICBtaW5pbmRlbnQgPSBpbmRlbnRlZDtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIG1pbmxpbmVcbiAgfVxuXG4gIGZ1bmN0aW9uIHJldHJlYXRGcm9udGllcihkb2MsIG4pIHtcbiAgICBkb2MubW9kZUZyb250aWVyID0gTWF0aC5taW4oZG9jLm1vZGVGcm9udGllciwgbik7XG4gICAgaWYgKGRvYy5oaWdobGlnaHRGcm9udGllciA8IG4gLSAxMCkgeyByZXR1cm4gfVxuICAgIHZhciBzdGFydCA9IGRvYy5maXJzdDtcbiAgICBmb3IgKHZhciBsaW5lID0gbiAtIDE7IGxpbmUgPiBzdGFydDsgbGluZS0tKSB7XG4gICAgICB2YXIgc2F2ZWQgPSBnZXRMaW5lKGRvYywgbGluZSkuc3RhdGVBZnRlcjtcbiAgICAgIC8vIGNoYW5nZSBpcyBvbiAzXG4gICAgICAvLyBzdGF0ZSBvbiBsaW5lIDEgbG9va2VkIGFoZWFkIDIgLS0gc28gc2F3IDNcbiAgICAgIC8vIHRlc3QgMSArIDIgPCAzIHNob3VsZCBjb3ZlciB0aGlzXG4gICAgICBpZiAoc2F2ZWQgJiYgKCEoc2F2ZWQgaW5zdGFuY2VvZiBTYXZlZENvbnRleHQpIHx8IGxpbmUgKyBzYXZlZC5sb29rQWhlYWQgPCBuKSkge1xuICAgICAgICBzdGFydCA9IGxpbmUgKyAxO1xuICAgICAgICBicmVha1xuICAgICAgfVxuICAgIH1cbiAgICBkb2MuaGlnaGxpZ2h0RnJvbnRpZXIgPSBNYXRoLm1pbihkb2MuaGlnaGxpZ2h0RnJvbnRpZXIsIHN0YXJ0KTtcbiAgfVxuXG4gIC8vIE9wdGltaXplIHNvbWUgY29kZSB3aGVuIHRoZXNlIGZlYXR1cmVzIGFyZSBub3QgdXNlZC5cbiAgdmFyIHNhd1JlYWRPbmx5U3BhbnMgPSBmYWxzZSwgc2F3Q29sbGFwc2VkU3BhbnMgPSBmYWxzZTtcblxuICBmdW5jdGlvbiBzZWVSZWFkT25seVNwYW5zKCkge1xuICAgIHNhd1JlYWRPbmx5U3BhbnMgPSB0cnVlO1xuICB9XG5cbiAgZnVuY3Rpb24gc2VlQ29sbGFwc2VkU3BhbnMoKSB7XG4gICAgc2F3Q29sbGFwc2VkU3BhbnMgPSB0cnVlO1xuICB9XG5cbiAgLy8gVEVYVE1BUktFUiBTUEFOU1xuXG4gIGZ1bmN0aW9uIE1hcmtlZFNwYW4obWFya2VyLCBmcm9tLCB0bykge1xuICAgIHRoaXMubWFya2VyID0gbWFya2VyO1xuICAgIHRoaXMuZnJvbSA9IGZyb207IHRoaXMudG8gPSB0bztcbiAgfVxuXG4gIC8vIFNlYXJjaCBhbiBhcnJheSBvZiBzcGFucyBmb3IgYSBzcGFuIG1hdGNoaW5nIHRoZSBnaXZlbiBtYXJrZXIuXG4gIGZ1bmN0aW9uIGdldE1hcmtlZFNwYW5Gb3Ioc3BhbnMsIG1hcmtlcikge1xuICAgIGlmIChzcGFucykgeyBmb3IgKHZhciBpID0gMDsgaSA8IHNwYW5zLmxlbmd0aDsgKytpKSB7XG4gICAgICB2YXIgc3BhbiA9IHNwYW5zW2ldO1xuICAgICAgaWYgKHNwYW4ubWFya2VyID09IG1hcmtlcikgeyByZXR1cm4gc3BhbiB9XG4gICAgfSB9XG4gIH1cblxuICAvLyBSZW1vdmUgYSBzcGFuIGZyb20gYW4gYXJyYXksIHJldHVybmluZyB1bmRlZmluZWQgaWYgbm8gc3BhbnMgYXJlXG4gIC8vIGxlZnQgKHdlIGRvbid0IHN0b3JlIGFycmF5cyBmb3IgbGluZXMgd2l0aG91dCBzcGFucykuXG4gIGZ1bmN0aW9uIHJlbW92ZU1hcmtlZFNwYW4oc3BhbnMsIHNwYW4pIHtcbiAgICB2YXIgcjtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IHNwYW5zLmxlbmd0aDsgKytpKVxuICAgICAgeyBpZiAoc3BhbnNbaV0gIT0gc3BhbikgeyAociB8fCAociA9IFtdKSkucHVzaChzcGFuc1tpXSk7IH0gfVxuICAgIHJldHVybiByXG4gIH1cblxuICAvLyBBZGQgYSBzcGFuIHRvIGEgbGluZS5cbiAgZnVuY3Rpb24gYWRkTWFya2VkU3BhbihsaW5lLCBzcGFuLCBvcCkge1xuICAgIHZhciBpblRoaXNPcCA9IG9wICYmIHdpbmRvdy5XZWFrU2V0ICYmIChvcC5tYXJrZWRTcGFucyB8fCAob3AubWFya2VkU3BhbnMgPSBuZXcgV2Vha1NldCkpO1xuICAgIGlmIChpblRoaXNPcCAmJiBsaW5lLm1hcmtlZFNwYW5zICYmIGluVGhpc09wLmhhcyhsaW5lLm1hcmtlZFNwYW5zKSkge1xuICAgICAgbGluZS5tYXJrZWRTcGFucy5wdXNoKHNwYW4pO1xuICAgIH0gZWxzZSB7XG4gICAgICBsaW5lLm1hcmtlZFNwYW5zID0gbGluZS5tYXJrZWRTcGFucyA/IGxpbmUubWFya2VkU3BhbnMuY29uY2F0KFtzcGFuXSkgOiBbc3Bhbl07XG4gICAgICBpZiAoaW5UaGlzT3ApIHsgaW5UaGlzT3AuYWRkKGxpbmUubWFya2VkU3BhbnMpOyB9XG4gICAgfVxuICAgIHNwYW4ubWFya2VyLmF0dGFjaExpbmUobGluZSk7XG4gIH1cblxuICAvLyBVc2VkIGZvciB0aGUgYWxnb3JpdGhtIHRoYXQgYWRqdXN0cyBtYXJrZXJzIGZvciBhIGNoYW5nZSBpbiB0aGVcbiAgLy8gZG9jdW1lbnQuIFRoZXNlIGZ1bmN0aW9ucyBjdXQgYW4gYXJyYXkgb2Ygc3BhbnMgYXQgYSBnaXZlblxuICAvLyBjaGFyYWN0ZXIgcG9zaXRpb24sIHJldHVybmluZyBhbiBhcnJheSBvZiByZW1haW5pbmcgY2h1bmtzIChvclxuICAvLyB1bmRlZmluZWQgaWYgbm90aGluZyByZW1haW5zKS5cbiAgZnVuY3Rpb24gbWFya2VkU3BhbnNCZWZvcmUob2xkLCBzdGFydENoLCBpc0luc2VydCkge1xuICAgIHZhciBudztcbiAgICBpZiAob2xkKSB7IGZvciAodmFyIGkgPSAwOyBpIDwgb2xkLmxlbmd0aDsgKytpKSB7XG4gICAgICB2YXIgc3BhbiA9IG9sZFtpXSwgbWFya2VyID0gc3Bhbi5tYXJrZXI7XG4gICAgICB2YXIgc3RhcnRzQmVmb3JlID0gc3Bhbi5mcm9tID09IG51bGwgfHwgKG1hcmtlci5pbmNsdXNpdmVMZWZ0ID8gc3Bhbi5mcm9tIDw9IHN0YXJ0Q2ggOiBzcGFuLmZyb20gPCBzdGFydENoKTtcbiAgICAgIGlmIChzdGFydHNCZWZvcmUgfHwgc3Bhbi5mcm9tID09IHN0YXJ0Q2ggJiYgbWFya2VyLnR5cGUgPT0gXCJib29rbWFya1wiICYmICghaXNJbnNlcnQgfHwgIXNwYW4ubWFya2VyLmluc2VydExlZnQpKSB7XG4gICAgICAgIHZhciBlbmRzQWZ0ZXIgPSBzcGFuLnRvID09IG51bGwgfHwgKG1hcmtlci5pbmNsdXNpdmVSaWdodCA/IHNwYW4udG8gPj0gc3RhcnRDaCA6IHNwYW4udG8gPiBzdGFydENoKVxuICAgICAgICA7KG53IHx8IChudyA9IFtdKSkucHVzaChuZXcgTWFya2VkU3BhbihtYXJrZXIsIHNwYW4uZnJvbSwgZW5kc0FmdGVyID8gbnVsbCA6IHNwYW4udG8pKTtcbiAgICAgIH1cbiAgICB9IH1cbiAgICByZXR1cm4gbndcbiAgfVxuICBmdW5jdGlvbiBtYXJrZWRTcGFuc0FmdGVyKG9sZCwgZW5kQ2gsIGlzSW5zZXJ0KSB7XG4gICAgdmFyIG53O1xuICAgIGlmIChvbGQpIHsgZm9yICh2YXIgaSA9IDA7IGkgPCBvbGQubGVuZ3RoOyArK2kpIHtcbiAgICAgIHZhciBzcGFuID0gb2xkW2ldLCBtYXJrZXIgPSBzcGFuLm1hcmtlcjtcbiAgICAgIHZhciBlbmRzQWZ0ZXIgPSBzcGFuLnRvID09IG51bGwgfHwgKG1hcmtlci5pbmNsdXNpdmVSaWdodCA/IHNwYW4udG8gPj0gZW5kQ2ggOiBzcGFuLnRvID4gZW5kQ2gpO1xuICAgICAgaWYgKGVuZHNBZnRlciB8fCBzcGFuLmZyb20gPT0gZW5kQ2ggJiYgbWFya2VyLnR5cGUgPT0gXCJib29rbWFya1wiICYmICghaXNJbnNlcnQgfHwgc3Bhbi5tYXJrZXIuaW5zZXJ0TGVmdCkpIHtcbiAgICAgICAgdmFyIHN0YXJ0c0JlZm9yZSA9IHNwYW4uZnJvbSA9PSBudWxsIHx8IChtYXJrZXIuaW5jbHVzaXZlTGVmdCA/IHNwYW4uZnJvbSA8PSBlbmRDaCA6IHNwYW4uZnJvbSA8IGVuZENoKVxuICAgICAgICA7KG53IHx8IChudyA9IFtdKSkucHVzaChuZXcgTWFya2VkU3BhbihtYXJrZXIsIHN0YXJ0c0JlZm9yZSA/IG51bGwgOiBzcGFuLmZyb20gLSBlbmRDaCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBzcGFuLnRvID09IG51bGwgPyBudWxsIDogc3Bhbi50byAtIGVuZENoKSk7XG4gICAgICB9XG4gICAgfSB9XG4gICAgcmV0dXJuIG53XG4gIH1cblxuICAvLyBHaXZlbiBhIGNoYW5nZSBvYmplY3QsIGNvbXB1dGUgdGhlIG5ldyBzZXQgb2YgbWFya2VyIHNwYW5zIHRoYXRcbiAgLy8gY292ZXIgdGhlIGxpbmUgaW4gd2hpY2ggdGhlIGNoYW5nZSB0b29rIHBsYWNlLiBSZW1vdmVzIHNwYW5zXG4gIC8vIGVudGlyZWx5IHdpdGhpbiB0aGUgY2hhbmdlLCByZWNvbm5lY3RzIHNwYW5zIGJlbG9uZ2luZyB0byB0aGVcbiAgLy8gc2FtZSBtYXJrZXIgdGhhdCBhcHBlYXIgb24gYm90aCBzaWRlcyBvZiB0aGUgY2hhbmdlLCBhbmQgY3V0cyBvZmZcbiAgLy8gc3BhbnMgcGFydGlhbGx5IHdpdGhpbiB0aGUgY2hhbmdlLiBSZXR1cm5zIGFuIGFycmF5IG9mIHNwYW5cbiAgLy8gYXJyYXlzIHdpdGggb25lIGVsZW1lbnQgZm9yIGVhY2ggbGluZSBpbiAoYWZ0ZXIpIHRoZSBjaGFuZ2UuXG4gIGZ1bmN0aW9uIHN0cmV0Y2hTcGFuc092ZXJDaGFuZ2UoZG9jLCBjaGFuZ2UpIHtcbiAgICBpZiAoY2hhbmdlLmZ1bGwpIHsgcmV0dXJuIG51bGwgfVxuICAgIHZhciBvbGRGaXJzdCA9IGlzTGluZShkb2MsIGNoYW5nZS5mcm9tLmxpbmUpICYmIGdldExpbmUoZG9jLCBjaGFuZ2UuZnJvbS5saW5lKS5tYXJrZWRTcGFucztcbiAgICB2YXIgb2xkTGFzdCA9IGlzTGluZShkb2MsIGNoYW5nZS50by5saW5lKSAmJiBnZXRMaW5lKGRvYywgY2hhbmdlLnRvLmxpbmUpLm1hcmtlZFNwYW5zO1xuICAgIGlmICghb2xkRmlyc3QgJiYgIW9sZExhc3QpIHsgcmV0dXJuIG51bGwgfVxuXG4gICAgdmFyIHN0YXJ0Q2ggPSBjaGFuZ2UuZnJvbS5jaCwgZW5kQ2ggPSBjaGFuZ2UudG8uY2gsIGlzSW5zZXJ0ID0gY21wKGNoYW5nZS5mcm9tLCBjaGFuZ2UudG8pID09IDA7XG4gICAgLy8gR2V0IHRoZSBzcGFucyB0aGF0ICdzdGljayBvdXQnIG9uIGJvdGggc2lkZXNcbiAgICB2YXIgZmlyc3QgPSBtYXJrZWRTcGFuc0JlZm9yZShvbGRGaXJzdCwgc3RhcnRDaCwgaXNJbnNlcnQpO1xuICAgIHZhciBsYXN0ID0gbWFya2VkU3BhbnNBZnRlcihvbGRMYXN0LCBlbmRDaCwgaXNJbnNlcnQpO1xuXG4gICAgLy8gTmV4dCwgbWVyZ2UgdGhvc2UgdHdvIGVuZHNcbiAgICB2YXIgc2FtZUxpbmUgPSBjaGFuZ2UudGV4dC5sZW5ndGggPT0gMSwgb2Zmc2V0ID0gbHN0KGNoYW5nZS50ZXh0KS5sZW5ndGggKyAoc2FtZUxpbmUgPyBzdGFydENoIDogMCk7XG4gICAgaWYgKGZpcnN0KSB7XG4gICAgICAvLyBGaXggdXAgLnRvIHByb3BlcnRpZXMgb2YgZmlyc3RcbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgZmlyc3QubGVuZ3RoOyArK2kpIHtcbiAgICAgICAgdmFyIHNwYW4gPSBmaXJzdFtpXTtcbiAgICAgICAgaWYgKHNwYW4udG8gPT0gbnVsbCkge1xuICAgICAgICAgIHZhciBmb3VuZCA9IGdldE1hcmtlZFNwYW5Gb3IobGFzdCwgc3Bhbi5tYXJrZXIpO1xuICAgICAgICAgIGlmICghZm91bmQpIHsgc3Bhbi50byA9IHN0YXJ0Q2g7IH1cbiAgICAgICAgICBlbHNlIGlmIChzYW1lTGluZSkgeyBzcGFuLnRvID0gZm91bmQudG8gPT0gbnVsbCA/IG51bGwgOiBmb3VuZC50byArIG9mZnNldDsgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICAgIGlmIChsYXN0KSB7XG4gICAgICAvLyBGaXggdXAgLmZyb20gaW4gbGFzdCAob3IgbW92ZSB0aGVtIGludG8gZmlyc3QgaW4gY2FzZSBvZiBzYW1lTGluZSlcbiAgICAgIGZvciAodmFyIGkkMSA9IDA7IGkkMSA8IGxhc3QubGVuZ3RoOyArK2kkMSkge1xuICAgICAgICB2YXIgc3BhbiQxID0gbGFzdFtpJDFdO1xuICAgICAgICBpZiAoc3BhbiQxLnRvICE9IG51bGwpIHsgc3BhbiQxLnRvICs9IG9mZnNldDsgfVxuICAgICAgICBpZiAoc3BhbiQxLmZyb20gPT0gbnVsbCkge1xuICAgICAgICAgIHZhciBmb3VuZCQxID0gZ2V0TWFya2VkU3BhbkZvcihmaXJzdCwgc3BhbiQxLm1hcmtlcik7XG4gICAgICAgICAgaWYgKCFmb3VuZCQxKSB7XG4gICAgICAgICAgICBzcGFuJDEuZnJvbSA9IG9mZnNldDtcbiAgICAgICAgICAgIGlmIChzYW1lTGluZSkgeyAoZmlyc3QgfHwgKGZpcnN0ID0gW10pKS5wdXNoKHNwYW4kMSk7IH1cbiAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgc3BhbiQxLmZyb20gKz0gb2Zmc2V0O1xuICAgICAgICAgIGlmIChzYW1lTGluZSkgeyAoZmlyc3QgfHwgKGZpcnN0ID0gW10pKS5wdXNoKHNwYW4kMSk7IH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgICAvLyBNYWtlIHN1cmUgd2UgZGlkbid0IGNyZWF0ZSBhbnkgemVyby1sZW5ndGggc3BhbnNcbiAgICBpZiAoZmlyc3QpIHsgZmlyc3QgPSBjbGVhckVtcHR5U3BhbnMoZmlyc3QpOyB9XG4gICAgaWYgKGxhc3QgJiYgbGFzdCAhPSBmaXJzdCkgeyBsYXN0ID0gY2xlYXJFbXB0eVNwYW5zKGxhc3QpOyB9XG5cbiAgICB2YXIgbmV3TWFya2VycyA9IFtmaXJzdF07XG4gICAgaWYgKCFzYW1lTGluZSkge1xuICAgICAgLy8gRmlsbCBnYXAgd2l0aCB3aG9sZS1saW5lLXNwYW5zXG4gICAgICB2YXIgZ2FwID0gY2hhbmdlLnRleHQubGVuZ3RoIC0gMiwgZ2FwTWFya2VycztcbiAgICAgIGlmIChnYXAgPiAwICYmIGZpcnN0KVxuICAgICAgICB7IGZvciAodmFyIGkkMiA9IDA7IGkkMiA8IGZpcnN0Lmxlbmd0aDsgKytpJDIpXG4gICAgICAgICAgeyBpZiAoZmlyc3RbaSQyXS50byA9PSBudWxsKVxuICAgICAgICAgICAgeyAoZ2FwTWFya2VycyB8fCAoZ2FwTWFya2VycyA9IFtdKSkucHVzaChuZXcgTWFya2VkU3BhbihmaXJzdFtpJDJdLm1hcmtlciwgbnVsbCwgbnVsbCkpOyB9IH0gfVxuICAgICAgZm9yICh2YXIgaSQzID0gMDsgaSQzIDwgZ2FwOyArK2kkMylcbiAgICAgICAgeyBuZXdNYXJrZXJzLnB1c2goZ2FwTWFya2Vycyk7IH1cbiAgICAgIG5ld01hcmtlcnMucHVzaChsYXN0KTtcbiAgICB9XG4gICAgcmV0dXJuIG5ld01hcmtlcnNcbiAgfVxuXG4gIC8vIFJlbW92ZSBzcGFucyB0aGF0IGFyZSBlbXB0eSBhbmQgZG9uJ3QgaGF2ZSBhIGNsZWFyV2hlbkVtcHR5XG4gIC8vIG9wdGlvbiBvZiBmYWxzZS5cbiAgZnVuY3Rpb24gY2xlYXJFbXB0eVNwYW5zKHNwYW5zKSB7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBzcGFucy5sZW5ndGg7ICsraSkge1xuICAgICAgdmFyIHNwYW4gPSBzcGFuc1tpXTtcbiAgICAgIGlmIChzcGFuLmZyb20gIT0gbnVsbCAmJiBzcGFuLmZyb20gPT0gc3Bhbi50byAmJiBzcGFuLm1hcmtlci5jbGVhcldoZW5FbXB0eSAhPT0gZmFsc2UpXG4gICAgICAgIHsgc3BhbnMuc3BsaWNlKGktLSwgMSk7IH1cbiAgICB9XG4gICAgaWYgKCFzcGFucy5sZW5ndGgpIHsgcmV0dXJuIG51bGwgfVxuICAgIHJldHVybiBzcGFuc1xuICB9XG5cbiAgLy8gVXNlZCB0byAnY2xpcCcgb3V0IHJlYWRPbmx5IHJhbmdlcyB3aGVuIG1ha2luZyBhIGNoYW5nZS5cbiAgZnVuY3Rpb24gcmVtb3ZlUmVhZE9ubHlSYW5nZXMoZG9jLCBmcm9tLCB0bykge1xuICAgIHZhciBtYXJrZXJzID0gbnVsbDtcbiAgICBkb2MuaXRlcihmcm9tLmxpbmUsIHRvLmxpbmUgKyAxLCBmdW5jdGlvbiAobGluZSkge1xuICAgICAgaWYgKGxpbmUubWFya2VkU3BhbnMpIHsgZm9yICh2YXIgaSA9IDA7IGkgPCBsaW5lLm1hcmtlZFNwYW5zLmxlbmd0aDsgKytpKSB7XG4gICAgICAgIHZhciBtYXJrID0gbGluZS5tYXJrZWRTcGFuc1tpXS5tYXJrZXI7XG4gICAgICAgIGlmIChtYXJrLnJlYWRPbmx5ICYmICghbWFya2VycyB8fCBpbmRleE9mKG1hcmtlcnMsIG1hcmspID09IC0xKSlcbiAgICAgICAgICB7IChtYXJrZXJzIHx8IChtYXJrZXJzID0gW10pKS5wdXNoKG1hcmspOyB9XG4gICAgICB9IH1cbiAgICB9KTtcbiAgICBpZiAoIW1hcmtlcnMpIHsgcmV0dXJuIG51bGwgfVxuICAgIHZhciBwYXJ0cyA9IFt7ZnJvbTogZnJvbSwgdG86IHRvfV07XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBtYXJrZXJzLmxlbmd0aDsgKytpKSB7XG4gICAgICB2YXIgbWsgPSBtYXJrZXJzW2ldLCBtID0gbWsuZmluZCgwKTtcbiAgICAgIGZvciAodmFyIGogPSAwOyBqIDwgcGFydHMubGVuZ3RoOyArK2opIHtcbiAgICAgICAgdmFyIHAgPSBwYXJ0c1tqXTtcbiAgICAgICAgaWYgKGNtcChwLnRvLCBtLmZyb20pIDwgMCB8fCBjbXAocC5mcm9tLCBtLnRvKSA+IDApIHsgY29udGludWUgfVxuICAgICAgICB2YXIgbmV3UGFydHMgPSBbaiwgMV0sIGRmcm9tID0gY21wKHAuZnJvbSwgbS5mcm9tKSwgZHRvID0gY21wKHAudG8sIG0udG8pO1xuICAgICAgICBpZiAoZGZyb20gPCAwIHx8ICFtay5pbmNsdXNpdmVMZWZ0ICYmICFkZnJvbSlcbiAgICAgICAgICB7IG5ld1BhcnRzLnB1c2goe2Zyb206IHAuZnJvbSwgdG86IG0uZnJvbX0pOyB9XG4gICAgICAgIGlmIChkdG8gPiAwIHx8ICFtay5pbmNsdXNpdmVSaWdodCAmJiAhZHRvKVxuICAgICAgICAgIHsgbmV3UGFydHMucHVzaCh7ZnJvbTogbS50bywgdG86IHAudG99KTsgfVxuICAgICAgICBwYXJ0cy5zcGxpY2UuYXBwbHkocGFydHMsIG5ld1BhcnRzKTtcbiAgICAgICAgaiArPSBuZXdQYXJ0cy5sZW5ndGggLSAzO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gcGFydHNcbiAgfVxuXG4gIC8vIENvbm5lY3Qgb3IgZGlzY29ubmVjdCBzcGFucyBmcm9tIGEgbGluZS5cbiAgZnVuY3Rpb24gZGV0YWNoTWFya2VkU3BhbnMobGluZSkge1xuICAgIHZhciBzcGFucyA9IGxpbmUubWFya2VkU3BhbnM7XG4gICAgaWYgKCFzcGFucykgeyByZXR1cm4gfVxuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgc3BhbnMubGVuZ3RoOyArK2kpXG4gICAgICB7IHNwYW5zW2ldLm1hcmtlci5kZXRhY2hMaW5lKGxpbmUpOyB9XG4gICAgbGluZS5tYXJrZWRTcGFucyA9IG51bGw7XG4gIH1cbiAgZnVuY3Rpb24gYXR0YWNoTWFya2VkU3BhbnMobGluZSwgc3BhbnMpIHtcbiAgICBpZiAoIXNwYW5zKSB7IHJldHVybiB9XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBzcGFucy5sZW5ndGg7ICsraSlcbiAgICAgIHsgc3BhbnNbaV0ubWFya2VyLmF0dGFjaExpbmUobGluZSk7IH1cbiAgICBsaW5lLm1hcmtlZFNwYW5zID0gc3BhbnM7XG4gIH1cblxuICAvLyBIZWxwZXJzIHVzZWQgd2hlbiBjb21wdXRpbmcgd2hpY2ggb3ZlcmxhcHBpbmcgY29sbGFwc2VkIHNwYW5cbiAgLy8gY291bnRzIGFzIHRoZSBsYXJnZXIgb25lLlxuICBmdW5jdGlvbiBleHRyYUxlZnQobWFya2VyKSB7IHJldHVybiBtYXJrZXIuaW5jbHVzaXZlTGVmdCA/IC0xIDogMCB9XG4gIGZ1bmN0aW9uIGV4dHJhUmlnaHQobWFya2VyKSB7IHJldHVybiBtYXJrZXIuaW5jbHVzaXZlUmlnaHQgPyAxIDogMCB9XG5cbiAgLy8gUmV0dXJucyBhIG51bWJlciBpbmRpY2F0aW5nIHdoaWNoIG9mIHR3byBvdmVybGFwcGluZyBjb2xsYXBzZWRcbiAgLy8gc3BhbnMgaXMgbGFyZ2VyIChhbmQgdGh1cyBpbmNsdWRlcyB0aGUgb3RoZXIpLiBGYWxscyBiYWNrIHRvXG4gIC8vIGNvbXBhcmluZyBpZHMgd2hlbiB0aGUgc3BhbnMgY292ZXIgZXhhY3RseSB0aGUgc2FtZSByYW5nZS5cbiAgZnVuY3Rpb24gY29tcGFyZUNvbGxhcHNlZE1hcmtlcnMoYSwgYikge1xuICAgIHZhciBsZW5EaWZmID0gYS5saW5lcy5sZW5ndGggLSBiLmxpbmVzLmxlbmd0aDtcbiAgICBpZiAobGVuRGlmZiAhPSAwKSB7IHJldHVybiBsZW5EaWZmIH1cbiAgICB2YXIgYVBvcyA9IGEuZmluZCgpLCBiUG9zID0gYi5maW5kKCk7XG4gICAgdmFyIGZyb21DbXAgPSBjbXAoYVBvcy5mcm9tLCBiUG9zLmZyb20pIHx8IGV4dHJhTGVmdChhKSAtIGV4dHJhTGVmdChiKTtcbiAgICBpZiAoZnJvbUNtcCkgeyByZXR1cm4gLWZyb21DbXAgfVxuICAgIHZhciB0b0NtcCA9IGNtcChhUG9zLnRvLCBiUG9zLnRvKSB8fCBleHRyYVJpZ2h0KGEpIC0gZXh0cmFSaWdodChiKTtcbiAgICBpZiAodG9DbXApIHsgcmV0dXJuIHRvQ21wIH1cbiAgICByZXR1cm4gYi5pZCAtIGEuaWRcbiAgfVxuXG4gIC8vIEZpbmQgb3V0IHdoZXRoZXIgYSBsaW5lIGVuZHMgb3Igc3RhcnRzIGluIGEgY29sbGFwc2VkIHNwYW4uIElmXG4gIC8vIHNvLCByZXR1cm4gdGhlIG1hcmtlciBmb3IgdGhhdCBzcGFuLlxuICBmdW5jdGlvbiBjb2xsYXBzZWRTcGFuQXRTaWRlKGxpbmUsIHN0YXJ0KSB7XG4gICAgdmFyIHNwcyA9IHNhd0NvbGxhcHNlZFNwYW5zICYmIGxpbmUubWFya2VkU3BhbnMsIGZvdW5kO1xuICAgIGlmIChzcHMpIHsgZm9yICh2YXIgc3AgPSAodm9pZCAwKSwgaSA9IDA7IGkgPCBzcHMubGVuZ3RoOyArK2kpIHtcbiAgICAgIHNwID0gc3BzW2ldO1xuICAgICAgaWYgKHNwLm1hcmtlci5jb2xsYXBzZWQgJiYgKHN0YXJ0ID8gc3AuZnJvbSA6IHNwLnRvKSA9PSBudWxsICYmXG4gICAgICAgICAgKCFmb3VuZCB8fCBjb21wYXJlQ29sbGFwc2VkTWFya2Vycyhmb3VuZCwgc3AubWFya2VyKSA8IDApKVxuICAgICAgICB7IGZvdW5kID0gc3AubWFya2VyOyB9XG4gICAgfSB9XG4gICAgcmV0dXJuIGZvdW5kXG4gIH1cbiAgZnVuY3Rpb24gY29sbGFwc2VkU3BhbkF0U3RhcnQobGluZSkgeyByZXR1cm4gY29sbGFwc2VkU3BhbkF0U2lkZShsaW5lLCB0cnVlKSB9XG4gIGZ1bmN0aW9uIGNvbGxhcHNlZFNwYW5BdEVuZChsaW5lKSB7IHJldHVybiBjb2xsYXBzZWRTcGFuQXRTaWRlKGxpbmUsIGZhbHNlKSB9XG5cbiAgZnVuY3Rpb24gY29sbGFwc2VkU3BhbkFyb3VuZChsaW5lLCBjaCkge1xuICAgIHZhciBzcHMgPSBzYXdDb2xsYXBzZWRTcGFucyAmJiBsaW5lLm1hcmtlZFNwYW5zLCBmb3VuZDtcbiAgICBpZiAoc3BzKSB7IGZvciAodmFyIGkgPSAwOyBpIDwgc3BzLmxlbmd0aDsgKytpKSB7XG4gICAgICB2YXIgc3AgPSBzcHNbaV07XG4gICAgICBpZiAoc3AubWFya2VyLmNvbGxhcHNlZCAmJiAoc3AuZnJvbSA9PSBudWxsIHx8IHNwLmZyb20gPCBjaCkgJiYgKHNwLnRvID09IG51bGwgfHwgc3AudG8gPiBjaCkgJiZcbiAgICAgICAgICAoIWZvdW5kIHx8IGNvbXBhcmVDb2xsYXBzZWRNYXJrZXJzKGZvdW5kLCBzcC5tYXJrZXIpIDwgMCkpIHsgZm91bmQgPSBzcC5tYXJrZXI7IH1cbiAgICB9IH1cbiAgICByZXR1cm4gZm91bmRcbiAgfVxuXG4gIC8vIFRlc3Qgd2hldGhlciB0aGVyZSBleGlzdHMgYSBjb2xsYXBzZWQgc3BhbiB0aGF0IHBhcnRpYWxseVxuICAvLyBvdmVybGFwcyAoY292ZXJzIHRoZSBzdGFydCBvciBlbmQsIGJ1dCBub3QgYm90aCkgb2YgYSBuZXcgc3Bhbi5cbiAgLy8gU3VjaCBvdmVybGFwIGlzIG5vdCBhbGxvd2VkLlxuICBmdW5jdGlvbiBjb25mbGljdGluZ0NvbGxhcHNlZFJhbmdlKGRvYywgbGluZU5vLCBmcm9tLCB0bywgbWFya2VyKSB7XG4gICAgdmFyIGxpbmUgPSBnZXRMaW5lKGRvYywgbGluZU5vKTtcbiAgICB2YXIgc3BzID0gc2F3Q29sbGFwc2VkU3BhbnMgJiYgbGluZS5tYXJrZWRTcGFucztcbiAgICBpZiAoc3BzKSB7IGZvciAodmFyIGkgPSAwOyBpIDwgc3BzLmxlbmd0aDsgKytpKSB7XG4gICAgICB2YXIgc3AgPSBzcHNbaV07XG4gICAgICBpZiAoIXNwLm1hcmtlci5jb2xsYXBzZWQpIHsgY29udGludWUgfVxuICAgICAgdmFyIGZvdW5kID0gc3AubWFya2VyLmZpbmQoMCk7XG4gICAgICB2YXIgZnJvbUNtcCA9IGNtcChmb3VuZC5mcm9tLCBmcm9tKSB8fCBleHRyYUxlZnQoc3AubWFya2VyKSAtIGV4dHJhTGVmdChtYXJrZXIpO1xuICAgICAgdmFyIHRvQ21wID0gY21wKGZvdW5kLnRvLCB0bykgfHwgZXh0cmFSaWdodChzcC5tYXJrZXIpIC0gZXh0cmFSaWdodChtYXJrZXIpO1xuICAgICAgaWYgKGZyb21DbXAgPj0gMCAmJiB0b0NtcCA8PSAwIHx8IGZyb21DbXAgPD0gMCAmJiB0b0NtcCA+PSAwKSB7IGNvbnRpbnVlIH1cbiAgICAgIGlmIChmcm9tQ21wIDw9IDAgJiYgKHNwLm1hcmtlci5pbmNsdXNpdmVSaWdodCAmJiBtYXJrZXIuaW5jbHVzaXZlTGVmdCA/IGNtcChmb3VuZC50bywgZnJvbSkgPj0gMCA6IGNtcChmb3VuZC50bywgZnJvbSkgPiAwKSB8fFxuICAgICAgICAgIGZyb21DbXAgPj0gMCAmJiAoc3AubWFya2VyLmluY2x1c2l2ZVJpZ2h0ICYmIG1hcmtlci5pbmNsdXNpdmVMZWZ0ID8gY21wKGZvdW5kLmZyb20sIHRvKSA8PSAwIDogY21wKGZvdW5kLmZyb20sIHRvKSA8IDApKVxuICAgICAgICB7IHJldHVybiB0cnVlIH1cbiAgICB9IH1cbiAgfVxuXG4gIC8vIEEgdmlzdWFsIGxpbmUgaXMgYSBsaW5lIGFzIGRyYXduIG9uIHRoZSBzY3JlZW4uIEZvbGRpbmcsIGZvclxuICAvLyBleGFtcGxlLCBjYW4gY2F1c2UgbXVsdGlwbGUgbG9naWNhbCBsaW5lcyB0byBhcHBlYXIgb24gdGhlIHNhbWVcbiAgLy8gdmlzdWFsIGxpbmUuIFRoaXMgZmluZHMgdGhlIHN0YXJ0IG9mIHRoZSB2aXN1YWwgbGluZSB0aGF0IHRoZVxuICAvLyBnaXZlbiBsaW5lIGlzIHBhcnQgb2YgKHVzdWFsbHkgdGhhdCBpcyB0aGUgbGluZSBpdHNlbGYpLlxuICBmdW5jdGlvbiB2aXN1YWxMaW5lKGxpbmUpIHtcbiAgICB2YXIgbWVyZ2VkO1xuICAgIHdoaWxlIChtZXJnZWQgPSBjb2xsYXBzZWRTcGFuQXRTdGFydChsaW5lKSlcbiAgICAgIHsgbGluZSA9IG1lcmdlZC5maW5kKC0xLCB0cnVlKS5saW5lOyB9XG4gICAgcmV0dXJuIGxpbmVcbiAgfVxuXG4gIGZ1bmN0aW9uIHZpc3VhbExpbmVFbmQobGluZSkge1xuICAgIHZhciBtZXJnZWQ7XG4gICAgd2hpbGUgKG1lcmdlZCA9IGNvbGxhcHNlZFNwYW5BdEVuZChsaW5lKSlcbiAgICAgIHsgbGluZSA9IG1lcmdlZC5maW5kKDEsIHRydWUpLmxpbmU7IH1cbiAgICByZXR1cm4gbGluZVxuICB9XG5cbiAgLy8gUmV0dXJucyBhbiBhcnJheSBvZiBsb2dpY2FsIGxpbmVzIHRoYXQgY29udGludWUgdGhlIHZpc3VhbCBsaW5lXG4gIC8vIHN0YXJ0ZWQgYnkgdGhlIGFyZ3VtZW50LCBvciB1bmRlZmluZWQgaWYgdGhlcmUgYXJlIG5vIHN1Y2ggbGluZXMuXG4gIGZ1bmN0aW9uIHZpc3VhbExpbmVDb250aW51ZWQobGluZSkge1xuICAgIHZhciBtZXJnZWQsIGxpbmVzO1xuICAgIHdoaWxlIChtZXJnZWQgPSBjb2xsYXBzZWRTcGFuQXRFbmQobGluZSkpIHtcbiAgICAgIGxpbmUgPSBtZXJnZWQuZmluZCgxLCB0cnVlKS5saW5lXG4gICAgICA7KGxpbmVzIHx8IChsaW5lcyA9IFtdKSkucHVzaChsaW5lKTtcbiAgICB9XG4gICAgcmV0dXJuIGxpbmVzXG4gIH1cblxuICAvLyBHZXQgdGhlIGxpbmUgbnVtYmVyIG9mIHRoZSBzdGFydCBvZiB0aGUgdmlzdWFsIGxpbmUgdGhhdCB0aGVcbiAgLy8gZ2l2ZW4gbGluZSBudW1iZXIgaXMgcGFydCBvZi5cbiAgZnVuY3Rpb24gdmlzdWFsTGluZU5vKGRvYywgbGluZU4pIHtcbiAgICB2YXIgbGluZSA9IGdldExpbmUoZG9jLCBsaW5lTiksIHZpcyA9IHZpc3VhbExpbmUobGluZSk7XG4gICAgaWYgKGxpbmUgPT0gdmlzKSB7IHJldHVybiBsaW5lTiB9XG4gICAgcmV0dXJuIGxpbmVObyh2aXMpXG4gIH1cblxuICAvLyBHZXQgdGhlIGxpbmUgbnVtYmVyIG9mIHRoZSBzdGFydCBvZiB0aGUgbmV4dCB2aXN1YWwgbGluZSBhZnRlclxuICAvLyB0aGUgZ2l2ZW4gbGluZS5cbiAgZnVuY3Rpb24gdmlzdWFsTGluZUVuZE5vKGRvYywgbGluZU4pIHtcbiAgICBpZiAobGluZU4gPiBkb2MubGFzdExpbmUoKSkgeyByZXR1cm4gbGluZU4gfVxuICAgIHZhciBsaW5lID0gZ2V0TGluZShkb2MsIGxpbmVOKSwgbWVyZ2VkO1xuICAgIGlmICghbGluZUlzSGlkZGVuKGRvYywgbGluZSkpIHsgcmV0dXJuIGxpbmVOIH1cbiAgICB3aGlsZSAobWVyZ2VkID0gY29sbGFwc2VkU3BhbkF0RW5kKGxpbmUpKVxuICAgICAgeyBsaW5lID0gbWVyZ2VkLmZpbmQoMSwgdHJ1ZSkubGluZTsgfVxuICAgIHJldHVybiBsaW5lTm8obGluZSkgKyAxXG4gIH1cblxuICAvLyBDb21wdXRlIHdoZXRoZXIgYSBsaW5lIGlzIGhpZGRlbi4gTGluZXMgY291bnQgYXMgaGlkZGVuIHdoZW4gdGhleVxuICAvLyBhcmUgcGFydCBvZiBhIHZpc3VhbCBsaW5lIHRoYXQgc3RhcnRzIHdpdGggYW5vdGhlciBsaW5lLCBvciB3aGVuXG4gIC8vIHRoZXkgYXJlIGVudGlyZWx5IGNvdmVyZWQgYnkgY29sbGFwc2VkLCBub24td2lkZ2V0IHNwYW4uXG4gIGZ1bmN0aW9uIGxpbmVJc0hpZGRlbihkb2MsIGxpbmUpIHtcbiAgICB2YXIgc3BzID0gc2F3Q29sbGFwc2VkU3BhbnMgJiYgbGluZS5tYXJrZWRTcGFucztcbiAgICBpZiAoc3BzKSB7IGZvciAodmFyIHNwID0gKHZvaWQgMCksIGkgPSAwOyBpIDwgc3BzLmxlbmd0aDsgKytpKSB7XG4gICAgICBzcCA9IHNwc1tpXTtcbiAgICAgIGlmICghc3AubWFya2VyLmNvbGxhcHNlZCkgeyBjb250aW51ZSB9XG4gICAgICBpZiAoc3AuZnJvbSA9PSBudWxsKSB7IHJldHVybiB0cnVlIH1cbiAgICAgIGlmIChzcC5tYXJrZXIud2lkZ2V0Tm9kZSkgeyBjb250aW51ZSB9XG4gICAgICBpZiAoc3AuZnJvbSA9PSAwICYmIHNwLm1hcmtlci5pbmNsdXNpdmVMZWZ0ICYmIGxpbmVJc0hpZGRlbklubmVyKGRvYywgbGluZSwgc3ApKVxuICAgICAgICB7IHJldHVybiB0cnVlIH1cbiAgICB9IH1cbiAgfVxuICBmdW5jdGlvbiBsaW5lSXNIaWRkZW5Jbm5lcihkb2MsIGxpbmUsIHNwYW4pIHtcbiAgICBpZiAoc3Bhbi50byA9PSBudWxsKSB7XG4gICAgICB2YXIgZW5kID0gc3Bhbi5tYXJrZXIuZmluZCgxLCB0cnVlKTtcbiAgICAgIHJldHVybiBsaW5lSXNIaWRkZW5Jbm5lcihkb2MsIGVuZC5saW5lLCBnZXRNYXJrZWRTcGFuRm9yKGVuZC5saW5lLm1hcmtlZFNwYW5zLCBzcGFuLm1hcmtlcikpXG4gICAgfVxuICAgIGlmIChzcGFuLm1hcmtlci5pbmNsdXNpdmVSaWdodCAmJiBzcGFuLnRvID09IGxpbmUudGV4dC5sZW5ndGgpXG4gICAgICB7IHJldHVybiB0cnVlIH1cbiAgICBmb3IgKHZhciBzcCA9ICh2b2lkIDApLCBpID0gMDsgaSA8IGxpbmUubWFya2VkU3BhbnMubGVuZ3RoOyArK2kpIHtcbiAgICAgIHNwID0gbGluZS5tYXJrZWRTcGFuc1tpXTtcbiAgICAgIGlmIChzcC5tYXJrZXIuY29sbGFwc2VkICYmICFzcC5tYXJrZXIud2lkZ2V0Tm9kZSAmJiBzcC5mcm9tID09IHNwYW4udG8gJiZcbiAgICAgICAgICAoc3AudG8gPT0gbnVsbCB8fCBzcC50byAhPSBzcGFuLmZyb20pICYmXG4gICAgICAgICAgKHNwLm1hcmtlci5pbmNsdXNpdmVMZWZ0IHx8IHNwYW4ubWFya2VyLmluY2x1c2l2ZVJpZ2h0KSAmJlxuICAgICAgICAgIGxpbmVJc0hpZGRlbklubmVyKGRvYywgbGluZSwgc3ApKSB7IHJldHVybiB0cnVlIH1cbiAgICB9XG4gIH1cblxuICAvLyBGaW5kIHRoZSBoZWlnaHQgYWJvdmUgdGhlIGdpdmVuIGxpbmUuXG4gIGZ1bmN0aW9uIGhlaWdodEF0TGluZShsaW5lT2JqKSB7XG4gICAgbGluZU9iaiA9IHZpc3VhbExpbmUobGluZU9iaik7XG5cbiAgICB2YXIgaCA9IDAsIGNodW5rID0gbGluZU9iai5wYXJlbnQ7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBjaHVuay5saW5lcy5sZW5ndGg7ICsraSkge1xuICAgICAgdmFyIGxpbmUgPSBjaHVuay5saW5lc1tpXTtcbiAgICAgIGlmIChsaW5lID09IGxpbmVPYmopIHsgYnJlYWsgfVxuICAgICAgZWxzZSB7IGggKz0gbGluZS5oZWlnaHQ7IH1cbiAgICB9XG4gICAgZm9yICh2YXIgcCA9IGNodW5rLnBhcmVudDsgcDsgY2h1bmsgPSBwLCBwID0gY2h1bmsucGFyZW50KSB7XG4gICAgICBmb3IgKHZhciBpJDEgPSAwOyBpJDEgPCBwLmNoaWxkcmVuLmxlbmd0aDsgKytpJDEpIHtcbiAgICAgICAgdmFyIGN1ciA9IHAuY2hpbGRyZW5baSQxXTtcbiAgICAgICAgaWYgKGN1ciA9PSBjaHVuaykgeyBicmVhayB9XG4gICAgICAgIGVsc2UgeyBoICs9IGN1ci5oZWlnaHQ7IH1cbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIGhcbiAgfVxuXG4gIC8vIENvbXB1dGUgdGhlIGNoYXJhY3RlciBsZW5ndGggb2YgYSBsaW5lLCB0YWtpbmcgaW50byBhY2NvdW50XG4gIC8vIGNvbGxhcHNlZCByYW5nZXMgKHNlZSBtYXJrVGV4dCkgdGhhdCBtaWdodCBoaWRlIHBhcnRzLCBhbmQgam9pblxuICAvLyBvdGhlciBsaW5lcyBvbnRvIGl0LlxuICBmdW5jdGlvbiBsaW5lTGVuZ3RoKGxpbmUpIHtcbiAgICBpZiAobGluZS5oZWlnaHQgPT0gMCkgeyByZXR1cm4gMCB9XG4gICAgdmFyIGxlbiA9IGxpbmUudGV4dC5sZW5ndGgsIG1lcmdlZCwgY3VyID0gbGluZTtcbiAgICB3aGlsZSAobWVyZ2VkID0gY29sbGFwc2VkU3BhbkF0U3RhcnQoY3VyKSkge1xuICAgICAgdmFyIGZvdW5kID0gbWVyZ2VkLmZpbmQoMCwgdHJ1ZSk7XG4gICAgICBjdXIgPSBmb3VuZC5mcm9tLmxpbmU7XG4gICAgICBsZW4gKz0gZm91bmQuZnJvbS5jaCAtIGZvdW5kLnRvLmNoO1xuICAgIH1cbiAgICBjdXIgPSBsaW5lO1xuICAgIHdoaWxlIChtZXJnZWQgPSBjb2xsYXBzZWRTcGFuQXRFbmQoY3VyKSkge1xuICAgICAgdmFyIGZvdW5kJDEgPSBtZXJnZWQuZmluZCgwLCB0cnVlKTtcbiAgICAgIGxlbiAtPSBjdXIudGV4dC5sZW5ndGggLSBmb3VuZCQxLmZyb20uY2g7XG4gICAgICBjdXIgPSBmb3VuZCQxLnRvLmxpbmU7XG4gICAgICBsZW4gKz0gY3VyLnRleHQubGVuZ3RoIC0gZm91bmQkMS50by5jaDtcbiAgICB9XG4gICAgcmV0dXJuIGxlblxuICB9XG5cbiAgLy8gRmluZCB0aGUgbG9uZ2VzdCBsaW5lIGluIHRoZSBkb2N1bWVudC5cbiAgZnVuY3Rpb24gZmluZE1heExpbmUoY20pIHtcbiAgICB2YXIgZCA9IGNtLmRpc3BsYXksIGRvYyA9IGNtLmRvYztcbiAgICBkLm1heExpbmUgPSBnZXRMaW5lKGRvYywgZG9jLmZpcnN0KTtcbiAgICBkLm1heExpbmVMZW5ndGggPSBsaW5lTGVuZ3RoKGQubWF4TGluZSk7XG4gICAgZC5tYXhMaW5lQ2hhbmdlZCA9IHRydWU7XG4gICAgZG9jLml0ZXIoZnVuY3Rpb24gKGxpbmUpIHtcbiAgICAgIHZhciBsZW4gPSBsaW5lTGVuZ3RoKGxpbmUpO1xuICAgICAgaWYgKGxlbiA+IGQubWF4TGluZUxlbmd0aCkge1xuICAgICAgICBkLm1heExpbmVMZW5ndGggPSBsZW47XG4gICAgICAgIGQubWF4TGluZSA9IGxpbmU7XG4gICAgICB9XG4gICAgfSk7XG4gIH1cblxuICAvLyBMSU5FIERBVEEgU1RSVUNUVVJFXG5cbiAgLy8gTGluZSBvYmplY3RzLiBUaGVzZSBob2xkIHN0YXRlIHJlbGF0ZWQgdG8gYSBsaW5lLCBpbmNsdWRpbmdcbiAgLy8gaGlnaGxpZ2h0aW5nIGluZm8gKHRoZSBzdHlsZXMgYXJyYXkpLlxuICB2YXIgTGluZSA9IGZ1bmN0aW9uKHRleHQsIG1hcmtlZFNwYW5zLCBlc3RpbWF0ZUhlaWdodCkge1xuICAgIHRoaXMudGV4dCA9IHRleHQ7XG4gICAgYXR0YWNoTWFya2VkU3BhbnModGhpcywgbWFya2VkU3BhbnMpO1xuICAgIHRoaXMuaGVpZ2h0ID0gZXN0aW1hdGVIZWlnaHQgPyBlc3RpbWF0ZUhlaWdodCh0aGlzKSA6IDE7XG4gIH07XG5cbiAgTGluZS5wcm90b3R5cGUubGluZU5vID0gZnVuY3Rpb24gKCkgeyByZXR1cm4gbGluZU5vKHRoaXMpIH07XG4gIGV2ZW50TWl4aW4oTGluZSk7XG5cbiAgLy8gQ2hhbmdlIHRoZSBjb250ZW50ICh0ZXh0LCBtYXJrZXJzKSBvZiBhIGxpbmUuIEF1dG9tYXRpY2FsbHlcbiAgLy8gaW52YWxpZGF0ZXMgY2FjaGVkIGluZm9ybWF0aW9uIGFuZCB0cmllcyB0byByZS1lc3RpbWF0ZSB0aGVcbiAgLy8gbGluZSdzIGhlaWdodC5cbiAgZnVuY3Rpb24gdXBkYXRlTGluZShsaW5lLCB0ZXh0LCBtYXJrZWRTcGFucywgZXN0aW1hdGVIZWlnaHQpIHtcbiAgICBsaW5lLnRleHQgPSB0ZXh0O1xuICAgIGlmIChsaW5lLnN0YXRlQWZ0ZXIpIHsgbGluZS5zdGF0ZUFmdGVyID0gbnVsbDsgfVxuICAgIGlmIChsaW5lLnN0eWxlcykgeyBsaW5lLnN0eWxlcyA9IG51bGw7IH1cbiAgICBpZiAobGluZS5vcmRlciAhPSBudWxsKSB7IGxpbmUub3JkZXIgPSBudWxsOyB9XG4gICAgZGV0YWNoTWFya2VkU3BhbnMobGluZSk7XG4gICAgYXR0YWNoTWFya2VkU3BhbnMobGluZSwgbWFya2VkU3BhbnMpO1xuICAgIHZhciBlc3RIZWlnaHQgPSBlc3RpbWF0ZUhlaWdodCA/IGVzdGltYXRlSGVpZ2h0KGxpbmUpIDogMTtcbiAgICBpZiAoZXN0SGVpZ2h0ICE9IGxpbmUuaGVpZ2h0KSB7IHVwZGF0ZUxpbmVIZWlnaHQobGluZSwgZXN0SGVpZ2h0KTsgfVxuICB9XG5cbiAgLy8gRGV0YWNoIGEgbGluZSBmcm9tIHRoZSBkb2N1bWVudCB0cmVlIGFuZCBpdHMgbWFya2Vycy5cbiAgZnVuY3Rpb24gY2xlYW5VcExpbmUobGluZSkge1xuICAgIGxpbmUucGFyZW50ID0gbnVsbDtcbiAgICBkZXRhY2hNYXJrZWRTcGFucyhsaW5lKTtcbiAgfVxuXG4gIC8vIENvbnZlcnQgYSBzdHlsZSBhcyByZXR1cm5lZCBieSBhIG1vZGUgKGVpdGhlciBudWxsLCBvciBhIHN0cmluZ1xuICAvLyBjb250YWluaW5nIG9uZSBvciBtb3JlIHN0eWxlcykgdG8gYSBDU1Mgc3R5bGUuIFRoaXMgaXMgY2FjaGVkLFxuICAvLyBhbmQgYWxzbyBsb29rcyBmb3IgbGluZS13aWRlIHN0eWxlcy5cbiAgdmFyIHN0eWxlVG9DbGFzc0NhY2hlID0ge30sIHN0eWxlVG9DbGFzc0NhY2hlV2l0aE1vZGUgPSB7fTtcbiAgZnVuY3Rpb24gaW50ZXJwcmV0VG9rZW5TdHlsZShzdHlsZSwgb3B0aW9ucykge1xuICAgIGlmICghc3R5bGUgfHwgL15cXHMqJC8udGVzdChzdHlsZSkpIHsgcmV0dXJuIG51bGwgfVxuICAgIHZhciBjYWNoZSA9IG9wdGlvbnMuYWRkTW9kZUNsYXNzID8gc3R5bGVUb0NsYXNzQ2FjaGVXaXRoTW9kZSA6IHN0eWxlVG9DbGFzc0NhY2hlO1xuICAgIHJldHVybiBjYWNoZVtzdHlsZV0gfHxcbiAgICAgIChjYWNoZVtzdHlsZV0gPSBzdHlsZS5yZXBsYWNlKC9cXFMrL2csIFwiY20tJCZcIikpXG4gIH1cblxuICAvLyBSZW5kZXIgdGhlIERPTSByZXByZXNlbnRhdGlvbiBvZiB0aGUgdGV4dCBvZiBhIGxpbmUuIEFsc28gYnVpbGRzXG4gIC8vIHVwIGEgJ2xpbmUgbWFwJywgd2hpY2ggcG9pbnRzIGF0IHRoZSBET00gbm9kZXMgdGhhdCByZXByZXNlbnRcbiAgLy8gc3BlY2lmaWMgc3RyZXRjaGVzIG9mIHRleHQsIGFuZCBpcyB1c2VkIGJ5IHRoZSBtZWFzdXJpbmcgY29kZS5cbiAgLy8gVGhlIHJldHVybmVkIG9iamVjdCBjb250YWlucyB0aGUgRE9NIG5vZGUsIHRoaXMgbWFwLCBhbmRcbiAgLy8gaW5mb3JtYXRpb24gYWJvdXQgbGluZS13aWRlIHN0eWxlcyB0aGF0IHdlcmUgc2V0IGJ5IHRoZSBtb2RlLlxuICBmdW5jdGlvbiBidWlsZExpbmVDb250ZW50KGNtLCBsaW5lVmlldykge1xuICAgIC8vIFRoZSBwYWRkaW5nLXJpZ2h0IGZvcmNlcyB0aGUgZWxlbWVudCB0byBoYXZlIGEgJ2JvcmRlcicsIHdoaWNoXG4gICAgLy8gaXMgbmVlZGVkIG9uIFdlYmtpdCB0byBiZSBhYmxlIHRvIGdldCBsaW5lLWxldmVsIGJvdW5kaW5nXG4gICAgLy8gcmVjdGFuZ2xlcyBmb3IgaXQgKGluIG1lYXN1cmVDaGFyKS5cbiAgICB2YXIgY29udGVudCA9IGVsdFAoXCJzcGFuXCIsIG51bGwsIG51bGwsIHdlYmtpdCA/IFwicGFkZGluZy1yaWdodDogLjFweFwiIDogbnVsbCk7XG4gICAgdmFyIGJ1aWxkZXIgPSB7cHJlOiBlbHRQKFwicHJlXCIsIFtjb250ZW50XSwgXCJDb2RlTWlycm9yLWxpbmVcIiksIGNvbnRlbnQ6IGNvbnRlbnQsXG4gICAgICAgICAgICAgICAgICAgY29sOiAwLCBwb3M6IDAsIGNtOiBjbSxcbiAgICAgICAgICAgICAgICAgICB0cmFpbGluZ1NwYWNlOiBmYWxzZSxcbiAgICAgICAgICAgICAgICAgICBzcGxpdFNwYWNlczogY20uZ2V0T3B0aW9uKFwibGluZVdyYXBwaW5nXCIpfTtcbiAgICBsaW5lVmlldy5tZWFzdXJlID0ge307XG5cbiAgICAvLyBJdGVyYXRlIG92ZXIgdGhlIGxvZ2ljYWwgbGluZXMgdGhhdCBtYWtlIHVwIHRoaXMgdmlzdWFsIGxpbmUuXG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPD0gKGxpbmVWaWV3LnJlc3QgPyBsaW5lVmlldy5yZXN0Lmxlbmd0aCA6IDApOyBpKyspIHtcbiAgICAgIHZhciBsaW5lID0gaSA/IGxpbmVWaWV3LnJlc3RbaSAtIDFdIDogbGluZVZpZXcubGluZSwgb3JkZXIgPSAodm9pZCAwKTtcbiAgICAgIGJ1aWxkZXIucG9zID0gMDtcbiAgICAgIGJ1aWxkZXIuYWRkVG9rZW4gPSBidWlsZFRva2VuO1xuICAgICAgLy8gT3B0aW9uYWxseSB3aXJlIGluIHNvbWUgaGFja3MgaW50byB0aGUgdG9rZW4tcmVuZGVyaW5nXG4gICAgICAvLyBhbGdvcml0aG0sIHRvIGRlYWwgd2l0aCBicm93c2VyIHF1aXJrcy5cbiAgICAgIGlmIChoYXNCYWRCaWRpUmVjdHMoY20uZGlzcGxheS5tZWFzdXJlKSAmJiAob3JkZXIgPSBnZXRPcmRlcihsaW5lLCBjbS5kb2MuZGlyZWN0aW9uKSkpXG4gICAgICAgIHsgYnVpbGRlci5hZGRUb2tlbiA9IGJ1aWxkVG9rZW5CYWRCaWRpKGJ1aWxkZXIuYWRkVG9rZW4sIG9yZGVyKTsgfVxuICAgICAgYnVpbGRlci5tYXAgPSBbXTtcbiAgICAgIHZhciBhbGxvd0Zyb250aWVyVXBkYXRlID0gbGluZVZpZXcgIT0gY20uZGlzcGxheS5leHRlcm5hbE1lYXN1cmVkICYmIGxpbmVObyhsaW5lKTtcbiAgICAgIGluc2VydExpbmVDb250ZW50KGxpbmUsIGJ1aWxkZXIsIGdldExpbmVTdHlsZXMoY20sIGxpbmUsIGFsbG93RnJvbnRpZXJVcGRhdGUpKTtcbiAgICAgIGlmIChsaW5lLnN0eWxlQ2xhc3Nlcykge1xuICAgICAgICBpZiAobGluZS5zdHlsZUNsYXNzZXMuYmdDbGFzcylcbiAgICAgICAgICB7IGJ1aWxkZXIuYmdDbGFzcyA9IGpvaW5DbGFzc2VzKGxpbmUuc3R5bGVDbGFzc2VzLmJnQ2xhc3MsIGJ1aWxkZXIuYmdDbGFzcyB8fCBcIlwiKTsgfVxuICAgICAgICBpZiAobGluZS5zdHlsZUNsYXNzZXMudGV4dENsYXNzKVxuICAgICAgICAgIHsgYnVpbGRlci50ZXh0Q2xhc3MgPSBqb2luQ2xhc3NlcyhsaW5lLnN0eWxlQ2xhc3Nlcy50ZXh0Q2xhc3MsIGJ1aWxkZXIudGV4dENsYXNzIHx8IFwiXCIpOyB9XG4gICAgICB9XG5cbiAgICAgIC8vIEVuc3VyZSBhdCBsZWFzdCBhIHNpbmdsZSBub2RlIGlzIHByZXNlbnQsIGZvciBtZWFzdXJpbmcuXG4gICAgICBpZiAoYnVpbGRlci5tYXAubGVuZ3RoID09IDApXG4gICAgICAgIHsgYnVpbGRlci5tYXAucHVzaCgwLCAwLCBidWlsZGVyLmNvbnRlbnQuYXBwZW5kQ2hpbGQoemVyb1dpZHRoRWxlbWVudChjbS5kaXNwbGF5Lm1lYXN1cmUpKSk7IH1cblxuICAgICAgLy8gU3RvcmUgdGhlIG1hcCBhbmQgYSBjYWNoZSBvYmplY3QgZm9yIHRoZSBjdXJyZW50IGxvZ2ljYWwgbGluZVxuICAgICAgaWYgKGkgPT0gMCkge1xuICAgICAgICBsaW5lVmlldy5tZWFzdXJlLm1hcCA9IGJ1aWxkZXIubWFwO1xuICAgICAgICBsaW5lVmlldy5tZWFzdXJlLmNhY2hlID0ge307XG4gICAgICB9IGVsc2Uge1xuICAobGluZVZpZXcubWVhc3VyZS5tYXBzIHx8IChsaW5lVmlldy5tZWFzdXJlLm1hcHMgPSBbXSkpLnB1c2goYnVpbGRlci5tYXApXG4gICAgICAgIDsobGluZVZpZXcubWVhc3VyZS5jYWNoZXMgfHwgKGxpbmVWaWV3Lm1lYXN1cmUuY2FjaGVzID0gW10pKS5wdXNoKHt9KTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICAvLyBTZWUgaXNzdWUgIzI5MDFcbiAgICBpZiAod2Via2l0KSB7XG4gICAgICB2YXIgbGFzdCA9IGJ1aWxkZXIuY29udGVudC5sYXN0Q2hpbGQ7XG4gICAgICBpZiAoL1xcYmNtLXRhYlxcYi8udGVzdChsYXN0LmNsYXNzTmFtZSkgfHwgKGxhc3QucXVlcnlTZWxlY3RvciAmJiBsYXN0LnF1ZXJ5U2VsZWN0b3IoXCIuY20tdGFiXCIpKSlcbiAgICAgICAgeyBidWlsZGVyLmNvbnRlbnQuY2xhc3NOYW1lID0gXCJjbS10YWItd3JhcC1oYWNrXCI7IH1cbiAgICB9XG5cbiAgICBzaWduYWwoY20sIFwicmVuZGVyTGluZVwiLCBjbSwgbGluZVZpZXcubGluZSwgYnVpbGRlci5wcmUpO1xuICAgIGlmIChidWlsZGVyLnByZS5jbGFzc05hbWUpXG4gICAgICB7IGJ1aWxkZXIudGV4dENsYXNzID0gam9pbkNsYXNzZXMoYnVpbGRlci5wcmUuY2xhc3NOYW1lLCBidWlsZGVyLnRleHRDbGFzcyB8fCBcIlwiKTsgfVxuXG4gICAgcmV0dXJuIGJ1aWxkZXJcbiAgfVxuXG4gIGZ1bmN0aW9uIGRlZmF1bHRTcGVjaWFsQ2hhclBsYWNlaG9sZGVyKGNoKSB7XG4gICAgdmFyIHRva2VuID0gZWx0KFwic3BhblwiLCBcIlxcdTIwMjJcIiwgXCJjbS1pbnZhbGlkY2hhclwiKTtcbiAgICB0b2tlbi50aXRsZSA9IFwiXFxcXHVcIiArIGNoLmNoYXJDb2RlQXQoMCkudG9TdHJpbmcoMTYpO1xuICAgIHRva2VuLnNldEF0dHJpYnV0ZShcImFyaWEtbGFiZWxcIiwgdG9rZW4udGl0bGUpO1xuICAgIHJldHVybiB0b2tlblxuICB9XG5cbiAgLy8gQnVpbGQgdXAgdGhlIERPTSByZXByZXNlbnRhdGlvbiBmb3IgYSBzaW5nbGUgdG9rZW4sIGFuZCBhZGQgaXQgdG9cbiAgLy8gdGhlIGxpbmUgbWFwLiBUYWtlcyBjYXJlIHRvIHJlbmRlciBzcGVjaWFsIGNoYXJhY3RlcnMgc2VwYXJhdGVseS5cbiAgZnVuY3Rpb24gYnVpbGRUb2tlbihidWlsZGVyLCB0ZXh0LCBzdHlsZSwgc3RhcnRTdHlsZSwgZW5kU3R5bGUsIGNzcywgYXR0cmlidXRlcykge1xuICAgIGlmICghdGV4dCkgeyByZXR1cm4gfVxuICAgIHZhciBkaXNwbGF5VGV4dCA9IGJ1aWxkZXIuc3BsaXRTcGFjZXMgPyBzcGxpdFNwYWNlcyh0ZXh0LCBidWlsZGVyLnRyYWlsaW5nU3BhY2UpIDogdGV4dDtcbiAgICB2YXIgc3BlY2lhbCA9IGJ1aWxkZXIuY20uc3RhdGUuc3BlY2lhbENoYXJzLCBtdXN0V3JhcCA9IGZhbHNlO1xuICAgIHZhciBjb250ZW50O1xuICAgIGlmICghc3BlY2lhbC50ZXN0KHRleHQpKSB7XG4gICAgICBidWlsZGVyLmNvbCArPSB0ZXh0Lmxlbmd0aDtcbiAgICAgIGNvbnRlbnQgPSBkb2N1bWVudC5jcmVhdGVUZXh0Tm9kZShkaXNwbGF5VGV4dCk7XG4gICAgICBidWlsZGVyLm1hcC5wdXNoKGJ1aWxkZXIucG9zLCBidWlsZGVyLnBvcyArIHRleHQubGVuZ3RoLCBjb250ZW50KTtcbiAgICAgIGlmIChpZSAmJiBpZV92ZXJzaW9uIDwgOSkgeyBtdXN0V3JhcCA9IHRydWU7IH1cbiAgICAgIGJ1aWxkZXIucG9zICs9IHRleHQubGVuZ3RoO1xuICAgIH0gZWxzZSB7XG4gICAgICBjb250ZW50ID0gZG9jdW1lbnQuY3JlYXRlRG9jdW1lbnRGcmFnbWVudCgpO1xuICAgICAgdmFyIHBvcyA9IDA7XG4gICAgICB3aGlsZSAodHJ1ZSkge1xuICAgICAgICBzcGVjaWFsLmxhc3RJbmRleCA9IHBvcztcbiAgICAgICAgdmFyIG0gPSBzcGVjaWFsLmV4ZWModGV4dCk7XG4gICAgICAgIHZhciBza2lwcGVkID0gbSA/IG0uaW5kZXggLSBwb3MgOiB0ZXh0Lmxlbmd0aCAtIHBvcztcbiAgICAgICAgaWYgKHNraXBwZWQpIHtcbiAgICAgICAgICB2YXIgdHh0ID0gZG9jdW1lbnQuY3JlYXRlVGV4dE5vZGUoZGlzcGxheVRleHQuc2xpY2UocG9zLCBwb3MgKyBza2lwcGVkKSk7XG4gICAgICAgICAgaWYgKGllICYmIGllX3ZlcnNpb24gPCA5KSB7IGNvbnRlbnQuYXBwZW5kQ2hpbGQoZWx0KFwic3BhblwiLCBbdHh0XSkpOyB9XG4gICAgICAgICAgZWxzZSB7IGNvbnRlbnQuYXBwZW5kQ2hpbGQodHh0KTsgfVxuICAgICAgICAgIGJ1aWxkZXIubWFwLnB1c2goYnVpbGRlci5wb3MsIGJ1aWxkZXIucG9zICsgc2tpcHBlZCwgdHh0KTtcbiAgICAgICAgICBidWlsZGVyLmNvbCArPSBza2lwcGVkO1xuICAgICAgICAgIGJ1aWxkZXIucG9zICs9IHNraXBwZWQ7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCFtKSB7IGJyZWFrIH1cbiAgICAgICAgcG9zICs9IHNraXBwZWQgKyAxO1xuICAgICAgICB2YXIgdHh0JDEgPSAodm9pZCAwKTtcbiAgICAgICAgaWYgKG1bMF0gPT0gXCJcXHRcIikge1xuICAgICAgICAgIHZhciB0YWJTaXplID0gYnVpbGRlci5jbS5vcHRpb25zLnRhYlNpemUsIHRhYldpZHRoID0gdGFiU2l6ZSAtIGJ1aWxkZXIuY29sICUgdGFiU2l6ZTtcbiAgICAgICAgICB0eHQkMSA9IGNvbnRlbnQuYXBwZW5kQ2hpbGQoZWx0KFwic3BhblwiLCBzcGFjZVN0cih0YWJXaWR0aCksIFwiY20tdGFiXCIpKTtcbiAgICAgICAgICB0eHQkMS5zZXRBdHRyaWJ1dGUoXCJyb2xlXCIsIFwicHJlc2VudGF0aW9uXCIpO1xuICAgICAgICAgIHR4dCQxLnNldEF0dHJpYnV0ZShcImNtLXRleHRcIiwgXCJcXHRcIik7XG4gICAgICAgICAgYnVpbGRlci5jb2wgKz0gdGFiV2lkdGg7XG4gICAgICAgIH0gZWxzZSBpZiAobVswXSA9PSBcIlxcclwiIHx8IG1bMF0gPT0gXCJcXG5cIikge1xuICAgICAgICAgIHR4dCQxID0gY29udGVudC5hcHBlbmRDaGlsZChlbHQoXCJzcGFuXCIsIG1bMF0gPT0gXCJcXHJcIiA/IFwiXFx1MjQwZFwiIDogXCJcXHUyNDI0XCIsIFwiY20taW52YWxpZGNoYXJcIikpO1xuICAgICAgICAgIHR4dCQxLnNldEF0dHJpYnV0ZShcImNtLXRleHRcIiwgbVswXSk7XG4gICAgICAgICAgYnVpbGRlci5jb2wgKz0gMTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB0eHQkMSA9IGJ1aWxkZXIuY20ub3B0aW9ucy5zcGVjaWFsQ2hhclBsYWNlaG9sZGVyKG1bMF0pO1xuICAgICAgICAgIHR4dCQxLnNldEF0dHJpYnV0ZShcImNtLXRleHRcIiwgbVswXSk7XG4gICAgICAgICAgaWYgKGllICYmIGllX3ZlcnNpb24gPCA5KSB7IGNvbnRlbnQuYXBwZW5kQ2hpbGQoZWx0KFwic3BhblwiLCBbdHh0JDFdKSk7IH1cbiAgICAgICAgICBlbHNlIHsgY29udGVudC5hcHBlbmRDaGlsZCh0eHQkMSk7IH1cbiAgICAgICAgICBidWlsZGVyLmNvbCArPSAxO1xuICAgICAgICB9XG4gICAgICAgIGJ1aWxkZXIubWFwLnB1c2goYnVpbGRlci5wb3MsIGJ1aWxkZXIucG9zICsgMSwgdHh0JDEpO1xuICAgICAgICBidWlsZGVyLnBvcysrO1xuICAgICAgfVxuICAgIH1cbiAgICBidWlsZGVyLnRyYWlsaW5nU3BhY2UgPSBkaXNwbGF5VGV4dC5jaGFyQ29kZUF0KHRleHQubGVuZ3RoIC0gMSkgPT0gMzI7XG4gICAgaWYgKHN0eWxlIHx8IHN0YXJ0U3R5bGUgfHwgZW5kU3R5bGUgfHwgbXVzdFdyYXAgfHwgY3NzIHx8IGF0dHJpYnV0ZXMpIHtcbiAgICAgIHZhciBmdWxsU3R5bGUgPSBzdHlsZSB8fCBcIlwiO1xuICAgICAgaWYgKHN0YXJ0U3R5bGUpIHsgZnVsbFN0eWxlICs9IHN0YXJ0U3R5bGU7IH1cbiAgICAgIGlmIChlbmRTdHlsZSkgeyBmdWxsU3R5bGUgKz0gZW5kU3R5bGU7IH1cbiAgICAgIHZhciB0b2tlbiA9IGVsdChcInNwYW5cIiwgW2NvbnRlbnRdLCBmdWxsU3R5bGUsIGNzcyk7XG4gICAgICBpZiAoYXR0cmlidXRlcykge1xuICAgICAgICBmb3IgKHZhciBhdHRyIGluIGF0dHJpYnV0ZXMpIHsgaWYgKGF0dHJpYnV0ZXMuaGFzT3duUHJvcGVydHkoYXR0cikgJiYgYXR0ciAhPSBcInN0eWxlXCIgJiYgYXR0ciAhPSBcImNsYXNzXCIpXG4gICAgICAgICAgeyB0b2tlbi5zZXRBdHRyaWJ1dGUoYXR0ciwgYXR0cmlidXRlc1thdHRyXSk7IH0gfVxuICAgICAgfVxuICAgICAgcmV0dXJuIGJ1aWxkZXIuY29udGVudC5hcHBlbmRDaGlsZCh0b2tlbilcbiAgICB9XG4gICAgYnVpbGRlci5jb250ZW50LmFwcGVuZENoaWxkKGNvbnRlbnQpO1xuICB9XG5cbiAgLy8gQ2hhbmdlIHNvbWUgc3BhY2VzIHRvIE5CU1AgdG8gcHJldmVudCB0aGUgYnJvd3NlciBmcm9tIGNvbGxhcHNpbmdcbiAgLy8gdHJhaWxpbmcgc3BhY2VzIGF0IHRoZSBlbmQgb2YgYSBsaW5lIHdoZW4gcmVuZGVyaW5nIHRleHQgKGlzc3VlICMxMzYyKS5cbiAgZnVuY3Rpb24gc3BsaXRTcGFjZXModGV4dCwgdHJhaWxpbmdCZWZvcmUpIHtcbiAgICBpZiAodGV4dC5sZW5ndGggPiAxICYmICEvICAvLnRlc3QodGV4dCkpIHsgcmV0dXJuIHRleHQgfVxuICAgIHZhciBzcGFjZUJlZm9yZSA9IHRyYWlsaW5nQmVmb3JlLCByZXN1bHQgPSBcIlwiO1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdGV4dC5sZW5ndGg7IGkrKykge1xuICAgICAgdmFyIGNoID0gdGV4dC5jaGFyQXQoaSk7XG4gICAgICBpZiAoY2ggPT0gXCIgXCIgJiYgc3BhY2VCZWZvcmUgJiYgKGkgPT0gdGV4dC5sZW5ndGggLSAxIHx8IHRleHQuY2hhckNvZGVBdChpICsgMSkgPT0gMzIpKVxuICAgICAgICB7IGNoID0gXCJcXHUwMGEwXCI7IH1cbiAgICAgIHJlc3VsdCArPSBjaDtcbiAgICAgIHNwYWNlQmVmb3JlID0gY2ggPT0gXCIgXCI7XG4gICAgfVxuICAgIHJldHVybiByZXN1bHRcbiAgfVxuXG4gIC8vIFdvcmsgYXJvdW5kIG5vbnNlbnNlIGRpbWVuc2lvbnMgYmVpbmcgcmVwb3J0ZWQgZm9yIHN0cmV0Y2hlcyBvZlxuICAvLyByaWdodC10by1sZWZ0IHRleHQuXG4gIGZ1bmN0aW9uIGJ1aWxkVG9rZW5CYWRCaWRpKGlubmVyLCBvcmRlcikge1xuICAgIHJldHVybiBmdW5jdGlvbiAoYnVpbGRlciwgdGV4dCwgc3R5bGUsIHN0YXJ0U3R5bGUsIGVuZFN0eWxlLCBjc3MsIGF0dHJpYnV0ZXMpIHtcbiAgICAgIHN0eWxlID0gc3R5bGUgPyBzdHlsZSArIFwiIGNtLWZvcmNlLWJvcmRlclwiIDogXCJjbS1mb3JjZS1ib3JkZXJcIjtcbiAgICAgIHZhciBzdGFydCA9IGJ1aWxkZXIucG9zLCBlbmQgPSBzdGFydCArIHRleHQubGVuZ3RoO1xuICAgICAgZm9yICg7Oykge1xuICAgICAgICAvLyBGaW5kIHRoZSBwYXJ0IHRoYXQgb3ZlcmxhcHMgd2l0aCB0aGUgc3RhcnQgb2YgdGhpcyB0ZXh0XG4gICAgICAgIHZhciBwYXJ0ID0gKHZvaWQgMCk7XG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgb3JkZXIubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICBwYXJ0ID0gb3JkZXJbaV07XG4gICAgICAgICAgaWYgKHBhcnQudG8gPiBzdGFydCAmJiBwYXJ0LmZyb20gPD0gc3RhcnQpIHsgYnJlYWsgfVxuICAgICAgICB9XG4gICAgICAgIGlmIChwYXJ0LnRvID49IGVuZCkgeyByZXR1cm4gaW5uZXIoYnVpbGRlciwgdGV4dCwgc3R5bGUsIHN0YXJ0U3R5bGUsIGVuZFN0eWxlLCBjc3MsIGF0dHJpYnV0ZXMpIH1cbiAgICAgICAgaW5uZXIoYnVpbGRlciwgdGV4dC5zbGljZSgwLCBwYXJ0LnRvIC0gc3RhcnQpLCBzdHlsZSwgc3RhcnRTdHlsZSwgbnVsbCwgY3NzLCBhdHRyaWJ1dGVzKTtcbiAgICAgICAgc3RhcnRTdHlsZSA9IG51bGw7XG4gICAgICAgIHRleHQgPSB0ZXh0LnNsaWNlKHBhcnQudG8gLSBzdGFydCk7XG4gICAgICAgIHN0YXJ0ID0gcGFydC50bztcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICBmdW5jdGlvbiBidWlsZENvbGxhcHNlZFNwYW4oYnVpbGRlciwgc2l6ZSwgbWFya2VyLCBpZ25vcmVXaWRnZXQpIHtcbiAgICB2YXIgd2lkZ2V0ID0gIWlnbm9yZVdpZGdldCAmJiBtYXJrZXIud2lkZ2V0Tm9kZTtcbiAgICBpZiAod2lkZ2V0KSB7IGJ1aWxkZXIubWFwLnB1c2goYnVpbGRlci5wb3MsIGJ1aWxkZXIucG9zICsgc2l6ZSwgd2lkZ2V0KTsgfVxuICAgIGlmICghaWdub3JlV2lkZ2V0ICYmIGJ1aWxkZXIuY20uZGlzcGxheS5pbnB1dC5uZWVkc0NvbnRlbnRBdHRyaWJ1dGUpIHtcbiAgICAgIGlmICghd2lkZ2V0KVxuICAgICAgICB7IHdpZGdldCA9IGJ1aWxkZXIuY29udGVudC5hcHBlbmRDaGlsZChkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwic3BhblwiKSk7IH1cbiAgICAgIHdpZGdldC5zZXRBdHRyaWJ1dGUoXCJjbS1tYXJrZXJcIiwgbWFya2VyLmlkKTtcbiAgICB9XG4gICAgaWYgKHdpZGdldCkge1xuICAgICAgYnVpbGRlci5jbS5kaXNwbGF5LmlucHV0LnNldFVuZWRpdGFibGUod2lkZ2V0KTtcbiAgICAgIGJ1aWxkZXIuY29udGVudC5hcHBlbmRDaGlsZCh3aWRnZXQpO1xuICAgIH1cbiAgICBidWlsZGVyLnBvcyArPSBzaXplO1xuICAgIGJ1aWxkZXIudHJhaWxpbmdTcGFjZSA9IGZhbHNlO1xuICB9XG5cbiAgLy8gT3V0cHV0cyBhIG51bWJlciBvZiBzcGFucyB0byBtYWtlIHVwIGEgbGluZSwgdGFraW5nIGhpZ2hsaWdodGluZ1xuICAvLyBhbmQgbWFya2VkIHRleHQgaW50byBhY2NvdW50LlxuICBmdW5jdGlvbiBpbnNlcnRMaW5lQ29udGVudChsaW5lLCBidWlsZGVyLCBzdHlsZXMpIHtcbiAgICB2YXIgc3BhbnMgPSBsaW5lLm1hcmtlZFNwYW5zLCBhbGxUZXh0ID0gbGluZS50ZXh0LCBhdCA9IDA7XG4gICAgaWYgKCFzcGFucykge1xuICAgICAgZm9yICh2YXIgaSQxID0gMTsgaSQxIDwgc3R5bGVzLmxlbmd0aDsgaSQxKz0yKVxuICAgICAgICB7IGJ1aWxkZXIuYWRkVG9rZW4oYnVpbGRlciwgYWxsVGV4dC5zbGljZShhdCwgYXQgPSBzdHlsZXNbaSQxXSksIGludGVycHJldFRva2VuU3R5bGUoc3R5bGVzW2kkMSsxXSwgYnVpbGRlci5jbS5vcHRpb25zKSk7IH1cbiAgICAgIHJldHVyblxuICAgIH1cblxuICAgIHZhciBsZW4gPSBhbGxUZXh0Lmxlbmd0aCwgcG9zID0gMCwgaSA9IDEsIHRleHQgPSBcIlwiLCBzdHlsZSwgY3NzO1xuICAgIHZhciBuZXh0Q2hhbmdlID0gMCwgc3BhblN0eWxlLCBzcGFuRW5kU3R5bGUsIHNwYW5TdGFydFN0eWxlLCBjb2xsYXBzZWQsIGF0dHJpYnV0ZXM7XG4gICAgZm9yICg7Oykge1xuICAgICAgaWYgKG5leHRDaGFuZ2UgPT0gcG9zKSB7IC8vIFVwZGF0ZSBjdXJyZW50IG1hcmtlciBzZXRcbiAgICAgICAgc3BhblN0eWxlID0gc3BhbkVuZFN0eWxlID0gc3BhblN0YXJ0U3R5bGUgPSBjc3MgPSBcIlwiO1xuICAgICAgICBhdHRyaWJ1dGVzID0gbnVsbDtcbiAgICAgICAgY29sbGFwc2VkID0gbnVsbDsgbmV4dENoYW5nZSA9IEluZmluaXR5O1xuICAgICAgICB2YXIgZm91bmRCb29rbWFya3MgPSBbXSwgZW5kU3R5bGVzID0gKHZvaWQgMCk7XG4gICAgICAgIGZvciAodmFyIGogPSAwOyBqIDwgc3BhbnMubGVuZ3RoOyArK2opIHtcbiAgICAgICAgICB2YXIgc3AgPSBzcGFuc1tqXSwgbSA9IHNwLm1hcmtlcjtcbiAgICAgICAgICBpZiAobS50eXBlID09IFwiYm9va21hcmtcIiAmJiBzcC5mcm9tID09IHBvcyAmJiBtLndpZGdldE5vZGUpIHtcbiAgICAgICAgICAgIGZvdW5kQm9va21hcmtzLnB1c2gobSk7XG4gICAgICAgICAgfSBlbHNlIGlmIChzcC5mcm9tIDw9IHBvcyAmJiAoc3AudG8gPT0gbnVsbCB8fCBzcC50byA+IHBvcyB8fCBtLmNvbGxhcHNlZCAmJiBzcC50byA9PSBwb3MgJiYgc3AuZnJvbSA9PSBwb3MpKSB7XG4gICAgICAgICAgICBpZiAoc3AudG8gIT0gbnVsbCAmJiBzcC50byAhPSBwb3MgJiYgbmV4dENoYW5nZSA+IHNwLnRvKSB7XG4gICAgICAgICAgICAgIG5leHRDaGFuZ2UgPSBzcC50bztcbiAgICAgICAgICAgICAgc3BhbkVuZFN0eWxlID0gXCJcIjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChtLmNsYXNzTmFtZSkgeyBzcGFuU3R5bGUgKz0gXCIgXCIgKyBtLmNsYXNzTmFtZTsgfVxuICAgICAgICAgICAgaWYgKG0uY3NzKSB7IGNzcyA9IChjc3MgPyBjc3MgKyBcIjtcIiA6IFwiXCIpICsgbS5jc3M7IH1cbiAgICAgICAgICAgIGlmIChtLnN0YXJ0U3R5bGUgJiYgc3AuZnJvbSA9PSBwb3MpIHsgc3BhblN0YXJ0U3R5bGUgKz0gXCIgXCIgKyBtLnN0YXJ0U3R5bGU7IH1cbiAgICAgICAgICAgIGlmIChtLmVuZFN0eWxlICYmIHNwLnRvID09IG5leHRDaGFuZ2UpIHsgKGVuZFN0eWxlcyB8fCAoZW5kU3R5bGVzID0gW10pKS5wdXNoKG0uZW5kU3R5bGUsIHNwLnRvKTsgfVxuICAgICAgICAgICAgLy8gc3VwcG9ydCBmb3IgdGhlIG9sZCB0aXRsZSBwcm9wZXJ0eVxuICAgICAgICAgICAgLy8gaHR0cHM6Ly9naXRodWIuY29tL2NvZGVtaXJyb3IvQ29kZU1pcnJvci9wdWxsLzU2NzNcbiAgICAgICAgICAgIGlmIChtLnRpdGxlKSB7IChhdHRyaWJ1dGVzIHx8IChhdHRyaWJ1dGVzID0ge30pKS50aXRsZSA9IG0udGl0bGU7IH1cbiAgICAgICAgICAgIGlmIChtLmF0dHJpYnV0ZXMpIHtcbiAgICAgICAgICAgICAgZm9yICh2YXIgYXR0ciBpbiBtLmF0dHJpYnV0ZXMpXG4gICAgICAgICAgICAgICAgeyAoYXR0cmlidXRlcyB8fCAoYXR0cmlidXRlcyA9IHt9KSlbYXR0cl0gPSBtLmF0dHJpYnV0ZXNbYXR0cl07IH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChtLmNvbGxhcHNlZCAmJiAoIWNvbGxhcHNlZCB8fCBjb21wYXJlQ29sbGFwc2VkTWFya2Vycyhjb2xsYXBzZWQubWFya2VyLCBtKSA8IDApKVxuICAgICAgICAgICAgICB7IGNvbGxhcHNlZCA9IHNwOyB9XG4gICAgICAgICAgfSBlbHNlIGlmIChzcC5mcm9tID4gcG9zICYmIG5leHRDaGFuZ2UgPiBzcC5mcm9tKSB7XG4gICAgICAgICAgICBuZXh0Q2hhbmdlID0gc3AuZnJvbTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGVuZFN0eWxlcykgeyBmb3IgKHZhciBqJDEgPSAwOyBqJDEgPCBlbmRTdHlsZXMubGVuZ3RoOyBqJDEgKz0gMilcbiAgICAgICAgICB7IGlmIChlbmRTdHlsZXNbaiQxICsgMV0gPT0gbmV4dENoYW5nZSkgeyBzcGFuRW5kU3R5bGUgKz0gXCIgXCIgKyBlbmRTdHlsZXNbaiQxXTsgfSB9IH1cblxuICAgICAgICBpZiAoIWNvbGxhcHNlZCB8fCBjb2xsYXBzZWQuZnJvbSA9PSBwb3MpIHsgZm9yICh2YXIgaiQyID0gMDsgaiQyIDwgZm91bmRCb29rbWFya3MubGVuZ3RoOyArK2okMilcbiAgICAgICAgICB7IGJ1aWxkQ29sbGFwc2VkU3BhbihidWlsZGVyLCAwLCBmb3VuZEJvb2ttYXJrc1tqJDJdKTsgfSB9XG4gICAgICAgIGlmIChjb2xsYXBzZWQgJiYgKGNvbGxhcHNlZC5mcm9tIHx8IDApID09IHBvcykge1xuICAgICAgICAgIGJ1aWxkQ29sbGFwc2VkU3BhbihidWlsZGVyLCAoY29sbGFwc2VkLnRvID09IG51bGwgPyBsZW4gKyAxIDogY29sbGFwc2VkLnRvKSAtIHBvcyxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY29sbGFwc2VkLm1hcmtlciwgY29sbGFwc2VkLmZyb20gPT0gbnVsbCk7XG4gICAgICAgICAgaWYgKGNvbGxhcHNlZC50byA9PSBudWxsKSB7IHJldHVybiB9XG4gICAgICAgICAgaWYgKGNvbGxhcHNlZC50byA9PSBwb3MpIHsgY29sbGFwc2VkID0gZmFsc2U7IH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgaWYgKHBvcyA+PSBsZW4pIHsgYnJlYWsgfVxuXG4gICAgICB2YXIgdXB0byA9IE1hdGgubWluKGxlbiwgbmV4dENoYW5nZSk7XG4gICAgICB3aGlsZSAodHJ1ZSkge1xuICAgICAgICBpZiAodGV4dCkge1xuICAgICAgICAgIHZhciBlbmQgPSBwb3MgKyB0ZXh0Lmxlbmd0aDtcbiAgICAgICAgICBpZiAoIWNvbGxhcHNlZCkge1xuICAgICAgICAgICAgdmFyIHRva2VuVGV4dCA9IGVuZCA+IHVwdG8gPyB0ZXh0LnNsaWNlKDAsIHVwdG8gLSBwb3MpIDogdGV4dDtcbiAgICAgICAgICAgIGJ1aWxkZXIuYWRkVG9rZW4oYnVpbGRlciwgdG9rZW5UZXh0LCBzdHlsZSA/IHN0eWxlICsgc3BhblN0eWxlIDogc3BhblN0eWxlLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICBzcGFuU3RhcnRTdHlsZSwgcG9zICsgdG9rZW5UZXh0Lmxlbmd0aCA9PSBuZXh0Q2hhbmdlID8gc3BhbkVuZFN0eWxlIDogXCJcIiwgY3NzLCBhdHRyaWJ1dGVzKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKGVuZCA+PSB1cHRvKSB7dGV4dCA9IHRleHQuc2xpY2UodXB0byAtIHBvcyk7IHBvcyA9IHVwdG87IGJyZWFrfVxuICAgICAgICAgIHBvcyA9IGVuZDtcbiAgICAgICAgICBzcGFuU3RhcnRTdHlsZSA9IFwiXCI7XG4gICAgICAgIH1cbiAgICAgICAgdGV4dCA9IGFsbFRleHQuc2xpY2UoYXQsIGF0ID0gc3R5bGVzW2krK10pO1xuICAgICAgICBzdHlsZSA9IGludGVycHJldFRva2VuU3R5bGUoc3R5bGVzW2krK10sIGJ1aWxkZXIuY20ub3B0aW9ucyk7XG4gICAgICB9XG4gICAgfVxuICB9XG5cblxuICAvLyBUaGVzZSBvYmplY3RzIGFyZSB1c2VkIHRvIHJlcHJlc2VudCB0aGUgdmlzaWJsZSAoY3VycmVudGx5IGRyYXduKVxuICAvLyBwYXJ0IG9mIHRoZSBkb2N1bWVudC4gQSBMaW5lVmlldyBtYXkgY29ycmVzcG9uZCB0byBtdWx0aXBsZVxuICAvLyBsb2dpY2FsIGxpbmVzLCBpZiB0aG9zZSBhcmUgY29ubmVjdGVkIGJ5IGNvbGxhcHNlZCByYW5nZXMuXG4gIGZ1bmN0aW9uIExpbmVWaWV3KGRvYywgbGluZSwgbGluZU4pIHtcbiAgICAvLyBUaGUgc3RhcnRpbmcgbGluZVxuICAgIHRoaXMubGluZSA9IGxpbmU7XG4gICAgLy8gQ29udGludWluZyBsaW5lcywgaWYgYW55XG4gICAgdGhpcy5yZXN0ID0gdmlzdWFsTGluZUNvbnRpbnVlZChsaW5lKTtcbiAgICAvLyBOdW1iZXIgb2YgbG9naWNhbCBsaW5lcyBpbiB0aGlzIHZpc3VhbCBsaW5lXG4gICAgdGhpcy5zaXplID0gdGhpcy5yZXN0ID8gbGluZU5vKGxzdCh0aGlzLnJlc3QpKSAtIGxpbmVOICsgMSA6IDE7XG4gICAgdGhpcy5ub2RlID0gdGhpcy50ZXh0ID0gbnVsbDtcbiAgICB0aGlzLmhpZGRlbiA9IGxpbmVJc0hpZGRlbihkb2MsIGxpbmUpO1xuICB9XG5cbiAgLy8gQ3JlYXRlIGEgcmFuZ2Ugb2YgTGluZVZpZXcgb2JqZWN0cyBmb3IgdGhlIGdpdmVuIGxpbmVzLlxuICBmdW5jdGlvbiBidWlsZFZpZXdBcnJheShjbSwgZnJvbSwgdG8pIHtcbiAgICB2YXIgYXJyYXkgPSBbXSwgbmV4dFBvcztcbiAgICBmb3IgKHZhciBwb3MgPSBmcm9tOyBwb3MgPCB0bzsgcG9zID0gbmV4dFBvcykge1xuICAgICAgdmFyIHZpZXcgPSBuZXcgTGluZVZpZXcoY20uZG9jLCBnZXRMaW5lKGNtLmRvYywgcG9zKSwgcG9zKTtcbiAgICAgIG5leHRQb3MgPSBwb3MgKyB2aWV3LnNpemU7XG4gICAgICBhcnJheS5wdXNoKHZpZXcpO1xuICAgIH1cbiAgICByZXR1cm4gYXJyYXlcbiAgfVxuXG4gIHZhciBvcGVyYXRpb25Hcm91cCA9IG51bGw7XG5cbiAgZnVuY3Rpb24gcHVzaE9wZXJhdGlvbihvcCkge1xuICAgIGlmIChvcGVyYXRpb25Hcm91cCkge1xuICAgICAgb3BlcmF0aW9uR3JvdXAub3BzLnB1c2gob3ApO1xuICAgIH0gZWxzZSB7XG4gICAgICBvcC5vd25zR3JvdXAgPSBvcGVyYXRpb25Hcm91cCA9IHtcbiAgICAgICAgb3BzOiBbb3BdLFxuICAgICAgICBkZWxheWVkQ2FsbGJhY2tzOiBbXVxuICAgICAgfTtcbiAgICB9XG4gIH1cblxuICBmdW5jdGlvbiBmaXJlQ2FsbGJhY2tzRm9yT3BzKGdyb3VwKSB7XG4gICAgLy8gQ2FsbHMgZGVsYXllZCBjYWxsYmFja3MgYW5kIGN1cnNvckFjdGl2aXR5IGhhbmRsZXJzIHVudGlsIG5vXG4gICAgLy8gbmV3IG9uZXMgYXBwZWFyXG4gICAgdmFyIGNhbGxiYWNrcyA9IGdyb3VwLmRlbGF5ZWRDYWxsYmFja3MsIGkgPSAwO1xuICAgIGRvIHtcbiAgICAgIGZvciAoOyBpIDwgY2FsbGJhY2tzLmxlbmd0aDsgaSsrKVxuICAgICAgICB7IGNhbGxiYWNrc1tpXS5jYWxsKG51bGwpOyB9XG4gICAgICBmb3IgKHZhciBqID0gMDsgaiA8IGdyb3VwLm9wcy5sZW5ndGg7IGorKykge1xuICAgICAgICB2YXIgb3AgPSBncm91cC5vcHNbal07XG4gICAgICAgIGlmIChvcC5jdXJzb3JBY3Rpdml0eUhhbmRsZXJzKVxuICAgICAgICAgIHsgd2hpbGUgKG9wLmN1cnNvckFjdGl2aXR5Q2FsbGVkIDwgb3AuY3Vyc29yQWN0aXZpdHlIYW5kbGVycy5sZW5ndGgpXG4gICAgICAgICAgICB7IG9wLmN1cnNvckFjdGl2aXR5SGFuZGxlcnNbb3AuY3Vyc29yQWN0aXZpdHlDYWxsZWQrK10uY2FsbChudWxsLCBvcC5jbSk7IH0gfVxuICAgICAgfVxuICAgIH0gd2hpbGUgKGkgPCBjYWxsYmFja3MubGVuZ3RoKVxuICB9XG5cbiAgZnVuY3Rpb24gZmluaXNoT3BlcmF0aW9uKG9wLCBlbmRDYikge1xuICAgIHZhciBncm91cCA9IG9wLm93bnNHcm91cDtcbiAgICBpZiAoIWdyb3VwKSB7IHJldHVybiB9XG5cbiAgICB0cnkgeyBmaXJlQ2FsbGJhY2tzRm9yT3BzKGdyb3VwKTsgfVxuICAgIGZpbmFsbHkge1xuICAgICAgb3BlcmF0aW9uR3JvdXAgPSBudWxsO1xuICAgICAgZW5kQ2IoZ3JvdXApO1xuICAgIH1cbiAgfVxuXG4gIHZhciBvcnBoYW5EZWxheWVkQ2FsbGJhY2tzID0gbnVsbDtcblxuICAvLyBPZnRlbiwgd2Ugd2FudCB0byBzaWduYWwgZXZlbnRzIGF0IGEgcG9pbnQgd2hlcmUgd2UgYXJlIGluIHRoZVxuICAvLyBtaWRkbGUgb2Ygc29tZSB3b3JrLCBidXQgZG9uJ3Qgd2FudCB0aGUgaGFuZGxlciB0byBzdGFydCBjYWxsaW5nXG4gIC8vIG90aGVyIG1ldGhvZHMgb24gdGhlIGVkaXRvciwgd2hpY2ggbWlnaHQgYmUgaW4gYW4gaW5jb25zaXN0ZW50XG4gIC8vIHN0YXRlIG9yIHNpbXBseSBub3QgZXhwZWN0IGFueSBvdGhlciBldmVudHMgdG8gaGFwcGVuLlxuICAvLyBzaWduYWxMYXRlciBsb29rcyB3aGV0aGVyIHRoZXJlIGFyZSBhbnkgaGFuZGxlcnMsIGFuZCBzY2hlZHVsZXNcbiAgLy8gdGhlbSB0byBiZSBleGVjdXRlZCB3aGVuIHRoZSBsYXN0IG9wZXJhdGlvbiBlbmRzLCBvciwgaWYgbm9cbiAgLy8gb3BlcmF0aW9uIGlzIGFjdGl2ZSwgd2hlbiBhIHRpbWVvdXQgZmlyZXMuXG4gIGZ1bmN0aW9uIHNpZ25hbExhdGVyKGVtaXR0ZXIsIHR5cGUgLyosIHZhbHVlcy4uLiovKSB7XG4gICAgdmFyIGFyciA9IGdldEhhbmRsZXJzKGVtaXR0ZXIsIHR5cGUpO1xuICAgIGlmICghYXJyLmxlbmd0aCkgeyByZXR1cm4gfVxuICAgIHZhciBhcmdzID0gQXJyYXkucHJvdG90eXBlLnNsaWNlLmNhbGwoYXJndW1lbnRzLCAyKSwgbGlzdDtcbiAgICBpZiAob3BlcmF0aW9uR3JvdXApIHtcbiAgICAgIGxpc3QgPSBvcGVyYXRpb25Hcm91cC5kZWxheWVkQ2FsbGJhY2tzO1xuICAgIH0gZWxzZSBpZiAob3JwaGFuRGVsYXllZENhbGxiYWNrcykge1xuICAgICAgbGlzdCA9IG9ycGhhbkRlbGF5ZWRDYWxsYmFja3M7XG4gICAgfSBlbHNlIHtcbiAgICAgIGxpc3QgPSBvcnBoYW5EZWxheWVkQ2FsbGJhY2tzID0gW107XG4gICAgICBzZXRUaW1lb3V0KGZpcmVPcnBoYW5EZWxheWVkLCAwKTtcbiAgICB9XG4gICAgdmFyIGxvb3AgPSBmdW5jdGlvbiAoIGkgKSB7XG4gICAgICBsaXN0LnB1c2goZnVuY3Rpb24gKCkgeyByZXR1cm4gYXJyW2ldLmFwcGx5KG51bGwsIGFyZ3MpOyB9KTtcbiAgICB9O1xuXG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBhcnIubGVuZ3RoOyArK2kpXG4gICAgICBsb29wKCBpICk7XG4gIH1cblxuICBmdW5jdGlvbiBmaXJlT3JwaGFuRGVsYXllZCgpIHtcbiAgICB2YXIgZGVsYXllZCA9IG9ycGhhbkRlbGF5ZWRDYWxsYmFja3M7XG4gICAgb3JwaGFuRGVsYXllZENhbGxiYWNrcyA9IG51bGw7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBkZWxheWVkLmxlbmd0aDsgKytpKSB7IGRlbGF5ZWRbaV0oKTsgfVxuICB9XG5cbiAgLy8gV2hlbiBhbiBhc3BlY3Qgb2YgYSBsaW5lIGNoYW5nZXMsIGEgc3RyaW5nIGlzIGFkZGVkIHRvXG4gIC8vIGxpbmVWaWV3LmNoYW5nZXMuIFRoaXMgdXBkYXRlcyB0aGUgcmVsZXZhbnQgcGFydCBvZiB0aGUgbGluZSdzXG4gIC8vIERPTSBzdHJ1Y3R1cmUuXG4gIGZ1bmN0aW9uIHVwZGF0ZUxpbmVGb3JDaGFuZ2VzKGNtLCBsaW5lVmlldywgbGluZU4sIGRpbXMpIHtcbiAgICBmb3IgKHZhciBqID0gMDsgaiA8IGxpbmVWaWV3LmNoYW5nZXMubGVuZ3RoOyBqKyspIHtcbiAgICAgIHZhciB0eXBlID0gbGluZVZpZXcuY2hhbmdlc1tqXTtcbiAgICAgIGlmICh0eXBlID09IFwidGV4dFwiKSB7IHVwZGF0ZUxpbmVUZXh0KGNtLCBsaW5lVmlldyk7IH1cbiAgICAgIGVsc2UgaWYgKHR5cGUgPT0gXCJndXR0ZXJcIikgeyB1cGRhdGVMaW5lR3V0dGVyKGNtLCBsaW5lVmlldywgbGluZU4sIGRpbXMpOyB9XG4gICAgICBlbHNlIGlmICh0eXBlID09IFwiY2xhc3NcIikgeyB1cGRhdGVMaW5lQ2xhc3NlcyhjbSwgbGluZVZpZXcpOyB9XG4gICAgICBlbHNlIGlmICh0eXBlID09IFwid2lkZ2V0XCIpIHsgdXBkYXRlTGluZVdpZGdldHMoY20sIGxpbmVWaWV3LCBkaW1zKTsgfVxuICAgIH1cbiAgICBsaW5lVmlldy5jaGFuZ2VzID0gbnVsbDtcbiAgfVxuXG4gIC8vIExpbmVzIHdpdGggZ3V0dGVyIGVsZW1lbnRzLCB3aWRnZXRzIG9yIGEgYmFja2dyb3VuZCBjbGFzcyBuZWVkIHRvXG4gIC8vIGJlIHdyYXBwZWQsIGFuZCBoYXZlIHRoZSBleHRyYSBlbGVtZW50cyBhZGRlZCB0byB0aGUgd3JhcHBlciBkaXZcbiAgZnVuY3Rpb24gZW5zdXJlTGluZVdyYXBwZWQobGluZVZpZXcpIHtcbiAgICBpZiAobGluZVZpZXcubm9kZSA9PSBsaW5lVmlldy50ZXh0KSB7XG4gICAgICBsaW5lVmlldy5ub2RlID0gZWx0KFwiZGl2XCIsIG51bGwsIG51bGwsIFwicG9zaXRpb246IHJlbGF0aXZlXCIpO1xuICAgICAgaWYgKGxpbmVWaWV3LnRleHQucGFyZW50Tm9kZSlcbiAgICAgICAgeyBsaW5lVmlldy50ZXh0LnBhcmVudE5vZGUucmVwbGFjZUNoaWxkKGxpbmVWaWV3Lm5vZGUsIGxpbmVWaWV3LnRleHQpOyB9XG4gICAgICBsaW5lVmlldy5ub2RlLmFwcGVuZENoaWxkKGxpbmVWaWV3LnRleHQpO1xuICAgICAgaWYgKGllICYmIGllX3ZlcnNpb24gPCA4KSB7IGxpbmVWaWV3Lm5vZGUuc3R5bGUuekluZGV4ID0gMjsgfVxuICAgIH1cbiAgICByZXR1cm4gbGluZVZpZXcubm9kZVxuICB9XG5cbiAgZnVuY3Rpb24gdXBkYXRlTGluZUJhY2tncm91bmQoY20sIGxpbmVWaWV3KSB7XG4gICAgdmFyIGNscyA9IGxpbmVWaWV3LmJnQ2xhc3MgPyBsaW5lVmlldy5iZ0NsYXNzICsgXCIgXCIgKyAobGluZVZpZXcubGluZS5iZ0NsYXNzIHx8IFwiXCIpIDogbGluZVZpZXcubGluZS5iZ0NsYXNzO1xuICAgIGlmIChjbHMpIHsgY2xzICs9IFwiIENvZGVNaXJyb3ItbGluZWJhY2tncm91bmRcIjsgfVxuICAgIGlmIChsaW5lVmlldy5iYWNrZ3JvdW5kKSB7XG4gICAgICBpZiAoY2xzKSB7IGxpbmVWaWV3LmJhY2tncm91bmQuY2xhc3NOYW1lID0gY2xzOyB9XG4gICAgICBlbHNlIHsgbGluZVZpZXcuYmFja2dyb3VuZC5wYXJlbnROb2RlLnJlbW92ZUNoaWxkKGxpbmVWaWV3LmJhY2tncm91bmQpOyBsaW5lVmlldy5iYWNrZ3JvdW5kID0gbnVsbDsgfVxuICAgIH0gZWxzZSBpZiAoY2xzKSB7XG4gICAgICB2YXIgd3JhcCA9IGVuc3VyZUxpbmVXcmFwcGVkKGxpbmVWaWV3KTtcbiAgICAgIGxpbmVWaWV3LmJhY2tncm91bmQgPSB3cmFwLmluc2VydEJlZm9yZShlbHQoXCJkaXZcIiwgbnVsbCwgY2xzKSwgd3JhcC5maXJzdENoaWxkKTtcbiAgICAgIGNtLmRpc3BsYXkuaW5wdXQuc2V0VW5lZGl0YWJsZShsaW5lVmlldy5iYWNrZ3JvdW5kKTtcbiAgICB9XG4gIH1cblxuICAvLyBXcmFwcGVyIGFyb3VuZCBidWlsZExpbmVDb250ZW50IHdoaWNoIHdpbGwgcmV1c2UgdGhlIHN0cnVjdHVyZVxuICAvLyBpbiBkaXNwbGF5LmV4dGVybmFsTWVhc3VyZWQgd2hlbiBwb3NzaWJsZS5cbiAgZnVuY3Rpb24gZ2V0TGluZUNvbnRlbnQoY20sIGxpbmVWaWV3KSB7XG4gICAgdmFyIGV4dCA9IGNtLmRpc3BsYXkuZXh0ZXJuYWxNZWFzdXJlZDtcbiAgICBpZiAoZXh0ICYmIGV4dC5saW5lID09IGxpbmVWaWV3LmxpbmUpIHtcbiAgICAgIGNtLmRpc3BsYXkuZXh0ZXJuYWxNZWFzdXJlZCA9IG51bGw7XG4gICAgICBsaW5lVmlldy5tZWFzdXJlID0gZXh0Lm1lYXN1cmU7XG4gICAgICByZXR1cm4gZXh0LmJ1aWx0XG4gICAgfVxuICAgIHJldHVybiBidWlsZExpbmVDb250ZW50KGNtLCBsaW5lVmlldylcbiAgfVxuXG4gIC8vIFJlZHJhdyB0aGUgbGluZSdzIHRleHQuIEludGVyYWN0cyB3aXRoIHRoZSBiYWNrZ3JvdW5kIGFuZCB0ZXh0XG4gIC8vIGNsYXNzZXMgYmVjYXVzZSB0aGUgbW9kZSBtYXkgb3V0cHV0IHRva2VucyB0aGF0IGluZmx1ZW5jZSB0aGVzZVxuICAvLyBjbGFzc2VzLlxuICBmdW5jdGlvbiB1cGRhdGVMaW5lVGV4dChjbSwgbGluZVZpZXcpIHtcbiAgICB2YXIgY2xzID0gbGluZVZpZXcudGV4dC5jbGFzc05hbWU7XG4gICAgdmFyIGJ1aWx0ID0gZ2V0TGluZUNvbnRlbnQoY20sIGxpbmVWaWV3KTtcbiAgICBpZiAobGluZVZpZXcudGV4dCA9PSBsaW5lVmlldy5ub2RlKSB7IGxpbmVWaWV3Lm5vZGUgPSBidWlsdC5wcmU7IH1cbiAgICBsaW5lVmlldy50ZXh0LnBhcmVudE5vZGUucmVwbGFjZUNoaWxkKGJ1aWx0LnByZSwgbGluZVZpZXcudGV4dCk7XG4gICAgbGluZVZpZXcudGV4dCA9IGJ1aWx0LnByZTtcbiAgICBpZiAoYnVpbHQuYmdDbGFzcyAhPSBsaW5lVmlldy5iZ0NsYXNzIHx8IGJ1aWx0LnRleHRDbGFzcyAhPSBsaW5lVmlldy50ZXh0Q2xhc3MpIHtcbiAgICAgIGxpbmVWaWV3LmJnQ2xhc3MgPSBidWlsdC5iZ0NsYXNzO1xuICAgICAgbGluZVZpZXcudGV4dENsYXNzID0gYnVpbHQudGV4dENsYXNzO1xuICAgICAgdXBkYXRlTGluZUNsYXNzZXMoY20sIGxpbmVWaWV3KTtcbiAgICB9IGVsc2UgaWYgKGNscykge1xuICAgICAgbGluZVZpZXcudGV4dC5jbGFzc05hbWUgPSBjbHM7XG4gICAgfVxuICB9XG5cbiAgZnVuY3Rpb24gdXBkYXRlTGluZUNsYXNzZXMoY20sIGxpbmVWaWV3KSB7XG4gICAgdXBkYXRlTGluZUJhY2tncm91bmQoY20sIGxpbmVWaWV3KTtcbiAgICBpZiAobGluZVZpZXcubGluZS53cmFwQ2xhc3MpXG4gICAgICB7IGVuc3VyZUxpbmVXcmFwcGVkKGxpbmVWaWV3KS5jbGFzc05hbWUgPSBsaW5lVmlldy5saW5lLndyYXBDbGFzczsgfVxuICAgIGVsc2UgaWYgKGxpbmVWaWV3Lm5vZGUgIT0gbGluZVZpZXcudGV4dClcbiAgICAgIHsgbGluZVZpZXcubm9kZS5jbGFzc05hbWUgPSBcIlwiOyB9XG4gICAgdmFyIHRleHRDbGFzcyA9IGxpbmVWaWV3LnRleHRDbGFzcyA/IGxpbmVWaWV3LnRleHRDbGFzcyArIFwiIFwiICsgKGxpbmVWaWV3LmxpbmUudGV4dENsYXNzIHx8IFwiXCIpIDogbGluZVZpZXcubGluZS50ZXh0Q2xhc3M7XG4gICAgbGluZVZpZXcudGV4dC5jbGFzc05hbWUgPSB0ZXh0Q2xhc3MgfHwgXCJcIjtcbiAgfVxuXG4gIGZ1bmN0aW9uIHVwZGF0ZUxpbmVHdXR0ZXIoY20sIGxpbmVWaWV3LCBsaW5lTiwgZGltcykge1xuICAgIGlmIChsaW5lVmlldy5ndXR0ZXIpIHtcbiAgICAgIGxpbmVWaWV3Lm5vZGUucmVtb3ZlQ2hpbGQobGluZVZpZXcuZ3V0dGVyKTtcbiAgICAgIGxpbmVWaWV3Lmd1dHRlciA9IG51bGw7XG4gICAgfVxuICAgIGlmIChsaW5lVmlldy5ndXR0ZXJCYWNrZ3JvdW5kKSB7XG4gICAgICBsaW5lVmlldy5ub2RlLnJlbW92ZUNoaWxkKGxpbmVWaWV3Lmd1dHRlckJhY2tncm91bmQpO1xuICAgICAgbGluZVZpZXcuZ3V0dGVyQmFja2dyb3VuZCA9IG51bGw7XG4gICAgfVxuICAgIGlmIChsaW5lVmlldy5saW5lLmd1dHRlckNsYXNzKSB7XG4gICAgICB2YXIgd3JhcCA9IGVuc3VyZUxpbmVXcmFwcGVkKGxpbmVWaWV3KTtcbiAgICAgIGxpbmVWaWV3Lmd1dHRlckJhY2tncm91bmQgPSBlbHQoXCJkaXZcIiwgbnVsbCwgXCJDb2RlTWlycm9yLWd1dHRlci1iYWNrZ3JvdW5kIFwiICsgbGluZVZpZXcubGluZS5ndXR0ZXJDbGFzcyxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKFwibGVmdDogXCIgKyAoY20ub3B0aW9ucy5maXhlZEd1dHRlciA/IGRpbXMuZml4ZWRQb3MgOiAtZGltcy5ndXR0ZXJUb3RhbFdpZHRoKSArIFwicHg7IHdpZHRoOiBcIiArIChkaW1zLmd1dHRlclRvdGFsV2lkdGgpICsgXCJweFwiKSk7XG4gICAgICBjbS5kaXNwbGF5LmlucHV0LnNldFVuZWRpdGFibGUobGluZVZpZXcuZ3V0dGVyQmFja2dyb3VuZCk7XG4gICAgICB3cmFwLmluc2VydEJlZm9yZShsaW5lVmlldy5ndXR0ZXJCYWNrZ3JvdW5kLCBsaW5lVmlldy50ZXh0KTtcbiAgICB9XG4gICAgdmFyIG1hcmtlcnMgPSBsaW5lVmlldy5saW5lLmd1dHRlck1hcmtlcnM7XG4gICAgaWYgKGNtLm9wdGlvbnMubGluZU51bWJlcnMgfHwgbWFya2Vycykge1xuICAgICAgdmFyIHdyYXAkMSA9IGVuc3VyZUxpbmVXcmFwcGVkKGxpbmVWaWV3KTtcbiAgICAgIHZhciBndXR0ZXJXcmFwID0gbGluZVZpZXcuZ3V0dGVyID0gZWx0KFwiZGl2XCIsIG51bGwsIFwiQ29kZU1pcnJvci1ndXR0ZXItd3JhcHBlclwiLCAoXCJsZWZ0OiBcIiArIChjbS5vcHRpb25zLmZpeGVkR3V0dGVyID8gZGltcy5maXhlZFBvcyA6IC1kaW1zLmd1dHRlclRvdGFsV2lkdGgpICsgXCJweFwiKSk7XG4gICAgICBndXR0ZXJXcmFwLnNldEF0dHJpYnV0ZShcImFyaWEtaGlkZGVuXCIsIFwidHJ1ZVwiKTtcbiAgICAgIGNtLmRpc3BsYXkuaW5wdXQuc2V0VW5lZGl0YWJsZShndXR0ZXJXcmFwKTtcbiAgICAgIHdyYXAkMS5pbnNlcnRCZWZvcmUoZ3V0dGVyV3JhcCwgbGluZVZpZXcudGV4dCk7XG4gICAgICBpZiAobGluZVZpZXcubGluZS5ndXR0ZXJDbGFzcylcbiAgICAgICAgeyBndXR0ZXJXcmFwLmNsYXNzTmFtZSArPSBcIiBcIiArIGxpbmVWaWV3LmxpbmUuZ3V0dGVyQ2xhc3M7IH1cbiAgICAgIGlmIChjbS5vcHRpb25zLmxpbmVOdW1iZXJzICYmICghbWFya2VycyB8fCAhbWFya2Vyc1tcIkNvZGVNaXJyb3ItbGluZW51bWJlcnNcIl0pKVxuICAgICAgICB7IGxpbmVWaWV3LmxpbmVOdW1iZXIgPSBndXR0ZXJXcmFwLmFwcGVuZENoaWxkKFxuICAgICAgICAgIGVsdChcImRpdlwiLCBsaW5lTnVtYmVyRm9yKGNtLm9wdGlvbnMsIGxpbmVOKSxcbiAgICAgICAgICAgICAgXCJDb2RlTWlycm9yLWxpbmVudW1iZXIgQ29kZU1pcnJvci1ndXR0ZXItZWx0XCIsXG4gICAgICAgICAgICAgIChcImxlZnQ6IFwiICsgKGRpbXMuZ3V0dGVyTGVmdFtcIkNvZGVNaXJyb3ItbGluZW51bWJlcnNcIl0pICsgXCJweDsgd2lkdGg6IFwiICsgKGNtLmRpc3BsYXkubGluZU51bUlubmVyV2lkdGgpICsgXCJweFwiKSkpOyB9XG4gICAgICBpZiAobWFya2VycykgeyBmb3IgKHZhciBrID0gMDsgayA8IGNtLmRpc3BsYXkuZ3V0dGVyU3BlY3MubGVuZ3RoOyArK2spIHtcbiAgICAgICAgdmFyIGlkID0gY20uZGlzcGxheS5ndXR0ZXJTcGVjc1trXS5jbGFzc05hbWUsIGZvdW5kID0gbWFya2Vycy5oYXNPd25Qcm9wZXJ0eShpZCkgJiYgbWFya2Vyc1tpZF07XG4gICAgICAgIGlmIChmb3VuZClcbiAgICAgICAgICB7IGd1dHRlcldyYXAuYXBwZW5kQ2hpbGQoZWx0KFwiZGl2XCIsIFtmb3VuZF0sIFwiQ29kZU1pcnJvci1ndXR0ZXItZWx0XCIsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKFwibGVmdDogXCIgKyAoZGltcy5ndXR0ZXJMZWZ0W2lkXSkgKyBcInB4OyB3aWR0aDogXCIgKyAoZGltcy5ndXR0ZXJXaWR0aFtpZF0pICsgXCJweFwiKSkpOyB9XG4gICAgICB9IH1cbiAgICB9XG4gIH1cblxuICBmdW5jdGlvbiB1cGRhdGVMaW5lV2lkZ2V0cyhjbSwgbGluZVZpZXcsIGRpbXMpIHtcbiAgICBpZiAobGluZVZpZXcuYWxpZ25hYmxlKSB7IGxpbmVWaWV3LmFsaWduYWJsZSA9IG51bGw7IH1cbiAgICB2YXIgaXNXaWRnZXQgPSBjbGFzc1Rlc3QoXCJDb2RlTWlycm9yLWxpbmV3aWRnZXRcIik7XG4gICAgZm9yICh2YXIgbm9kZSA9IGxpbmVWaWV3Lm5vZGUuZmlyc3RDaGlsZCwgbmV4dCA9ICh2b2lkIDApOyBub2RlOyBub2RlID0gbmV4dCkge1xuICAgICAgbmV4dCA9IG5vZGUubmV4dFNpYmxpbmc7XG4gICAgICBpZiAoaXNXaWRnZXQudGVzdChub2RlLmNsYXNzTmFtZSkpIHsgbGluZVZpZXcubm9kZS5yZW1vdmVDaGlsZChub2RlKTsgfVxuICAgIH1cbiAgICBpbnNlcnRMaW5lV2lkZ2V0cyhjbSwgbGluZVZpZXcsIGRpbXMpO1xuICB9XG5cbiAgLy8gQnVpbGQgYSBsaW5lJ3MgRE9NIHJlcHJlc2VudGF0aW9uIGZyb20gc2NyYXRjaFxuICBmdW5jdGlvbiBidWlsZExpbmVFbGVtZW50KGNtLCBsaW5lVmlldywgbGluZU4sIGRpbXMpIHtcbiAgICB2YXIgYnVpbHQgPSBnZXRMaW5lQ29udGVudChjbSwgbGluZVZpZXcpO1xuICAgIGxpbmVWaWV3LnRleHQgPSBsaW5lVmlldy5ub2RlID0gYnVpbHQucHJlO1xuICAgIGlmIChidWlsdC5iZ0NsYXNzKSB7IGxpbmVWaWV3LmJnQ2xhc3MgPSBidWlsdC5iZ0NsYXNzOyB9XG4gICAgaWYgKGJ1aWx0LnRleHRDbGFzcykgeyBsaW5lVmlldy50ZXh0Q2xhc3MgPSBidWlsdC50ZXh0Q2xhc3M7IH1cblxuICAgIHVwZGF0ZUxpbmVDbGFzc2VzKGNtLCBsaW5lVmlldyk7XG4gICAgdXBkYXRlTGluZUd1dHRlcihjbSwgbGluZVZpZXcsIGxpbmVOLCBkaW1zKTtcbiAgICBpbnNlcnRMaW5lV2lkZ2V0cyhjbSwgbGluZVZpZXcsIGRpbXMpO1xuICAgIHJldHVybiBsaW5lVmlldy5ub2RlXG4gIH1cblxuICAvLyBBIGxpbmVWaWV3IG1heSBjb250YWluIG11bHRpcGxlIGxvZ2ljYWwgbGluZXMgKHdoZW4gbWVyZ2VkIGJ5XG4gIC8vIGNvbGxhcHNlZCBzcGFucykuIFRoZSB3aWRnZXRzIGZvciBhbGwgb2YgdGhlbSBuZWVkIHRvIGJlIGRyYXduLlxuICBmdW5jdGlvbiBpbnNlcnRMaW5lV2lkZ2V0cyhjbSwgbGluZVZpZXcsIGRpbXMpIHtcbiAgICBpbnNlcnRMaW5lV2lkZ2V0c0ZvcihjbSwgbGluZVZpZXcubGluZSwgbGluZVZpZXcsIGRpbXMsIHRydWUpO1xuICAgIGlmIChsaW5lVmlldy5yZXN0KSB7IGZvciAodmFyIGkgPSAwOyBpIDwgbGluZVZpZXcucmVzdC5sZW5ndGg7IGkrKylcbiAgICAgIHsgaW5zZXJ0TGluZVdpZGdldHNGb3IoY20sIGxpbmVWaWV3LnJlc3RbaV0sIGxpbmVWaWV3LCBkaW1zLCBmYWxzZSk7IH0gfVxuICB9XG5cbiAgZnVuY3Rpb24gaW5zZXJ0TGluZVdpZGdldHNGb3IoY20sIGxpbmUsIGxpbmVWaWV3LCBkaW1zLCBhbGxvd0Fib3ZlKSB7XG4gICAgaWYgKCFsaW5lLndpZGdldHMpIHsgcmV0dXJuIH1cbiAgICB2YXIgd3JhcCA9IGVuc3VyZUxpbmVXcmFwcGVkKGxpbmVWaWV3KTtcbiAgICBmb3IgKHZhciBpID0gMCwgd3MgPSBsaW5lLndpZGdldHM7IGkgPCB3cy5sZW5ndGg7ICsraSkge1xuICAgICAgdmFyIHdpZGdldCA9IHdzW2ldLCBub2RlID0gZWx0KFwiZGl2XCIsIFt3aWRnZXQubm9kZV0sIFwiQ29kZU1pcnJvci1saW5ld2lkZ2V0XCIgKyAod2lkZ2V0LmNsYXNzTmFtZSA/IFwiIFwiICsgd2lkZ2V0LmNsYXNzTmFtZSA6IFwiXCIpKTtcbiAgICAgIGlmICghd2lkZ2V0LmhhbmRsZU1vdXNlRXZlbnRzKSB7IG5vZGUuc2V0QXR0cmlidXRlKFwiY20taWdub3JlLWV2ZW50c1wiLCBcInRydWVcIik7IH1cbiAgICAgIHBvc2l0aW9uTGluZVdpZGdldCh3aWRnZXQsIG5vZGUsIGxpbmVWaWV3LCBkaW1zKTtcbiAgICAgIGNtLmRpc3BsYXkuaW5wdXQuc2V0VW5lZGl0YWJsZShub2RlKTtcbiAgICAgIGlmIChhbGxvd0Fib3ZlICYmIHdpZGdldC5hYm92ZSlcbiAgICAgICAgeyB3cmFwLmluc2VydEJlZm9yZShub2RlLCBsaW5lVmlldy5ndXR0ZXIgfHwgbGluZVZpZXcudGV4dCk7IH1cbiAgICAgIGVsc2VcbiAgICAgICAgeyB3cmFwLmFwcGVuZENoaWxkKG5vZGUpOyB9XG4gICAgICBzaWduYWxMYXRlcih3aWRnZXQsIFwicmVkcmF3XCIpO1xuICAgIH1cbiAgfVxuXG4gIGZ1bmN0aW9uIHBvc2l0aW9uTGluZVdpZGdldCh3aWRnZXQsIG5vZGUsIGxpbmVWaWV3LCBkaW1zKSB7XG4gICAgaWYgKHdpZGdldC5ub0hTY3JvbGwpIHtcbiAgKGxpbmVWaWV3LmFsaWduYWJsZSB8fCAobGluZVZpZXcuYWxpZ25hYmxlID0gW10pKS5wdXNoKG5vZGUpO1xuICAgICAgdmFyIHdpZHRoID0gZGltcy53cmFwcGVyV2lkdGg7XG4gICAgICBub2RlLnN0eWxlLmxlZnQgPSBkaW1zLmZpeGVkUG9zICsgXCJweFwiO1xuICAgICAgaWYgKCF3aWRnZXQuY292ZXJHdXR0ZXIpIHtcbiAgICAgICAgd2lkdGggLT0gZGltcy5ndXR0ZXJUb3RhbFdpZHRoO1xuICAgICAgICBub2RlLnN0eWxlLnBhZGRpbmdMZWZ0ID0gZGltcy5ndXR0ZXJUb3RhbFdpZHRoICsgXCJweFwiO1xuICAgICAgfVxuICAgICAgbm9kZS5zdHlsZS53aWR0aCA9IHdpZHRoICsgXCJweFwiO1xuICAgIH1cbiAgICBpZiAod2lkZ2V0LmNvdmVyR3V0dGVyKSB7XG4gICAgICBub2RlLnN0eWxlLnpJbmRleCA9IDU7XG4gICAgICBub2RlLnN0eWxlLnBvc2l0aW9uID0gXCJyZWxhdGl2ZVwiO1xuICAgICAgaWYgKCF3aWRnZXQubm9IU2Nyb2xsKSB7IG5vZGUuc3R5bGUubWFyZ2luTGVmdCA9IC1kaW1zLmd1dHRlclRvdGFsV2lkdGggKyBcInB4XCI7IH1cbiAgICB9XG4gIH1cblxuICBmdW5jdGlvbiB3aWRnZXRIZWlnaHQod2lkZ2V0KSB7XG4gICAgaWYgKHdpZGdldC5oZWlnaHQgIT0gbnVsbCkgeyByZXR1cm4gd2lkZ2V0LmhlaWdodCB9XG4gICAgdmFyIGNtID0gd2lkZ2V0LmRvYy5jbTtcbiAgICBpZiAoIWNtKSB7IHJldHVybiAwIH1cbiAgICBpZiAoIWNvbnRhaW5zKGRvY3VtZW50LmJvZHksIHdpZGdldC5ub2RlKSkge1xuICAgICAgdmFyIHBhcmVudFN0eWxlID0gXCJwb3NpdGlvbjogcmVsYXRpdmU7XCI7XG4gICAgICBpZiAod2lkZ2V0LmNvdmVyR3V0dGVyKVxuICAgICAgICB7IHBhcmVudFN0eWxlICs9IFwibWFyZ2luLWxlZnQ6IC1cIiArIGNtLmRpc3BsYXkuZ3V0dGVycy5vZmZzZXRXaWR0aCArIFwicHg7XCI7IH1cbiAgICAgIGlmICh3aWRnZXQubm9IU2Nyb2xsKVxuICAgICAgICB7IHBhcmVudFN0eWxlICs9IFwid2lkdGg6IFwiICsgY20uZGlzcGxheS53cmFwcGVyLmNsaWVudFdpZHRoICsgXCJweDtcIjsgfVxuICAgICAgcmVtb3ZlQ2hpbGRyZW5BbmRBZGQoY20uZGlzcGxheS5tZWFzdXJlLCBlbHQoXCJkaXZcIiwgW3dpZGdldC5ub2RlXSwgbnVsbCwgcGFyZW50U3R5bGUpKTtcbiAgICB9XG4gICAgcmV0dXJuIHdpZGdldC5oZWlnaHQgPSB3aWRnZXQubm9kZS5wYXJlbnROb2RlLm9mZnNldEhlaWdodFxuICB9XG5cbiAgLy8gUmV0dXJuIHRydWUgd2hlbiB0aGUgZ2l2ZW4gbW91c2UgZXZlbnQgaGFwcGVuZWQgaW4gYSB3aWRnZXRcbiAgZnVuY3Rpb24gZXZlbnRJbldpZGdldChkaXNwbGF5LCBlKSB7XG4gICAgZm9yICh2YXIgbiA9IGVfdGFyZ2V0KGUpOyBuICE9IGRpc3BsYXkud3JhcHBlcjsgbiA9IG4ucGFyZW50Tm9kZSkge1xuICAgICAgaWYgKCFuIHx8IChuLm5vZGVUeXBlID09IDEgJiYgbi5nZXRBdHRyaWJ1dGUoXCJjbS1pZ25vcmUtZXZlbnRzXCIpID09IFwidHJ1ZVwiKSB8fFxuICAgICAgICAgIChuLnBhcmVudE5vZGUgPT0gZGlzcGxheS5zaXplciAmJiBuICE9IGRpc3BsYXkubW92ZXIpKVxuICAgICAgICB7IHJldHVybiB0cnVlIH1cbiAgICB9XG4gIH1cblxuICAvLyBQT1NJVElPTiBNRUFTVVJFTUVOVFxuXG4gIGZ1bmN0aW9uIHBhZGRpbmdUb3AoZGlzcGxheSkge3JldHVybiBkaXNwbGF5LmxpbmVTcGFjZS5vZmZzZXRUb3B9XG4gIGZ1bmN0aW9uIHBhZGRpbmdWZXJ0KGRpc3BsYXkpIHtyZXR1cm4gZGlzcGxheS5tb3Zlci5vZmZzZXRIZWlnaHQgLSBkaXNwbGF5LmxpbmVTcGFjZS5vZmZzZXRIZWlnaHR9XG4gIGZ1bmN0aW9uIHBhZGRpbmdIKGRpc3BsYXkpIHtcbiAgICBpZiAoZGlzcGxheS5jYWNoZWRQYWRkaW5nSCkgeyByZXR1cm4gZGlzcGxheS5jYWNoZWRQYWRkaW5nSCB9XG4gICAgdmFyIGUgPSByZW1vdmVDaGlsZHJlbkFuZEFkZChkaXNwbGF5Lm1lYXN1cmUsIGVsdChcInByZVwiLCBcInhcIiwgXCJDb2RlTWlycm9yLWxpbmUtbGlrZVwiKSk7XG4gICAgdmFyIHN0eWxlID0gd2luZG93LmdldENvbXB1dGVkU3R5bGUgPyB3aW5kb3cuZ2V0Q29tcHV0ZWRTdHlsZShlKSA6IGUuY3VycmVudFN0eWxlO1xuICAgIHZhciBkYXRhID0ge2xlZnQ6IHBhcnNlSW50KHN0eWxlLnBhZGRpbmdMZWZ0KSwgcmlnaHQ6IHBhcnNlSW50KHN0eWxlLnBhZGRpbmdSaWdodCl9O1xuICAgIGlmICghaXNOYU4oZGF0YS5sZWZ0KSAmJiAhaXNOYU4oZGF0YS5yaWdodCkpIHsgZGlzcGxheS5jYWNoZWRQYWRkaW5nSCA9IGRhdGE7IH1cbiAgICByZXR1cm4gZGF0YVxuICB9XG5cbiAgZnVuY3Rpb24gc2Nyb2xsR2FwKGNtKSB7IHJldHVybiBzY3JvbGxlckdhcCAtIGNtLmRpc3BsYXkubmF0aXZlQmFyV2lkdGggfVxuICBmdW5jdGlvbiBkaXNwbGF5V2lkdGgoY20pIHtcbiAgICByZXR1cm4gY20uZGlzcGxheS5zY3JvbGxlci5jbGllbnRXaWR0aCAtIHNjcm9sbEdhcChjbSkgLSBjbS5kaXNwbGF5LmJhcldpZHRoXG4gIH1cbiAgZnVuY3Rpb24gZGlzcGxheUhlaWdodChjbSkge1xuICAgIHJldHVybiBjbS5kaXNwbGF5LnNjcm9sbGVyLmNsaWVudEhlaWdodCAtIHNjcm9sbEdhcChjbSkgLSBjbS5kaXNwbGF5LmJhckhlaWdodFxuICB9XG5cbiAgLy8gRW5zdXJlIHRoZSBsaW5lVmlldy53cmFwcGluZy5oZWlnaHRzIGFycmF5IGlzIHBvcHVsYXRlZC4gVGhpcyBpc1xuICAvLyBhbiBhcnJheSBvZiBib3R0b20gb2Zmc2V0cyBmb3IgdGhlIGxpbmVzIHRoYXQgbWFrZSB1cCBhIGRyYXduXG4gIC8vIGxpbmUuIFdoZW4gbGluZVdyYXBwaW5nIGlzIG9uLCB0aGVyZSBtaWdodCBiZSBtb3JlIHRoYW4gb25lXG4gIC8vIGhlaWdodC5cbiAgZnVuY3Rpb24gZW5zdXJlTGluZUhlaWdodHMoY20sIGxpbmVWaWV3LCByZWN0KSB7XG4gICAgdmFyIHdyYXBwaW5nID0gY20ub3B0aW9ucy5saW5lV3JhcHBpbmc7XG4gICAgdmFyIGN1cldpZHRoID0gd3JhcHBpbmcgJiYgZGlzcGxheVdpZHRoKGNtKTtcbiAgICBpZiAoIWxpbmVWaWV3Lm1lYXN1cmUuaGVpZ2h0cyB8fCB3cmFwcGluZyAmJiBsaW5lVmlldy5tZWFzdXJlLndpZHRoICE9IGN1cldpZHRoKSB7XG4gICAgICB2YXIgaGVpZ2h0cyA9IGxpbmVWaWV3Lm1lYXN1cmUuaGVpZ2h0cyA9IFtdO1xuICAgICAgaWYgKHdyYXBwaW5nKSB7XG4gICAgICAgIGxpbmVWaWV3Lm1lYXN1cmUud2lkdGggPSBjdXJXaWR0aDtcbiAgICAgICAgdmFyIHJlY3RzID0gbGluZVZpZXcudGV4dC5maXJzdENoaWxkLmdldENsaWVudFJlY3RzKCk7XG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgcmVjdHMubGVuZ3RoIC0gMTsgaSsrKSB7XG4gICAgICAgICAgdmFyIGN1ciA9IHJlY3RzW2ldLCBuZXh0ID0gcmVjdHNbaSArIDFdO1xuICAgICAgICAgIGlmIChNYXRoLmFicyhjdXIuYm90dG9tIC0gbmV4dC5ib3R0b20pID4gMilcbiAgICAgICAgICAgIHsgaGVpZ2h0cy5wdXNoKChjdXIuYm90dG9tICsgbmV4dC50b3ApIC8gMiAtIHJlY3QudG9wKTsgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgICBoZWlnaHRzLnB1c2gocmVjdC5ib3R0b20gLSByZWN0LnRvcCk7XG4gICAgfVxuICB9XG5cbiAgLy8gRmluZCBhIGxpbmUgbWFwIChtYXBwaW5nIGNoYXJhY3RlciBvZmZzZXRzIHRvIHRleHQgbm9kZXMpIGFuZCBhXG4gIC8vIG1lYXN1cmVtZW50IGNhY2hlIGZvciB0aGUgZ2l2ZW4gbGluZSBudW1iZXIuIChBIGxpbmUgdmlldyBtaWdodFxuICAvLyBjb250YWluIG11bHRpcGxlIGxpbmVzIHdoZW4gY29sbGFwc2VkIHJhbmdlcyBhcmUgcHJlc2VudC4pXG4gIGZ1bmN0aW9uIG1hcEZyb21MaW5lVmlldyhsaW5lVmlldywgbGluZSwgbGluZU4pIHtcbiAgICBpZiAobGluZVZpZXcubGluZSA9PSBsaW5lKVxuICAgICAgeyByZXR1cm4ge21hcDogbGluZVZpZXcubWVhc3VyZS5tYXAsIGNhY2hlOiBsaW5lVmlldy5tZWFzdXJlLmNhY2hlfSB9XG4gICAgaWYgKGxpbmVWaWV3LnJlc3QpIHtcbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbGluZVZpZXcucmVzdC5sZW5ndGg7IGkrKylcbiAgICAgICAgeyBpZiAobGluZVZpZXcucmVzdFtpXSA9PSBsaW5lKVxuICAgICAgICAgIHsgcmV0dXJuIHttYXA6IGxpbmVWaWV3Lm1lYXN1cmUubWFwc1tpXSwgY2FjaGU6IGxpbmVWaWV3Lm1lYXN1cmUuY2FjaGVzW2ldfSB9IH1cbiAgICAgIGZvciAodmFyIGkkMSA9IDA7IGkkMSA8IGxpbmVWaWV3LnJlc3QubGVuZ3RoOyBpJDErKylcbiAgICAgICAgeyBpZiAobGluZU5vKGxpbmVWaWV3LnJlc3RbaSQxXSkgPiBsaW5lTilcbiAgICAgICAgICB7IHJldHVybiB7bWFwOiBsaW5lVmlldy5tZWFzdXJlLm1hcHNbaSQxXSwgY2FjaGU6IGxpbmVWaWV3Lm1lYXN1cmUuY2FjaGVzW2kkMV0sIGJlZm9yZTogdHJ1ZX0gfSB9XG4gICAgfVxuICB9XG5cbiAgLy8gUmVuZGVyIGEgbGluZSBpbnRvIHRoZSBoaWRkZW4gbm9kZSBkaXNwbGF5LmV4dGVybmFsTWVhc3VyZWQuIFVzZWRcbiAgLy8gd2hlbiBtZWFzdXJlbWVudCBpcyBuZWVkZWQgZm9yIGEgbGluZSB0aGF0J3Mgbm90IGluIHRoZSB2aWV3cG9ydC5cbiAgZnVuY3Rpb24gdXBkYXRlRXh0ZXJuYWxNZWFzdXJlbWVudChjbSwgbGluZSkge1xuICAgIGxpbmUgPSB2aXN1YWxMaW5lKGxpbmUpO1xuICAgIHZhciBsaW5lTiA9IGxpbmVObyhsaW5lKTtcbiAgICB2YXIgdmlldyA9IGNtLmRpc3BsYXkuZXh0ZXJuYWxNZWFzdXJlZCA9IG5ldyBMaW5lVmlldyhjbS5kb2MsIGxpbmUsIGxpbmVOKTtcbiAgICB2aWV3LmxpbmVOID0gbGluZU47XG4gICAgdmFyIGJ1aWx0ID0gdmlldy5idWlsdCA9IGJ1aWxkTGluZUNvbnRlbnQoY20sIHZpZXcpO1xuICAgIHZpZXcudGV4dCA9IGJ1aWx0LnByZTtcbiAgICByZW1vdmVDaGlsZHJlbkFuZEFkZChjbS5kaXNwbGF5LmxpbmVNZWFzdXJlLCBidWlsdC5wcmUpO1xuICAgIHJldHVybiB2aWV3XG4gIH1cblxuICAvLyBHZXQgYSB7dG9wLCBib3R0b20sIGxlZnQsIHJpZ2h0fSBib3ggKGluIGxpbmUtbG9jYWwgY29vcmRpbmF0ZXMpXG4gIC8vIGZvciBhIGdpdmVuIGNoYXJhY3Rlci5cbiAgZnVuY3Rpb24gbWVhc3VyZUNoYXIoY20sIGxpbmUsIGNoLCBiaWFzKSB7XG4gICAgcmV0dXJuIG1lYXN1cmVDaGFyUHJlcGFyZWQoY20sIHByZXBhcmVNZWFzdXJlRm9yTGluZShjbSwgbGluZSksIGNoLCBiaWFzKVxuICB9XG5cbiAgLy8gRmluZCBhIGxpbmUgdmlldyB0aGF0IGNvcnJlc3BvbmRzIHRvIHRoZSBnaXZlbiBsaW5lIG51bWJlci5cbiAgZnVuY3Rpb24gZmluZFZpZXdGb3JMaW5lKGNtLCBsaW5lTikge1xuICAgIGlmIChsaW5lTiA+PSBjbS5kaXNwbGF5LnZpZXdGcm9tICYmIGxpbmVOIDwgY20uZGlzcGxheS52aWV3VG8pXG4gICAgICB7IHJldHVybiBjbS5kaXNwbGF5LnZpZXdbZmluZFZpZXdJbmRleChjbSwgbGluZU4pXSB9XG4gICAgdmFyIGV4dCA9IGNtLmRpc3BsYXkuZXh0ZXJuYWxNZWFzdXJlZDtcbiAgICBpZiAoZXh0ICYmIGxpbmVOID49IGV4dC5saW5lTiAmJiBsaW5lTiA8IGV4dC5saW5lTiArIGV4dC5zaXplKVxuICAgICAgeyByZXR1cm4gZXh0IH1cbiAgfVxuXG4gIC8vIE1lYXN1cmVtZW50IGNhbiBiZSBzcGxpdCBpbiB0d28gc3RlcHMsIHRoZSBzZXQtdXAgd29yayB0aGF0XG4gIC8vIGFwcGxpZXMgdG8gdGhlIHdob2xlIGxpbmUsIGFuZCB0aGUgbWVhc3VyZW1lbnQgb2YgdGhlIGFjdHVhbFxuICAvLyBjaGFyYWN0ZXIuIEZ1bmN0aW9ucyBsaWtlIGNvb3Jkc0NoYXIsIHRoYXQgbmVlZCB0byBkbyBhIGxvdCBvZlxuICAvLyBtZWFzdXJlbWVudHMgaW4gYSByb3csIGNhbiB0aHVzIGVuc3VyZSB0aGF0IHRoZSBzZXQtdXAgd29yayBpc1xuICAvLyBvbmx5IGRvbmUgb25jZS5cbiAgZnVuY3Rpb24gcHJlcGFyZU1lYXN1cmVGb3JMaW5lKGNtLCBsaW5lKSB7XG4gICAgdmFyIGxpbmVOID0gbGluZU5vKGxpbmUpO1xuICAgIHZhciB2aWV3ID0gZmluZFZpZXdGb3JMaW5lKGNtLCBsaW5lTik7XG4gICAgaWYgKHZpZXcgJiYgIXZpZXcudGV4dCkge1xuICAgICAgdmlldyA9IG51bGw7XG4gICAgfSBlbHNlIGlmICh2aWV3ICYmIHZpZXcuY2hhbmdlcykge1xuICAgICAgdXBkYXRlTGluZUZvckNoYW5nZXMoY20sIHZpZXcsIGxpbmVOLCBnZXREaW1lbnNpb25zKGNtKSk7XG4gICAgICBjbS5jdXJPcC5mb3JjZVVwZGF0ZSA9IHRydWU7XG4gICAgfVxuICAgIGlmICghdmlldylcbiAgICAgIHsgdmlldyA9IHVwZGF0ZUV4dGVybmFsTWVhc3VyZW1lbnQoY20sIGxpbmUpOyB9XG5cbiAgICB2YXIgaW5mbyA9IG1hcEZyb21MaW5lVmlldyh2aWV3LCBsaW5lLCBsaW5lTik7XG4gICAgcmV0dXJuIHtcbiAgICAgIGxpbmU6IGxpbmUsIHZpZXc6IHZpZXcsIHJlY3Q6IG51bGwsXG4gICAgICBtYXA6IGluZm8ubWFwLCBjYWNoZTogaW5mby5jYWNoZSwgYmVmb3JlOiBpbmZvLmJlZm9yZSxcbiAgICAgIGhhc0hlaWdodHM6IGZhbHNlXG4gICAgfVxuICB9XG5cbiAgLy8gR2l2ZW4gYSBwcmVwYXJlZCBtZWFzdXJlbWVudCBvYmplY3QsIG1lYXN1cmVzIHRoZSBwb3NpdGlvbiBvZiBhblxuICAvLyBhY3R1YWwgY2hhcmFjdGVyIChvciBmZXRjaGVzIGl0IGZyb20gdGhlIGNhY2hlKS5cbiAgZnVuY3Rpb24gbWVhc3VyZUNoYXJQcmVwYXJlZChjbSwgcHJlcGFyZWQsIGNoLCBiaWFzLCB2YXJIZWlnaHQpIHtcbiAgICBpZiAocHJlcGFyZWQuYmVmb3JlKSB7IGNoID0gLTE7IH1cbiAgICB2YXIga2V5ID0gY2ggKyAoYmlhcyB8fCBcIlwiKSwgZm91bmQ7XG4gICAgaWYgKHByZXBhcmVkLmNhY2hlLmhhc093blByb3BlcnR5KGtleSkpIHtcbiAgICAgIGZvdW5kID0gcHJlcGFyZWQuY2FjaGVba2V5XTtcbiAgICB9IGVsc2Uge1xuICAgICAgaWYgKCFwcmVwYXJlZC5yZWN0KVxuICAgICAgICB7IHByZXBhcmVkLnJlY3QgPSBwcmVwYXJlZC52aWV3LnRleHQuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCk7IH1cbiAgICAgIGlmICghcHJlcGFyZWQuaGFzSGVpZ2h0cykge1xuICAgICAgICBlbnN1cmVMaW5lSGVpZ2h0cyhjbSwgcHJlcGFyZWQudmlldywgcHJlcGFyZWQucmVjdCk7XG4gICAgICAgIHByZXBhcmVkLmhhc0hlaWdodHMgPSB0cnVlO1xuICAgICAgfVxuICAgICAgZm91bmQgPSBtZWFzdXJlQ2hhcklubmVyKGNtLCBwcmVwYXJlZCwgY2gsIGJpYXMpO1xuICAgICAgaWYgKCFmb3VuZC5ib2d1cykgeyBwcmVwYXJlZC5jYWNoZVtrZXldID0gZm91bmQ7IH1cbiAgICB9XG4gICAgcmV0dXJuIHtsZWZ0OiBmb3VuZC5sZWZ0LCByaWdodDogZm91bmQucmlnaHQsXG4gICAgICAgICAgICB0b3A6IHZhckhlaWdodCA/IGZvdW5kLnJ0b3AgOiBmb3VuZC50b3AsXG4gICAgICAgICAgICBib3R0b206IHZhckhlaWdodCA/IGZvdW5kLnJib3R0b20gOiBmb3VuZC5ib3R0b219XG4gIH1cblxuICB2YXIgbnVsbFJlY3QgPSB7bGVmdDogMCwgcmlnaHQ6IDAsIHRvcDogMCwgYm90dG9tOiAwfTtcblxuICBmdW5jdGlvbiBub2RlQW5kT2Zmc2V0SW5MaW5lTWFwKG1hcCwgY2gsIGJpYXMpIHtcbiAgICB2YXIgbm9kZSwgc3RhcnQsIGVuZCwgY29sbGFwc2UsIG1TdGFydCwgbUVuZDtcbiAgICAvLyBGaXJzdCwgc2VhcmNoIHRoZSBsaW5lIG1hcCBmb3IgdGhlIHRleHQgbm9kZSBjb3JyZXNwb25kaW5nIHRvLFxuICAgIC8vIG9yIGNsb3Nlc3QgdG8sIHRoZSB0YXJnZXQgY2hhcmFjdGVyLlxuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbWFwLmxlbmd0aDsgaSArPSAzKSB7XG4gICAgICBtU3RhcnQgPSBtYXBbaV07XG4gICAgICBtRW5kID0gbWFwW2kgKyAxXTtcbiAgICAgIGlmIChjaCA8IG1TdGFydCkge1xuICAgICAgICBzdGFydCA9IDA7IGVuZCA9IDE7XG4gICAgICAgIGNvbGxhcHNlID0gXCJsZWZ0XCI7XG4gICAgICB9IGVsc2UgaWYgKGNoIDwgbUVuZCkge1xuICAgICAgICBzdGFydCA9IGNoIC0gbVN0YXJ0O1xuICAgICAgICBlbmQgPSBzdGFydCArIDE7XG4gICAgICB9IGVsc2UgaWYgKGkgPT0gbWFwLmxlbmd0aCAtIDMgfHwgY2ggPT0gbUVuZCAmJiBtYXBbaSArIDNdID4gY2gpIHtcbiAgICAgICAgZW5kID0gbUVuZCAtIG1TdGFydDtcbiAgICAgICAgc3RhcnQgPSBlbmQgLSAxO1xuICAgICAgICBpZiAoY2ggPj0gbUVuZCkgeyBjb2xsYXBzZSA9IFwicmlnaHRcIjsgfVxuICAgICAgfVxuICAgICAgaWYgKHN0YXJ0ICE9IG51bGwpIHtcbiAgICAgICAgbm9kZSA9IG1hcFtpICsgMl07XG4gICAgICAgIGlmIChtU3RhcnQgPT0gbUVuZCAmJiBiaWFzID09IChub2RlLmluc2VydExlZnQgPyBcImxlZnRcIiA6IFwicmlnaHRcIikpXG4gICAgICAgICAgeyBjb2xsYXBzZSA9IGJpYXM7IH1cbiAgICAgICAgaWYgKGJpYXMgPT0gXCJsZWZ0XCIgJiYgc3RhcnQgPT0gMClcbiAgICAgICAgICB7IHdoaWxlIChpICYmIG1hcFtpIC0gMl0gPT0gbWFwW2kgLSAzXSAmJiBtYXBbaSAtIDFdLmluc2VydExlZnQpIHtcbiAgICAgICAgICAgIG5vZGUgPSBtYXBbKGkgLT0gMykgKyAyXTtcbiAgICAgICAgICAgIGNvbGxhcHNlID0gXCJsZWZ0XCI7XG4gICAgICAgICAgfSB9XG4gICAgICAgIGlmIChiaWFzID09IFwicmlnaHRcIiAmJiBzdGFydCA9PSBtRW5kIC0gbVN0YXJ0KVxuICAgICAgICAgIHsgd2hpbGUgKGkgPCBtYXAubGVuZ3RoIC0gMyAmJiBtYXBbaSArIDNdID09IG1hcFtpICsgNF0gJiYgIW1hcFtpICsgNV0uaW5zZXJ0TGVmdCkge1xuICAgICAgICAgICAgbm9kZSA9IG1hcFsoaSArPSAzKSArIDJdO1xuICAgICAgICAgICAgY29sbGFwc2UgPSBcInJpZ2h0XCI7XG4gICAgICAgICAgfSB9XG4gICAgICAgIGJyZWFrXG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiB7bm9kZTogbm9kZSwgc3RhcnQ6IHN0YXJ0LCBlbmQ6IGVuZCwgY29sbGFwc2U6IGNvbGxhcHNlLCBjb3ZlclN0YXJ0OiBtU3RhcnQsIGNvdmVyRW5kOiBtRW5kfVxuICB9XG5cbiAgZnVuY3Rpb24gZ2V0VXNlZnVsUmVjdChyZWN0cywgYmlhcykge1xuICAgIHZhciByZWN0ID0gbnVsbFJlY3Q7XG4gICAgaWYgKGJpYXMgPT0gXCJsZWZ0XCIpIHsgZm9yICh2YXIgaSA9IDA7IGkgPCByZWN0cy5sZW5ndGg7IGkrKykge1xuICAgICAgaWYgKChyZWN0ID0gcmVjdHNbaV0pLmxlZnQgIT0gcmVjdC5yaWdodCkgeyBicmVhayB9XG4gICAgfSB9IGVsc2UgeyBmb3IgKHZhciBpJDEgPSByZWN0cy5sZW5ndGggLSAxOyBpJDEgPj0gMDsgaSQxLS0pIHtcbiAgICAgIGlmICgocmVjdCA9IHJlY3RzW2kkMV0pLmxlZnQgIT0gcmVjdC5yaWdodCkgeyBicmVhayB9XG4gICAgfSB9XG4gICAgcmV0dXJuIHJlY3RcbiAgfVxuXG4gIGZ1bmN0aW9uIG1lYXN1cmVDaGFySW5uZXIoY20sIHByZXBhcmVkLCBjaCwgYmlhcykge1xuICAgIHZhciBwbGFjZSA9IG5vZGVBbmRPZmZzZXRJbkxpbmVNYXAocHJlcGFyZWQubWFwLCBjaCwgYmlhcyk7XG4gICAgdmFyIG5vZGUgPSBwbGFjZS5ub2RlLCBzdGFydCA9IHBsYWNlLnN0YXJ0LCBlbmQgPSBwbGFjZS5lbmQsIGNvbGxhcHNlID0gcGxhY2UuY29sbGFwc2U7XG5cbiAgICB2YXIgcmVjdDtcbiAgICBpZiAobm9kZS5ub2RlVHlwZSA9PSAzKSB7IC8vIElmIGl0IGlzIGEgdGV4dCBub2RlLCB1c2UgYSByYW5nZSB0byByZXRyaWV2ZSB0aGUgY29vcmRpbmF0ZXMuXG4gICAgICBmb3IgKHZhciBpJDEgPSAwOyBpJDEgPCA0OyBpJDErKykgeyAvLyBSZXRyeSBhIG1heGltdW0gb2YgNCB0aW1lcyB3aGVuIG5vbnNlbnNlIHJlY3RhbmdsZXMgYXJlIHJldHVybmVkXG4gICAgICAgIHdoaWxlIChzdGFydCAmJiBpc0V4dGVuZGluZ0NoYXIocHJlcGFyZWQubGluZS50ZXh0LmNoYXJBdChwbGFjZS5jb3ZlclN0YXJ0ICsgc3RhcnQpKSkgeyAtLXN0YXJ0OyB9XG4gICAgICAgIHdoaWxlIChwbGFjZS5jb3ZlclN0YXJ0ICsgZW5kIDwgcGxhY2UuY292ZXJFbmQgJiYgaXNFeHRlbmRpbmdDaGFyKHByZXBhcmVkLmxpbmUudGV4dC5jaGFyQXQocGxhY2UuY292ZXJTdGFydCArIGVuZCkpKSB7ICsrZW5kOyB9XG4gICAgICAgIGlmIChpZSAmJiBpZV92ZXJzaW9uIDwgOSAmJiBzdGFydCA9PSAwICYmIGVuZCA9PSBwbGFjZS5jb3ZlckVuZCAtIHBsYWNlLmNvdmVyU3RhcnQpXG4gICAgICAgICAgeyByZWN0ID0gbm9kZS5wYXJlbnROb2RlLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpOyB9XG4gICAgICAgIGVsc2VcbiAgICAgICAgICB7IHJlY3QgPSBnZXRVc2VmdWxSZWN0KHJhbmdlKG5vZGUsIHN0YXJ0LCBlbmQpLmdldENsaWVudFJlY3RzKCksIGJpYXMpOyB9XG4gICAgICAgIGlmIChyZWN0LmxlZnQgfHwgcmVjdC5yaWdodCB8fCBzdGFydCA9PSAwKSB7IGJyZWFrIH1cbiAgICAgICAgZW5kID0gc3RhcnQ7XG4gICAgICAgIHN0YXJ0ID0gc3RhcnQgLSAxO1xuICAgICAgICBjb2xsYXBzZSA9IFwicmlnaHRcIjtcbiAgICAgIH1cbiAgICAgIGlmIChpZSAmJiBpZV92ZXJzaW9uIDwgMTEpIHsgcmVjdCA9IG1heWJlVXBkYXRlUmVjdEZvclpvb21pbmcoY20uZGlzcGxheS5tZWFzdXJlLCByZWN0KTsgfVxuICAgIH0gZWxzZSB7IC8vIElmIGl0IGlzIGEgd2lkZ2V0LCBzaW1wbHkgZ2V0IHRoZSBib3ggZm9yIHRoZSB3aG9sZSB3aWRnZXQuXG4gICAgICBpZiAoc3RhcnQgPiAwKSB7IGNvbGxhcHNlID0gYmlhcyA9IFwicmlnaHRcIjsgfVxuICAgICAgdmFyIHJlY3RzO1xuICAgICAgaWYgKGNtLm9wdGlvbnMubGluZVdyYXBwaW5nICYmIChyZWN0cyA9IG5vZGUuZ2V0Q2xpZW50UmVjdHMoKSkubGVuZ3RoID4gMSlcbiAgICAgICAgeyByZWN0ID0gcmVjdHNbYmlhcyA9PSBcInJpZ2h0XCIgPyByZWN0cy5sZW5ndGggLSAxIDogMF07IH1cbiAgICAgIGVsc2VcbiAgICAgICAgeyByZWN0ID0gbm9kZS5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKTsgfVxuICAgIH1cbiAgICBpZiAoaWUgJiYgaWVfdmVyc2lvbiA8IDkgJiYgIXN0YXJ0ICYmICghcmVjdCB8fCAhcmVjdC5sZWZ0ICYmICFyZWN0LnJpZ2h0KSkge1xuICAgICAgdmFyIHJTcGFuID0gbm9kZS5wYXJlbnROb2RlLmdldENsaWVudFJlY3RzKClbMF07XG4gICAgICBpZiAoclNwYW4pXG4gICAgICAgIHsgcmVjdCA9IHtsZWZ0OiByU3Bhbi5sZWZ0LCByaWdodDogclNwYW4ubGVmdCArIGNoYXJXaWR0aChjbS5kaXNwbGF5KSwgdG9wOiByU3Bhbi50b3AsIGJvdHRvbTogclNwYW4uYm90dG9tfTsgfVxuICAgICAgZWxzZVxuICAgICAgICB7IHJlY3QgPSBudWxsUmVjdDsgfVxuICAgIH1cblxuICAgIHZhciBydG9wID0gcmVjdC50b3AgLSBwcmVwYXJlZC5yZWN0LnRvcCwgcmJvdCA9IHJlY3QuYm90dG9tIC0gcHJlcGFyZWQucmVjdC50b3A7XG4gICAgdmFyIG1pZCA9IChydG9wICsgcmJvdCkgLyAyO1xuICAgIHZhciBoZWlnaHRzID0gcHJlcGFyZWQudmlldy5tZWFzdXJlLmhlaWdodHM7XG4gICAgdmFyIGkgPSAwO1xuICAgIGZvciAoOyBpIDwgaGVpZ2h0cy5sZW5ndGggLSAxOyBpKyspXG4gICAgICB7IGlmIChtaWQgPCBoZWlnaHRzW2ldKSB7IGJyZWFrIH0gfVxuICAgIHZhciB0b3AgPSBpID8gaGVpZ2h0c1tpIC0gMV0gOiAwLCBib3QgPSBoZWlnaHRzW2ldO1xuICAgIHZhciByZXN1bHQgPSB7bGVmdDogKGNvbGxhcHNlID09IFwicmlnaHRcIiA/IHJlY3QucmlnaHQgOiByZWN0LmxlZnQpIC0gcHJlcGFyZWQucmVjdC5sZWZ0LFxuICAgICAgICAgICAgICAgICAgcmlnaHQ6IChjb2xsYXBzZSA9PSBcImxlZnRcIiA/IHJlY3QubGVmdCA6IHJlY3QucmlnaHQpIC0gcHJlcGFyZWQucmVjdC5sZWZ0LFxuICAgICAgICAgICAgICAgICAgdG9wOiB0b3AsIGJvdHRvbTogYm90fTtcbiAgICBpZiAoIXJlY3QubGVmdCAmJiAhcmVjdC5yaWdodCkgeyByZXN1bHQuYm9ndXMgPSB0cnVlOyB9XG4gICAgaWYgKCFjbS5vcHRpb25zLnNpbmdsZUN1cnNvckhlaWdodFBlckxpbmUpIHsgcmVzdWx0LnJ0b3AgPSBydG9wOyByZXN1bHQucmJvdHRvbSA9IHJib3Q7IH1cblxuICAgIHJldHVybiByZXN1bHRcbiAgfVxuXG4gIC8vIFdvcmsgYXJvdW5kIHByb2JsZW0gd2l0aCBib3VuZGluZyBjbGllbnQgcmVjdHMgb24gcmFuZ2VzIGJlaW5nXG4gIC8vIHJldHVybmVkIGluY29ycmVjdGx5IHdoZW4gem9vbWVkIG9uIElFMTAgYW5kIGJlbG93LlxuICBmdW5jdGlvbiBtYXliZVVwZGF0ZVJlY3RGb3Jab29taW5nKG1lYXN1cmUsIHJlY3QpIHtcbiAgICBpZiAoIXdpbmRvdy5zY3JlZW4gfHwgc2NyZWVuLmxvZ2ljYWxYRFBJID09IG51bGwgfHxcbiAgICAgICAgc2NyZWVuLmxvZ2ljYWxYRFBJID09IHNjcmVlbi5kZXZpY2VYRFBJIHx8ICFoYXNCYWRab29tZWRSZWN0cyhtZWFzdXJlKSlcbiAgICAgIHsgcmV0dXJuIHJlY3QgfVxuICAgIHZhciBzY2FsZVggPSBzY3JlZW4ubG9naWNhbFhEUEkgLyBzY3JlZW4uZGV2aWNlWERQSTtcbiAgICB2YXIgc2NhbGVZID0gc2NyZWVuLmxvZ2ljYWxZRFBJIC8gc2NyZWVuLmRldmljZVlEUEk7XG4gICAgcmV0dXJuIHtsZWZ0OiByZWN0LmxlZnQgKiBzY2FsZVgsIHJpZ2h0OiByZWN0LnJpZ2h0ICogc2NhbGVYLFxuICAgICAgICAgICAgdG9wOiByZWN0LnRvcCAqIHNjYWxlWSwgYm90dG9tOiByZWN0LmJvdHRvbSAqIHNjYWxlWX1cbiAgfVxuXG4gIGZ1bmN0aW9uIGNsZWFyTGluZU1lYXN1cmVtZW50Q2FjaGVGb3IobGluZVZpZXcpIHtcbiAgICBpZiAobGluZVZpZXcubWVhc3VyZSkge1xuICAgICAgbGluZVZpZXcubWVhc3VyZS5jYWNoZSA9IHt9O1xuICAgICAgbGluZVZpZXcubWVhc3VyZS5oZWlnaHRzID0gbnVsbDtcbiAgICAgIGlmIChsaW5lVmlldy5yZXN0KSB7IGZvciAodmFyIGkgPSAwOyBpIDwgbGluZVZpZXcucmVzdC5sZW5ndGg7IGkrKylcbiAgICAgICAgeyBsaW5lVmlldy5tZWFzdXJlLmNhY2hlc1tpXSA9IHt9OyB9IH1cbiAgICB9XG4gIH1cblxuICBmdW5jdGlvbiBjbGVhckxpbmVNZWFzdXJlbWVudENhY2hlKGNtKSB7XG4gICAgY20uZGlzcGxheS5leHRlcm5hbE1lYXN1cmUgPSBudWxsO1xuICAgIHJlbW92ZUNoaWxkcmVuKGNtLmRpc3BsYXkubGluZU1lYXN1cmUpO1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgY20uZGlzcGxheS52aWV3Lmxlbmd0aDsgaSsrKVxuICAgICAgeyBjbGVhckxpbmVNZWFzdXJlbWVudENhY2hlRm9yKGNtLmRpc3BsYXkudmlld1tpXSk7IH1cbiAgfVxuXG4gIGZ1bmN0aW9uIGNsZWFyQ2FjaGVzKGNtKSB7XG4gICAgY2xlYXJMaW5lTWVhc3VyZW1lbnRDYWNoZShjbSk7XG4gICAgY20uZGlzcGxheS5jYWNoZWRDaGFyV2lkdGggPSBjbS5kaXNwbGF5LmNhY2hlZFRleHRIZWlnaHQgPSBjbS5kaXNwbGF5LmNhY2hlZFBhZGRpbmdIID0gbnVsbDtcbiAgICBpZiAoIWNtLm9wdGlvbnMubGluZVdyYXBwaW5nKSB7IGNtLmRpc3BsYXkubWF4TGluZUNoYW5nZWQgPSB0cnVlOyB9XG4gICAgY20uZGlzcGxheS5saW5lTnVtQ2hhcnMgPSBudWxsO1xuICB9XG5cbiAgZnVuY3Rpb24gcGFnZVNjcm9sbFgoKSB7XG4gICAgLy8gV29yayBhcm91bmQgaHR0cHM6Ly9idWdzLmNocm9taXVtLm9yZy9wL2Nocm9taXVtL2lzc3Vlcy9kZXRhaWw/aWQ9NDg5MjA2XG4gICAgLy8gd2hpY2ggY2F1c2VzIHBhZ2VfT2Zmc2V0IGFuZCBib3VuZGluZyBjbGllbnQgcmVjdHMgdG8gdXNlXG4gICAgLy8gZGlmZmVyZW50IHJlZmVyZW5jZSB2aWV3cG9ydHMgYW5kIGludmFsaWRhdGUgb3VyIGNhbGN1bGF0aW9ucy5cbiAgICBpZiAoY2hyb21lICYmIGFuZHJvaWQpIHsgcmV0dXJuIC0oZG9jdW1lbnQuYm9keS5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKS5sZWZ0IC0gcGFyc2VJbnQoZ2V0Q29tcHV0ZWRTdHlsZShkb2N1bWVudC5ib2R5KS5tYXJnaW5MZWZ0KSkgfVxuICAgIHJldHVybiB3aW5kb3cucGFnZVhPZmZzZXQgfHwgKGRvY3VtZW50LmRvY3VtZW50RWxlbWVudCB8fCBkb2N1bWVudC5ib2R5KS5zY3JvbGxMZWZ0XG4gIH1cbiAgZnVuY3Rpb24gcGFnZVNjcm9sbFkoKSB7XG4gICAgaWYgKGNocm9tZSAmJiBhbmRyb2lkKSB7IHJldHVybiAtKGRvY3VtZW50LmJvZHkuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCkudG9wIC0gcGFyc2VJbnQoZ2V0Q29tcHV0ZWRTdHlsZShkb2N1bWVudC5ib2R5KS5tYXJnaW5Ub3ApKSB9XG4gICAgcmV0dXJuIHdpbmRvdy5wYWdlWU9mZnNldCB8fCAoZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50IHx8IGRvY3VtZW50LmJvZHkpLnNjcm9sbFRvcFxuICB9XG5cbiAgZnVuY3Rpb24gd2lkZ2V0VG9wSGVpZ2h0KGxpbmVPYmopIHtcbiAgICB2YXIgcmVmID0gdmlzdWFsTGluZShsaW5lT2JqKTtcbiAgICB2YXIgd2lkZ2V0cyA9IHJlZi53aWRnZXRzO1xuICAgIHZhciBoZWlnaHQgPSAwO1xuICAgIGlmICh3aWRnZXRzKSB7IGZvciAodmFyIGkgPSAwOyBpIDwgd2lkZ2V0cy5sZW5ndGg7ICsraSkgeyBpZiAod2lkZ2V0c1tpXS5hYm92ZSlcbiAgICAgIHsgaGVpZ2h0ICs9IHdpZGdldEhlaWdodCh3aWRnZXRzW2ldKTsgfSB9IH1cbiAgICByZXR1cm4gaGVpZ2h0XG4gIH1cblxuICAvLyBDb252ZXJ0cyBhIHt0b3AsIGJvdHRvbSwgbGVmdCwgcmlnaHR9IGJveCBmcm9tIGxpbmUtbG9jYWxcbiAgLy8gY29vcmRpbmF0ZXMgaW50byBhbm90aGVyIGNvb3JkaW5hdGUgc3lzdGVtLiBDb250ZXh0IG1heSBiZSBvbmUgb2ZcbiAgLy8gXCJsaW5lXCIsIFwiZGl2XCIgKGRpc3BsYXkubGluZURpdiksIFwibG9jYWxcIi4vbnVsbCAoZWRpdG9yKSwgXCJ3aW5kb3dcIixcbiAgLy8gb3IgXCJwYWdlXCIuXG4gIGZ1bmN0aW9uIGludG9Db29yZFN5c3RlbShjbSwgbGluZU9iaiwgcmVjdCwgY29udGV4dCwgaW5jbHVkZVdpZGdldHMpIHtcbiAgICBpZiAoIWluY2x1ZGVXaWRnZXRzKSB7XG4gICAgICB2YXIgaGVpZ2h0ID0gd2lkZ2V0VG9wSGVpZ2h0KGxpbmVPYmopO1xuICAgICAgcmVjdC50b3AgKz0gaGVpZ2h0OyByZWN0LmJvdHRvbSArPSBoZWlnaHQ7XG4gICAgfVxuICAgIGlmIChjb250ZXh0ID09IFwibGluZVwiKSB7IHJldHVybiByZWN0IH1cbiAgICBpZiAoIWNvbnRleHQpIHsgY29udGV4dCA9IFwibG9jYWxcIjsgfVxuICAgIHZhciB5T2ZmID0gaGVpZ2h0QXRMaW5lKGxpbmVPYmopO1xuICAgIGlmIChjb250ZXh0ID09IFwibG9jYWxcIikgeyB5T2ZmICs9IHBhZGRpbmdUb3AoY20uZGlzcGxheSk7IH1cbiAgICBlbHNlIHsgeU9mZiAtPSBjbS5kaXNwbGF5LnZpZXdPZmZzZXQ7IH1cbiAgICBpZiAoY29udGV4dCA9PSBcInBhZ2VcIiB8fCBjb250ZXh0ID09IFwid2luZG93XCIpIHtcbiAgICAgIHZhciBsT2ZmID0gY20uZGlzcGxheS5saW5lU3BhY2UuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCk7XG4gICAgICB5T2ZmICs9IGxPZmYudG9wICsgKGNvbnRleHQgPT0gXCJ3aW5kb3dcIiA/IDAgOiBwYWdlU2Nyb2xsWSgpKTtcbiAgICAgIHZhciB4T2ZmID0gbE9mZi5sZWZ0ICsgKGNvbnRleHQgPT0gXCJ3aW5kb3dcIiA/IDAgOiBwYWdlU2Nyb2xsWCgpKTtcbiAgICAgIHJlY3QubGVmdCArPSB4T2ZmOyByZWN0LnJpZ2h0ICs9IHhPZmY7XG4gICAgfVxuICAgIHJlY3QudG9wICs9IHlPZmY7IHJlY3QuYm90dG9tICs9IHlPZmY7XG4gICAgcmV0dXJuIHJlY3RcbiAgfVxuXG4gIC8vIENvdmVydHMgYSBib3ggZnJvbSBcImRpdlwiIGNvb3JkcyB0byBhbm90aGVyIGNvb3JkaW5hdGUgc3lzdGVtLlxuICAvLyBDb250ZXh0IG1heSBiZSBcIndpbmRvd1wiLCBcInBhZ2VcIiwgXCJkaXZcIiwgb3IgXCJsb2NhbFwiLi9udWxsLlxuICBmdW5jdGlvbiBmcm9tQ29vcmRTeXN0ZW0oY20sIGNvb3JkcywgY29udGV4dCkge1xuICAgIGlmIChjb250ZXh0ID09IFwiZGl2XCIpIHsgcmV0dXJuIGNvb3JkcyB9XG4gICAgdmFyIGxlZnQgPSBjb29yZHMubGVmdCwgdG9wID0gY29vcmRzLnRvcDtcbiAgICAvLyBGaXJzdCBtb3ZlIGludG8gXCJwYWdlXCIgY29vcmRpbmF0ZSBzeXN0ZW1cbiAgICBpZiAoY29udGV4dCA9PSBcInBhZ2VcIikge1xuICAgICAgbGVmdCAtPSBwYWdlU2Nyb2xsWCgpO1xuICAgICAgdG9wIC09IHBhZ2VTY3JvbGxZKCk7XG4gICAgfSBlbHNlIGlmIChjb250ZXh0ID09IFwibG9jYWxcIiB8fCAhY29udGV4dCkge1xuICAgICAgdmFyIGxvY2FsQm94ID0gY20uZGlzcGxheS5zaXplci5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKTtcbiAgICAgIGxlZnQgKz0gbG9jYWxCb3gubGVmdDtcbiAgICAgIHRvcCArPSBsb2NhbEJveC50b3A7XG4gICAgfVxuXG4gICAgdmFyIGxpbmVTcGFjZUJveCA9IGNtLmRpc3BsYXkubGluZVNwYWNlLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpO1xuICAgIHJldHVybiB7bGVmdDogbGVmdCAtIGxpbmVTcGFjZUJveC5sZWZ0LCB0b3A6IHRvcCAtIGxpbmVTcGFjZUJveC50b3B9XG4gIH1cblxuICBmdW5jdGlvbiBjaGFyQ29vcmRzKGNtLCBwb3MsIGNvbnRleHQsIGxpbmVPYmosIGJpYXMpIHtcbiAgICBpZiAoIWxpbmVPYmopIHsgbGluZU9iaiA9IGdldExpbmUoY20uZG9jLCBwb3MubGluZSk7IH1cbiAgICByZXR1cm4gaW50b0Nvb3JkU3lzdGVtKGNtLCBsaW5lT2JqLCBtZWFzdXJlQ2hhcihjbSwgbGluZU9iaiwgcG9zLmNoLCBiaWFzKSwgY29udGV4dClcbiAgfVxuXG4gIC8vIFJldHVybnMgYSBib3ggZm9yIGEgZ2l2ZW4gY3Vyc29yIHBvc2l0aW9uLCB3aGljaCBtYXkgaGF2ZSBhblxuICAvLyAnb3RoZXInIHByb3BlcnR5IGNvbnRhaW5pbmcgdGhlIHBvc2l0aW9uIG9mIHRoZSBzZWNvbmRhcnkgY3Vyc29yXG4gIC8vIG9uIGEgYmlkaSBib3VuZGFyeS5cbiAgLy8gQSBjdXJzb3IgUG9zKGxpbmUsIGNoYXIsIFwiYmVmb3JlXCIpIGlzIG9uIHRoZSBzYW1lIHZpc3VhbCBsaW5lIGFzIGBjaGFyIC0gMWBcbiAgLy8gYW5kIGFmdGVyIGBjaGFyIC0gMWAgaW4gd3JpdGluZyBvcmRlciBvZiBgY2hhciAtIDFgXG4gIC8vIEEgY3Vyc29yIFBvcyhsaW5lLCBjaGFyLCBcImFmdGVyXCIpIGlzIG9uIHRoZSBzYW1lIHZpc3VhbCBsaW5lIGFzIGBjaGFyYFxuICAvLyBhbmQgYmVmb3JlIGBjaGFyYCBpbiB3cml0aW5nIG9yZGVyIG9mIGBjaGFyYFxuICAvLyBFeGFtcGxlcyAodXBwZXItY2FzZSBsZXR0ZXJzIGFyZSBSVEwsIGxvd2VyLWNhc2UgYXJlIExUUik6XG4gIC8vICAgICBQb3MoMCwgMSwgLi4uKVxuICAvLyAgICAgYmVmb3JlICAgYWZ0ZXJcbiAgLy8gYWIgICAgIGF8YiAgICAgYXxiXG4gIC8vIGFCICAgICBhfEIgICAgIGFCfFxuICAvLyBBYiAgICAgfEFiICAgICBBfGJcbiAgLy8gQUIgICAgIEJ8QSAgICAgQnxBXG4gIC8vIEV2ZXJ5IHBvc2l0aW9uIGFmdGVyIHRoZSBsYXN0IGNoYXJhY3RlciBvbiBhIGxpbmUgaXMgY29uc2lkZXJlZCB0byBzdGlja1xuICAvLyB0byB0aGUgbGFzdCBjaGFyYWN0ZXIgb24gdGhlIGxpbmUuXG4gIGZ1bmN0aW9uIGN1cnNvckNvb3JkcyhjbSwgcG9zLCBjb250ZXh0LCBsaW5lT2JqLCBwcmVwYXJlZE1lYXN1cmUsIHZhckhlaWdodCkge1xuICAgIGxpbmVPYmogPSBsaW5lT2JqIHx8IGdldExpbmUoY20uZG9jLCBwb3MubGluZSk7XG4gICAgaWYgKCFwcmVwYXJlZE1lYXN1cmUpIHsgcHJlcGFyZWRNZWFzdXJlID0gcHJlcGFyZU1lYXN1cmVGb3JMaW5lKGNtLCBsaW5lT2JqKTsgfVxuICAgIGZ1bmN0aW9uIGdldChjaCwgcmlnaHQpIHtcbiAgICAgIHZhciBtID0gbWVhc3VyZUNoYXJQcmVwYXJlZChjbSwgcHJlcGFyZWRNZWFzdXJlLCBjaCwgcmlnaHQgPyBcInJpZ2h0XCIgOiBcImxlZnRcIiwgdmFySGVpZ2h0KTtcbiAgICAgIGlmIChyaWdodCkgeyBtLmxlZnQgPSBtLnJpZ2h0OyB9IGVsc2UgeyBtLnJpZ2h0ID0gbS5sZWZ0OyB9XG4gICAgICByZXR1cm4gaW50b0Nvb3JkU3lzdGVtKGNtLCBsaW5lT2JqLCBtLCBjb250ZXh0KVxuICAgIH1cbiAgICB2YXIgb3JkZXIgPSBnZXRPcmRlcihsaW5lT2JqLCBjbS5kb2MuZGlyZWN0aW9uKSwgY2ggPSBwb3MuY2gsIHN0aWNreSA9IHBvcy5zdGlja3k7XG4gICAgaWYgKGNoID49IGxpbmVPYmoudGV4dC5sZW5ndGgpIHtcbiAgICAgIGNoID0gbGluZU9iai50ZXh0Lmxlbmd0aDtcbiAgICAgIHN0aWNreSA9IFwiYmVmb3JlXCI7XG4gICAgfSBlbHNlIGlmIChjaCA8PSAwKSB7XG4gICAgICBjaCA9IDA7XG4gICAgICBzdGlja3kgPSBcImFmdGVyXCI7XG4gICAgfVxuICAgIGlmICghb3JkZXIpIHsgcmV0dXJuIGdldChzdGlja3kgPT0gXCJiZWZvcmVcIiA/IGNoIC0gMSA6IGNoLCBzdGlja3kgPT0gXCJiZWZvcmVcIikgfVxuXG4gICAgZnVuY3Rpb24gZ2V0QmlkaShjaCwgcGFydFBvcywgaW52ZXJ0KSB7XG4gICAgICB2YXIgcGFydCA9IG9yZGVyW3BhcnRQb3NdLCByaWdodCA9IHBhcnQubGV2ZWwgPT0gMTtcbiAgICAgIHJldHVybiBnZXQoaW52ZXJ0ID8gY2ggLSAxIDogY2gsIHJpZ2h0ICE9IGludmVydClcbiAgICB9XG4gICAgdmFyIHBhcnRQb3MgPSBnZXRCaWRpUGFydEF0KG9yZGVyLCBjaCwgc3RpY2t5KTtcbiAgICB2YXIgb3RoZXIgPSBiaWRpT3RoZXI7XG4gICAgdmFyIHZhbCA9IGdldEJpZGkoY2gsIHBhcnRQb3MsIHN0aWNreSA9PSBcImJlZm9yZVwiKTtcbiAgICBpZiAob3RoZXIgIT0gbnVsbCkgeyB2YWwub3RoZXIgPSBnZXRCaWRpKGNoLCBvdGhlciwgc3RpY2t5ICE9IFwiYmVmb3JlXCIpOyB9XG4gICAgcmV0dXJuIHZhbFxuICB9XG5cbiAgLy8gVXNlZCB0byBjaGVhcGx5IGVzdGltYXRlIHRoZSBjb29yZGluYXRlcyBmb3IgYSBwb3NpdGlvbi4gVXNlZCBmb3JcbiAgLy8gaW50ZXJtZWRpYXRlIHNjcm9sbCB1cGRhdGVzLlxuICBmdW5jdGlvbiBlc3RpbWF0ZUNvb3JkcyhjbSwgcG9zKSB7XG4gICAgdmFyIGxlZnQgPSAwO1xuICAgIHBvcyA9IGNsaXBQb3MoY20uZG9jLCBwb3MpO1xuICAgIGlmICghY20ub3B0aW9ucy5saW5lV3JhcHBpbmcpIHsgbGVmdCA9IGNoYXJXaWR0aChjbS5kaXNwbGF5KSAqIHBvcy5jaDsgfVxuICAgIHZhciBsaW5lT2JqID0gZ2V0TGluZShjbS5kb2MsIHBvcy5saW5lKTtcbiAgICB2YXIgdG9wID0gaGVpZ2h0QXRMaW5lKGxpbmVPYmopICsgcGFkZGluZ1RvcChjbS5kaXNwbGF5KTtcbiAgICByZXR1cm4ge2xlZnQ6IGxlZnQsIHJpZ2h0OiBsZWZ0LCB0b3A6IHRvcCwgYm90dG9tOiB0b3AgKyBsaW5lT2JqLmhlaWdodH1cbiAgfVxuXG4gIC8vIFBvc2l0aW9ucyByZXR1cm5lZCBieSBjb29yZHNDaGFyIGNvbnRhaW4gc29tZSBleHRyYSBpbmZvcm1hdGlvbi5cbiAgLy8geFJlbCBpcyB0aGUgcmVsYXRpdmUgeCBwb3NpdGlvbiBvZiB0aGUgaW5wdXQgY29vcmRpbmF0ZXMgY29tcGFyZWRcbiAgLy8gdG8gdGhlIGZvdW5kIHBvc2l0aW9uIChzbyB4UmVsID4gMCBtZWFucyB0aGUgY29vcmRpbmF0ZXMgYXJlIHRvXG4gIC8vIHRoZSByaWdodCBvZiB0aGUgY2hhcmFjdGVyIHBvc2l0aW9uLCBmb3IgZXhhbXBsZSkuIFdoZW4gb3V0c2lkZVxuICAvLyBpcyB0cnVlLCB0aGF0IG1lYW5zIHRoZSBjb29yZGluYXRlcyBsaWUgb3V0c2lkZSB0aGUgbGluZSdzXG4gIC8vIHZlcnRpY2FsIHJhbmdlLlxuICBmdW5jdGlvbiBQb3NXaXRoSW5mbyhsaW5lLCBjaCwgc3RpY2t5LCBvdXRzaWRlLCB4UmVsKSB7XG4gICAgdmFyIHBvcyA9IFBvcyhsaW5lLCBjaCwgc3RpY2t5KTtcbiAgICBwb3MueFJlbCA9IHhSZWw7XG4gICAgaWYgKG91dHNpZGUpIHsgcG9zLm91dHNpZGUgPSBvdXRzaWRlOyB9XG4gICAgcmV0dXJuIHBvc1xuICB9XG5cbiAgLy8gQ29tcHV0ZSB0aGUgY2hhcmFjdGVyIHBvc2l0aW9uIGNsb3Nlc3QgdG8gdGhlIGdpdmVuIGNvb3JkaW5hdGVzLlxuICAvLyBJbnB1dCBtdXN0IGJlIGxpbmVTcGFjZS1sb2NhbCAoXCJkaXZcIiBjb29yZGluYXRlIHN5c3RlbSkuXG4gIGZ1bmN0aW9uIGNvb3Jkc0NoYXIoY20sIHgsIHkpIHtcbiAgICB2YXIgZG9jID0gY20uZG9jO1xuICAgIHkgKz0gY20uZGlzcGxheS52aWV3T2Zmc2V0O1xuICAgIGlmICh5IDwgMCkgeyByZXR1cm4gUG9zV2l0aEluZm8oZG9jLmZpcnN0LCAwLCBudWxsLCAtMSwgLTEpIH1cbiAgICB2YXIgbGluZU4gPSBsaW5lQXRIZWlnaHQoZG9jLCB5KSwgbGFzdCA9IGRvYy5maXJzdCArIGRvYy5zaXplIC0gMTtcbiAgICBpZiAobGluZU4gPiBsYXN0KVxuICAgICAgeyByZXR1cm4gUG9zV2l0aEluZm8oZG9jLmZpcnN0ICsgZG9jLnNpemUgLSAxLCBnZXRMaW5lKGRvYywgbGFzdCkudGV4dC5sZW5ndGgsIG51bGwsIDEsIDEpIH1cbiAgICBpZiAoeCA8IDApIHsgeCA9IDA7IH1cblxuICAgIHZhciBsaW5lT2JqID0gZ2V0TGluZShkb2MsIGxpbmVOKTtcbiAgICBmb3IgKDs7KSB7XG4gICAgICB2YXIgZm91bmQgPSBjb29yZHNDaGFySW5uZXIoY20sIGxpbmVPYmosIGxpbmVOLCB4LCB5KTtcbiAgICAgIHZhciBjb2xsYXBzZWQgPSBjb2xsYXBzZWRTcGFuQXJvdW5kKGxpbmVPYmosIGZvdW5kLmNoICsgKGZvdW5kLnhSZWwgPiAwIHx8IGZvdW5kLm91dHNpZGUgPiAwID8gMSA6IDApKTtcbiAgICAgIGlmICghY29sbGFwc2VkKSB7IHJldHVybiBmb3VuZCB9XG4gICAgICB2YXIgcmFuZ2VFbmQgPSBjb2xsYXBzZWQuZmluZCgxKTtcbiAgICAgIGlmIChyYW5nZUVuZC5saW5lID09IGxpbmVOKSB7IHJldHVybiByYW5nZUVuZCB9XG4gICAgICBsaW5lT2JqID0gZ2V0TGluZShkb2MsIGxpbmVOID0gcmFuZ2VFbmQubGluZSk7XG4gICAgfVxuICB9XG5cbiAgZnVuY3Rpb24gd3JhcHBlZExpbmVFeHRlbnQoY20sIGxpbmVPYmosIHByZXBhcmVkTWVhc3VyZSwgeSkge1xuICAgIHkgLT0gd2lkZ2V0VG9wSGVpZ2h0KGxpbmVPYmopO1xuICAgIHZhciBlbmQgPSBsaW5lT2JqLnRleHQubGVuZ3RoO1xuICAgIHZhciBiZWdpbiA9IGZpbmRGaXJzdChmdW5jdGlvbiAoY2gpIHsgcmV0dXJuIG1lYXN1cmVDaGFyUHJlcGFyZWQoY20sIHByZXBhcmVkTWVhc3VyZSwgY2ggLSAxKS5ib3R0b20gPD0geTsgfSwgZW5kLCAwKTtcbiAgICBlbmQgPSBmaW5kRmlyc3QoZnVuY3Rpb24gKGNoKSB7IHJldHVybiBtZWFzdXJlQ2hhclByZXBhcmVkKGNtLCBwcmVwYXJlZE1lYXN1cmUsIGNoKS50b3AgPiB5OyB9LCBiZWdpbiwgZW5kKTtcbiAgICByZXR1cm4ge2JlZ2luOiBiZWdpbiwgZW5kOiBlbmR9XG4gIH1cblxuICBmdW5jdGlvbiB3cmFwcGVkTGluZUV4dGVudENoYXIoY20sIGxpbmVPYmosIHByZXBhcmVkTWVhc3VyZSwgdGFyZ2V0KSB7XG4gICAgaWYgKCFwcmVwYXJlZE1lYXN1cmUpIHsgcHJlcGFyZWRNZWFzdXJlID0gcHJlcGFyZU1lYXN1cmVGb3JMaW5lKGNtLCBsaW5lT2JqKTsgfVxuICAgIHZhciB0YXJnZXRUb3AgPSBpbnRvQ29vcmRTeXN0ZW0oY20sIGxpbmVPYmosIG1lYXN1cmVDaGFyUHJlcGFyZWQoY20sIHByZXBhcmVkTWVhc3VyZSwgdGFyZ2V0KSwgXCJsaW5lXCIpLnRvcDtcbiAgICByZXR1cm4gd3JhcHBlZExpbmVFeHRlbnQoY20sIGxpbmVPYmosIHByZXBhcmVkTWVhc3VyZSwgdGFyZ2V0VG9wKVxuICB9XG5cbiAgLy8gUmV0dXJucyB0cnVlIGlmIHRoZSBnaXZlbiBzaWRlIG9mIGEgYm94IGlzIGFmdGVyIHRoZSBnaXZlblxuICAvLyBjb29yZGluYXRlcywgaW4gdG9wLXRvLWJvdHRvbSwgbGVmdC10by1yaWdodCBvcmRlci5cbiAgZnVuY3Rpb24gYm94SXNBZnRlcihib3gsIHgsIHksIGxlZnQpIHtcbiAgICByZXR1cm4gYm94LmJvdHRvbSA8PSB5ID8gZmFsc2UgOiBib3gudG9wID4geSA/IHRydWUgOiAobGVmdCA/IGJveC5sZWZ0IDogYm94LnJpZ2h0KSA+IHhcbiAgfVxuXG4gIGZ1bmN0aW9uIGNvb3Jkc0NoYXJJbm5lcihjbSwgbGluZU9iaiwgbGluZU5vLCB4LCB5KSB7XG4gICAgLy8gTW92ZSB5IGludG8gbGluZS1sb2NhbCBjb29yZGluYXRlIHNwYWNlXG4gICAgeSAtPSBoZWlnaHRBdExpbmUobGluZU9iaik7XG4gICAgdmFyIHByZXBhcmVkTWVhc3VyZSA9IHByZXBhcmVNZWFzdXJlRm9yTGluZShjbSwgbGluZU9iaik7XG4gICAgLy8gV2hlbiBkaXJlY3RseSBjYWxsaW5nIGBtZWFzdXJlQ2hhclByZXBhcmVkYCwgd2UgaGF2ZSB0byBhZGp1c3RcbiAgICAvLyBmb3IgdGhlIHdpZGdldHMgYXQgdGhpcyBsaW5lLlxuICAgIHZhciB3aWRnZXRIZWlnaHQgPSB3aWRnZXRUb3BIZWlnaHQobGluZU9iaik7XG4gICAgdmFyIGJlZ2luID0gMCwgZW5kID0gbGluZU9iai50ZXh0Lmxlbmd0aCwgbHRyID0gdHJ1ZTtcblxuICAgIHZhciBvcmRlciA9IGdldE9yZGVyKGxpbmVPYmosIGNtLmRvYy5kaXJlY3Rpb24pO1xuICAgIC8vIElmIHRoZSBsaW5lIGlzbid0IHBsYWluIGxlZnQtdG8tcmlnaHQgdGV4dCwgZmlyc3QgZmlndXJlIG91dFxuICAgIC8vIHdoaWNoIGJpZGkgc2VjdGlvbiB0aGUgY29vcmRpbmF0ZXMgZmFsbCBpbnRvLlxuICAgIGlmIChvcmRlcikge1xuICAgICAgdmFyIHBhcnQgPSAoY20ub3B0aW9ucy5saW5lV3JhcHBpbmcgPyBjb29yZHNCaWRpUGFydFdyYXBwZWQgOiBjb29yZHNCaWRpUGFydClcbiAgICAgICAgICAgICAgICAgICAoY20sIGxpbmVPYmosIGxpbmVObywgcHJlcGFyZWRNZWFzdXJlLCBvcmRlciwgeCwgeSk7XG4gICAgICBsdHIgPSBwYXJ0LmxldmVsICE9IDE7XG4gICAgICAvLyBUaGUgYXdrd2FyZCAtMSBvZmZzZXRzIGFyZSBuZWVkZWQgYmVjYXVzZSBmaW5kRmlyc3QgKGNhbGxlZFxuICAgICAgLy8gb24gdGhlc2UgYmVsb3cpIHdpbGwgdHJlYXQgaXRzIGZpcnN0IGJvdW5kIGFzIGluY2x1c2l2ZSxcbiAgICAgIC8vIHNlY29uZCBhcyBleGNsdXNpdmUsIGJ1dCB3ZSB3YW50IHRvIGFjdHVhbGx5IGFkZHJlc3MgdGhlXG4gICAgICAvLyBjaGFyYWN0ZXJzIGluIHRoZSBwYXJ0J3MgcmFuZ2VcbiAgICAgIGJlZ2luID0gbHRyID8gcGFydC5mcm9tIDogcGFydC50byAtIDE7XG4gICAgICBlbmQgPSBsdHIgPyBwYXJ0LnRvIDogcGFydC5mcm9tIC0gMTtcbiAgICB9XG5cbiAgICAvLyBBIGJpbmFyeSBzZWFyY2ggdG8gZmluZCB0aGUgZmlyc3QgY2hhcmFjdGVyIHdob3NlIGJvdW5kaW5nIGJveFxuICAgIC8vIHN0YXJ0cyBhZnRlciB0aGUgY29vcmRpbmF0ZXMuIElmIHdlIHJ1biBhY3Jvc3MgYW55IHdob3NlIGJveCB3cmFwXG4gICAgLy8gdGhlIGNvb3JkaW5hdGVzLCBzdG9yZSB0aGF0LlxuICAgIHZhciBjaEFyb3VuZCA9IG51bGwsIGJveEFyb3VuZCA9IG51bGw7XG4gICAgdmFyIGNoID0gZmluZEZpcnN0KGZ1bmN0aW9uIChjaCkge1xuICAgICAgdmFyIGJveCA9IG1lYXN1cmVDaGFyUHJlcGFyZWQoY20sIHByZXBhcmVkTWVhc3VyZSwgY2gpO1xuICAgICAgYm94LnRvcCArPSB3aWRnZXRIZWlnaHQ7IGJveC5ib3R0b20gKz0gd2lkZ2V0SGVpZ2h0O1xuICAgICAgaWYgKCFib3hJc0FmdGVyKGJveCwgeCwgeSwgZmFsc2UpKSB7IHJldHVybiBmYWxzZSB9XG4gICAgICBpZiAoYm94LnRvcCA8PSB5ICYmIGJveC5sZWZ0IDw9IHgpIHtcbiAgICAgICAgY2hBcm91bmQgPSBjaDtcbiAgICAgICAgYm94QXJvdW5kID0gYm94O1xuICAgICAgfVxuICAgICAgcmV0dXJuIHRydWVcbiAgICB9LCBiZWdpbiwgZW5kKTtcblxuICAgIHZhciBiYXNlWCwgc3RpY2t5LCBvdXRzaWRlID0gZmFsc2U7XG4gICAgLy8gSWYgYSBib3ggYXJvdW5kIHRoZSBjb29yZGluYXRlcyB3YXMgZm91bmQsIHVzZSB0aGF0XG4gICAgaWYgKGJveEFyb3VuZCkge1xuICAgICAgLy8gRGlzdGluZ3Vpc2ggY29vcmRpbmF0ZXMgbmVhcmVyIHRvIHRoZSBsZWZ0IG9yIHJpZ2h0IHNpZGUgb2YgdGhlIGJveFxuICAgICAgdmFyIGF0TGVmdCA9IHggLSBib3hBcm91bmQubGVmdCA8IGJveEFyb3VuZC5yaWdodCAtIHgsIGF0U3RhcnQgPSBhdExlZnQgPT0gbHRyO1xuICAgICAgY2ggPSBjaEFyb3VuZCArIChhdFN0YXJ0ID8gMCA6IDEpO1xuICAgICAgc3RpY2t5ID0gYXRTdGFydCA/IFwiYWZ0ZXJcIiA6IFwiYmVmb3JlXCI7XG4gICAgICBiYXNlWCA9IGF0TGVmdCA/IGJveEFyb3VuZC5sZWZ0IDogYm94QXJvdW5kLnJpZ2h0O1xuICAgIH0gZWxzZSB7XG4gICAgICAvLyAoQWRqdXN0IGZvciBleHRlbmRlZCBib3VuZCwgaWYgbmVjZXNzYXJ5LilcbiAgICAgIGlmICghbHRyICYmIChjaCA9PSBlbmQgfHwgY2ggPT0gYmVnaW4pKSB7IGNoKys7IH1cbiAgICAgIC8vIFRvIGRldGVybWluZSB3aGljaCBzaWRlIHRvIGFzc29jaWF0ZSB3aXRoLCBnZXQgdGhlIGJveCB0byB0aGVcbiAgICAgIC8vIGxlZnQgb2YgdGhlIGNoYXJhY3RlciBhbmQgY29tcGFyZSBpdCdzIHZlcnRpY2FsIHBvc2l0aW9uIHRvIHRoZVxuICAgICAgLy8gY29vcmRpbmF0ZXNcbiAgICAgIHN0aWNreSA9IGNoID09IDAgPyBcImFmdGVyXCIgOiBjaCA9PSBsaW5lT2JqLnRleHQubGVuZ3RoID8gXCJiZWZvcmVcIiA6XG4gICAgICAgIChtZWFzdXJlQ2hhclByZXBhcmVkKGNtLCBwcmVwYXJlZE1lYXN1cmUsIGNoIC0gKGx0ciA/IDEgOiAwKSkuYm90dG9tICsgd2lkZ2V0SGVpZ2h0IDw9IHkpID09IGx0ciA/XG4gICAgICAgIFwiYWZ0ZXJcIiA6IFwiYmVmb3JlXCI7XG4gICAgICAvLyBOb3cgZ2V0IGFjY3VyYXRlIGNvb3JkaW5hdGVzIGZvciB0aGlzIHBsYWNlLCBpbiBvcmRlciB0byBnZXQgYVxuICAgICAgLy8gYmFzZSBYIHBvc2l0aW9uXG4gICAgICB2YXIgY29vcmRzID0gY3Vyc29yQ29vcmRzKGNtLCBQb3MobGluZU5vLCBjaCwgc3RpY2t5KSwgXCJsaW5lXCIsIGxpbmVPYmosIHByZXBhcmVkTWVhc3VyZSk7XG4gICAgICBiYXNlWCA9IGNvb3Jkcy5sZWZ0O1xuICAgICAgb3V0c2lkZSA9IHkgPCBjb29yZHMudG9wID8gLTEgOiB5ID49IGNvb3Jkcy5ib3R0b20gPyAxIDogMDtcbiAgICB9XG5cbiAgICBjaCA9IHNraXBFeHRlbmRpbmdDaGFycyhsaW5lT2JqLnRleHQsIGNoLCAxKTtcbiAgICByZXR1cm4gUG9zV2l0aEluZm8obGluZU5vLCBjaCwgc3RpY2t5LCBvdXRzaWRlLCB4IC0gYmFzZVgpXG4gIH1cblxuICBmdW5jdGlvbiBjb29yZHNCaWRpUGFydChjbSwgbGluZU9iaiwgbGluZU5vLCBwcmVwYXJlZE1lYXN1cmUsIG9yZGVyLCB4LCB5KSB7XG4gICAgLy8gQmlkaSBwYXJ0cyBhcmUgc29ydGVkIGxlZnQtdG8tcmlnaHQsIGFuZCBpbiBhIG5vbi1saW5lLXdyYXBwaW5nXG4gICAgLy8gc2l0dWF0aW9uLCB3ZSBjYW4gdGFrZSB0aGlzIG9yZGVyaW5nIHRvIGNvcnJlc3BvbmQgdG8gdGhlIHZpc3VhbFxuICAgIC8vIG9yZGVyaW5nLiBUaGlzIGZpbmRzIHRoZSBmaXJzdCBwYXJ0IHdob3NlIGVuZCBpcyBhZnRlciB0aGUgZ2l2ZW5cbiAgICAvLyBjb29yZGluYXRlcy5cbiAgICB2YXIgaW5kZXggPSBmaW5kRmlyc3QoZnVuY3Rpb24gKGkpIHtcbiAgICAgIHZhciBwYXJ0ID0gb3JkZXJbaV0sIGx0ciA9IHBhcnQubGV2ZWwgIT0gMTtcbiAgICAgIHJldHVybiBib3hJc0FmdGVyKGN1cnNvckNvb3JkcyhjbSwgUG9zKGxpbmVObywgbHRyID8gcGFydC50byA6IHBhcnQuZnJvbSwgbHRyID8gXCJiZWZvcmVcIiA6IFwiYWZ0ZXJcIiksXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgXCJsaW5lXCIsIGxpbmVPYmosIHByZXBhcmVkTWVhc3VyZSksIHgsIHksIHRydWUpXG4gICAgfSwgMCwgb3JkZXIubGVuZ3RoIC0gMSk7XG4gICAgdmFyIHBhcnQgPSBvcmRlcltpbmRleF07XG4gICAgLy8gSWYgdGhpcyBpc24ndCB0aGUgZmlyc3QgcGFydCwgdGhlIHBhcnQncyBzdGFydCBpcyBhbHNvIGFmdGVyXG4gICAgLy8gdGhlIGNvb3JkaW5hdGVzLCBhbmQgdGhlIGNvb3JkaW5hdGVzIGFyZW4ndCBvbiB0aGUgc2FtZSBsaW5lIGFzXG4gICAgLy8gdGhhdCBzdGFydCwgbW92ZSBvbmUgcGFydCBiYWNrLlxuICAgIGlmIChpbmRleCA+IDApIHtcbiAgICAgIHZhciBsdHIgPSBwYXJ0LmxldmVsICE9IDE7XG4gICAgICB2YXIgc3RhcnQgPSBjdXJzb3JDb29yZHMoY20sIFBvcyhsaW5lTm8sIGx0ciA/IHBhcnQuZnJvbSA6IHBhcnQudG8sIGx0ciA/IFwiYWZ0ZXJcIiA6IFwiYmVmb3JlXCIpLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIFwibGluZVwiLCBsaW5lT2JqLCBwcmVwYXJlZE1lYXN1cmUpO1xuICAgICAgaWYgKGJveElzQWZ0ZXIoc3RhcnQsIHgsIHksIHRydWUpICYmIHN0YXJ0LnRvcCA+IHkpXG4gICAgICAgIHsgcGFydCA9IG9yZGVyW2luZGV4IC0gMV07IH1cbiAgICB9XG4gICAgcmV0dXJuIHBhcnRcbiAgfVxuXG4gIGZ1bmN0aW9uIGNvb3Jkc0JpZGlQYXJ0V3JhcHBlZChjbSwgbGluZU9iaiwgX2xpbmVObywgcHJlcGFyZWRNZWFzdXJlLCBvcmRlciwgeCwgeSkge1xuICAgIC8vIEluIGEgd3JhcHBlZCBsaW5lLCBydGwgdGV4dCBvbiB3cmFwcGluZyBib3VuZGFyaWVzIGNhbiBkbyB0aGluZ3NcbiAgICAvLyB0aGF0IGRvbid0IGNvcnJlc3BvbmQgdG8gdGhlIG9yZGVyaW5nIGluIG91ciBgb3JkZXJgIGFycmF5IGF0XG4gICAgLy8gYWxsLCBzbyBhIGJpbmFyeSBzZWFyY2ggZG9lc24ndCB3b3JrLCBhbmQgd2Ugd2FudCB0byByZXR1cm4gYVxuICAgIC8vIHBhcnQgdGhhdCBvbmx5IHNwYW5zIG9uZSBsaW5lIHNvIHRoYXQgdGhlIGJpbmFyeSBzZWFyY2ggaW5cbiAgICAvLyBjb29yZHNDaGFySW5uZXIgaXMgc2FmZS4gQXMgc3VjaCwgd2UgZmlyc3QgZmluZCB0aGUgZXh0ZW50IG9mIHRoZVxuICAgIC8vIHdyYXBwZWQgbGluZSwgYW5kIHRoZW4gZG8gYSBmbGF0IHNlYXJjaCBpbiB3aGljaCB3ZSBkaXNjYXJkIGFueVxuICAgIC8vIHNwYW5zIHRoYXQgYXJlbid0IG9uIHRoZSBsaW5lLlxuICAgIHZhciByZWYgPSB3cmFwcGVkTGluZUV4dGVudChjbSwgbGluZU9iaiwgcHJlcGFyZWRNZWFzdXJlLCB5KTtcbiAgICB2YXIgYmVnaW4gPSByZWYuYmVnaW47XG4gICAgdmFyIGVuZCA9IHJlZi5lbmQ7XG4gICAgaWYgKC9cXHMvLnRlc3QobGluZU9iai50ZXh0LmNoYXJBdChlbmQgLSAxKSkpIHsgZW5kLS07IH1cbiAgICB2YXIgcGFydCA9IG51bGwsIGNsb3Nlc3REaXN0ID0gbnVsbDtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IG9yZGVyLmxlbmd0aDsgaSsrKSB7XG4gICAgICB2YXIgcCA9IG9yZGVyW2ldO1xuICAgICAgaWYgKHAuZnJvbSA+PSBlbmQgfHwgcC50byA8PSBiZWdpbikgeyBjb250aW51ZSB9XG4gICAgICB2YXIgbHRyID0gcC5sZXZlbCAhPSAxO1xuICAgICAgdmFyIGVuZFggPSBtZWFzdXJlQ2hhclByZXBhcmVkKGNtLCBwcmVwYXJlZE1lYXN1cmUsIGx0ciA/IE1hdGgubWluKGVuZCwgcC50bykgLSAxIDogTWF0aC5tYXgoYmVnaW4sIHAuZnJvbSkpLnJpZ2h0O1xuICAgICAgLy8gV2VpZ2ggYWdhaW5zdCBzcGFucyBlbmRpbmcgYmVmb3JlIHRoaXMsIHNvIHRoYXQgdGhleSBhcmUgb25seVxuICAgICAgLy8gcGlja2VkIGlmIG5vdGhpbmcgZW5kcyBhZnRlclxuICAgICAgdmFyIGRpc3QgPSBlbmRYIDwgeCA/IHggLSBlbmRYICsgMWU5IDogZW5kWCAtIHg7XG4gICAgICBpZiAoIXBhcnQgfHwgY2xvc2VzdERpc3QgPiBkaXN0KSB7XG4gICAgICAgIHBhcnQgPSBwO1xuICAgICAgICBjbG9zZXN0RGlzdCA9IGRpc3Q7XG4gICAgICB9XG4gICAgfVxuICAgIGlmICghcGFydCkgeyBwYXJ0ID0gb3JkZXJbb3JkZXIubGVuZ3RoIC0gMV07IH1cbiAgICAvLyBDbGlwIHRoZSBwYXJ0IHRvIHRoZSB3cmFwcGVkIGxpbmUuXG4gICAgaWYgKHBhcnQuZnJvbSA8IGJlZ2luKSB7IHBhcnQgPSB7ZnJvbTogYmVnaW4sIHRvOiBwYXJ0LnRvLCBsZXZlbDogcGFydC5sZXZlbH07IH1cbiAgICBpZiAocGFydC50byA+IGVuZCkgeyBwYXJ0ID0ge2Zyb206IHBhcnQuZnJvbSwgdG86IGVuZCwgbGV2ZWw6IHBhcnQubGV2ZWx9OyB9XG4gICAgcmV0dXJuIHBhcnRcbiAgfVxuXG4gIHZhciBtZWFzdXJlVGV4dDtcbiAgLy8gQ29tcHV0ZSB0aGUgZGVmYXVsdCB0ZXh0IGhlaWdodC5cbiAgZnVuY3Rpb24gdGV4dEhlaWdodChkaXNwbGF5KSB7XG4gICAgaWYgKGRpc3BsYXkuY2FjaGVkVGV4dEhlaWdodCAhPSBudWxsKSB7IHJldHVybiBkaXNwbGF5LmNhY2hlZFRleHRIZWlnaHQgfVxuICAgIGlmIChtZWFzdXJlVGV4dCA9PSBudWxsKSB7XG4gICAgICBtZWFzdXJlVGV4dCA9IGVsdChcInByZVwiLCBudWxsLCBcIkNvZGVNaXJyb3ItbGluZS1saWtlXCIpO1xuICAgICAgLy8gTWVhc3VyZSBhIGJ1bmNoIG9mIGxpbmVzLCBmb3IgYnJvd3NlcnMgdGhhdCBjb21wdXRlXG4gICAgICAvLyBmcmFjdGlvbmFsIGhlaWdodHMuXG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IDQ5OyArK2kpIHtcbiAgICAgICAgbWVhc3VyZVRleHQuYXBwZW5kQ2hpbGQoZG9jdW1lbnQuY3JlYXRlVGV4dE5vZGUoXCJ4XCIpKTtcbiAgICAgICAgbWVhc3VyZVRleHQuYXBwZW5kQ2hpbGQoZWx0KFwiYnJcIikpO1xuICAgICAgfVxuICAgICAgbWVhc3VyZVRleHQuYXBwZW5kQ2hpbGQoZG9jdW1lbnQuY3JlYXRlVGV4dE5vZGUoXCJ4XCIpKTtcbiAgICB9XG4gICAgcmVtb3ZlQ2hpbGRyZW5BbmRBZGQoZGlzcGxheS5tZWFzdXJlLCBtZWFzdXJlVGV4dCk7XG4gICAgdmFyIGhlaWdodCA9IG1lYXN1cmVUZXh0Lm9mZnNldEhlaWdodCAvIDUwO1xuICAgIGlmIChoZWlnaHQgPiAzKSB7IGRpc3BsYXkuY2FjaGVkVGV4dEhlaWdodCA9IGhlaWdodDsgfVxuICAgIHJlbW92ZUNoaWxkcmVuKGRpc3BsYXkubWVhc3VyZSk7XG4gICAgcmV0dXJuIGhlaWdodCB8fCAxXG4gIH1cblxuICAvLyBDb21wdXRlIHRoZSBkZWZhdWx0IGNoYXJhY3RlciB3aWR0aC5cbiAgZnVuY3Rpb24gY2hhcldpZHRoKGRpc3BsYXkpIHtcbiAgICBpZiAoZGlzcGxheS5jYWNoZWRDaGFyV2lkdGggIT0gbnVsbCkgeyByZXR1cm4gZGlzcGxheS5jYWNoZWRDaGFyV2lkdGggfVxuICAgIHZhciBhbmNob3IgPSBlbHQoXCJzcGFuXCIsIFwieHh4eHh4eHh4eFwiKTtcbiAgICB2YXIgcHJlID0gZWx0KFwicHJlXCIsIFthbmNob3JdLCBcIkNvZGVNaXJyb3ItbGluZS1saWtlXCIpO1xuICAgIHJlbW92ZUNoaWxkcmVuQW5kQWRkKGRpc3BsYXkubWVhc3VyZSwgcHJlKTtcbiAgICB2YXIgcmVjdCA9IGFuY2hvci5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKSwgd2lkdGggPSAocmVjdC5yaWdodCAtIHJlY3QubGVmdCkgLyAxMDtcbiAgICBpZiAod2lkdGggPiAyKSB7IGRpc3BsYXkuY2FjaGVkQ2hhcldpZHRoID0gd2lkdGg7IH1cbiAgICByZXR1cm4gd2lkdGggfHwgMTBcbiAgfVxuXG4gIC8vIERvIGEgYnVsay1yZWFkIG9mIHRoZSBET00gcG9zaXRpb25zIGFuZCBzaXplcyBuZWVkZWQgdG8gZHJhdyB0aGVcbiAgLy8gdmlldywgc28gdGhhdCB3ZSBkb24ndCBpbnRlcmxlYXZlIHJlYWRpbmcgYW5kIHdyaXRpbmcgdG8gdGhlIERPTS5cbiAgZnVuY3Rpb24gZ2V0RGltZW5zaW9ucyhjbSkge1xuICAgIHZhciBkID0gY20uZGlzcGxheSwgbGVmdCA9IHt9LCB3aWR0aCA9IHt9O1xuICAgIHZhciBndXR0ZXJMZWZ0ID0gZC5ndXR0ZXJzLmNsaWVudExlZnQ7XG4gICAgZm9yICh2YXIgbiA9IGQuZ3V0dGVycy5maXJzdENoaWxkLCBpID0gMDsgbjsgbiA9IG4ubmV4dFNpYmxpbmcsICsraSkge1xuICAgICAgdmFyIGlkID0gY20uZGlzcGxheS5ndXR0ZXJTcGVjc1tpXS5jbGFzc05hbWU7XG4gICAgICBsZWZ0W2lkXSA9IG4ub2Zmc2V0TGVmdCArIG4uY2xpZW50TGVmdCArIGd1dHRlckxlZnQ7XG4gICAgICB3aWR0aFtpZF0gPSBuLmNsaWVudFdpZHRoO1xuICAgIH1cbiAgICByZXR1cm4ge2ZpeGVkUG9zOiBjb21wZW5zYXRlRm9ySFNjcm9sbChkKSxcbiAgICAgICAgICAgIGd1dHRlclRvdGFsV2lkdGg6IGQuZ3V0dGVycy5vZmZzZXRXaWR0aCxcbiAgICAgICAgICAgIGd1dHRlckxlZnQ6IGxlZnQsXG4gICAgICAgICAgICBndXR0ZXJXaWR0aDogd2lkdGgsXG4gICAgICAgICAgICB3cmFwcGVyV2lkdGg6IGQud3JhcHBlci5jbGllbnRXaWR0aH1cbiAgfVxuXG4gIC8vIENvbXB1dGVzIGRpc3BsYXkuc2Nyb2xsZXIuc2Nyb2xsTGVmdCArIGRpc3BsYXkuZ3V0dGVycy5vZmZzZXRXaWR0aCxcbiAgLy8gYnV0IHVzaW5nIGdldEJvdW5kaW5nQ2xpZW50UmVjdCB0byBnZXQgYSBzdWItcGl4ZWwtYWNjdXJhdGVcbiAgLy8gcmVzdWx0LlxuICBmdW5jdGlvbiBjb21wZW5zYXRlRm9ySFNjcm9sbChkaXNwbGF5KSB7XG4gICAgcmV0dXJuIGRpc3BsYXkuc2Nyb2xsZXIuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCkubGVmdCAtIGRpc3BsYXkuc2l6ZXIuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCkubGVmdFxuICB9XG5cbiAgLy8gUmV0dXJucyBhIGZ1bmN0aW9uIHRoYXQgZXN0aW1hdGVzIHRoZSBoZWlnaHQgb2YgYSBsaW5lLCB0byB1c2UgYXNcbiAgLy8gZmlyc3QgYXBwcm94aW1hdGlvbiB1bnRpbCB0aGUgbGluZSBiZWNvbWVzIHZpc2libGUgKGFuZCBpcyB0aHVzXG4gIC8vIHByb3Blcmx5IG1lYXN1cmFibGUpLlxuICBmdW5jdGlvbiBlc3RpbWF0ZUhlaWdodChjbSkge1xuICAgIHZhciB0aCA9IHRleHRIZWlnaHQoY20uZGlzcGxheSksIHdyYXBwaW5nID0gY20ub3B0aW9ucy5saW5lV3JhcHBpbmc7XG4gICAgdmFyIHBlckxpbmUgPSB3cmFwcGluZyAmJiBNYXRoLm1heCg1LCBjbS5kaXNwbGF5LnNjcm9sbGVyLmNsaWVudFdpZHRoIC8gY2hhcldpZHRoKGNtLmRpc3BsYXkpIC0gMyk7XG4gICAgcmV0dXJuIGZ1bmN0aW9uIChsaW5lKSB7XG4gICAgICBpZiAobGluZUlzSGlkZGVuKGNtLmRvYywgbGluZSkpIHsgcmV0dXJuIDAgfVxuXG4gICAgICB2YXIgd2lkZ2V0c0hlaWdodCA9IDA7XG4gICAgICBpZiAobGluZS53aWRnZXRzKSB7IGZvciAodmFyIGkgPSAwOyBpIDwgbGluZS53aWRnZXRzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIGlmIChsaW5lLndpZGdldHNbaV0uaGVpZ2h0KSB7IHdpZGdldHNIZWlnaHQgKz0gbGluZS53aWRnZXRzW2ldLmhlaWdodDsgfVxuICAgICAgfSB9XG5cbiAgICAgIGlmICh3cmFwcGluZylcbiAgICAgICAgeyByZXR1cm4gd2lkZ2V0c0hlaWdodCArIChNYXRoLmNlaWwobGluZS50ZXh0Lmxlbmd0aCAvIHBlckxpbmUpIHx8IDEpICogdGggfVxuICAgICAgZWxzZVxuICAgICAgICB7IHJldHVybiB3aWRnZXRzSGVpZ2h0ICsgdGggfVxuICAgIH1cbiAgfVxuXG4gIGZ1bmN0aW9uIGVzdGltYXRlTGluZUhlaWdodHMoY20pIHtcbiAgICB2YXIgZG9jID0gY20uZG9jLCBlc3QgPSBlc3RpbWF0ZUhlaWdodChjbSk7XG4gICAgZG9jLml0ZXIoZnVuY3Rpb24gKGxpbmUpIHtcbiAgICAgIHZhciBlc3RIZWlnaHQgPSBlc3QobGluZSk7XG4gICAgICBpZiAoZXN0SGVpZ2h0ICE9IGxpbmUuaGVpZ2h0KSB7IHVwZGF0ZUxpbmVIZWlnaHQobGluZSwgZXN0SGVpZ2h0KTsgfVxuICAgIH0pO1xuICB9XG5cbiAgLy8gR2l2ZW4gYSBtb3VzZSBldmVudCwgZmluZCB0aGUgY29ycmVzcG9uZGluZyBwb3NpdGlvbi4gSWYgbGliZXJhbFxuICAvLyBpcyBmYWxzZSwgaXQgY2hlY2tzIHdoZXRoZXIgYSBndXR0ZXIgb3Igc2Nyb2xsYmFyIHdhcyBjbGlja2VkLFxuICAvLyBhbmQgcmV0dXJucyBudWxsIGlmIGl0IHdhcy4gZm9yUmVjdCBpcyB1c2VkIGJ5IHJlY3Rhbmd1bGFyXG4gIC8vIHNlbGVjdGlvbnMsIGFuZCB0cmllcyB0byBlc3RpbWF0ZSBhIGNoYXJhY3RlciBwb3NpdGlvbiBldmVuIGZvclxuICAvLyBjb29yZGluYXRlcyBiZXlvbmQgdGhlIHJpZ2h0IG9mIHRoZSB0ZXh0LlxuICBmdW5jdGlvbiBwb3NGcm9tTW91c2UoY20sIGUsIGxpYmVyYWwsIGZvclJlY3QpIHtcbiAgICB2YXIgZGlzcGxheSA9IGNtLmRpc3BsYXk7XG4gICAgaWYgKCFsaWJlcmFsICYmIGVfdGFyZ2V0KGUpLmdldEF0dHJpYnV0ZShcImNtLW5vdC1jb250ZW50XCIpID09IFwidHJ1ZVwiKSB7IHJldHVybiBudWxsIH1cblxuICAgIHZhciB4LCB5LCBzcGFjZSA9IGRpc3BsYXkubGluZVNwYWNlLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpO1xuICAgIC8vIEZhaWxzIHVucHJlZGljdGFibHkgb24gSUVbNjddIHdoZW4gbW91c2UgaXMgZHJhZ2dlZCBhcm91bmQgcXVpY2tseS5cbiAgICB0cnkgeyB4ID0gZS5jbGllbnRYIC0gc3BhY2UubGVmdDsgeSA9IGUuY2xpZW50WSAtIHNwYWNlLnRvcDsgfVxuICAgIGNhdGNoIChlJDEpIHsgcmV0dXJuIG51bGwgfVxuICAgIHZhciBjb29yZHMgPSBjb29yZHNDaGFyKGNtLCB4LCB5KSwgbGluZTtcbiAgICBpZiAoZm9yUmVjdCAmJiBjb29yZHMueFJlbCA+IDAgJiYgKGxpbmUgPSBnZXRMaW5lKGNtLmRvYywgY29vcmRzLmxpbmUpLnRleHQpLmxlbmd0aCA9PSBjb29yZHMuY2gpIHtcbiAgICAgIHZhciBjb2xEaWZmID0gY291bnRDb2x1bW4obGluZSwgbGluZS5sZW5ndGgsIGNtLm9wdGlvbnMudGFiU2l6ZSkgLSBsaW5lLmxlbmd0aDtcbiAgICAgIGNvb3JkcyA9IFBvcyhjb29yZHMubGluZSwgTWF0aC5tYXgoMCwgTWF0aC5yb3VuZCgoeCAtIHBhZGRpbmdIKGNtLmRpc3BsYXkpLmxlZnQpIC8gY2hhcldpZHRoKGNtLmRpc3BsYXkpKSAtIGNvbERpZmYpKTtcbiAgICB9XG4gICAgcmV0dXJuIGNvb3Jkc1xuICB9XG5cbiAgLy8gRmluZCB0aGUgdmlldyBlbGVtZW50IGNvcnJlc3BvbmRpbmcgdG8gYSBnaXZlbiBsaW5lLiBSZXR1cm4gbnVsbFxuICAvLyB3aGVuIHRoZSBsaW5lIGlzbid0IHZpc2libGUuXG4gIGZ1bmN0aW9uIGZpbmRWaWV3SW5kZXgoY20sIG4pIHtcbiAgICBpZiAobiA+PSBjbS5kaXNwbGF5LnZpZXdUbykgeyByZXR1cm4gbnVsbCB9XG4gICAgbiAtPSBjbS5kaXNwbGF5LnZpZXdGcm9tO1xuICAgIGlmIChuIDwgMCkgeyByZXR1cm4gbnVsbCB9XG4gICAgdmFyIHZpZXcgPSBjbS5kaXNwbGF5LnZpZXc7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCB2aWV3Lmxlbmd0aDsgaSsrKSB7XG4gICAgICBuIC09IHZpZXdbaV0uc2l6ZTtcbiAgICAgIGlmIChuIDwgMCkgeyByZXR1cm4gaSB9XG4gICAgfVxuICB9XG5cbiAgLy8gVXBkYXRlcyB0aGUgZGlzcGxheS52aWV3IGRhdGEgc3RydWN0dXJlIGZvciBhIGdpdmVuIGNoYW5nZSB0byB0aGVcbiAgLy8gZG9jdW1lbnQuIEZyb20gYW5kIHRvIGFyZSBpbiBwcmUtY2hhbmdlIGNvb3JkaW5hdGVzLiBMZW5kaWZmIGlzXG4gIC8vIHRoZSBhbW91bnQgb2YgbGluZXMgYWRkZWQgb3Igc3VidHJhY3RlZCBieSB0aGUgY2hhbmdlLiBUaGlzIGlzXG4gIC8vIHVzZWQgZm9yIGNoYW5nZXMgdGhhdCBzcGFuIG11bHRpcGxlIGxpbmVzLCBvciBjaGFuZ2UgdGhlIHdheVxuICAvLyBsaW5lcyBhcmUgZGl2aWRlZCBpbnRvIHZpc3VhbCBsaW5lcy4gcmVnTGluZUNoYW5nZSAoYmVsb3cpXG4gIC8vIHJlZ2lzdGVycyBzaW5nbGUtbGluZSBjaGFuZ2VzLlxuICBmdW5jdGlvbiByZWdDaGFuZ2UoY20sIGZyb20sIHRvLCBsZW5kaWZmKSB7XG4gICAgaWYgKGZyb20gPT0gbnVsbCkgeyBmcm9tID0gY20uZG9jLmZpcnN0OyB9XG4gICAgaWYgKHRvID09IG51bGwpIHsgdG8gPSBjbS5kb2MuZmlyc3QgKyBjbS5kb2Muc2l6ZTsgfVxuICAgIGlmICghbGVuZGlmZikgeyBsZW5kaWZmID0gMDsgfVxuXG4gICAgdmFyIGRpc3BsYXkgPSBjbS5kaXNwbGF5O1xuICAgIGlmIChsZW5kaWZmICYmIHRvIDwgZGlzcGxheS52aWV3VG8gJiZcbiAgICAgICAgKGRpc3BsYXkudXBkYXRlTGluZU51bWJlcnMgPT0gbnVsbCB8fCBkaXNwbGF5LnVwZGF0ZUxpbmVOdW1iZXJzID4gZnJvbSkpXG4gICAgICB7IGRpc3BsYXkudXBkYXRlTGluZU51bWJlcnMgPSBmcm9tOyB9XG5cbiAgICBjbS5jdXJPcC52aWV3Q2hhbmdlZCA9IHRydWU7XG5cbiAgICBpZiAoZnJvbSA+PSBkaXNwbGF5LnZpZXdUbykgeyAvLyBDaGFuZ2UgYWZ0ZXJcbiAgICAgIGlmIChzYXdDb2xsYXBzZWRTcGFucyAmJiB2aXN1YWxMaW5lTm8oY20uZG9jLCBmcm9tKSA8IGRpc3BsYXkudmlld1RvKVxuICAgICAgICB7IHJlc2V0VmlldyhjbSk7IH1cbiAgICB9IGVsc2UgaWYgKHRvIDw9IGRpc3BsYXkudmlld0Zyb20pIHsgLy8gQ2hhbmdlIGJlZm9yZVxuICAgICAgaWYgKHNhd0NvbGxhcHNlZFNwYW5zICYmIHZpc3VhbExpbmVFbmRObyhjbS5kb2MsIHRvICsgbGVuZGlmZikgPiBkaXNwbGF5LnZpZXdGcm9tKSB7XG4gICAgICAgIHJlc2V0VmlldyhjbSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBkaXNwbGF5LnZpZXdGcm9tICs9IGxlbmRpZmY7XG4gICAgICAgIGRpc3BsYXkudmlld1RvICs9IGxlbmRpZmY7XG4gICAgICB9XG4gICAgfSBlbHNlIGlmIChmcm9tIDw9IGRpc3BsYXkudmlld0Zyb20gJiYgdG8gPj0gZGlzcGxheS52aWV3VG8pIHsgLy8gRnVsbCBvdmVybGFwXG4gICAgICByZXNldFZpZXcoY20pO1xuICAgIH0gZWxzZSBpZiAoZnJvbSA8PSBkaXNwbGF5LnZpZXdGcm9tKSB7IC8vIFRvcCBvdmVybGFwXG4gICAgICB2YXIgY3V0ID0gdmlld0N1dHRpbmdQb2ludChjbSwgdG8sIHRvICsgbGVuZGlmZiwgMSk7XG4gICAgICBpZiAoY3V0KSB7XG4gICAgICAgIGRpc3BsYXkudmlldyA9IGRpc3BsYXkudmlldy5zbGljZShjdXQuaW5kZXgpO1xuICAgICAgICBkaXNwbGF5LnZpZXdGcm9tID0gY3V0LmxpbmVOO1xuICAgICAgICBkaXNwbGF5LnZpZXdUbyArPSBsZW5kaWZmO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcmVzZXRWaWV3KGNtKTtcbiAgICAgIH1cbiAgICB9IGVsc2UgaWYgKHRvID49IGRpc3BsYXkudmlld1RvKSB7IC8vIEJvdHRvbSBvdmVybGFwXG4gICAgICB2YXIgY3V0JDEgPSB2aWV3Q3V0dGluZ1BvaW50KGNtLCBmcm9tLCBmcm9tLCAtMSk7XG4gICAgICBpZiAoY3V0JDEpIHtcbiAgICAgICAgZGlzcGxheS52aWV3ID0gZGlzcGxheS52aWV3LnNsaWNlKDAsIGN1dCQxLmluZGV4KTtcbiAgICAgICAgZGlzcGxheS52aWV3VG8gPSBjdXQkMS5saW5lTjtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHJlc2V0VmlldyhjbSk7XG4gICAgICB9XG4gICAgfSBlbHNlIHsgLy8gR2FwIGluIHRoZSBtaWRkbGVcbiAgICAgIHZhciBjdXRUb3AgPSB2aWV3Q3V0dGluZ1BvaW50KGNtLCBmcm9tLCBmcm9tLCAtMSk7XG4gICAgICB2YXIgY3V0Qm90ID0gdmlld0N1dHRpbmdQb2ludChjbSwgdG8sIHRvICsgbGVuZGlmZiwgMSk7XG4gICAgICBpZiAoY3V0VG9wICYmIGN1dEJvdCkge1xuICAgICAgICBkaXNwbGF5LnZpZXcgPSBkaXNwbGF5LnZpZXcuc2xpY2UoMCwgY3V0VG9wLmluZGV4KVxuICAgICAgICAgIC5jb25jYXQoYnVpbGRWaWV3QXJyYXkoY20sIGN1dFRvcC5saW5lTiwgY3V0Qm90LmxpbmVOKSlcbiAgICAgICAgICAuY29uY2F0KGRpc3BsYXkudmlldy5zbGljZShjdXRCb3QuaW5kZXgpKTtcbiAgICAgICAgZGlzcGxheS52aWV3VG8gKz0gbGVuZGlmZjtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHJlc2V0VmlldyhjbSk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgdmFyIGV4dCA9IGRpc3BsYXkuZXh0ZXJuYWxNZWFzdXJlZDtcbiAgICBpZiAoZXh0KSB7XG4gICAgICBpZiAodG8gPCBleHQubGluZU4pXG4gICAgICAgIHsgZXh0LmxpbmVOICs9IGxlbmRpZmY7IH1cbiAgICAgIGVsc2UgaWYgKGZyb20gPCBleHQubGluZU4gKyBleHQuc2l6ZSlcbiAgICAgICAgeyBkaXNwbGF5LmV4dGVybmFsTWVhc3VyZWQgPSBudWxsOyB9XG4gICAgfVxuICB9XG5cbiAgLy8gUmVnaXN0ZXIgYSBjaGFuZ2UgdG8gYSBzaW5nbGUgbGluZS4gVHlwZSBtdXN0IGJlIG9uZSBvZiBcInRleHRcIixcbiAgLy8gXCJndXR0ZXJcIiwgXCJjbGFzc1wiLCBcIndpZGdldFwiXG4gIGZ1bmN0aW9uIHJlZ0xpbmVDaGFuZ2UoY20sIGxpbmUsIHR5cGUpIHtcbiAgICBjbS5jdXJPcC52aWV3Q2hhbmdlZCA9IHRydWU7XG4gICAgdmFyIGRpc3BsYXkgPSBjbS5kaXNwbGF5LCBleHQgPSBjbS5kaXNwbGF5LmV4dGVybmFsTWVhc3VyZWQ7XG4gICAgaWYgKGV4dCAmJiBsaW5lID49IGV4dC5saW5lTiAmJiBsaW5lIDwgZXh0LmxpbmVOICsgZXh0LnNpemUpXG4gICAgICB7IGRpc3BsYXkuZXh0ZXJuYWxNZWFzdXJlZCA9IG51bGw7IH1cblxuICAgIGlmIChsaW5lIDwgZGlzcGxheS52aWV3RnJvbSB8fCBsaW5lID49IGRpc3BsYXkudmlld1RvKSB7IHJldHVybiB9XG4gICAgdmFyIGxpbmVWaWV3ID0gZGlzcGxheS52aWV3W2ZpbmRWaWV3SW5kZXgoY20sIGxpbmUpXTtcbiAgICBpZiAobGluZVZpZXcubm9kZSA9PSBudWxsKSB7IHJldHVybiB9XG4gICAgdmFyIGFyciA9IGxpbmVWaWV3LmNoYW5nZXMgfHwgKGxpbmVWaWV3LmNoYW5nZXMgPSBbXSk7XG4gICAgaWYgKGluZGV4T2YoYXJyLCB0eXBlKSA9PSAtMSkgeyBhcnIucHVzaCh0eXBlKTsgfVxuICB9XG5cbiAgLy8gQ2xlYXIgdGhlIHZpZXcuXG4gIGZ1bmN0aW9uIHJlc2V0VmlldyhjbSkge1xuICAgIGNtLmRpc3BsYXkudmlld0Zyb20gPSBjbS5kaXNwbGF5LnZpZXdUbyA9IGNtLmRvYy5maXJzdDtcbiAgICBjbS5kaXNwbGF5LnZpZXcgPSBbXTtcbiAgICBjbS5kaXNwbGF5LnZpZXdPZmZzZXQgPSAwO1xuICB9XG5cbiAgZnVuY3Rpb24gdmlld0N1dHRpbmdQb2ludChjbSwgb2xkTiwgbmV3TiwgZGlyKSB7XG4gICAgdmFyIGluZGV4ID0gZmluZFZpZXdJbmRleChjbSwgb2xkTiksIGRpZmYsIHZpZXcgPSBjbS5kaXNwbGF5LnZpZXc7XG4gICAgaWYgKCFzYXdDb2xsYXBzZWRTcGFucyB8fCBuZXdOID09IGNtLmRvYy5maXJzdCArIGNtLmRvYy5zaXplKVxuICAgICAgeyByZXR1cm4ge2luZGV4OiBpbmRleCwgbGluZU46IG5ld059IH1cbiAgICB2YXIgbiA9IGNtLmRpc3BsYXkudmlld0Zyb207XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBpbmRleDsgaSsrKVxuICAgICAgeyBuICs9IHZpZXdbaV0uc2l6ZTsgfVxuICAgIGlmIChuICE9IG9sZE4pIHtcbiAgICAgIGlmIChkaXIgPiAwKSB7XG4gICAgICAgIGlmIChpbmRleCA9PSB2aWV3Lmxlbmd0aCAtIDEpIHsgcmV0dXJuIG51bGwgfVxuICAgICAgICBkaWZmID0gKG4gKyB2aWV3W2luZGV4XS5zaXplKSAtIG9sZE47XG4gICAgICAgIGluZGV4Kys7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBkaWZmID0gbiAtIG9sZE47XG4gICAgICB9XG4gICAgICBvbGROICs9IGRpZmY7IG5ld04gKz0gZGlmZjtcbiAgICB9XG4gICAgd2hpbGUgKHZpc3VhbExpbmVObyhjbS5kb2MsIG5ld04pICE9IG5ld04pIHtcbiAgICAgIGlmIChpbmRleCA9PSAoZGlyIDwgMCA/IDAgOiB2aWV3Lmxlbmd0aCAtIDEpKSB7IHJldHVybiBudWxsIH1cbiAgICAgIG5ld04gKz0gZGlyICogdmlld1tpbmRleCAtIChkaXIgPCAwID8gMSA6IDApXS5zaXplO1xuICAgICAgaW5kZXggKz0gZGlyO1xuICAgIH1cbiAgICByZXR1cm4ge2luZGV4OiBpbmRleCwgbGluZU46IG5ld059XG4gIH1cblxuICAvLyBGb3JjZSB0aGUgdmlldyB0byBjb3ZlciBhIGdpdmVuIHJhbmdlLCBhZGRpbmcgZW1wdHkgdmlldyBlbGVtZW50XG4gIC8vIG9yIGNsaXBwaW5nIG9mZiBleGlzdGluZyBvbmVzIGFzIG5lZWRlZC5cbiAgZnVuY3Rpb24gYWRqdXN0VmlldyhjbSwgZnJvbSwgdG8pIHtcbiAgICB2YXIgZGlzcGxheSA9IGNtLmRpc3BsYXksIHZpZXcgPSBkaXNwbGF5LnZpZXc7XG4gICAgaWYgKHZpZXcubGVuZ3RoID09IDAgfHwgZnJvbSA+PSBkaXNwbGF5LnZpZXdUbyB8fCB0byA8PSBkaXNwbGF5LnZpZXdGcm9tKSB7XG4gICAgICBkaXNwbGF5LnZpZXcgPSBidWlsZFZpZXdBcnJheShjbSwgZnJvbSwgdG8pO1xuICAgICAgZGlzcGxheS52aWV3RnJvbSA9IGZyb207XG4gICAgfSBlbHNlIHtcbiAgICAgIGlmIChkaXNwbGF5LnZpZXdGcm9tID4gZnJvbSlcbiAgICAgICAgeyBkaXNwbGF5LnZpZXcgPSBidWlsZFZpZXdBcnJheShjbSwgZnJvbSwgZGlzcGxheS52aWV3RnJvbSkuY29uY2F0KGRpc3BsYXkudmlldyk7IH1cbiAgICAgIGVsc2UgaWYgKGRpc3BsYXkudmlld0Zyb20gPCBmcm9tKVxuICAgICAgICB7IGRpc3BsYXkudmlldyA9IGRpc3BsYXkudmlldy5zbGljZShmaW5kVmlld0luZGV4KGNtLCBmcm9tKSk7IH1cbiAgICAgIGRpc3BsYXkudmlld0Zyb20gPSBmcm9tO1xuICAgICAgaWYgKGRpc3BsYXkudmlld1RvIDwgdG8pXG4gICAgICAgIHsgZGlzcGxheS52aWV3ID0gZGlzcGxheS52aWV3LmNvbmNhdChidWlsZFZpZXdBcnJheShjbSwgZGlzcGxheS52aWV3VG8sIHRvKSk7IH1cbiAgICAgIGVsc2UgaWYgKGRpc3BsYXkudmlld1RvID4gdG8pXG4gICAgICAgIHsgZGlzcGxheS52aWV3ID0gZGlzcGxheS52aWV3LnNsaWNlKDAsIGZpbmRWaWV3SW5kZXgoY20sIHRvKSk7IH1cbiAgICB9XG4gICAgZGlzcGxheS52aWV3VG8gPSB0bztcbiAgfVxuXG4gIC8vIENvdW50IHRoZSBudW1iZXIgb2YgbGluZXMgaW4gdGhlIHZpZXcgd2hvc2UgRE9NIHJlcHJlc2VudGF0aW9uIGlzXG4gIC8vIG91dCBvZiBkYXRlIChvciBub25leGlzdGVudCkuXG4gIGZ1bmN0aW9uIGNvdW50RGlydHlWaWV3KGNtKSB7XG4gICAgdmFyIHZpZXcgPSBjbS5kaXNwbGF5LnZpZXcsIGRpcnR5ID0gMDtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IHZpZXcubGVuZ3RoOyBpKyspIHtcbiAgICAgIHZhciBsaW5lVmlldyA9IHZpZXdbaV07XG4gICAgICBpZiAoIWxpbmVWaWV3LmhpZGRlbiAmJiAoIWxpbmVWaWV3Lm5vZGUgfHwgbGluZVZpZXcuY2hhbmdlcykpIHsgKytkaXJ0eTsgfVxuICAgIH1cbiAgICByZXR1cm4gZGlydHlcbiAgfVxuXG4gIGZ1bmN0aW9uIHVwZGF0ZVNlbGVjdGlvbihjbSkge1xuICAgIGNtLmRpc3BsYXkuaW5wdXQuc2hvd1NlbGVjdGlvbihjbS5kaXNwbGF5LmlucHV0LnByZXBhcmVTZWxlY3Rpb24oKSk7XG4gIH1cblxuICBmdW5jdGlvbiBwcmVwYXJlU2VsZWN0aW9uKGNtLCBwcmltYXJ5KSB7XG4gICAgaWYgKCBwcmltYXJ5ID09PSB2b2lkIDAgKSBwcmltYXJ5ID0gdHJ1ZTtcblxuICAgIHZhciBkb2MgPSBjbS5kb2MsIHJlc3VsdCA9IHt9O1xuICAgIHZhciBjdXJGcmFnbWVudCA9IHJlc3VsdC5jdXJzb3JzID0gZG9jdW1lbnQuY3JlYXRlRG9jdW1lbnRGcmFnbWVudCgpO1xuICAgIHZhciBzZWxGcmFnbWVudCA9IHJlc3VsdC5zZWxlY3Rpb24gPSBkb2N1bWVudC5jcmVhdGVEb2N1bWVudEZyYWdtZW50KCk7XG5cbiAgICB2YXIgY3VzdG9tQ3Vyc29yID0gY20ub3B0aW9ucy4kY3VzdG9tQ3Vyc29yO1xuICAgIGlmIChjdXN0b21DdXJzb3IpIHsgcHJpbWFyeSA9IHRydWU7IH1cbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGRvYy5zZWwucmFuZ2VzLmxlbmd0aDsgaSsrKSB7XG4gICAgICBpZiAoIXByaW1hcnkgJiYgaSA9PSBkb2Muc2VsLnByaW1JbmRleCkgeyBjb250aW51ZSB9XG4gICAgICB2YXIgcmFuZ2UgPSBkb2Muc2VsLnJhbmdlc1tpXTtcbiAgICAgIGlmIChyYW5nZS5mcm9tKCkubGluZSA+PSBjbS5kaXNwbGF5LnZpZXdUbyB8fCByYW5nZS50bygpLmxpbmUgPCBjbS5kaXNwbGF5LnZpZXdGcm9tKSB7IGNvbnRpbnVlIH1cbiAgICAgIHZhciBjb2xsYXBzZWQgPSByYW5nZS5lbXB0eSgpO1xuICAgICAgaWYgKGN1c3RvbUN1cnNvcikge1xuICAgICAgICB2YXIgaGVhZCA9IGN1c3RvbUN1cnNvcihjbSwgcmFuZ2UpO1xuICAgICAgICBpZiAoaGVhZCkgeyBkcmF3U2VsZWN0aW9uQ3Vyc29yKGNtLCBoZWFkLCBjdXJGcmFnbWVudCk7IH1cbiAgICAgIH0gZWxzZSBpZiAoY29sbGFwc2VkIHx8IGNtLm9wdGlvbnMuc2hvd0N1cnNvcldoZW5TZWxlY3RpbmcpIHtcbiAgICAgICAgZHJhd1NlbGVjdGlvbkN1cnNvcihjbSwgcmFuZ2UuaGVhZCwgY3VyRnJhZ21lbnQpO1xuICAgICAgfVxuICAgICAgaWYgKCFjb2xsYXBzZWQpXG4gICAgICAgIHsgZHJhd1NlbGVjdGlvblJhbmdlKGNtLCByYW5nZSwgc2VsRnJhZ21lbnQpOyB9XG4gICAgfVxuICAgIHJldHVybiByZXN1bHRcbiAgfVxuXG4gIC8vIERyYXdzIGEgY3Vyc29yIGZvciB0aGUgZ2l2ZW4gcmFuZ2VcbiAgZnVuY3Rpb24gZHJhd1NlbGVjdGlvbkN1cnNvcihjbSwgaGVhZCwgb3V0cHV0KSB7XG4gICAgdmFyIHBvcyA9IGN1cnNvckNvb3JkcyhjbSwgaGVhZCwgXCJkaXZcIiwgbnVsbCwgbnVsbCwgIWNtLm9wdGlvbnMuc2luZ2xlQ3Vyc29ySGVpZ2h0UGVyTGluZSk7XG5cbiAgICB2YXIgY3Vyc29yID0gb3V0cHV0LmFwcGVuZENoaWxkKGVsdChcImRpdlwiLCBcIlxcdTAwYTBcIiwgXCJDb2RlTWlycm9yLWN1cnNvclwiKSk7XG4gICAgY3Vyc29yLnN0eWxlLmxlZnQgPSBwb3MubGVmdCArIFwicHhcIjtcbiAgICBjdXJzb3Iuc3R5bGUudG9wID0gcG9zLnRvcCArIFwicHhcIjtcbiAgICBjdXJzb3Iuc3R5bGUuaGVpZ2h0ID0gTWF0aC5tYXgoMCwgcG9zLmJvdHRvbSAtIHBvcy50b3ApICogY20ub3B0aW9ucy5jdXJzb3JIZWlnaHQgKyBcInB4XCI7XG5cbiAgICBpZiAoL1xcYmNtLWZhdC1jdXJzb3JcXGIvLnRlc3QoY20uZ2V0V3JhcHBlckVsZW1lbnQoKS5jbGFzc05hbWUpKSB7XG4gICAgICB2YXIgY2hhclBvcyA9IGNoYXJDb29yZHMoY20sIGhlYWQsIFwiZGl2XCIsIG51bGwsIG51bGwpO1xuICAgICAgdmFyIHdpZHRoID0gY2hhclBvcy5yaWdodCAtIGNoYXJQb3MubGVmdDtcbiAgICAgIGN1cnNvci5zdHlsZS53aWR0aCA9ICh3aWR0aCA+IDAgPyB3aWR0aCA6IGNtLmRlZmF1bHRDaGFyV2lkdGgoKSkgKyBcInB4XCI7XG4gICAgfVxuXG4gICAgaWYgKHBvcy5vdGhlcikge1xuICAgICAgLy8gU2Vjb25kYXJ5IGN1cnNvciwgc2hvd24gd2hlbiBvbiBhICdqdW1wJyBpbiBiaS1kaXJlY3Rpb25hbCB0ZXh0XG4gICAgICB2YXIgb3RoZXJDdXJzb3IgPSBvdXRwdXQuYXBwZW5kQ2hpbGQoZWx0KFwiZGl2XCIsIFwiXFx1MDBhMFwiLCBcIkNvZGVNaXJyb3ItY3Vyc29yIENvZGVNaXJyb3Itc2Vjb25kYXJ5Y3Vyc29yXCIpKTtcbiAgICAgIG90aGVyQ3Vyc29yLnN0eWxlLmRpc3BsYXkgPSBcIlwiO1xuICAgICAgb3RoZXJDdXJzb3Iuc3R5bGUubGVmdCA9IHBvcy5vdGhlci5sZWZ0ICsgXCJweFwiO1xuICAgICAgb3RoZXJDdXJzb3Iuc3R5bGUudG9wID0gcG9zLm90aGVyLnRvcCArIFwicHhcIjtcbiAgICAgIG90aGVyQ3Vyc29yLnN0eWxlLmhlaWdodCA9IChwb3Mub3RoZXIuYm90dG9tIC0gcG9zLm90aGVyLnRvcCkgKiAuODUgKyBcInB4XCI7XG4gICAgfVxuICB9XG5cbiAgZnVuY3Rpb24gY21wQ29vcmRzKGEsIGIpIHsgcmV0dXJuIGEudG9wIC0gYi50b3AgfHwgYS5sZWZ0IC0gYi5sZWZ0IH1cblxuICAvLyBEcmF3cyB0aGUgZ2l2ZW4gcmFuZ2UgYXMgYSBoaWdobGlnaHRlZCBzZWxlY3Rpb25cbiAgZnVuY3Rpb24gZHJhd1NlbGVjdGlvblJhbmdlKGNtLCByYW5nZSwgb3V0cHV0KSB7XG4gICAgdmFyIGRpc3BsYXkgPSBjbS5kaXNwbGF5LCBkb2MgPSBjbS5kb2M7XG4gICAgdmFyIGZyYWdtZW50ID0gZG9jdW1lbnQuY3JlYXRlRG9jdW1lbnRGcmFnbWVudCgpO1xuICAgIHZhciBwYWRkaW5nID0gcGFkZGluZ0goY20uZGlzcGxheSksIGxlZnRTaWRlID0gcGFkZGluZy5sZWZ0O1xuICAgIHZhciByaWdodFNpZGUgPSBNYXRoLm1heChkaXNwbGF5LnNpemVyV2lkdGgsIGRpc3BsYXlXaWR0aChjbSkgLSBkaXNwbGF5LnNpemVyLm9mZnNldExlZnQpIC0gcGFkZGluZy5yaWdodDtcbiAgICB2YXIgZG9jTFRSID0gZG9jLmRpcmVjdGlvbiA9PSBcImx0clwiO1xuXG4gICAgZnVuY3Rpb24gYWRkKGxlZnQsIHRvcCwgd2lkdGgsIGJvdHRvbSkge1xuICAgICAgaWYgKHRvcCA8IDApIHsgdG9wID0gMDsgfVxuICAgICAgdG9wID0gTWF0aC5yb3VuZCh0b3ApO1xuICAgICAgYm90dG9tID0gTWF0aC5yb3VuZChib3R0b20pO1xuICAgICAgZnJhZ21lbnQuYXBwZW5kQ2hpbGQoZWx0KFwiZGl2XCIsIG51bGwsIFwiQ29kZU1pcnJvci1zZWxlY3RlZFwiLCAoXCJwb3NpdGlvbjogYWJzb2x1dGU7IGxlZnQ6IFwiICsgbGVmdCArIFwicHg7XFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0b3A6IFwiICsgdG9wICsgXCJweDsgd2lkdGg6IFwiICsgKHdpZHRoID09IG51bGwgPyByaWdodFNpZGUgLSBsZWZ0IDogd2lkdGgpICsgXCJweDtcXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgIGhlaWdodDogXCIgKyAoYm90dG9tIC0gdG9wKSArIFwicHhcIikpKTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBkcmF3Rm9yTGluZShsaW5lLCBmcm9tQXJnLCB0b0FyZykge1xuICAgICAgdmFyIGxpbmVPYmogPSBnZXRMaW5lKGRvYywgbGluZSk7XG4gICAgICB2YXIgbGluZUxlbiA9IGxpbmVPYmoudGV4dC5sZW5ndGg7XG4gICAgICB2YXIgc3RhcnQsIGVuZDtcbiAgICAgIGZ1bmN0aW9uIGNvb3JkcyhjaCwgYmlhcykge1xuICAgICAgICByZXR1cm4gY2hhckNvb3JkcyhjbSwgUG9zKGxpbmUsIGNoKSwgXCJkaXZcIiwgbGluZU9iaiwgYmlhcylcbiAgICAgIH1cblxuICAgICAgZnVuY3Rpb24gd3JhcFgocG9zLCBkaXIsIHNpZGUpIHtcbiAgICAgICAgdmFyIGV4dGVudCA9IHdyYXBwZWRMaW5lRXh0ZW50Q2hhcihjbSwgbGluZU9iaiwgbnVsbCwgcG9zKTtcbiAgICAgICAgdmFyIHByb3AgPSAoZGlyID09IFwibHRyXCIpID09IChzaWRlID09IFwiYWZ0ZXJcIikgPyBcImxlZnRcIiA6IFwicmlnaHRcIjtcbiAgICAgICAgdmFyIGNoID0gc2lkZSA9PSBcImFmdGVyXCIgPyBleHRlbnQuYmVnaW4gOiBleHRlbnQuZW5kIC0gKC9cXHMvLnRlc3QobGluZU9iai50ZXh0LmNoYXJBdChleHRlbnQuZW5kIC0gMSkpID8gMiA6IDEpO1xuICAgICAgICByZXR1cm4gY29vcmRzKGNoLCBwcm9wKVtwcm9wXVxuICAgICAgfVxuXG4gICAgICB2YXIgb3JkZXIgPSBnZXRPcmRlcihsaW5lT2JqLCBkb2MuZGlyZWN0aW9uKTtcbiAgICAgIGl0ZXJhdGVCaWRpU2VjdGlvbnMob3JkZXIsIGZyb21BcmcgfHwgMCwgdG9BcmcgPT0gbnVsbCA/IGxpbmVMZW4gOiB0b0FyZywgZnVuY3Rpb24gKGZyb20sIHRvLCBkaXIsIGkpIHtcbiAgICAgICAgdmFyIGx0ciA9IGRpciA9PSBcImx0clwiO1xuICAgICAgICB2YXIgZnJvbVBvcyA9IGNvb3Jkcyhmcm9tLCBsdHIgPyBcImxlZnRcIiA6IFwicmlnaHRcIik7XG4gICAgICAgIHZhciB0b1BvcyA9IGNvb3Jkcyh0byAtIDEsIGx0ciA/IFwicmlnaHRcIiA6IFwibGVmdFwiKTtcblxuICAgICAgICB2YXIgb3BlblN0YXJ0ID0gZnJvbUFyZyA9PSBudWxsICYmIGZyb20gPT0gMCwgb3BlbkVuZCA9IHRvQXJnID09IG51bGwgJiYgdG8gPT0gbGluZUxlbjtcbiAgICAgICAgdmFyIGZpcnN0ID0gaSA9PSAwLCBsYXN0ID0gIW9yZGVyIHx8IGkgPT0gb3JkZXIubGVuZ3RoIC0gMTtcbiAgICAgICAgaWYgKHRvUG9zLnRvcCAtIGZyb21Qb3MudG9wIDw9IDMpIHsgLy8gU2luZ2xlIGxpbmVcbiAgICAgICAgICB2YXIgb3BlbkxlZnQgPSAoZG9jTFRSID8gb3BlblN0YXJ0IDogb3BlbkVuZCkgJiYgZmlyc3Q7XG4gICAgICAgICAgdmFyIG9wZW5SaWdodCA9IChkb2NMVFIgPyBvcGVuRW5kIDogb3BlblN0YXJ0KSAmJiBsYXN0O1xuICAgICAgICAgIHZhciBsZWZ0ID0gb3BlbkxlZnQgPyBsZWZ0U2lkZSA6IChsdHIgPyBmcm9tUG9zIDogdG9Qb3MpLmxlZnQ7XG4gICAgICAgICAgdmFyIHJpZ2h0ID0gb3BlblJpZ2h0ID8gcmlnaHRTaWRlIDogKGx0ciA/IHRvUG9zIDogZnJvbVBvcykucmlnaHQ7XG4gICAgICAgICAgYWRkKGxlZnQsIGZyb21Qb3MudG9wLCByaWdodCAtIGxlZnQsIGZyb21Qb3MuYm90dG9tKTtcbiAgICAgICAgfSBlbHNlIHsgLy8gTXVsdGlwbGUgbGluZXNcbiAgICAgICAgICB2YXIgdG9wTGVmdCwgdG9wUmlnaHQsIGJvdExlZnQsIGJvdFJpZ2h0O1xuICAgICAgICAgIGlmIChsdHIpIHtcbiAgICAgICAgICAgIHRvcExlZnQgPSBkb2NMVFIgJiYgb3BlblN0YXJ0ICYmIGZpcnN0ID8gbGVmdFNpZGUgOiBmcm9tUG9zLmxlZnQ7XG4gICAgICAgICAgICB0b3BSaWdodCA9IGRvY0xUUiA/IHJpZ2h0U2lkZSA6IHdyYXBYKGZyb20sIGRpciwgXCJiZWZvcmVcIik7XG4gICAgICAgICAgICBib3RMZWZ0ID0gZG9jTFRSID8gbGVmdFNpZGUgOiB3cmFwWCh0bywgZGlyLCBcImFmdGVyXCIpO1xuICAgICAgICAgICAgYm90UmlnaHQgPSBkb2NMVFIgJiYgb3BlbkVuZCAmJiBsYXN0ID8gcmlnaHRTaWRlIDogdG9Qb3MucmlnaHQ7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHRvcExlZnQgPSAhZG9jTFRSID8gbGVmdFNpZGUgOiB3cmFwWChmcm9tLCBkaXIsIFwiYmVmb3JlXCIpO1xuICAgICAgICAgICAgdG9wUmlnaHQgPSAhZG9jTFRSICYmIG9wZW5TdGFydCAmJiBmaXJzdCA/IHJpZ2h0U2lkZSA6IGZyb21Qb3MucmlnaHQ7XG4gICAgICAgICAgICBib3RMZWZ0ID0gIWRvY0xUUiAmJiBvcGVuRW5kICYmIGxhc3QgPyBsZWZ0U2lkZSA6IHRvUG9zLmxlZnQ7XG4gICAgICAgICAgICBib3RSaWdodCA9ICFkb2NMVFIgPyByaWdodFNpZGUgOiB3cmFwWCh0bywgZGlyLCBcImFmdGVyXCIpO1xuICAgICAgICAgIH1cbiAgICAgICAgICBhZGQodG9wTGVmdCwgZnJvbVBvcy50b3AsIHRvcFJpZ2h0IC0gdG9wTGVmdCwgZnJvbVBvcy5ib3R0b20pO1xuICAgICAgICAgIGlmIChmcm9tUG9zLmJvdHRvbSA8IHRvUG9zLnRvcCkgeyBhZGQobGVmdFNpZGUsIGZyb21Qb3MuYm90dG9tLCBudWxsLCB0b1Bvcy50b3ApOyB9XG4gICAgICAgICAgYWRkKGJvdExlZnQsIHRvUG9zLnRvcCwgYm90UmlnaHQgLSBib3RMZWZ0LCB0b1Bvcy5ib3R0b20pO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKCFzdGFydCB8fCBjbXBDb29yZHMoZnJvbVBvcywgc3RhcnQpIDwgMCkgeyBzdGFydCA9IGZyb21Qb3M7IH1cbiAgICAgICAgaWYgKGNtcENvb3Jkcyh0b1Bvcywgc3RhcnQpIDwgMCkgeyBzdGFydCA9IHRvUG9zOyB9XG4gICAgICAgIGlmICghZW5kIHx8IGNtcENvb3Jkcyhmcm9tUG9zLCBlbmQpIDwgMCkgeyBlbmQgPSBmcm9tUG9zOyB9XG4gICAgICAgIGlmIChjbXBDb29yZHModG9Qb3MsIGVuZCkgPCAwKSB7IGVuZCA9IHRvUG9zOyB9XG4gICAgICB9KTtcbiAgICAgIHJldHVybiB7c3RhcnQ6IHN0YXJ0LCBlbmQ6IGVuZH1cbiAgICB9XG5cbiAgICB2YXIgc0Zyb20gPSByYW5nZS5mcm9tKCksIHNUbyA9IHJhbmdlLnRvKCk7XG4gICAgaWYgKHNGcm9tLmxpbmUgPT0gc1RvLmxpbmUpIHtcbiAgICAgIGRyYXdGb3JMaW5lKHNGcm9tLmxpbmUsIHNGcm9tLmNoLCBzVG8uY2gpO1xuICAgIH0gZWxzZSB7XG4gICAgICB2YXIgZnJvbUxpbmUgPSBnZXRMaW5lKGRvYywgc0Zyb20ubGluZSksIHRvTGluZSA9IGdldExpbmUoZG9jLCBzVG8ubGluZSk7XG4gICAgICB2YXIgc2luZ2xlVkxpbmUgPSB2aXN1YWxMaW5lKGZyb21MaW5lKSA9PSB2aXN1YWxMaW5lKHRvTGluZSk7XG4gICAgICB2YXIgbGVmdEVuZCA9IGRyYXdGb3JMaW5lKHNGcm9tLmxpbmUsIHNGcm9tLmNoLCBzaW5nbGVWTGluZSA/IGZyb21MaW5lLnRleHQubGVuZ3RoICsgMSA6IG51bGwpLmVuZDtcbiAgICAgIHZhciByaWdodFN0YXJ0ID0gZHJhd0ZvckxpbmUoc1RvLmxpbmUsIHNpbmdsZVZMaW5lID8gMCA6IG51bGwsIHNUby5jaCkuc3RhcnQ7XG4gICAgICBpZiAoc2luZ2xlVkxpbmUpIHtcbiAgICAgICAgaWYgKGxlZnRFbmQudG9wIDwgcmlnaHRTdGFydC50b3AgLSAyKSB7XG4gICAgICAgICAgYWRkKGxlZnRFbmQucmlnaHQsIGxlZnRFbmQudG9wLCBudWxsLCBsZWZ0RW5kLmJvdHRvbSk7XG4gICAgICAgICAgYWRkKGxlZnRTaWRlLCByaWdodFN0YXJ0LnRvcCwgcmlnaHRTdGFydC5sZWZ0LCByaWdodFN0YXJ0LmJvdHRvbSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgYWRkKGxlZnRFbmQucmlnaHQsIGxlZnRFbmQudG9wLCByaWdodFN0YXJ0LmxlZnQgLSBsZWZ0RW5kLnJpZ2h0LCBsZWZ0RW5kLmJvdHRvbSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGlmIChsZWZ0RW5kLmJvdHRvbSA8IHJpZ2h0U3RhcnQudG9wKVxuICAgICAgICB7IGFkZChsZWZ0U2lkZSwgbGVmdEVuZC5ib3R0b20sIG51bGwsIHJpZ2h0U3RhcnQudG9wKTsgfVxuICAgIH1cblxuICAgIG91dHB1dC5hcHBlbmRDaGlsZChmcmFnbWVudCk7XG4gIH1cblxuICAvLyBDdXJzb3ItYmxpbmtpbmdcbiAgZnVuY3Rpb24gcmVzdGFydEJsaW5rKGNtKSB7XG4gICAgaWYgKCFjbS5zdGF0ZS5mb2N1c2VkKSB7IHJldHVybiB9XG4gICAgdmFyIGRpc3BsYXkgPSBjbS5kaXNwbGF5O1xuICAgIGNsZWFySW50ZXJ2YWwoZGlzcGxheS5ibGlua2VyKTtcbiAgICB2YXIgb24gPSB0cnVlO1xuICAgIGRpc3BsYXkuY3Vyc29yRGl2LnN0eWxlLnZpc2liaWxpdHkgPSBcIlwiO1xuICAgIGlmIChjbS5vcHRpb25zLmN1cnNvckJsaW5rUmF0ZSA+IDApXG4gICAgICB7IGRpc3BsYXkuYmxpbmtlciA9IHNldEludGVydmFsKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgaWYgKCFjbS5oYXNGb2N1cygpKSB7IG9uQmx1cihjbSk7IH1cbiAgICAgICAgZGlzcGxheS5jdXJzb3JEaXYuc3R5bGUudmlzaWJpbGl0eSA9IChvbiA9ICFvbikgPyBcIlwiIDogXCJoaWRkZW5cIjtcbiAgICAgIH0sIGNtLm9wdGlvbnMuY3Vyc29yQmxpbmtSYXRlKTsgfVxuICAgIGVsc2UgaWYgKGNtLm9wdGlvbnMuY3Vyc29yQmxpbmtSYXRlIDwgMClcbiAgICAgIHsgZGlzcGxheS5jdXJzb3JEaXYuc3R5bGUudmlzaWJpbGl0eSA9IFwiaGlkZGVuXCI7IH1cbiAgfVxuXG4gIGZ1bmN0aW9uIGVuc3VyZUZvY3VzKGNtKSB7XG4gICAgaWYgKCFjbS5oYXNGb2N1cygpKSB7XG4gICAgICBjbS5kaXNwbGF5LmlucHV0LmZvY3VzKCk7XG4gICAgICBpZiAoIWNtLnN0YXRlLmZvY3VzZWQpIHsgb25Gb2N1cyhjbSk7IH1cbiAgICB9XG4gIH1cblxuICBmdW5jdGlvbiBkZWxheUJsdXJFdmVudChjbSkge1xuICAgIGNtLnN0YXRlLmRlbGF5aW5nQmx1ckV2ZW50ID0gdHJ1ZTtcbiAgICBzZXRUaW1lb3V0KGZ1bmN0aW9uICgpIHsgaWYgKGNtLnN0YXRlLmRlbGF5aW5nQmx1ckV2ZW50KSB7XG4gICAgICBjbS5zdGF0ZS5kZWxheWluZ0JsdXJFdmVudCA9IGZhbHNlO1xuICAgICAgaWYgKGNtLnN0YXRlLmZvY3VzZWQpIHsgb25CbHVyKGNtKTsgfVxuICAgIH0gfSwgMTAwKTtcbiAgfVxuXG4gIGZ1bmN0aW9uIG9uRm9jdXMoY20sIGUpIHtcbiAgICBpZiAoY20uc3RhdGUuZGVsYXlpbmdCbHVyRXZlbnQgJiYgIWNtLnN0YXRlLmRyYWdnaW5nVGV4dCkgeyBjbS5zdGF0ZS5kZWxheWluZ0JsdXJFdmVudCA9IGZhbHNlOyB9XG5cbiAgICBpZiAoY20ub3B0aW9ucy5yZWFkT25seSA9PSBcIm5vY3Vyc29yXCIpIHsgcmV0dXJuIH1cbiAgICBpZiAoIWNtLnN0YXRlLmZvY3VzZWQpIHtcbiAgICAgIHNpZ25hbChjbSwgXCJmb2N1c1wiLCBjbSwgZSk7XG4gICAgICBjbS5zdGF0ZS5mb2N1c2VkID0gdHJ1ZTtcbiAgICAgIGFkZENsYXNzKGNtLmRpc3BsYXkud3JhcHBlciwgXCJDb2RlTWlycm9yLWZvY3VzZWRcIik7XG4gICAgICAvLyBUaGlzIHRlc3QgcHJldmVudHMgdGhpcyBmcm9tIGZpcmluZyB3aGVuIGEgY29udGV4dFxuICAgICAgLy8gbWVudSBpcyBjbG9zZWQgKHNpbmNlIHRoZSBpbnB1dCByZXNldCB3b3VsZCBraWxsIHRoZVxuICAgICAgLy8gc2VsZWN0LWFsbCBkZXRlY3Rpb24gaGFjaylcbiAgICAgIGlmICghY20uY3VyT3AgJiYgY20uZGlzcGxheS5zZWxGb3JDb250ZXh0TWVudSAhPSBjbS5kb2Muc2VsKSB7XG4gICAgICAgIGNtLmRpc3BsYXkuaW5wdXQucmVzZXQoKTtcbiAgICAgICAgaWYgKHdlYmtpdCkgeyBzZXRUaW1lb3V0KGZ1bmN0aW9uICgpIHsgcmV0dXJuIGNtLmRpc3BsYXkuaW5wdXQucmVzZXQodHJ1ZSk7IH0sIDIwKTsgfSAvLyBJc3N1ZSAjMTczMFxuICAgICAgfVxuICAgICAgY20uZGlzcGxheS5pbnB1dC5yZWNlaXZlZEZvY3VzKCk7XG4gICAgfVxuICAgIHJlc3RhcnRCbGluayhjbSk7XG4gIH1cbiAgZnVuY3Rpb24gb25CbHVyKGNtLCBlKSB7XG4gICAgaWYgKGNtLnN0YXRlLmRlbGF5aW5nQmx1ckV2ZW50KSB7IHJldHVybiB9XG5cbiAgICBpZiAoY20uc3RhdGUuZm9jdXNlZCkge1xuICAgICAgc2lnbmFsKGNtLCBcImJsdXJcIiwgY20sIGUpO1xuICAgICAgY20uc3RhdGUuZm9jdXNlZCA9IGZhbHNlO1xuICAgICAgcm1DbGFzcyhjbS5kaXNwbGF5LndyYXBwZXIsIFwiQ29kZU1pcnJvci1mb2N1c2VkXCIpO1xuICAgIH1cbiAgICBjbGVhckludGVydmFsKGNtLmRpc3BsYXkuYmxpbmtlcik7XG4gICAgc2V0VGltZW91dChmdW5jdGlvbiAoKSB7IGlmICghY20uc3RhdGUuZm9jdXNlZCkgeyBjbS5kaXNwbGF5LnNoaWZ0ID0gZmFsc2U7IH0gfSwgMTUwKTtcbiAgfVxuXG4gIC8vIFJlYWQgdGhlIGFjdHVhbCBoZWlnaHRzIG9mIHRoZSByZW5kZXJlZCBsaW5lcywgYW5kIHVwZGF0ZSB0aGVpclxuICAvLyBzdG9yZWQgaGVpZ2h0cyB0byBtYXRjaC5cbiAgZnVuY3Rpb24gdXBkYXRlSGVpZ2h0c0luVmlld3BvcnQoY20pIHtcbiAgICB2YXIgZGlzcGxheSA9IGNtLmRpc3BsYXk7XG4gICAgdmFyIHByZXZCb3R0b20gPSBkaXNwbGF5LmxpbmVEaXYub2Zmc2V0VG9wO1xuICAgIHZhciB2aWV3VG9wID0gTWF0aC5tYXgoMCwgZGlzcGxheS5zY3JvbGxlci5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKS50b3ApO1xuICAgIHZhciBvbGRIZWlnaHQgPSBkaXNwbGF5LmxpbmVEaXYuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCkudG9wO1xuICAgIHZhciBtdXN0U2Nyb2xsID0gMDtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGRpc3BsYXkudmlldy5sZW5ndGg7IGkrKykge1xuICAgICAgdmFyIGN1ciA9IGRpc3BsYXkudmlld1tpXSwgd3JhcHBpbmcgPSBjbS5vcHRpb25zLmxpbmVXcmFwcGluZztcbiAgICAgIHZhciBoZWlnaHQgPSAodm9pZCAwKSwgd2lkdGggPSAwO1xuICAgICAgaWYgKGN1ci5oaWRkZW4pIHsgY29udGludWUgfVxuICAgICAgb2xkSGVpZ2h0ICs9IGN1ci5saW5lLmhlaWdodDtcbiAgICAgIGlmIChpZSAmJiBpZV92ZXJzaW9uIDwgOCkge1xuICAgICAgICB2YXIgYm90ID0gY3VyLm5vZGUub2Zmc2V0VG9wICsgY3VyLm5vZGUub2Zmc2V0SGVpZ2h0O1xuICAgICAgICBoZWlnaHQgPSBib3QgLSBwcmV2Qm90dG9tO1xuICAgICAgICBwcmV2Qm90dG9tID0gYm90O1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdmFyIGJveCA9IGN1ci5ub2RlLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpO1xuICAgICAgICBoZWlnaHQgPSBib3guYm90dG9tIC0gYm94LnRvcDtcbiAgICAgICAgLy8gQ2hlY2sgdGhhdCBsaW5lcyBkb24ndCBleHRlbmQgcGFzdCB0aGUgcmlnaHQgb2YgdGhlIGN1cnJlbnRcbiAgICAgICAgLy8gZWRpdG9yIHdpZHRoXG4gICAgICAgIGlmICghd3JhcHBpbmcgJiYgY3VyLnRleHQuZmlyc3RDaGlsZClcbiAgICAgICAgICB7IHdpZHRoID0gY3VyLnRleHQuZmlyc3RDaGlsZC5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKS5yaWdodCAtIGJveC5sZWZ0IC0gMTsgfVxuICAgICAgfVxuICAgICAgdmFyIGRpZmYgPSBjdXIubGluZS5oZWlnaHQgLSBoZWlnaHQ7XG4gICAgICBpZiAoZGlmZiA+IC4wMDUgfHwgZGlmZiA8IC0uMDA1KSB7XG4gICAgICAgIGlmIChvbGRIZWlnaHQgPCB2aWV3VG9wKSB7IG11c3RTY3JvbGwgLT0gZGlmZjsgfVxuICAgICAgICB1cGRhdGVMaW5lSGVpZ2h0KGN1ci5saW5lLCBoZWlnaHQpO1xuICAgICAgICB1cGRhdGVXaWRnZXRIZWlnaHQoY3VyLmxpbmUpO1xuICAgICAgICBpZiAoY3VyLnJlc3QpIHsgZm9yICh2YXIgaiA9IDA7IGogPCBjdXIucmVzdC5sZW5ndGg7IGorKylcbiAgICAgICAgICB7IHVwZGF0ZVdpZGdldEhlaWdodChjdXIucmVzdFtqXSk7IH0gfVxuICAgICAgfVxuICAgICAgaWYgKHdpZHRoID4gY20uZGlzcGxheS5zaXplcldpZHRoKSB7XG4gICAgICAgIHZhciBjaFdpZHRoID0gTWF0aC5jZWlsKHdpZHRoIC8gY2hhcldpZHRoKGNtLmRpc3BsYXkpKTtcbiAgICAgICAgaWYgKGNoV2lkdGggPiBjbS5kaXNwbGF5Lm1heExpbmVMZW5ndGgpIHtcbiAgICAgICAgICBjbS5kaXNwbGF5Lm1heExpbmVMZW5ndGggPSBjaFdpZHRoO1xuICAgICAgICAgIGNtLmRpc3BsYXkubWF4TGluZSA9IGN1ci5saW5lO1xuICAgICAgICAgIGNtLmRpc3BsYXkubWF4TGluZUNoYW5nZWQgPSB0cnVlO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICAgIGlmIChNYXRoLmFicyhtdXN0U2Nyb2xsKSA+IDIpIHsgZGlzcGxheS5zY3JvbGxlci5zY3JvbGxUb3AgKz0gbXVzdFNjcm9sbDsgfVxuICB9XG5cbiAgLy8gUmVhZCBhbmQgc3RvcmUgdGhlIGhlaWdodCBvZiBsaW5lIHdpZGdldHMgYXNzb2NpYXRlZCB3aXRoIHRoZVxuICAvLyBnaXZlbiBsaW5lLlxuICBmdW5jdGlvbiB1cGRhdGVXaWRnZXRIZWlnaHQobGluZSkge1xuICAgIGlmIChsaW5lLndpZGdldHMpIHsgZm9yICh2YXIgaSA9IDA7IGkgPCBsaW5lLndpZGdldHMubGVuZ3RoOyArK2kpIHtcbiAgICAgIHZhciB3ID0gbGluZS53aWRnZXRzW2ldLCBwYXJlbnQgPSB3Lm5vZGUucGFyZW50Tm9kZTtcbiAgICAgIGlmIChwYXJlbnQpIHsgdy5oZWlnaHQgPSBwYXJlbnQub2Zmc2V0SGVpZ2h0OyB9XG4gICAgfSB9XG4gIH1cblxuICAvLyBDb21wdXRlIHRoZSBsaW5lcyB0aGF0IGFyZSB2aXNpYmxlIGluIGEgZ2l2ZW4gdmlld3BvcnQgKGRlZmF1bHRzXG4gIC8vIHRoZSB0aGUgY3VycmVudCBzY3JvbGwgcG9zaXRpb24pLiB2aWV3cG9ydCBtYXkgY29udGFpbiB0b3AsXG4gIC8vIGhlaWdodCwgYW5kIGVuc3VyZSAoc2VlIG9wLnNjcm9sbFRvUG9zKSBwcm9wZXJ0aWVzLlxuICBmdW5jdGlvbiB2aXNpYmxlTGluZXMoZGlzcGxheSwgZG9jLCB2aWV3cG9ydCkge1xuICAgIHZhciB0b3AgPSB2aWV3cG9ydCAmJiB2aWV3cG9ydC50b3AgIT0gbnVsbCA/IE1hdGgubWF4KDAsIHZpZXdwb3J0LnRvcCkgOiBkaXNwbGF5LnNjcm9sbGVyLnNjcm9sbFRvcDtcbiAgICB0b3AgPSBNYXRoLmZsb29yKHRvcCAtIHBhZGRpbmdUb3AoZGlzcGxheSkpO1xuICAgIHZhciBib3R0b20gPSB2aWV3cG9ydCAmJiB2aWV3cG9ydC5ib3R0b20gIT0gbnVsbCA/IHZpZXdwb3J0LmJvdHRvbSA6IHRvcCArIGRpc3BsYXkud3JhcHBlci5jbGllbnRIZWlnaHQ7XG5cbiAgICB2YXIgZnJvbSA9IGxpbmVBdEhlaWdodChkb2MsIHRvcCksIHRvID0gbGluZUF0SGVpZ2h0KGRvYywgYm90dG9tKTtcbiAgICAvLyBFbnN1cmUgaXMgYSB7ZnJvbToge2xpbmUsIGNofSwgdG86IHtsaW5lLCBjaH19IG9iamVjdCwgYW5kXG4gICAgLy8gZm9yY2VzIHRob3NlIGxpbmVzIGludG8gdGhlIHZpZXdwb3J0IChpZiBwb3NzaWJsZSkuXG4gICAgaWYgKHZpZXdwb3J0ICYmIHZpZXdwb3J0LmVuc3VyZSkge1xuICAgICAgdmFyIGVuc3VyZUZyb20gPSB2aWV3cG9ydC5lbnN1cmUuZnJvbS5saW5lLCBlbnN1cmVUbyA9IHZpZXdwb3J0LmVuc3VyZS50by5saW5lO1xuICAgICAgaWYgKGVuc3VyZUZyb20gPCBmcm9tKSB7XG4gICAgICAgIGZyb20gPSBlbnN1cmVGcm9tO1xuICAgICAgICB0byA9IGxpbmVBdEhlaWdodChkb2MsIGhlaWdodEF0TGluZShnZXRMaW5lKGRvYywgZW5zdXJlRnJvbSkpICsgZGlzcGxheS53cmFwcGVyLmNsaWVudEhlaWdodCk7XG4gICAgICB9IGVsc2UgaWYgKE1hdGgubWluKGVuc3VyZVRvLCBkb2MubGFzdExpbmUoKSkgPj0gdG8pIHtcbiAgICAgICAgZnJvbSA9IGxpbmVBdEhlaWdodChkb2MsIGhlaWdodEF0TGluZShnZXRMaW5lKGRvYywgZW5zdXJlVG8pKSAtIGRpc3BsYXkud3JhcHBlci5jbGllbnRIZWlnaHQpO1xuICAgICAgICB0byA9IGVuc3VyZVRvO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4ge2Zyb206IGZyb20sIHRvOiBNYXRoLm1heCh0bywgZnJvbSArIDEpfVxuICB9XG5cbiAgLy8gU0NST0xMSU5HIFRISU5HUyBJTlRPIFZJRVdcblxuICAvLyBJZiBhbiBlZGl0b3Igc2l0cyBvbiB0aGUgdG9wIG9yIGJvdHRvbSBvZiB0aGUgd2luZG93LCBwYXJ0aWFsbHlcbiAgLy8gc2Nyb2xsZWQgb3V0IG9mIHZpZXcsIHRoaXMgZW5zdXJlcyB0aGF0IHRoZSBjdXJzb3IgaXMgdmlzaWJsZS5cbiAgZnVuY3Rpb24gbWF5YmVTY3JvbGxXaW5kb3coY20sIHJlY3QpIHtcbiAgICBpZiAoc2lnbmFsRE9NRXZlbnQoY20sIFwic2Nyb2xsQ3Vyc29ySW50b1ZpZXdcIikpIHsgcmV0dXJuIH1cblxuICAgIHZhciBkaXNwbGF5ID0gY20uZGlzcGxheSwgYm94ID0gZGlzcGxheS5zaXplci5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKSwgZG9TY3JvbGwgPSBudWxsO1xuICAgIGlmIChyZWN0LnRvcCArIGJveC50b3AgPCAwKSB7IGRvU2Nyb2xsID0gdHJ1ZTsgfVxuICAgIGVsc2UgaWYgKHJlY3QuYm90dG9tICsgYm94LnRvcCA+ICh3aW5kb3cuaW5uZXJIZWlnaHQgfHwgZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50LmNsaWVudEhlaWdodCkpIHsgZG9TY3JvbGwgPSBmYWxzZTsgfVxuICAgIGlmIChkb1Njcm9sbCAhPSBudWxsICYmICFwaGFudG9tKSB7XG4gICAgICB2YXIgc2Nyb2xsTm9kZSA9IGVsdChcImRpdlwiLCBcIlxcdTIwMGJcIiwgbnVsbCwgKFwicG9zaXRpb246IGFic29sdXRlO1xcbiAgICAgICAgICAgICAgICAgICAgICAgICB0b3A6IFwiICsgKHJlY3QudG9wIC0gZGlzcGxheS52aWV3T2Zmc2V0IC0gcGFkZGluZ1RvcChjbS5kaXNwbGF5KSkgKyBcInB4O1xcbiAgICAgICAgICAgICAgICAgICAgICAgICBoZWlnaHQ6IFwiICsgKHJlY3QuYm90dG9tIC0gcmVjdC50b3AgKyBzY3JvbGxHYXAoY20pICsgZGlzcGxheS5iYXJIZWlnaHQpICsgXCJweDtcXG4gICAgICAgICAgICAgICAgICAgICAgICAgbGVmdDogXCIgKyAocmVjdC5sZWZ0KSArIFwicHg7IHdpZHRoOiBcIiArIChNYXRoLm1heCgyLCByZWN0LnJpZ2h0IC0gcmVjdC5sZWZ0KSkgKyBcInB4O1wiKSk7XG4gICAgICBjbS5kaXNwbGF5LmxpbmVTcGFjZS5hcHBlbmRDaGlsZChzY3JvbGxOb2RlKTtcbiAgICAgIHNjcm9sbE5vZGUuc2Nyb2xsSW50b1ZpZXcoZG9TY3JvbGwpO1xuICAgICAgY20uZGlzcGxheS5saW5lU3BhY2UucmVtb3ZlQ2hpbGQoc2Nyb2xsTm9kZSk7XG4gICAgfVxuICB9XG5cbiAgLy8gU2Nyb2xsIGEgZ2l2ZW4gcG9zaXRpb24gaW50byB2aWV3IChpbW1lZGlhdGVseSksIHZlcmlmeWluZyB0aGF0XG4gIC8vIGl0IGFjdHVhbGx5IGJlY2FtZSB2aXNpYmxlIChhcyBsaW5lIGhlaWdodHMgYXJlIGFjY3VyYXRlbHlcbiAgLy8gbWVhc3VyZWQsIHRoZSBwb3NpdGlvbiBvZiBzb21ldGhpbmcgbWF5ICdkcmlmdCcgZHVyaW5nIGRyYXdpbmcpLlxuICBmdW5jdGlvbiBzY3JvbGxQb3NJbnRvVmlldyhjbSwgcG9zLCBlbmQsIG1hcmdpbikge1xuICAgIGlmIChtYXJnaW4gPT0gbnVsbCkgeyBtYXJnaW4gPSAwOyB9XG4gICAgdmFyIHJlY3Q7XG4gICAgaWYgKCFjbS5vcHRpb25zLmxpbmVXcmFwcGluZyAmJiBwb3MgPT0gZW5kKSB7XG4gICAgICAvLyBTZXQgcG9zIGFuZCBlbmQgdG8gdGhlIGN1cnNvciBwb3NpdGlvbnMgYXJvdW5kIHRoZSBjaGFyYWN0ZXIgcG9zIHN0aWNrcyB0b1xuICAgICAgLy8gSWYgcG9zLnN0aWNreSA9PSBcImJlZm9yZVwiLCB0aGF0IGlzIGFyb3VuZCBwb3MuY2ggLSAxLCBvdGhlcndpc2UgYXJvdW5kIHBvcy5jaFxuICAgICAgLy8gSWYgcG9zID09IFBvcyhfLCAwLCBcImJlZm9yZVwiKSwgcG9zIGFuZCBlbmQgYXJlIHVuY2hhbmdlZFxuICAgICAgZW5kID0gcG9zLnN0aWNreSA9PSBcImJlZm9yZVwiID8gUG9zKHBvcy5saW5lLCBwb3MuY2ggKyAxLCBcImJlZm9yZVwiKSA6IHBvcztcbiAgICAgIHBvcyA9IHBvcy5jaCA/IFBvcyhwb3MubGluZSwgcG9zLnN0aWNreSA9PSBcImJlZm9yZVwiID8gcG9zLmNoIC0gMSA6IHBvcy5jaCwgXCJhZnRlclwiKSA6IHBvcztcbiAgICB9XG4gICAgZm9yICh2YXIgbGltaXQgPSAwOyBsaW1pdCA8IDU7IGxpbWl0KyspIHtcbiAgICAgIHZhciBjaGFuZ2VkID0gZmFsc2U7XG4gICAgICB2YXIgY29vcmRzID0gY3Vyc29yQ29vcmRzKGNtLCBwb3MpO1xuICAgICAgdmFyIGVuZENvb3JkcyA9ICFlbmQgfHwgZW5kID09IHBvcyA/IGNvb3JkcyA6IGN1cnNvckNvb3JkcyhjbSwgZW5kKTtcbiAgICAgIHJlY3QgPSB7bGVmdDogTWF0aC5taW4oY29vcmRzLmxlZnQsIGVuZENvb3Jkcy5sZWZ0KSxcbiAgICAgICAgICAgICAgdG9wOiBNYXRoLm1pbihjb29yZHMudG9wLCBlbmRDb29yZHMudG9wKSAtIG1hcmdpbixcbiAgICAgICAgICAgICAgcmlnaHQ6IE1hdGgubWF4KGNvb3Jkcy5sZWZ0LCBlbmRDb29yZHMubGVmdCksXG4gICAgICAgICAgICAgIGJvdHRvbTogTWF0aC5tYXgoY29vcmRzLmJvdHRvbSwgZW5kQ29vcmRzLmJvdHRvbSkgKyBtYXJnaW59O1xuICAgICAgdmFyIHNjcm9sbFBvcyA9IGNhbGN1bGF0ZVNjcm9sbFBvcyhjbSwgcmVjdCk7XG4gICAgICB2YXIgc3RhcnRUb3AgPSBjbS5kb2Muc2Nyb2xsVG9wLCBzdGFydExlZnQgPSBjbS5kb2Muc2Nyb2xsTGVmdDtcbiAgICAgIGlmIChzY3JvbGxQb3Muc2Nyb2xsVG9wICE9IG51bGwpIHtcbiAgICAgICAgdXBkYXRlU2Nyb2xsVG9wKGNtLCBzY3JvbGxQb3Muc2Nyb2xsVG9wKTtcbiAgICAgICAgaWYgKE1hdGguYWJzKGNtLmRvYy5zY3JvbGxUb3AgLSBzdGFydFRvcCkgPiAxKSB7IGNoYW5nZWQgPSB0cnVlOyB9XG4gICAgICB9XG4gICAgICBpZiAoc2Nyb2xsUG9zLnNjcm9sbExlZnQgIT0gbnVsbCkge1xuICAgICAgICBzZXRTY3JvbGxMZWZ0KGNtLCBzY3JvbGxQb3Muc2Nyb2xsTGVmdCk7XG4gICAgICAgIGlmIChNYXRoLmFicyhjbS5kb2Muc2Nyb2xsTGVmdCAtIHN0YXJ0TGVmdCkgPiAxKSB7IGNoYW5nZWQgPSB0cnVlOyB9XG4gICAgICB9XG4gICAgICBpZiAoIWNoYW5nZWQpIHsgYnJlYWsgfVxuICAgIH1cbiAgICByZXR1cm4gcmVjdFxuICB9XG5cbiAgLy8gU2Nyb2xsIGEgZ2l2ZW4gc2V0IG9mIGNvb3JkaW5hdGVzIGludG8gdmlldyAoaW1tZWRpYXRlbHkpLlxuICBmdW5jdGlvbiBzY3JvbGxJbnRvVmlldyhjbSwgcmVjdCkge1xuICAgIHZhciBzY3JvbGxQb3MgPSBjYWxjdWxhdGVTY3JvbGxQb3MoY20sIHJlY3QpO1xuICAgIGlmIChzY3JvbGxQb3Muc2Nyb2xsVG9wICE9IG51bGwpIHsgdXBkYXRlU2Nyb2xsVG9wKGNtLCBzY3JvbGxQb3Muc2Nyb2xsVG9wKTsgfVxuICAgIGlmIChzY3JvbGxQb3Muc2Nyb2xsTGVmdCAhPSBudWxsKSB7IHNldFNjcm9sbExlZnQoY20sIHNjcm9sbFBvcy5zY3JvbGxMZWZ0KTsgfVxuICB9XG5cbiAgLy8gQ2FsY3VsYXRlIGEgbmV3IHNjcm9sbCBwb3NpdGlvbiBuZWVkZWQgdG8gc2Nyb2xsIHRoZSBnaXZlblxuICAvLyByZWN0YW5nbGUgaW50byB2aWV3LiBSZXR1cm5zIGFuIG9iamVjdCB3aXRoIHNjcm9sbFRvcCBhbmRcbiAgLy8gc2Nyb2xsTGVmdCBwcm9wZXJ0aWVzLiBXaGVuIHRoZXNlIGFyZSB1bmRlZmluZWQsIHRoZVxuICAvLyB2ZXJ0aWNhbC9ob3Jpem9udGFsIHBvc2l0aW9uIGRvZXMgbm90IG5lZWQgdG8gYmUgYWRqdXN0ZWQuXG4gIGZ1bmN0aW9uIGNhbGN1bGF0ZVNjcm9sbFBvcyhjbSwgcmVjdCkge1xuICAgIHZhciBkaXNwbGF5ID0gY20uZGlzcGxheSwgc25hcE1hcmdpbiA9IHRleHRIZWlnaHQoY20uZGlzcGxheSk7XG4gICAgaWYgKHJlY3QudG9wIDwgMCkgeyByZWN0LnRvcCA9IDA7IH1cbiAgICB2YXIgc2NyZWVudG9wID0gY20uY3VyT3AgJiYgY20uY3VyT3Auc2Nyb2xsVG9wICE9IG51bGwgPyBjbS5jdXJPcC5zY3JvbGxUb3AgOiBkaXNwbGF5LnNjcm9sbGVyLnNjcm9sbFRvcDtcbiAgICB2YXIgc2NyZWVuID0gZGlzcGxheUhlaWdodChjbSksIHJlc3VsdCA9IHt9O1xuICAgIGlmIChyZWN0LmJvdHRvbSAtIHJlY3QudG9wID4gc2NyZWVuKSB7IHJlY3QuYm90dG9tID0gcmVjdC50b3AgKyBzY3JlZW47IH1cbiAgICB2YXIgZG9jQm90dG9tID0gY20uZG9jLmhlaWdodCArIHBhZGRpbmdWZXJ0KGRpc3BsYXkpO1xuICAgIHZhciBhdFRvcCA9IHJlY3QudG9wIDwgc25hcE1hcmdpbiwgYXRCb3R0b20gPSByZWN0LmJvdHRvbSA+IGRvY0JvdHRvbSAtIHNuYXBNYXJnaW47XG4gICAgaWYgKHJlY3QudG9wIDwgc2NyZWVudG9wKSB7XG4gICAgICByZXN1bHQuc2Nyb2xsVG9wID0gYXRUb3AgPyAwIDogcmVjdC50b3A7XG4gICAgfSBlbHNlIGlmIChyZWN0LmJvdHRvbSA+IHNjcmVlbnRvcCArIHNjcmVlbikge1xuICAgICAgdmFyIG5ld1RvcCA9IE1hdGgubWluKHJlY3QudG9wLCAoYXRCb3R0b20gPyBkb2NCb3R0b20gOiByZWN0LmJvdHRvbSkgLSBzY3JlZW4pO1xuICAgICAgaWYgKG5ld1RvcCAhPSBzY3JlZW50b3ApIHsgcmVzdWx0LnNjcm9sbFRvcCA9IG5ld1RvcDsgfVxuICAgIH1cblxuICAgIHZhciBndXR0ZXJTcGFjZSA9IGNtLm9wdGlvbnMuZml4ZWRHdXR0ZXIgPyAwIDogZGlzcGxheS5ndXR0ZXJzLm9mZnNldFdpZHRoO1xuICAgIHZhciBzY3JlZW5sZWZ0ID0gY20uY3VyT3AgJiYgY20uY3VyT3Auc2Nyb2xsTGVmdCAhPSBudWxsID8gY20uY3VyT3Auc2Nyb2xsTGVmdCA6IGRpc3BsYXkuc2Nyb2xsZXIuc2Nyb2xsTGVmdCAtIGd1dHRlclNwYWNlO1xuICAgIHZhciBzY3JlZW53ID0gZGlzcGxheVdpZHRoKGNtKSAtIGRpc3BsYXkuZ3V0dGVycy5vZmZzZXRXaWR0aDtcbiAgICB2YXIgdG9vV2lkZSA9IHJlY3QucmlnaHQgLSByZWN0LmxlZnQgPiBzY3JlZW53O1xuICAgIGlmICh0b29XaWRlKSB7IHJlY3QucmlnaHQgPSByZWN0LmxlZnQgKyBzY3JlZW53OyB9XG4gICAgaWYgKHJlY3QubGVmdCA8IDEwKVxuICAgICAgeyByZXN1bHQuc2Nyb2xsTGVmdCA9IDA7IH1cbiAgICBlbHNlIGlmIChyZWN0LmxlZnQgPCBzY3JlZW5sZWZ0KVxuICAgICAgeyByZXN1bHQuc2Nyb2xsTGVmdCA9IE1hdGgubWF4KDAsIHJlY3QubGVmdCArIGd1dHRlclNwYWNlIC0gKHRvb1dpZGUgPyAwIDogMTApKTsgfVxuICAgIGVsc2UgaWYgKHJlY3QucmlnaHQgPiBzY3JlZW53ICsgc2NyZWVubGVmdCAtIDMpXG4gICAgICB7IHJlc3VsdC5zY3JvbGxMZWZ0ID0gcmVjdC5yaWdodCArICh0b29XaWRlID8gMCA6IDEwKSAtIHNjcmVlbnc7IH1cbiAgICByZXR1cm4gcmVzdWx0XG4gIH1cblxuICAvLyBTdG9yZSBhIHJlbGF0aXZlIGFkanVzdG1lbnQgdG8gdGhlIHNjcm9sbCBwb3NpdGlvbiBpbiB0aGUgY3VycmVudFxuICAvLyBvcGVyYXRpb24gKHRvIGJlIGFwcGxpZWQgd2hlbiB0aGUgb3BlcmF0aW9uIGZpbmlzaGVzKS5cbiAgZnVuY3Rpb24gYWRkVG9TY3JvbGxUb3AoY20sIHRvcCkge1xuICAgIGlmICh0b3AgPT0gbnVsbCkgeyByZXR1cm4gfVxuICAgIHJlc29sdmVTY3JvbGxUb1BvcyhjbSk7XG4gICAgY20uY3VyT3Auc2Nyb2xsVG9wID0gKGNtLmN1ck9wLnNjcm9sbFRvcCA9PSBudWxsID8gY20uZG9jLnNjcm9sbFRvcCA6IGNtLmN1ck9wLnNjcm9sbFRvcCkgKyB0b3A7XG4gIH1cblxuICAvLyBNYWtlIHN1cmUgdGhhdCBhdCB0aGUgZW5kIG9mIHRoZSBvcGVyYXRpb24gdGhlIGN1cnJlbnQgY3Vyc29yIGlzXG4gIC8vIHNob3duLlxuICBmdW5jdGlvbiBlbnN1cmVDdXJzb3JWaXNpYmxlKGNtKSB7XG4gICAgcmVzb2x2ZVNjcm9sbFRvUG9zKGNtKTtcbiAgICB2YXIgY3VyID0gY20uZ2V0Q3Vyc29yKCk7XG4gICAgY20uY3VyT3Auc2Nyb2xsVG9Qb3MgPSB7ZnJvbTogY3VyLCB0bzogY3VyLCBtYXJnaW46IGNtLm9wdGlvbnMuY3Vyc29yU2Nyb2xsTWFyZ2lufTtcbiAgfVxuXG4gIGZ1bmN0aW9uIHNjcm9sbFRvQ29vcmRzKGNtLCB4LCB5KSB7XG4gICAgaWYgKHggIT0gbnVsbCB8fCB5ICE9IG51bGwpIHsgcmVzb2x2ZVNjcm9sbFRvUG9zKGNtKTsgfVxuICAgIGlmICh4ICE9IG51bGwpIHsgY20uY3VyT3Auc2Nyb2xsTGVmdCA9IHg7IH1cbiAgICBpZiAoeSAhPSBudWxsKSB7IGNtLmN1ck9wLnNjcm9sbFRvcCA9IHk7IH1cbiAgfVxuXG4gIGZ1bmN0aW9uIHNjcm9sbFRvUmFuZ2UoY20sIHJhbmdlKSB7XG4gICAgcmVzb2x2ZVNjcm9sbFRvUG9zKGNtKTtcbiAgICBjbS5jdXJPcC5zY3JvbGxUb1BvcyA9IHJhbmdlO1xuICB9XG5cbiAgLy8gV2hlbiBhbiBvcGVyYXRpb24gaGFzIGl0cyBzY3JvbGxUb1BvcyBwcm9wZXJ0eSBzZXQsIGFuZCBhbm90aGVyXG4gIC8vIHNjcm9sbCBhY3Rpb24gaXMgYXBwbGllZCBiZWZvcmUgdGhlIGVuZCBvZiB0aGUgb3BlcmF0aW9uLCB0aGlzXG4gIC8vICdzaW11bGF0ZXMnIHNjcm9sbGluZyB0aGF0IHBvc2l0aW9uIGludG8gdmlldyBpbiBhIGNoZWFwIHdheSwgc29cbiAgLy8gdGhhdCB0aGUgZWZmZWN0IG9mIGludGVybWVkaWF0ZSBzY3JvbGwgY29tbWFuZHMgaXMgbm90IGlnbm9yZWQuXG4gIGZ1bmN0aW9uIHJlc29sdmVTY3JvbGxUb1BvcyhjbSkge1xuICAgIHZhciByYW5nZSA9IGNtLmN1ck9wLnNjcm9sbFRvUG9zO1xuICAgIGlmIChyYW5nZSkge1xuICAgICAgY20uY3VyT3Auc2Nyb2xsVG9Qb3MgPSBudWxsO1xuICAgICAgdmFyIGZyb20gPSBlc3RpbWF0ZUNvb3JkcyhjbSwgcmFuZ2UuZnJvbSksIHRvID0gZXN0aW1hdGVDb29yZHMoY20sIHJhbmdlLnRvKTtcbiAgICAgIHNjcm9sbFRvQ29vcmRzUmFuZ2UoY20sIGZyb20sIHRvLCByYW5nZS5tYXJnaW4pO1xuICAgIH1cbiAgfVxuXG4gIGZ1bmN0aW9uIHNjcm9sbFRvQ29vcmRzUmFuZ2UoY20sIGZyb20sIHRvLCBtYXJnaW4pIHtcbiAgICB2YXIgc1BvcyA9IGNhbGN1bGF0ZVNjcm9sbFBvcyhjbSwge1xuICAgICAgbGVmdDogTWF0aC5taW4oZnJvbS5sZWZ0LCB0by5sZWZ0KSxcbiAgICAgIHRvcDogTWF0aC5taW4oZnJvbS50b3AsIHRvLnRvcCkgLSBtYXJnaW4sXG4gICAgICByaWdodDogTWF0aC5tYXgoZnJvbS5yaWdodCwgdG8ucmlnaHQpLFxuICAgICAgYm90dG9tOiBNYXRoLm1heChmcm9tLmJvdHRvbSwgdG8uYm90dG9tKSArIG1hcmdpblxuICAgIH0pO1xuICAgIHNjcm9sbFRvQ29vcmRzKGNtLCBzUG9zLnNjcm9sbExlZnQsIHNQb3Muc2Nyb2xsVG9wKTtcbiAgfVxuXG4gIC8vIFN5bmMgdGhlIHNjcm9sbGFibGUgYXJlYSBhbmQgc2Nyb2xsYmFycywgZW5zdXJlIHRoZSB2aWV3cG9ydFxuICAvLyBjb3ZlcnMgdGhlIHZpc2libGUgYXJlYS5cbiAgZnVuY3Rpb24gdXBkYXRlU2Nyb2xsVG9wKGNtLCB2YWwpIHtcbiAgICBpZiAoTWF0aC5hYnMoY20uZG9jLnNjcm9sbFRvcCAtIHZhbCkgPCAyKSB7IHJldHVybiB9XG4gICAgaWYgKCFnZWNrbykgeyB1cGRhdGVEaXNwbGF5U2ltcGxlKGNtLCB7dG9wOiB2YWx9KTsgfVxuICAgIHNldFNjcm9sbFRvcChjbSwgdmFsLCB0cnVlKTtcbiAgICBpZiAoZ2Vja28pIHsgdXBkYXRlRGlzcGxheVNpbXBsZShjbSk7IH1cbiAgICBzdGFydFdvcmtlcihjbSwgMTAwKTtcbiAgfVxuXG4gIGZ1bmN0aW9uIHNldFNjcm9sbFRvcChjbSwgdmFsLCBmb3JjZVNjcm9sbCkge1xuICAgIHZhbCA9IE1hdGgubWF4KDAsIE1hdGgubWluKGNtLmRpc3BsYXkuc2Nyb2xsZXIuc2Nyb2xsSGVpZ2h0IC0gY20uZGlzcGxheS5zY3JvbGxlci5jbGllbnRIZWlnaHQsIHZhbCkpO1xuICAgIGlmIChjbS5kaXNwbGF5LnNjcm9sbGVyLnNjcm9sbFRvcCA9PSB2YWwgJiYgIWZvcmNlU2Nyb2xsKSB7IHJldHVybiB9XG4gICAgY20uZG9jLnNjcm9sbFRvcCA9IHZhbDtcbiAgICBjbS5kaXNwbGF5LnNjcm9sbGJhcnMuc2V0U2Nyb2xsVG9wKHZhbCk7XG4gICAgaWYgKGNtLmRpc3BsYXkuc2Nyb2xsZXIuc2Nyb2xsVG9wICE9IHZhbCkgeyBjbS5kaXNwbGF5LnNjcm9sbGVyLnNjcm9sbFRvcCA9IHZhbDsgfVxuICB9XG5cbiAgLy8gU3luYyBzY3JvbGxlciBhbmQgc2Nyb2xsYmFyLCBlbnN1cmUgdGhlIGd1dHRlciBlbGVtZW50cyBhcmVcbiAgLy8gYWxpZ25lZC5cbiAgZnVuY3Rpb24gc2V0U2Nyb2xsTGVmdChjbSwgdmFsLCBpc1Njcm9sbGVyLCBmb3JjZVNjcm9sbCkge1xuICAgIHZhbCA9IE1hdGgubWF4KDAsIE1hdGgubWluKHZhbCwgY20uZGlzcGxheS5zY3JvbGxlci5zY3JvbGxXaWR0aCAtIGNtLmRpc3BsYXkuc2Nyb2xsZXIuY2xpZW50V2lkdGgpKTtcbiAgICBpZiAoKGlzU2Nyb2xsZXIgPyB2YWwgPT0gY20uZG9jLnNjcm9sbExlZnQgOiBNYXRoLmFicyhjbS5kb2Muc2Nyb2xsTGVmdCAtIHZhbCkgPCAyKSAmJiAhZm9yY2VTY3JvbGwpIHsgcmV0dXJuIH1cbiAgICBjbS5kb2Muc2Nyb2xsTGVmdCA9IHZhbDtcbiAgICBhbGlnbkhvcml6b250YWxseShjbSk7XG4gICAgaWYgKGNtLmRpc3BsYXkuc2Nyb2xsZXIuc2Nyb2xsTGVmdCAhPSB2YWwpIHsgY20uZGlzcGxheS5zY3JvbGxlci5zY3JvbGxMZWZ0ID0gdmFsOyB9XG4gICAgY20uZGlzcGxheS5zY3JvbGxiYXJzLnNldFNjcm9sbExlZnQodmFsKTtcbiAgfVxuXG4gIC8vIFNDUk9MTEJBUlNcblxuICAvLyBQcmVwYXJlIERPTSByZWFkcyBuZWVkZWQgdG8gdXBkYXRlIHRoZSBzY3JvbGxiYXJzLiBEb25lIGluIG9uZVxuICAvLyBzaG90IHRvIG1pbmltaXplIHVwZGF0ZS9tZWFzdXJlIHJvdW5kdHJpcHMuXG4gIGZ1bmN0aW9uIG1lYXN1cmVGb3JTY3JvbGxiYXJzKGNtKSB7XG4gICAgdmFyIGQgPSBjbS5kaXNwbGF5LCBndXR0ZXJXID0gZC5ndXR0ZXJzLm9mZnNldFdpZHRoO1xuICAgIHZhciBkb2NIID0gTWF0aC5yb3VuZChjbS5kb2MuaGVpZ2h0ICsgcGFkZGluZ1ZlcnQoY20uZGlzcGxheSkpO1xuICAgIHJldHVybiB7XG4gICAgICBjbGllbnRIZWlnaHQ6IGQuc2Nyb2xsZXIuY2xpZW50SGVpZ2h0LFxuICAgICAgdmlld0hlaWdodDogZC53cmFwcGVyLmNsaWVudEhlaWdodCxcbiAgICAgIHNjcm9sbFdpZHRoOiBkLnNjcm9sbGVyLnNjcm9sbFdpZHRoLCBjbGllbnRXaWR0aDogZC5zY3JvbGxlci5jbGllbnRXaWR0aCxcbiAgICAgIHZpZXdXaWR0aDogZC53cmFwcGVyLmNsaWVudFdpZHRoLFxuICAgICAgYmFyTGVmdDogY20ub3B0aW9ucy5maXhlZEd1dHRlciA/IGd1dHRlclcgOiAwLFxuICAgICAgZG9jSGVpZ2h0OiBkb2NILFxuICAgICAgc2Nyb2xsSGVpZ2h0OiBkb2NIICsgc2Nyb2xsR2FwKGNtKSArIGQuYmFySGVpZ2h0LFxuICAgICAgbmF0aXZlQmFyV2lkdGg6IGQubmF0aXZlQmFyV2lkdGgsXG4gICAgICBndXR0ZXJXaWR0aDogZ3V0dGVyV1xuICAgIH1cbiAgfVxuXG4gIHZhciBOYXRpdmVTY3JvbGxiYXJzID0gZnVuY3Rpb24ocGxhY2UsIHNjcm9sbCwgY20pIHtcbiAgICB0aGlzLmNtID0gY207XG4gICAgdmFyIHZlcnQgPSB0aGlzLnZlcnQgPSBlbHQoXCJkaXZcIiwgW2VsdChcImRpdlwiLCBudWxsLCBudWxsLCBcIm1pbi13aWR0aDogMXB4XCIpXSwgXCJDb2RlTWlycm9yLXZzY3JvbGxiYXJcIik7XG4gICAgdmFyIGhvcml6ID0gdGhpcy5ob3JpeiA9IGVsdChcImRpdlwiLCBbZWx0KFwiZGl2XCIsIG51bGwsIG51bGwsIFwiaGVpZ2h0OiAxMDAlOyBtaW4taGVpZ2h0OiAxcHhcIildLCBcIkNvZGVNaXJyb3ItaHNjcm9sbGJhclwiKTtcbiAgICB2ZXJ0LnRhYkluZGV4ID0gaG9yaXoudGFiSW5kZXggPSAtMTtcbiAgICBwbGFjZSh2ZXJ0KTsgcGxhY2UoaG9yaXopO1xuXG4gICAgb24odmVydCwgXCJzY3JvbGxcIiwgZnVuY3Rpb24gKCkge1xuICAgICAgaWYgKHZlcnQuY2xpZW50SGVpZ2h0KSB7IHNjcm9sbCh2ZXJ0LnNjcm9sbFRvcCwgXCJ2ZXJ0aWNhbFwiKTsgfVxuICAgIH0pO1xuICAgIG9uKGhvcml6LCBcInNjcm9sbFwiLCBmdW5jdGlvbiAoKSB7XG4gICAgICBpZiAoaG9yaXouY2xpZW50V2lkdGgpIHsgc2Nyb2xsKGhvcml6LnNjcm9sbExlZnQsIFwiaG9yaXpvbnRhbFwiKTsgfVxuICAgIH0pO1xuXG4gICAgdGhpcy5jaGVja2VkWmVyb1dpZHRoID0gZmFsc2U7XG4gICAgLy8gTmVlZCB0byBzZXQgYSBtaW5pbXVtIHdpZHRoIHRvIHNlZSB0aGUgc2Nyb2xsYmFyIG9uIElFNyAoYnV0IG11c3Qgbm90IHNldCBpdCBvbiBJRTgpLlxuICAgIGlmIChpZSAmJiBpZV92ZXJzaW9uIDwgOCkgeyB0aGlzLmhvcml6LnN0eWxlLm1pbkhlaWdodCA9IHRoaXMudmVydC5zdHlsZS5taW5XaWR0aCA9IFwiMThweFwiOyB9XG4gIH07XG5cbiAgTmF0aXZlU2Nyb2xsYmFycy5wcm90b3R5cGUudXBkYXRlID0gZnVuY3Rpb24gKG1lYXN1cmUpIHtcbiAgICB2YXIgbmVlZHNIID0gbWVhc3VyZS5zY3JvbGxXaWR0aCA+IG1lYXN1cmUuY2xpZW50V2lkdGggKyAxO1xuICAgIHZhciBuZWVkc1YgPSBtZWFzdXJlLnNjcm9sbEhlaWdodCA+IG1lYXN1cmUuY2xpZW50SGVpZ2h0ICsgMTtcbiAgICB2YXIgc1dpZHRoID0gbWVhc3VyZS5uYXRpdmVCYXJXaWR0aDtcblxuICAgIGlmIChuZWVkc1YpIHtcbiAgICAgIHRoaXMudmVydC5zdHlsZS5kaXNwbGF5ID0gXCJibG9ja1wiO1xuICAgICAgdGhpcy52ZXJ0LnN0eWxlLmJvdHRvbSA9IG5lZWRzSCA/IHNXaWR0aCArIFwicHhcIiA6IFwiMFwiO1xuICAgICAgdmFyIHRvdGFsSGVpZ2h0ID0gbWVhc3VyZS52aWV3SGVpZ2h0IC0gKG5lZWRzSCA/IHNXaWR0aCA6IDApO1xuICAgICAgLy8gQSBidWcgaW4gSUU4IGNhbiBjYXVzZSB0aGlzIHZhbHVlIHRvIGJlIG5lZ2F0aXZlLCBzbyBndWFyZCBpdC5cbiAgICAgIHRoaXMudmVydC5maXJzdENoaWxkLnN0eWxlLmhlaWdodCA9XG4gICAgICAgIE1hdGgubWF4KDAsIG1lYXN1cmUuc2Nyb2xsSGVpZ2h0IC0gbWVhc3VyZS5jbGllbnRIZWlnaHQgKyB0b3RhbEhlaWdodCkgKyBcInB4XCI7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMudmVydC5zY3JvbGxUb3AgPSAwO1xuICAgICAgdGhpcy52ZXJ0LnN0eWxlLmRpc3BsYXkgPSBcIlwiO1xuICAgICAgdGhpcy52ZXJ0LmZpcnN0Q2hpbGQuc3R5bGUuaGVpZ2h0ID0gXCIwXCI7XG4gICAgfVxuXG4gICAgaWYgKG5lZWRzSCkge1xuICAgICAgdGhpcy5ob3Jpei5zdHlsZS5kaXNwbGF5ID0gXCJibG9ja1wiO1xuICAgICAgdGhpcy5ob3Jpei5zdHlsZS5yaWdodCA9IG5lZWRzViA/IHNXaWR0aCArIFwicHhcIiA6IFwiMFwiO1xuICAgICAgdGhpcy5ob3Jpei5zdHlsZS5sZWZ0ID0gbWVhc3VyZS5iYXJMZWZ0ICsgXCJweFwiO1xuICAgICAgdmFyIHRvdGFsV2lkdGggPSBtZWFzdXJlLnZpZXdXaWR0aCAtIG1lYXN1cmUuYmFyTGVmdCAtIChuZWVkc1YgPyBzV2lkdGggOiAwKTtcbiAgICAgIHRoaXMuaG9yaXouZmlyc3RDaGlsZC5zdHlsZS53aWR0aCA9XG4gICAgICAgIE1hdGgubWF4KDAsIG1lYXN1cmUuc2Nyb2xsV2lkdGggLSBtZWFzdXJlLmNsaWVudFdpZHRoICsgdG90YWxXaWR0aCkgKyBcInB4XCI7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMuaG9yaXouc3R5bGUuZGlzcGxheSA9IFwiXCI7XG4gICAgICB0aGlzLmhvcml6LmZpcnN0Q2hpbGQuc3R5bGUud2lkdGggPSBcIjBcIjtcbiAgICB9XG5cbiAgICBpZiAoIXRoaXMuY2hlY2tlZFplcm9XaWR0aCAmJiBtZWFzdXJlLmNsaWVudEhlaWdodCA+IDApIHtcbiAgICAgIGlmIChzV2lkdGggPT0gMCkgeyB0aGlzLnplcm9XaWR0aEhhY2soKTsgfVxuICAgICAgdGhpcy5jaGVja2VkWmVyb1dpZHRoID0gdHJ1ZTtcbiAgICB9XG5cbiAgICByZXR1cm4ge3JpZ2h0OiBuZWVkc1YgPyBzV2lkdGggOiAwLCBib3R0b206IG5lZWRzSCA/IHNXaWR0aCA6IDB9XG4gIH07XG5cbiAgTmF0aXZlU2Nyb2xsYmFycy5wcm90b3R5cGUuc2V0U2Nyb2xsTGVmdCA9IGZ1bmN0aW9uIChwb3MpIHtcbiAgICBpZiAodGhpcy5ob3Jpei5zY3JvbGxMZWZ0ICE9IHBvcykgeyB0aGlzLmhvcml6LnNjcm9sbExlZnQgPSBwb3M7IH1cbiAgICBpZiAodGhpcy5kaXNhYmxlSG9yaXopIHsgdGhpcy5lbmFibGVaZXJvV2lkdGhCYXIodGhpcy5ob3JpeiwgdGhpcy5kaXNhYmxlSG9yaXosIFwiaG9yaXpcIik7IH1cbiAgfTtcblxuICBOYXRpdmVTY3JvbGxiYXJzLnByb3RvdHlwZS5zZXRTY3JvbGxUb3AgPSBmdW5jdGlvbiAocG9zKSB7XG4gICAgaWYgKHRoaXMudmVydC5zY3JvbGxUb3AgIT0gcG9zKSB7IHRoaXMudmVydC5zY3JvbGxUb3AgPSBwb3M7IH1cbiAgICBpZiAodGhpcy5kaXNhYmxlVmVydCkgeyB0aGlzLmVuYWJsZVplcm9XaWR0aEJhcih0aGlzLnZlcnQsIHRoaXMuZGlzYWJsZVZlcnQsIFwidmVydFwiKTsgfVxuICB9O1xuXG4gIE5hdGl2ZVNjcm9sbGJhcnMucHJvdG90eXBlLnplcm9XaWR0aEhhY2sgPSBmdW5jdGlvbiAoKSB7XG4gICAgdmFyIHcgPSBtYWMgJiYgIW1hY19nZU1vdW50YWluTGlvbiA/IFwiMTJweFwiIDogXCIxOHB4XCI7XG4gICAgdGhpcy5ob3Jpei5zdHlsZS5oZWlnaHQgPSB0aGlzLnZlcnQuc3R5bGUud2lkdGggPSB3O1xuICAgIHRoaXMuaG9yaXouc3R5bGUucG9pbnRlckV2ZW50cyA9IHRoaXMudmVydC5zdHlsZS5wb2ludGVyRXZlbnRzID0gXCJub25lXCI7XG4gICAgdGhpcy5kaXNhYmxlSG9yaXogPSBuZXcgRGVsYXllZDtcbiAgICB0aGlzLmRpc2FibGVWZXJ0ID0gbmV3IERlbGF5ZWQ7XG4gIH07XG5cbiAgTmF0aXZlU2Nyb2xsYmFycy5wcm90b3R5cGUuZW5hYmxlWmVyb1dpZHRoQmFyID0gZnVuY3Rpb24gKGJhciwgZGVsYXksIHR5cGUpIHtcbiAgICBiYXIuc3R5bGUucG9pbnRlckV2ZW50cyA9IFwiYXV0b1wiO1xuICAgIGZ1bmN0aW9uIG1heWJlRGlzYWJsZSgpIHtcbiAgICAgIC8vIFRvIGZpbmQgb3V0IHdoZXRoZXIgdGhlIHNjcm9sbGJhciBpcyBzdGlsbCB2aXNpYmxlLCB3ZVxuICAgICAgLy8gY2hlY2sgd2hldGhlciB0aGUgZWxlbWVudCB1bmRlciB0aGUgcGl4ZWwgaW4gdGhlIGJvdHRvbVxuICAgICAgLy8gcmlnaHQgY29ybmVyIG9mIHRoZSBzY3JvbGxiYXIgYm94IGlzIHRoZSBzY3JvbGxiYXIgYm94XG4gICAgICAvLyBpdHNlbGYgKHdoZW4gdGhlIGJhciBpcyBzdGlsbCB2aXNpYmxlKSBvciBpdHMgZmlsbGVyIGNoaWxkXG4gICAgICAvLyAod2hlbiB0aGUgYmFyIGlzIGhpZGRlbikuIElmIGl0IGlzIHN0aWxsIHZpc2libGUsIHdlIGtlZXBcbiAgICAgIC8vIGl0IGVuYWJsZWQsIGlmIGl0J3MgaGlkZGVuLCB3ZSBkaXNhYmxlIHBvaW50ZXIgZXZlbnRzLlxuICAgICAgdmFyIGJveCA9IGJhci5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKTtcbiAgICAgIHZhciBlbHQgPSB0eXBlID09IFwidmVydFwiID8gZG9jdW1lbnQuZWxlbWVudEZyb21Qb2ludChib3gucmlnaHQgLSAxLCAoYm94LnRvcCArIGJveC5ib3R0b20pIC8gMilcbiAgICAgICAgICA6IGRvY3VtZW50LmVsZW1lbnRGcm9tUG9pbnQoKGJveC5yaWdodCArIGJveC5sZWZ0KSAvIDIsIGJveC5ib3R0b20gLSAxKTtcbiAgICAgIGlmIChlbHQgIT0gYmFyKSB7IGJhci5zdHlsZS5wb2ludGVyRXZlbnRzID0gXCJub25lXCI7IH1cbiAgICAgIGVsc2UgeyBkZWxheS5zZXQoMTAwMCwgbWF5YmVEaXNhYmxlKTsgfVxuICAgIH1cbiAgICBkZWxheS5zZXQoMTAwMCwgbWF5YmVEaXNhYmxlKTtcbiAgfTtcblxuICBOYXRpdmVTY3JvbGxiYXJzLnByb3RvdHlwZS5jbGVhciA9IGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgcGFyZW50ID0gdGhpcy5ob3Jpei5wYXJlbnROb2RlO1xuICAgIHBhcmVudC5yZW1vdmVDaGlsZCh0aGlzLmhvcml6KTtcbiAgICBwYXJlbnQucmVtb3ZlQ2hpbGQodGhpcy52ZXJ0KTtcbiAgfTtcblxuICB2YXIgTnVsbFNjcm9sbGJhcnMgPSBmdW5jdGlvbiAoKSB7fTtcblxuICBOdWxsU2Nyb2xsYmFycy5wcm90b3R5cGUudXBkYXRlID0gZnVuY3Rpb24gKCkgeyByZXR1cm4ge2JvdHRvbTogMCwgcmlnaHQ6IDB9IH07XG4gIE51bGxTY3JvbGxiYXJzLnByb3RvdHlwZS5zZXRTY3JvbGxMZWZ0ID0gZnVuY3Rpb24gKCkge307XG4gIE51bGxTY3JvbGxiYXJzLnByb3RvdHlwZS5zZXRTY3JvbGxUb3AgPSBmdW5jdGlvbiAoKSB7fTtcbiAgTnVsbFNjcm9sbGJhcnMucHJvdG90eXBlLmNsZWFyID0gZnVuY3Rpb24gKCkge307XG5cbiAgZnVuY3Rpb24gdXBkYXRlU2Nyb2xsYmFycyhjbSwgbWVhc3VyZSkge1xuICAgIGlmICghbWVhc3VyZSkgeyBtZWFzdXJlID0gbWVhc3VyZUZvclNjcm9sbGJhcnMoY20pOyB9XG4gICAgdmFyIHN0YXJ0V2lkdGggPSBjbS5kaXNwbGF5LmJhcldpZHRoLCBzdGFydEhlaWdodCA9IGNtLmRpc3BsYXkuYmFySGVpZ2h0O1xuICAgIHVwZGF0ZVNjcm9sbGJhcnNJbm5lcihjbSwgbWVhc3VyZSk7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCA0ICYmIHN0YXJ0V2lkdGggIT0gY20uZGlzcGxheS5iYXJXaWR0aCB8fCBzdGFydEhlaWdodCAhPSBjbS5kaXNwbGF5LmJhckhlaWdodDsgaSsrKSB7XG4gICAgICBpZiAoc3RhcnRXaWR0aCAhPSBjbS5kaXNwbGF5LmJhcldpZHRoICYmIGNtLm9wdGlvbnMubGluZVdyYXBwaW5nKVxuICAgICAgICB7IHVwZGF0ZUhlaWdodHNJblZpZXdwb3J0KGNtKTsgfVxuICAgICAgdXBkYXRlU2Nyb2xsYmFyc0lubmVyKGNtLCBtZWFzdXJlRm9yU2Nyb2xsYmFycyhjbSkpO1xuICAgICAgc3RhcnRXaWR0aCA9IGNtLmRpc3BsYXkuYmFyV2lkdGg7IHN0YXJ0SGVpZ2h0ID0gY20uZGlzcGxheS5iYXJIZWlnaHQ7XG4gICAgfVxuICB9XG5cbiAgLy8gUmUtc3luY2hyb25pemUgdGhlIGZha2Ugc2Nyb2xsYmFycyB3aXRoIHRoZSBhY3R1YWwgc2l6ZSBvZiB0aGVcbiAgLy8gY29udGVudC5cbiAgZnVuY3Rpb24gdXBkYXRlU2Nyb2xsYmFyc0lubmVyKGNtLCBtZWFzdXJlKSB7XG4gICAgdmFyIGQgPSBjbS5kaXNwbGF5O1xuICAgIHZhciBzaXplcyA9IGQuc2Nyb2xsYmFycy51cGRhdGUobWVhc3VyZSk7XG5cbiAgICBkLnNpemVyLnN0eWxlLnBhZGRpbmdSaWdodCA9IChkLmJhcldpZHRoID0gc2l6ZXMucmlnaHQpICsgXCJweFwiO1xuICAgIGQuc2l6ZXIuc3R5bGUucGFkZGluZ0JvdHRvbSA9IChkLmJhckhlaWdodCA9IHNpemVzLmJvdHRvbSkgKyBcInB4XCI7XG4gICAgZC5oZWlnaHRGb3JjZXIuc3R5bGUuYm9yZGVyQm90dG9tID0gc2l6ZXMuYm90dG9tICsgXCJweCBzb2xpZCB0cmFuc3BhcmVudFwiO1xuXG4gICAgaWYgKHNpemVzLnJpZ2h0ICYmIHNpemVzLmJvdHRvbSkge1xuICAgICAgZC5zY3JvbGxiYXJGaWxsZXIuc3R5bGUuZGlzcGxheSA9IFwiYmxvY2tcIjtcbiAgICAgIGQuc2Nyb2xsYmFyRmlsbGVyLnN0eWxlLmhlaWdodCA9IHNpemVzLmJvdHRvbSArIFwicHhcIjtcbiAgICAgIGQuc2Nyb2xsYmFyRmlsbGVyLnN0eWxlLndpZHRoID0gc2l6ZXMucmlnaHQgKyBcInB4XCI7XG4gICAgfSBlbHNlIHsgZC5zY3JvbGxiYXJGaWxsZXIuc3R5bGUuZGlzcGxheSA9IFwiXCI7IH1cbiAgICBpZiAoc2l6ZXMuYm90dG9tICYmIGNtLm9wdGlvbnMuY292ZXJHdXR0ZXJOZXh0VG9TY3JvbGxiYXIgJiYgY20ub3B0aW9ucy5maXhlZEd1dHRlcikge1xuICAgICAgZC5ndXR0ZXJGaWxsZXIuc3R5bGUuZGlzcGxheSA9IFwiYmxvY2tcIjtcbiAgICAgIGQuZ3V0dGVyRmlsbGVyLnN0eWxlLmhlaWdodCA9IHNpemVzLmJvdHRvbSArIFwicHhcIjtcbiAgICAgIGQuZ3V0dGVyRmlsbGVyLnN0eWxlLndpZHRoID0gbWVhc3VyZS5ndXR0ZXJXaWR0aCArIFwicHhcIjtcbiAgICB9IGVsc2UgeyBkLmd1dHRlckZpbGxlci5zdHlsZS5kaXNwbGF5ID0gXCJcIjsgfVxuICB9XG5cbiAgdmFyIHNjcm9sbGJhck1vZGVsID0ge1wibmF0aXZlXCI6IE5hdGl2ZVNjcm9sbGJhcnMsIFwibnVsbFwiOiBOdWxsU2Nyb2xsYmFyc307XG5cbiAgZnVuY3Rpb24gaW5pdFNjcm9sbGJhcnMoY20pIHtcbiAgICBpZiAoY20uZGlzcGxheS5zY3JvbGxiYXJzKSB7XG4gICAgICBjbS5kaXNwbGF5LnNjcm9sbGJhcnMuY2xlYXIoKTtcbiAgICAgIGlmIChjbS5kaXNwbGF5LnNjcm9sbGJhcnMuYWRkQ2xhc3MpXG4gICAgICAgIHsgcm1DbGFzcyhjbS5kaXNwbGF5LndyYXBwZXIsIGNtLmRpc3BsYXkuc2Nyb2xsYmFycy5hZGRDbGFzcyk7IH1cbiAgICB9XG5cbiAgICBjbS5kaXNwbGF5LnNjcm9sbGJhcnMgPSBuZXcgc2Nyb2xsYmFyTW9kZWxbY20ub3B0aW9ucy5zY3JvbGxiYXJTdHlsZV0oZnVuY3Rpb24gKG5vZGUpIHtcbiAgICAgIGNtLmRpc3BsYXkud3JhcHBlci5pbnNlcnRCZWZvcmUobm9kZSwgY20uZGlzcGxheS5zY3JvbGxiYXJGaWxsZXIpO1xuICAgICAgLy8gUHJldmVudCBjbGlja3MgaW4gdGhlIHNjcm9sbGJhcnMgZnJvbSBraWxsaW5nIGZvY3VzXG4gICAgICBvbihub2RlLCBcIm1vdXNlZG93blwiLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgIGlmIChjbS5zdGF0ZS5mb2N1c2VkKSB7IHNldFRpbWVvdXQoZnVuY3Rpb24gKCkgeyByZXR1cm4gY20uZGlzcGxheS5pbnB1dC5mb2N1cygpOyB9LCAwKTsgfVxuICAgICAgfSk7XG4gICAgICBub2RlLnNldEF0dHJpYnV0ZShcImNtLW5vdC1jb250ZW50XCIsIFwidHJ1ZVwiKTtcbiAgICB9LCBmdW5jdGlvbiAocG9zLCBheGlzKSB7XG4gICAgICBpZiAoYXhpcyA9PSBcImhvcml6b250YWxcIikgeyBzZXRTY3JvbGxMZWZ0KGNtLCBwb3MpOyB9XG4gICAgICBlbHNlIHsgdXBkYXRlU2Nyb2xsVG9wKGNtLCBwb3MpOyB9XG4gICAgfSwgY20pO1xuICAgIGlmIChjbS5kaXNwbGF5LnNjcm9sbGJhcnMuYWRkQ2xhc3MpXG4gICAgICB7IGFkZENsYXNzKGNtLmRpc3BsYXkud3JhcHBlciwgY20uZGlzcGxheS5zY3JvbGxiYXJzLmFkZENsYXNzKTsgfVxuICB9XG5cbiAgLy8gT3BlcmF0aW9ucyBhcmUgdXNlZCB0byB3cmFwIGEgc2VyaWVzIG9mIGNoYW5nZXMgdG8gdGhlIGVkaXRvclxuICAvLyBzdGF0ZSBpbiBzdWNoIGEgd2F5IHRoYXQgZWFjaCBjaGFuZ2Ugd29uJ3QgaGF2ZSB0byB1cGRhdGUgdGhlXG4gIC8vIGN1cnNvciBhbmQgZGlzcGxheSAod2hpY2ggd291bGQgYmUgYXdrd2FyZCwgc2xvdywgYW5kXG4gIC8vIGVycm9yLXByb25lKS4gSW5zdGVhZCwgZGlzcGxheSB1cGRhdGVzIGFyZSBiYXRjaGVkIGFuZCB0aGVuIGFsbFxuICAvLyBjb21iaW5lZCBhbmQgZXhlY3V0ZWQgYXQgb25jZS5cblxuICB2YXIgbmV4dE9wSWQgPSAwO1xuICAvLyBTdGFydCBhIG5ldyBvcGVyYXRpb24uXG4gIGZ1bmN0aW9uIHN0YXJ0T3BlcmF0aW9uKGNtKSB7XG4gICAgY20uY3VyT3AgPSB7XG4gICAgICBjbTogY20sXG4gICAgICB2aWV3Q2hhbmdlZDogZmFsc2UsICAgICAgLy8gRmxhZyB0aGF0IGluZGljYXRlcyB0aGF0IGxpbmVzIG1pZ2h0IG5lZWQgdG8gYmUgcmVkcmF3blxuICAgICAgc3RhcnRIZWlnaHQ6IGNtLmRvYy5oZWlnaHQsIC8vIFVzZWQgdG8gZGV0ZWN0IG5lZWQgdG8gdXBkYXRlIHNjcm9sbGJhclxuICAgICAgZm9yY2VVcGRhdGU6IGZhbHNlLCAgICAgIC8vIFVzZWQgdG8gZm9yY2UgYSByZWRyYXdcbiAgICAgIHVwZGF0ZUlucHV0OiAwLCAgICAgICAvLyBXaGV0aGVyIHRvIHJlc2V0IHRoZSBpbnB1dCB0ZXh0YXJlYVxuICAgICAgdHlwaW5nOiBmYWxzZSwgICAgICAgICAgIC8vIFdoZXRoZXIgdGhpcyByZXNldCBzaG91bGQgYmUgY2FyZWZ1bCB0byBsZWF2ZSBleGlzdGluZyB0ZXh0IChmb3IgY29tcG9zaXRpbmcpXG4gICAgICBjaGFuZ2VPYmpzOiBudWxsLCAgICAgICAgLy8gQWNjdW11bGF0ZWQgY2hhbmdlcywgZm9yIGZpcmluZyBjaGFuZ2UgZXZlbnRzXG4gICAgICBjdXJzb3JBY3Rpdml0eUhhbmRsZXJzOiBudWxsLCAvLyBTZXQgb2YgaGFuZGxlcnMgdG8gZmlyZSBjdXJzb3JBY3Rpdml0eSBvblxuICAgICAgY3Vyc29yQWN0aXZpdHlDYWxsZWQ6IDAsIC8vIFRyYWNrcyB3aGljaCBjdXJzb3JBY3Rpdml0eSBoYW5kbGVycyBoYXZlIGJlZW4gY2FsbGVkIGFscmVhZHlcbiAgICAgIHNlbGVjdGlvbkNoYW5nZWQ6IGZhbHNlLCAvLyBXaGV0aGVyIHRoZSBzZWxlY3Rpb24gbmVlZHMgdG8gYmUgcmVkcmF3blxuICAgICAgdXBkYXRlTWF4TGluZTogZmFsc2UsICAgIC8vIFNldCB3aGVuIHRoZSB3aWRlc3QgbGluZSBuZWVkcyB0byBiZSBkZXRlcm1pbmVkIGFuZXdcbiAgICAgIHNjcm9sbExlZnQ6IG51bGwsIHNjcm9sbFRvcDogbnVsbCwgLy8gSW50ZXJtZWRpYXRlIHNjcm9sbCBwb3NpdGlvbiwgbm90IHB1c2hlZCB0byBET00geWV0XG4gICAgICBzY3JvbGxUb1BvczogbnVsbCwgICAgICAgLy8gVXNlZCB0byBzY3JvbGwgdG8gYSBzcGVjaWZpYyBwb3NpdGlvblxuICAgICAgZm9jdXM6IGZhbHNlLFxuICAgICAgaWQ6ICsrbmV4dE9wSWQsICAgICAgICAgIC8vIFVuaXF1ZSBJRFxuICAgICAgbWFya0FycmF5czogbnVsbCAgICAgICAgIC8vIFVzZWQgYnkgYWRkTWFya2VkU3BhblxuICAgIH07XG4gICAgcHVzaE9wZXJhdGlvbihjbS5jdXJPcCk7XG4gIH1cblxuICAvLyBGaW5pc2ggYW4gb3BlcmF0aW9uLCB1cGRhdGluZyB0aGUgZGlzcGxheSBhbmQgc2lnbmFsbGluZyBkZWxheWVkIGV2ZW50c1xuICBmdW5jdGlvbiBlbmRPcGVyYXRpb24oY20pIHtcbiAgICB2YXIgb3AgPSBjbS5jdXJPcDtcbiAgICBpZiAob3ApIHsgZmluaXNoT3BlcmF0aW9uKG9wLCBmdW5jdGlvbiAoZ3JvdXApIHtcbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgZ3JvdXAub3BzLmxlbmd0aDsgaSsrKVxuICAgICAgICB7IGdyb3VwLm9wc1tpXS5jbS5jdXJPcCA9IG51bGw7IH1cbiAgICAgIGVuZE9wZXJhdGlvbnMoZ3JvdXApO1xuICAgIH0pOyB9XG4gIH1cblxuICAvLyBUaGUgRE9NIHVwZGF0ZXMgZG9uZSB3aGVuIGFuIG9wZXJhdGlvbiBmaW5pc2hlcyBhcmUgYmF0Y2hlZCBzb1xuICAvLyB0aGF0IHRoZSBtaW5pbXVtIG51bWJlciBvZiByZWxheW91dHMgYXJlIHJlcXVpcmVkLlxuICBmdW5jdGlvbiBlbmRPcGVyYXRpb25zKGdyb3VwKSB7XG4gICAgdmFyIG9wcyA9IGdyb3VwLm9wcztcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IG9wcy5sZW5ndGg7IGkrKykgLy8gUmVhZCBET01cbiAgICAgIHsgZW5kT3BlcmF0aW9uX1IxKG9wc1tpXSk7IH1cbiAgICBmb3IgKHZhciBpJDEgPSAwOyBpJDEgPCBvcHMubGVuZ3RoOyBpJDErKykgLy8gV3JpdGUgRE9NIChtYXliZSlcbiAgICAgIHsgZW5kT3BlcmF0aW9uX1cxKG9wc1tpJDFdKTsgfVxuICAgIGZvciAodmFyIGkkMiA9IDA7IGkkMiA8IG9wcy5sZW5ndGg7IGkkMisrKSAvLyBSZWFkIERPTVxuICAgICAgeyBlbmRPcGVyYXRpb25fUjIob3BzW2kkMl0pOyB9XG4gICAgZm9yICh2YXIgaSQzID0gMDsgaSQzIDwgb3BzLmxlbmd0aDsgaSQzKyspIC8vIFdyaXRlIERPTSAobWF5YmUpXG4gICAgICB7IGVuZE9wZXJhdGlvbl9XMihvcHNbaSQzXSk7IH1cbiAgICBmb3IgKHZhciBpJDQgPSAwOyBpJDQgPCBvcHMubGVuZ3RoOyBpJDQrKykgLy8gUmVhZCBET01cbiAgICAgIHsgZW5kT3BlcmF0aW9uX2ZpbmlzaChvcHNbaSQ0XSk7IH1cbiAgfVxuXG4gIGZ1bmN0aW9uIGVuZE9wZXJhdGlvbl9SMShvcCkge1xuICAgIHZhciBjbSA9IG9wLmNtLCBkaXNwbGF5ID0gY20uZGlzcGxheTtcbiAgICBtYXliZUNsaXBTY3JvbGxiYXJzKGNtKTtcbiAgICBpZiAob3AudXBkYXRlTWF4TGluZSkgeyBmaW5kTWF4TGluZShjbSk7IH1cblxuICAgIG9wLm11c3RVcGRhdGUgPSBvcC52aWV3Q2hhbmdlZCB8fCBvcC5mb3JjZVVwZGF0ZSB8fCBvcC5zY3JvbGxUb3AgIT0gbnVsbCB8fFxuICAgICAgb3Auc2Nyb2xsVG9Qb3MgJiYgKG9wLnNjcm9sbFRvUG9zLmZyb20ubGluZSA8IGRpc3BsYXkudmlld0Zyb20gfHxcbiAgICAgICAgICAgICAgICAgICAgICAgICBvcC5zY3JvbGxUb1Bvcy50by5saW5lID49IGRpc3BsYXkudmlld1RvKSB8fFxuICAgICAgZGlzcGxheS5tYXhMaW5lQ2hhbmdlZCAmJiBjbS5vcHRpb25zLmxpbmVXcmFwcGluZztcbiAgICBvcC51cGRhdGUgPSBvcC5tdXN0VXBkYXRlICYmXG4gICAgICBuZXcgRGlzcGxheVVwZGF0ZShjbSwgb3AubXVzdFVwZGF0ZSAmJiB7dG9wOiBvcC5zY3JvbGxUb3AsIGVuc3VyZTogb3Auc2Nyb2xsVG9Qb3N9LCBvcC5mb3JjZVVwZGF0ZSk7XG4gIH1cblxuICBmdW5jdGlvbiBlbmRPcGVyYXRpb25fVzEob3ApIHtcbiAgICBvcC51cGRhdGVkRGlzcGxheSA9IG9wLm11c3RVcGRhdGUgJiYgdXBkYXRlRGlzcGxheUlmTmVlZGVkKG9wLmNtLCBvcC51cGRhdGUpO1xuICB9XG5cbiAgZnVuY3Rpb24gZW5kT3BlcmF0aW9uX1IyKG9wKSB7XG4gICAgdmFyIGNtID0gb3AuY20sIGRpc3BsYXkgPSBjbS5kaXNwbGF5O1xuICAgIGlmIChvcC51cGRhdGVkRGlzcGxheSkgeyB1cGRhdGVIZWlnaHRzSW5WaWV3cG9ydChjbSk7IH1cblxuICAgIG9wLmJhck1lYXN1cmUgPSBtZWFzdXJlRm9yU2Nyb2xsYmFycyhjbSk7XG5cbiAgICAvLyBJZiB0aGUgbWF4IGxpbmUgY2hhbmdlZCBzaW5jZSBpdCB3YXMgbGFzdCBtZWFzdXJlZCwgbWVhc3VyZSBpdCxcbiAgICAvLyBhbmQgZW5zdXJlIHRoZSBkb2N1bWVudCdzIHdpZHRoIG1hdGNoZXMgaXQuXG4gICAgLy8gdXBkYXRlRGlzcGxheV9XMiB3aWxsIHVzZSB0aGVzZSBwcm9wZXJ0aWVzIHRvIGRvIHRoZSBhY3R1YWwgcmVzaXppbmdcbiAgICBpZiAoZGlzcGxheS5tYXhMaW5lQ2hhbmdlZCAmJiAhY20ub3B0aW9ucy5saW5lV3JhcHBpbmcpIHtcbiAgICAgIG9wLmFkanVzdFdpZHRoVG8gPSBtZWFzdXJlQ2hhcihjbSwgZGlzcGxheS5tYXhMaW5lLCBkaXNwbGF5Lm1heExpbmUudGV4dC5sZW5ndGgpLmxlZnQgKyAzO1xuICAgICAgY20uZGlzcGxheS5zaXplcldpZHRoID0gb3AuYWRqdXN0V2lkdGhUbztcbiAgICAgIG9wLmJhck1lYXN1cmUuc2Nyb2xsV2lkdGggPVxuICAgICAgICBNYXRoLm1heChkaXNwbGF5LnNjcm9sbGVyLmNsaWVudFdpZHRoLCBkaXNwbGF5LnNpemVyLm9mZnNldExlZnQgKyBvcC5hZGp1c3RXaWR0aFRvICsgc2Nyb2xsR2FwKGNtKSArIGNtLmRpc3BsYXkuYmFyV2lkdGgpO1xuICAgICAgb3AubWF4U2Nyb2xsTGVmdCA9IE1hdGgubWF4KDAsIGRpc3BsYXkuc2l6ZXIub2Zmc2V0TGVmdCArIG9wLmFkanVzdFdpZHRoVG8gLSBkaXNwbGF5V2lkdGgoY20pKTtcbiAgICB9XG5cbiAgICBpZiAob3AudXBkYXRlZERpc3BsYXkgfHwgb3Auc2VsZWN0aW9uQ2hhbmdlZClcbiAgICAgIHsgb3AucHJlcGFyZWRTZWxlY3Rpb24gPSBkaXNwbGF5LmlucHV0LnByZXBhcmVTZWxlY3Rpb24oKTsgfVxuICB9XG5cbiAgZnVuY3Rpb24gZW5kT3BlcmF0aW9uX1cyKG9wKSB7XG4gICAgdmFyIGNtID0gb3AuY207XG5cbiAgICBpZiAob3AuYWRqdXN0V2lkdGhUbyAhPSBudWxsKSB7XG4gICAgICBjbS5kaXNwbGF5LnNpemVyLnN0eWxlLm1pbldpZHRoID0gb3AuYWRqdXN0V2lkdGhUbyArIFwicHhcIjtcbiAgICAgIGlmIChvcC5tYXhTY3JvbGxMZWZ0IDwgY20uZG9jLnNjcm9sbExlZnQpXG4gICAgICAgIHsgc2V0U2Nyb2xsTGVmdChjbSwgTWF0aC5taW4oY20uZGlzcGxheS5zY3JvbGxlci5zY3JvbGxMZWZ0LCBvcC5tYXhTY3JvbGxMZWZ0KSwgdHJ1ZSk7IH1cbiAgICAgIGNtLmRpc3BsYXkubWF4TGluZUNoYW5nZWQgPSBmYWxzZTtcbiAgICB9XG5cbiAgICB2YXIgdGFrZUZvY3VzID0gb3AuZm9jdXMgJiYgb3AuZm9jdXMgPT0gYWN0aXZlRWx0KCk7XG4gICAgaWYgKG9wLnByZXBhcmVkU2VsZWN0aW9uKVxuICAgICAgeyBjbS5kaXNwbGF5LmlucHV0LnNob3dTZWxlY3Rpb24ob3AucHJlcGFyZWRTZWxlY3Rpb24sIHRha2VGb2N1cyk7IH1cbiAgICBpZiAob3AudXBkYXRlZERpc3BsYXkgfHwgb3Auc3RhcnRIZWlnaHQgIT0gY20uZG9jLmhlaWdodClcbiAgICAgIHsgdXBkYXRlU2Nyb2xsYmFycyhjbSwgb3AuYmFyTWVhc3VyZSk7IH1cbiAgICBpZiAob3AudXBkYXRlZERpc3BsYXkpXG4gICAgICB7IHNldERvY3VtZW50SGVpZ2h0KGNtLCBvcC5iYXJNZWFzdXJlKTsgfVxuXG4gICAgaWYgKG9wLnNlbGVjdGlvbkNoYW5nZWQpIHsgcmVzdGFydEJsaW5rKGNtKTsgfVxuXG4gICAgaWYgKGNtLnN0YXRlLmZvY3VzZWQgJiYgb3AudXBkYXRlSW5wdXQpXG4gICAgICB7IGNtLmRpc3BsYXkuaW5wdXQucmVzZXQob3AudHlwaW5nKTsgfVxuICAgIGlmICh0YWtlRm9jdXMpIHsgZW5zdXJlRm9jdXMob3AuY20pOyB9XG4gIH1cblxuICBmdW5jdGlvbiBlbmRPcGVyYXRpb25fZmluaXNoKG9wKSB7XG4gICAgdmFyIGNtID0gb3AuY20sIGRpc3BsYXkgPSBjbS5kaXNwbGF5LCBkb2MgPSBjbS5kb2M7XG5cbiAgICBpZiAob3AudXBkYXRlZERpc3BsYXkpIHsgcG9zdFVwZGF0ZURpc3BsYXkoY20sIG9wLnVwZGF0ZSk7IH1cblxuICAgIC8vIEFib3J0IG1vdXNlIHdoZWVsIGRlbHRhIG1lYXN1cmVtZW50LCB3aGVuIHNjcm9sbGluZyBleHBsaWNpdGx5XG4gICAgaWYgKGRpc3BsYXkud2hlZWxTdGFydFggIT0gbnVsbCAmJiAob3Auc2Nyb2xsVG9wICE9IG51bGwgfHwgb3Auc2Nyb2xsTGVmdCAhPSBudWxsIHx8IG9wLnNjcm9sbFRvUG9zKSlcbiAgICAgIHsgZGlzcGxheS53aGVlbFN0YXJ0WCA9IGRpc3BsYXkud2hlZWxTdGFydFkgPSBudWxsOyB9XG5cbiAgICAvLyBQcm9wYWdhdGUgdGhlIHNjcm9sbCBwb3NpdGlvbiB0byB0aGUgYWN0dWFsIERPTSBzY3JvbGxlclxuICAgIGlmIChvcC5zY3JvbGxUb3AgIT0gbnVsbCkgeyBzZXRTY3JvbGxUb3AoY20sIG9wLnNjcm9sbFRvcCwgb3AuZm9yY2VTY3JvbGwpOyB9XG5cbiAgICBpZiAob3Auc2Nyb2xsTGVmdCAhPSBudWxsKSB7IHNldFNjcm9sbExlZnQoY20sIG9wLnNjcm9sbExlZnQsIHRydWUsIHRydWUpOyB9XG4gICAgLy8gSWYgd2UgbmVlZCB0byBzY3JvbGwgYSBzcGVjaWZpYyBwb3NpdGlvbiBpbnRvIHZpZXcsIGRvIHNvLlxuICAgIGlmIChvcC5zY3JvbGxUb1Bvcykge1xuICAgICAgdmFyIHJlY3QgPSBzY3JvbGxQb3NJbnRvVmlldyhjbSwgY2xpcFBvcyhkb2MsIG9wLnNjcm9sbFRvUG9zLmZyb20pLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjbGlwUG9zKGRvYywgb3Auc2Nyb2xsVG9Qb3MudG8pLCBvcC5zY3JvbGxUb1Bvcy5tYXJnaW4pO1xuICAgICAgbWF5YmVTY3JvbGxXaW5kb3coY20sIHJlY3QpO1xuICAgIH1cblxuICAgIC8vIEZpcmUgZXZlbnRzIGZvciBtYXJrZXJzIHRoYXQgYXJlIGhpZGRlbi91bmlkZGVuIGJ5IGVkaXRpbmcgb3JcbiAgICAvLyB1bmRvaW5nXG4gICAgdmFyIGhpZGRlbiA9IG9wLm1heWJlSGlkZGVuTWFya2VycywgdW5oaWRkZW4gPSBvcC5tYXliZVVuaGlkZGVuTWFya2VycztcbiAgICBpZiAoaGlkZGVuKSB7IGZvciAodmFyIGkgPSAwOyBpIDwgaGlkZGVuLmxlbmd0aDsgKytpKVxuICAgICAgeyBpZiAoIWhpZGRlbltpXS5saW5lcy5sZW5ndGgpIHsgc2lnbmFsKGhpZGRlbltpXSwgXCJoaWRlXCIpOyB9IH0gfVxuICAgIGlmICh1bmhpZGRlbikgeyBmb3IgKHZhciBpJDEgPSAwOyBpJDEgPCB1bmhpZGRlbi5sZW5ndGg7ICsraSQxKVxuICAgICAgeyBpZiAodW5oaWRkZW5baSQxXS5saW5lcy5sZW5ndGgpIHsgc2lnbmFsKHVuaGlkZGVuW2kkMV0sIFwidW5oaWRlXCIpOyB9IH0gfVxuXG4gICAgaWYgKGRpc3BsYXkud3JhcHBlci5vZmZzZXRIZWlnaHQpXG4gICAgICB7IGRvYy5zY3JvbGxUb3AgPSBjbS5kaXNwbGF5LnNjcm9sbGVyLnNjcm9sbFRvcDsgfVxuXG4gICAgLy8gRmlyZSBjaGFuZ2UgZXZlbnRzLCBhbmQgZGVsYXllZCBldmVudCBoYW5kbGVyc1xuICAgIGlmIChvcC5jaGFuZ2VPYmpzKVxuICAgICAgeyBzaWduYWwoY20sIFwiY2hhbmdlc1wiLCBjbSwgb3AuY2hhbmdlT2Jqcyk7IH1cbiAgICBpZiAob3AudXBkYXRlKVxuICAgICAgeyBvcC51cGRhdGUuZmluaXNoKCk7IH1cbiAgfVxuXG4gIC8vIFJ1biB0aGUgZ2l2ZW4gZnVuY3Rpb24gaW4gYW4gb3BlcmF0aW9uXG4gIGZ1bmN0aW9uIHJ1bkluT3AoY20sIGYpIHtcbiAgICBpZiAoY20uY3VyT3ApIHsgcmV0dXJuIGYoKSB9XG4gICAgc3RhcnRPcGVyYXRpb24oY20pO1xuICAgIHRyeSB7IHJldHVybiBmKCkgfVxuICAgIGZpbmFsbHkgeyBlbmRPcGVyYXRpb24oY20pOyB9XG4gIH1cbiAgLy8gV3JhcHMgYSBmdW5jdGlvbiBpbiBhbiBvcGVyYXRpb24uIFJldHVybnMgdGhlIHdyYXBwZWQgZnVuY3Rpb24uXG4gIGZ1bmN0aW9uIG9wZXJhdGlvbihjbSwgZikge1xuICAgIHJldHVybiBmdW5jdGlvbigpIHtcbiAgICAgIGlmIChjbS5jdXJPcCkgeyByZXR1cm4gZi5hcHBseShjbSwgYXJndW1lbnRzKSB9XG4gICAgICBzdGFydE9wZXJhdGlvbihjbSk7XG4gICAgICB0cnkgeyByZXR1cm4gZi5hcHBseShjbSwgYXJndW1lbnRzKSB9XG4gICAgICBmaW5hbGx5IHsgZW5kT3BlcmF0aW9uKGNtKTsgfVxuICAgIH1cbiAgfVxuICAvLyBVc2VkIHRvIGFkZCBtZXRob2RzIHRvIGVkaXRvciBhbmQgZG9jIGluc3RhbmNlcywgd3JhcHBpbmcgdGhlbSBpblxuICAvLyBvcGVyYXRpb25zLlxuICBmdW5jdGlvbiBtZXRob2RPcChmKSB7XG4gICAgcmV0dXJuIGZ1bmN0aW9uKCkge1xuICAgICAgaWYgKHRoaXMuY3VyT3ApIHsgcmV0dXJuIGYuYXBwbHkodGhpcywgYXJndW1lbnRzKSB9XG4gICAgICBzdGFydE9wZXJhdGlvbih0aGlzKTtcbiAgICAgIHRyeSB7IHJldHVybiBmLmFwcGx5KHRoaXMsIGFyZ3VtZW50cykgfVxuICAgICAgZmluYWxseSB7IGVuZE9wZXJhdGlvbih0aGlzKTsgfVxuICAgIH1cbiAgfVxuICBmdW5jdGlvbiBkb2NNZXRob2RPcChmKSB7XG4gICAgcmV0dXJuIGZ1bmN0aW9uKCkge1xuICAgICAgdmFyIGNtID0gdGhpcy5jbTtcbiAgICAgIGlmICghY20gfHwgY20uY3VyT3ApIHsgcmV0dXJuIGYuYXBwbHkodGhpcywgYXJndW1lbnRzKSB9XG4gICAgICBzdGFydE9wZXJhdGlvbihjbSk7XG4gICAgICB0cnkgeyByZXR1cm4gZi5hcHBseSh0aGlzLCBhcmd1bWVudHMpIH1cbiAgICAgIGZpbmFsbHkgeyBlbmRPcGVyYXRpb24oY20pOyB9XG4gICAgfVxuICB9XG5cbiAgLy8gSElHSExJR0hUIFdPUktFUlxuXG4gIGZ1bmN0aW9uIHN0YXJ0V29ya2VyKGNtLCB0aW1lKSB7XG4gICAgaWYgKGNtLmRvYy5oaWdobGlnaHRGcm9udGllciA8IGNtLmRpc3BsYXkudmlld1RvKVxuICAgICAgeyBjbS5zdGF0ZS5oaWdobGlnaHQuc2V0KHRpbWUsIGJpbmQoaGlnaGxpZ2h0V29ya2VyLCBjbSkpOyB9XG4gIH1cblxuICBmdW5jdGlvbiBoaWdobGlnaHRXb3JrZXIoY20pIHtcbiAgICB2YXIgZG9jID0gY20uZG9jO1xuICAgIGlmIChkb2MuaGlnaGxpZ2h0RnJvbnRpZXIgPj0gY20uZGlzcGxheS52aWV3VG8pIHsgcmV0dXJuIH1cbiAgICB2YXIgZW5kID0gK25ldyBEYXRlICsgY20ub3B0aW9ucy53b3JrVGltZTtcbiAgICB2YXIgY29udGV4dCA9IGdldENvbnRleHRCZWZvcmUoY20sIGRvYy5oaWdobGlnaHRGcm9udGllcik7XG4gICAgdmFyIGNoYW5nZWRMaW5lcyA9IFtdO1xuXG4gICAgZG9jLml0ZXIoY29udGV4dC5saW5lLCBNYXRoLm1pbihkb2MuZmlyc3QgKyBkb2Muc2l6ZSwgY20uZGlzcGxheS52aWV3VG8gKyA1MDApLCBmdW5jdGlvbiAobGluZSkge1xuICAgICAgaWYgKGNvbnRleHQubGluZSA+PSBjbS5kaXNwbGF5LnZpZXdGcm9tKSB7IC8vIFZpc2libGVcbiAgICAgICAgdmFyIG9sZFN0eWxlcyA9IGxpbmUuc3R5bGVzO1xuICAgICAgICB2YXIgcmVzZXRTdGF0ZSA9IGxpbmUudGV4dC5sZW5ndGggPiBjbS5vcHRpb25zLm1heEhpZ2hsaWdodExlbmd0aCA/IGNvcHlTdGF0ZShkb2MubW9kZSwgY29udGV4dC5zdGF0ZSkgOiBudWxsO1xuICAgICAgICB2YXIgaGlnaGxpZ2h0ZWQgPSBoaWdobGlnaHRMaW5lKGNtLCBsaW5lLCBjb250ZXh0LCB0cnVlKTtcbiAgICAgICAgaWYgKHJlc2V0U3RhdGUpIHsgY29udGV4dC5zdGF0ZSA9IHJlc2V0U3RhdGU7IH1cbiAgICAgICAgbGluZS5zdHlsZXMgPSBoaWdobGlnaHRlZC5zdHlsZXM7XG4gICAgICAgIHZhciBvbGRDbHMgPSBsaW5lLnN0eWxlQ2xhc3NlcywgbmV3Q2xzID0gaGlnaGxpZ2h0ZWQuY2xhc3NlcztcbiAgICAgICAgaWYgKG5ld0NscykgeyBsaW5lLnN0eWxlQ2xhc3NlcyA9IG5ld0NsczsgfVxuICAgICAgICBlbHNlIGlmIChvbGRDbHMpIHsgbGluZS5zdHlsZUNsYXNzZXMgPSBudWxsOyB9XG4gICAgICAgIHZhciBpc2NoYW5nZSA9ICFvbGRTdHlsZXMgfHwgb2xkU3R5bGVzLmxlbmd0aCAhPSBsaW5lLnN0eWxlcy5sZW5ndGggfHxcbiAgICAgICAgICBvbGRDbHMgIT0gbmV3Q2xzICYmICghb2xkQ2xzIHx8ICFuZXdDbHMgfHwgb2xkQ2xzLmJnQ2xhc3MgIT0gbmV3Q2xzLmJnQ2xhc3MgfHwgb2xkQ2xzLnRleHRDbGFzcyAhPSBuZXdDbHMudGV4dENsYXNzKTtcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7ICFpc2NoYW5nZSAmJiBpIDwgb2xkU3R5bGVzLmxlbmd0aDsgKytpKSB7IGlzY2hhbmdlID0gb2xkU3R5bGVzW2ldICE9IGxpbmUuc3R5bGVzW2ldOyB9XG4gICAgICAgIGlmIChpc2NoYW5nZSkgeyBjaGFuZ2VkTGluZXMucHVzaChjb250ZXh0LmxpbmUpOyB9XG4gICAgICAgIGxpbmUuc3RhdGVBZnRlciA9IGNvbnRleHQuc2F2ZSgpO1xuICAgICAgICBjb250ZXh0Lm5leHRMaW5lKCk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBpZiAobGluZS50ZXh0Lmxlbmd0aCA8PSBjbS5vcHRpb25zLm1heEhpZ2hsaWdodExlbmd0aClcbiAgICAgICAgICB7IHByb2Nlc3NMaW5lKGNtLCBsaW5lLnRleHQsIGNvbnRleHQpOyB9XG4gICAgICAgIGxpbmUuc3RhdGVBZnRlciA9IGNvbnRleHQubGluZSAlIDUgPT0gMCA/IGNvbnRleHQuc2F2ZSgpIDogbnVsbDtcbiAgICAgICAgY29udGV4dC5uZXh0TGluZSgpO1xuICAgICAgfVxuICAgICAgaWYgKCtuZXcgRGF0ZSA+IGVuZCkge1xuICAgICAgICBzdGFydFdvcmtlcihjbSwgY20ub3B0aW9ucy53b3JrRGVsYXkpO1xuICAgICAgICByZXR1cm4gdHJ1ZVxuICAgICAgfVxuICAgIH0pO1xuICAgIGRvYy5oaWdobGlnaHRGcm9udGllciA9IGNvbnRleHQubGluZTtcbiAgICBkb2MubW9kZUZyb250aWVyID0gTWF0aC5tYXgoZG9jLm1vZGVGcm9udGllciwgY29udGV4dC5saW5lKTtcbiAgICBpZiAoY2hhbmdlZExpbmVzLmxlbmd0aCkgeyBydW5Jbk9wKGNtLCBmdW5jdGlvbiAoKSB7XG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGNoYW5nZWRMaW5lcy5sZW5ndGg7IGkrKylcbiAgICAgICAgeyByZWdMaW5lQ2hhbmdlKGNtLCBjaGFuZ2VkTGluZXNbaV0sIFwidGV4dFwiKTsgfVxuICAgIH0pOyB9XG4gIH1cblxuICAvLyBESVNQTEFZIERSQVdJTkdcblxuICB2YXIgRGlzcGxheVVwZGF0ZSA9IGZ1bmN0aW9uKGNtLCB2aWV3cG9ydCwgZm9yY2UpIHtcbiAgICB2YXIgZGlzcGxheSA9IGNtLmRpc3BsYXk7XG5cbiAgICB0aGlzLnZpZXdwb3J0ID0gdmlld3BvcnQ7XG4gICAgLy8gU3RvcmUgc29tZSB2YWx1ZXMgdGhhdCB3ZSdsbCBuZWVkIGxhdGVyIChidXQgZG9uJ3Qgd2FudCB0byBmb3JjZSBhIHJlbGF5b3V0IGZvcilcbiAgICB0aGlzLnZpc2libGUgPSB2aXNpYmxlTGluZXMoZGlzcGxheSwgY20uZG9jLCB2aWV3cG9ydCk7XG4gICAgdGhpcy5lZGl0b3JJc0hpZGRlbiA9ICFkaXNwbGF5LndyYXBwZXIub2Zmc2V0V2lkdGg7XG4gICAgdGhpcy53cmFwcGVySGVpZ2h0ID0gZGlzcGxheS53cmFwcGVyLmNsaWVudEhlaWdodDtcbiAgICB0aGlzLndyYXBwZXJXaWR0aCA9IGRpc3BsYXkud3JhcHBlci5jbGllbnRXaWR0aDtcbiAgICB0aGlzLm9sZERpc3BsYXlXaWR0aCA9IGRpc3BsYXlXaWR0aChjbSk7XG4gICAgdGhpcy5mb3JjZSA9IGZvcmNlO1xuICAgIHRoaXMuZGltcyA9IGdldERpbWVuc2lvbnMoY20pO1xuICAgIHRoaXMuZXZlbnRzID0gW107XG4gIH07XG5cbiAgRGlzcGxheVVwZGF0ZS5wcm90b3R5cGUuc2lnbmFsID0gZnVuY3Rpb24gKGVtaXR0ZXIsIHR5cGUpIHtcbiAgICBpZiAoaGFzSGFuZGxlcihlbWl0dGVyLCB0eXBlKSlcbiAgICAgIHsgdGhpcy5ldmVudHMucHVzaChhcmd1bWVudHMpOyB9XG4gIH07XG4gIERpc3BsYXlVcGRhdGUucHJvdG90eXBlLmZpbmlzaCA9IGZ1bmN0aW9uICgpIHtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IHRoaXMuZXZlbnRzLmxlbmd0aDsgaSsrKVxuICAgICAgeyBzaWduYWwuYXBwbHkobnVsbCwgdGhpcy5ldmVudHNbaV0pOyB9XG4gIH07XG5cbiAgZnVuY3Rpb24gbWF5YmVDbGlwU2Nyb2xsYmFycyhjbSkge1xuICAgIHZhciBkaXNwbGF5ID0gY20uZGlzcGxheTtcbiAgICBpZiAoIWRpc3BsYXkuc2Nyb2xsYmFyc0NsaXBwZWQgJiYgZGlzcGxheS5zY3JvbGxlci5vZmZzZXRXaWR0aCkge1xuICAgICAgZGlzcGxheS5uYXRpdmVCYXJXaWR0aCA9IGRpc3BsYXkuc2Nyb2xsZXIub2Zmc2V0V2lkdGggLSBkaXNwbGF5LnNjcm9sbGVyLmNsaWVudFdpZHRoO1xuICAgICAgZGlzcGxheS5oZWlnaHRGb3JjZXIuc3R5bGUuaGVpZ2h0ID0gc2Nyb2xsR2FwKGNtKSArIFwicHhcIjtcbiAgICAgIGRpc3BsYXkuc2l6ZXIuc3R5bGUubWFyZ2luQm90dG9tID0gLWRpc3BsYXkubmF0aXZlQmFyV2lkdGggKyBcInB4XCI7XG4gICAgICBkaXNwbGF5LnNpemVyLnN0eWxlLmJvcmRlclJpZ2h0V2lkdGggPSBzY3JvbGxHYXAoY20pICsgXCJweFwiO1xuICAgICAgZGlzcGxheS5zY3JvbGxiYXJzQ2xpcHBlZCA9IHRydWU7XG4gICAgfVxuICB9XG5cbiAgZnVuY3Rpb24gc2VsZWN0aW9uU25hcHNob3QoY20pIHtcbiAgICBpZiAoY20uaGFzRm9jdXMoKSkgeyByZXR1cm4gbnVsbCB9XG4gICAgdmFyIGFjdGl2ZSA9IGFjdGl2ZUVsdCgpO1xuICAgIGlmICghYWN0aXZlIHx8ICFjb250YWlucyhjbS5kaXNwbGF5LmxpbmVEaXYsIGFjdGl2ZSkpIHsgcmV0dXJuIG51bGwgfVxuICAgIHZhciByZXN1bHQgPSB7YWN0aXZlRWx0OiBhY3RpdmV9O1xuICAgIGlmICh3aW5kb3cuZ2V0U2VsZWN0aW9uKSB7XG4gICAgICB2YXIgc2VsID0gd2luZG93LmdldFNlbGVjdGlvbigpO1xuICAgICAgaWYgKHNlbC5hbmNob3JOb2RlICYmIHNlbC5leHRlbmQgJiYgY29udGFpbnMoY20uZGlzcGxheS5saW5lRGl2LCBzZWwuYW5jaG9yTm9kZSkpIHtcbiAgICAgICAgcmVzdWx0LmFuY2hvck5vZGUgPSBzZWwuYW5jaG9yTm9kZTtcbiAgICAgICAgcmVzdWx0LmFuY2hvck9mZnNldCA9IHNlbC5hbmNob3JPZmZzZXQ7XG4gICAgICAgIHJlc3VsdC5mb2N1c05vZGUgPSBzZWwuZm9jdXNOb2RlO1xuICAgICAgICByZXN1bHQuZm9jdXNPZmZzZXQgPSBzZWwuZm9jdXNPZmZzZXQ7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiByZXN1bHRcbiAgfVxuXG4gIGZ1bmN0aW9uIHJlc3RvcmVTZWxlY3Rpb24oc25hcHNob3QpIHtcbiAgICBpZiAoIXNuYXBzaG90IHx8ICFzbmFwc2hvdC5hY3RpdmVFbHQgfHwgc25hcHNob3QuYWN0aXZlRWx0ID09IGFjdGl2ZUVsdCgpKSB7IHJldHVybiB9XG4gICAgc25hcHNob3QuYWN0aXZlRWx0LmZvY3VzKCk7XG4gICAgaWYgKCEvXihJTlBVVHxURVhUQVJFQSkkLy50ZXN0KHNuYXBzaG90LmFjdGl2ZUVsdC5ub2RlTmFtZSkgJiZcbiAgICAgICAgc25hcHNob3QuYW5jaG9yTm9kZSAmJiBjb250YWlucyhkb2N1bWVudC5ib2R5LCBzbmFwc2hvdC5hbmNob3JOb2RlKSAmJiBjb250YWlucyhkb2N1bWVudC5ib2R5LCBzbmFwc2hvdC5mb2N1c05vZGUpKSB7XG4gICAgICB2YXIgc2VsID0gd2luZG93LmdldFNlbGVjdGlvbigpLCByYW5nZSA9IGRvY3VtZW50LmNyZWF0ZVJhbmdlKCk7XG4gICAgICByYW5nZS5zZXRFbmQoc25hcHNob3QuYW5jaG9yTm9kZSwgc25hcHNob3QuYW5jaG9yT2Zmc2V0KTtcbiAgICAgIHJhbmdlLmNvbGxhcHNlKGZhbHNlKTtcbiAgICAgIHNlbC5yZW1vdmVBbGxSYW5nZXMoKTtcbiAgICAgIHNlbC5hZGRSYW5nZShyYW5nZSk7XG4gICAgICBzZWwuZXh0ZW5kKHNuYXBzaG90LmZvY3VzTm9kZSwgc25hcHNob3QuZm9jdXNPZmZzZXQpO1xuICAgIH1cbiAgfVxuXG4gIC8vIERvZXMgdGhlIGFjdHVhbCB1cGRhdGluZyBvZiB0aGUgbGluZSBkaXNwbGF5LiBCYWlscyBvdXRcbiAgLy8gKHJldHVybmluZyBmYWxzZSkgd2hlbiB0aGVyZSBpcyBub3RoaW5nIHRvIGJlIGRvbmUgYW5kIGZvcmNlZCBpc1xuICAvLyBmYWxzZS5cbiAgZnVuY3Rpb24gdXBkYXRlRGlzcGxheUlmTmVlZGVkKGNtLCB1cGRhdGUpIHtcbiAgICB2YXIgZGlzcGxheSA9IGNtLmRpc3BsYXksIGRvYyA9IGNtLmRvYztcblxuICAgIGlmICh1cGRhdGUuZWRpdG9ySXNIaWRkZW4pIHtcbiAgICAgIHJlc2V0VmlldyhjbSk7XG4gICAgICByZXR1cm4gZmFsc2VcbiAgICB9XG5cbiAgICAvLyBCYWlsIG91dCBpZiB0aGUgdmlzaWJsZSBhcmVhIGlzIGFscmVhZHkgcmVuZGVyZWQgYW5kIG5vdGhpbmcgY2hhbmdlZC5cbiAgICBpZiAoIXVwZGF0ZS5mb3JjZSAmJlxuICAgICAgICB1cGRhdGUudmlzaWJsZS5mcm9tID49IGRpc3BsYXkudmlld0Zyb20gJiYgdXBkYXRlLnZpc2libGUudG8gPD0gZGlzcGxheS52aWV3VG8gJiZcbiAgICAgICAgKGRpc3BsYXkudXBkYXRlTGluZU51bWJlcnMgPT0gbnVsbCB8fCBkaXNwbGF5LnVwZGF0ZUxpbmVOdW1iZXJzID49IGRpc3BsYXkudmlld1RvKSAmJlxuICAgICAgICBkaXNwbGF5LnJlbmRlcmVkVmlldyA9PSBkaXNwbGF5LnZpZXcgJiYgY291bnREaXJ0eVZpZXcoY20pID09IDApXG4gICAgICB7IHJldHVybiBmYWxzZSB9XG5cbiAgICBpZiAobWF5YmVVcGRhdGVMaW5lTnVtYmVyV2lkdGgoY20pKSB7XG4gICAgICByZXNldFZpZXcoY20pO1xuICAgICAgdXBkYXRlLmRpbXMgPSBnZXREaW1lbnNpb25zKGNtKTtcbiAgICB9XG5cbiAgICAvLyBDb21wdXRlIGEgc3VpdGFibGUgbmV3IHZpZXdwb3J0IChmcm9tICYgdG8pXG4gICAgdmFyIGVuZCA9IGRvYy5maXJzdCArIGRvYy5zaXplO1xuICAgIHZhciBmcm9tID0gTWF0aC5tYXgodXBkYXRlLnZpc2libGUuZnJvbSAtIGNtLm9wdGlvbnMudmlld3BvcnRNYXJnaW4sIGRvYy5maXJzdCk7XG4gICAgdmFyIHRvID0gTWF0aC5taW4oZW5kLCB1cGRhdGUudmlzaWJsZS50byArIGNtLm9wdGlvbnMudmlld3BvcnRNYXJnaW4pO1xuICAgIGlmIChkaXNwbGF5LnZpZXdGcm9tIDwgZnJvbSAmJiBmcm9tIC0gZGlzcGxheS52aWV3RnJvbSA8IDIwKSB7IGZyb20gPSBNYXRoLm1heChkb2MuZmlyc3QsIGRpc3BsYXkudmlld0Zyb20pOyB9XG4gICAgaWYgKGRpc3BsYXkudmlld1RvID4gdG8gJiYgZGlzcGxheS52aWV3VG8gLSB0byA8IDIwKSB7IHRvID0gTWF0aC5taW4oZW5kLCBkaXNwbGF5LnZpZXdUbyk7IH1cbiAgICBpZiAoc2F3Q29sbGFwc2VkU3BhbnMpIHtcbiAgICAgIGZyb20gPSB2aXN1YWxMaW5lTm8oY20uZG9jLCBmcm9tKTtcbiAgICAgIHRvID0gdmlzdWFsTGluZUVuZE5vKGNtLmRvYywgdG8pO1xuICAgIH1cblxuICAgIHZhciBkaWZmZXJlbnQgPSBmcm9tICE9IGRpc3BsYXkudmlld0Zyb20gfHwgdG8gIT0gZGlzcGxheS52aWV3VG8gfHxcbiAgICAgIGRpc3BsYXkubGFzdFdyYXBIZWlnaHQgIT0gdXBkYXRlLndyYXBwZXJIZWlnaHQgfHwgZGlzcGxheS5sYXN0V3JhcFdpZHRoICE9IHVwZGF0ZS53cmFwcGVyV2lkdGg7XG4gICAgYWRqdXN0VmlldyhjbSwgZnJvbSwgdG8pO1xuXG4gICAgZGlzcGxheS52aWV3T2Zmc2V0ID0gaGVpZ2h0QXRMaW5lKGdldExpbmUoY20uZG9jLCBkaXNwbGF5LnZpZXdGcm9tKSk7XG4gICAgLy8gUG9zaXRpb24gdGhlIG1vdmVyIGRpdiB0byBhbGlnbiB3aXRoIHRoZSBjdXJyZW50IHNjcm9sbCBwb3NpdGlvblxuICAgIGNtLmRpc3BsYXkubW92ZXIuc3R5bGUudG9wID0gZGlzcGxheS52aWV3T2Zmc2V0ICsgXCJweFwiO1xuXG4gICAgdmFyIHRvVXBkYXRlID0gY291bnREaXJ0eVZpZXcoY20pO1xuICAgIGlmICghZGlmZmVyZW50ICYmIHRvVXBkYXRlID09IDAgJiYgIXVwZGF0ZS5mb3JjZSAmJiBkaXNwbGF5LnJlbmRlcmVkVmlldyA9PSBkaXNwbGF5LnZpZXcgJiZcbiAgICAgICAgKGRpc3BsYXkudXBkYXRlTGluZU51bWJlcnMgPT0gbnVsbCB8fCBkaXNwbGF5LnVwZGF0ZUxpbmVOdW1iZXJzID49IGRpc3BsYXkudmlld1RvKSlcbiAgICAgIHsgcmV0dXJuIGZhbHNlIH1cblxuICAgIC8vIEZvciBiaWcgY2hhbmdlcywgd2UgaGlkZSB0aGUgZW5jbG9zaW5nIGVsZW1lbnQgZHVyaW5nIHRoZVxuICAgIC8vIHVwZGF0ZSwgc2luY2UgdGhhdCBzcGVlZHMgdXAgdGhlIG9wZXJhdGlvbnMgb24gbW9zdCBicm93c2Vycy5cbiAgICB2YXIgc2VsU25hcHNob3QgPSBzZWxlY3Rpb25TbmFwc2hvdChjbSk7XG4gICAgaWYgKHRvVXBkYXRlID4gNCkgeyBkaXNwbGF5LmxpbmVEaXYuc3R5bGUuZGlzcGxheSA9IFwibm9uZVwiOyB9XG4gICAgcGF0Y2hEaXNwbGF5KGNtLCBkaXNwbGF5LnVwZGF0ZUxpbmVOdW1iZXJzLCB1cGRhdGUuZGltcyk7XG4gICAgaWYgKHRvVXBkYXRlID4gNCkgeyBkaXNwbGF5LmxpbmVEaXYuc3R5bGUuZGlzcGxheSA9IFwiXCI7IH1cbiAgICBkaXNwbGF5LnJlbmRlcmVkVmlldyA9IGRpc3BsYXkudmlldztcbiAgICAvLyBUaGVyZSBtaWdodCBoYXZlIGJlZW4gYSB3aWRnZXQgd2l0aCBhIGZvY3VzZWQgZWxlbWVudCB0aGF0IGdvdFxuICAgIC8vIGhpZGRlbiBvciB1cGRhdGVkLCBpZiBzbyByZS1mb2N1cyBpdC5cbiAgICByZXN0b3JlU2VsZWN0aW9uKHNlbFNuYXBzaG90KTtcblxuICAgIC8vIFByZXZlbnQgc2VsZWN0aW9uIGFuZCBjdXJzb3JzIGZyb20gaW50ZXJmZXJpbmcgd2l0aCB0aGUgc2Nyb2xsXG4gICAgLy8gd2lkdGggYW5kIGhlaWdodC5cbiAgICByZW1vdmVDaGlsZHJlbihkaXNwbGF5LmN1cnNvckRpdik7XG4gICAgcmVtb3ZlQ2hpbGRyZW4oZGlzcGxheS5zZWxlY3Rpb25EaXYpO1xuICAgIGRpc3BsYXkuZ3V0dGVycy5zdHlsZS5oZWlnaHQgPSBkaXNwbGF5LnNpemVyLnN0eWxlLm1pbkhlaWdodCA9IDA7XG5cbiAgICBpZiAoZGlmZmVyZW50KSB7XG4gICAgICBkaXNwbGF5Lmxhc3RXcmFwSGVpZ2h0ID0gdXBkYXRlLndyYXBwZXJIZWlnaHQ7XG4gICAgICBkaXNwbGF5Lmxhc3RXcmFwV2lkdGggPSB1cGRhdGUud3JhcHBlcldpZHRoO1xuICAgICAgc3RhcnRXb3JrZXIoY20sIDQwMCk7XG4gICAgfVxuXG4gICAgZGlzcGxheS51cGRhdGVMaW5lTnVtYmVycyA9IG51bGw7XG5cbiAgICByZXR1cm4gdHJ1ZVxuICB9XG5cbiAgZnVuY3Rpb24gcG9zdFVwZGF0ZURpc3BsYXkoY20sIHVwZGF0ZSkge1xuICAgIHZhciB2aWV3cG9ydCA9IHVwZGF0ZS52aWV3cG9ydDtcblxuICAgIGZvciAodmFyIGZpcnN0ID0gdHJ1ZTs7IGZpcnN0ID0gZmFsc2UpIHtcbiAgICAgIGlmICghZmlyc3QgfHwgIWNtLm9wdGlvbnMubGluZVdyYXBwaW5nIHx8IHVwZGF0ZS5vbGREaXNwbGF5V2lkdGggPT0gZGlzcGxheVdpZHRoKGNtKSkge1xuICAgICAgICAvLyBDbGlwIGZvcmNlZCB2aWV3cG9ydCB0byBhY3R1YWwgc2Nyb2xsYWJsZSBhcmVhLlxuICAgICAgICBpZiAodmlld3BvcnQgJiYgdmlld3BvcnQudG9wICE9IG51bGwpXG4gICAgICAgICAgeyB2aWV3cG9ydCA9IHt0b3A6IE1hdGgubWluKGNtLmRvYy5oZWlnaHQgKyBwYWRkaW5nVmVydChjbS5kaXNwbGF5KSAtIGRpc3BsYXlIZWlnaHQoY20pLCB2aWV3cG9ydC50b3ApfTsgfVxuICAgICAgICAvLyBVcGRhdGVkIGxpbmUgaGVpZ2h0cyBtaWdodCByZXN1bHQgaW4gdGhlIGRyYXduIGFyZWEgbm90XG4gICAgICAgIC8vIGFjdHVhbGx5IGNvdmVyaW5nIHRoZSB2aWV3cG9ydC4gS2VlcCBsb29waW5nIHVudGlsIGl0IGRvZXMuXG4gICAgICAgIHVwZGF0ZS52aXNpYmxlID0gdmlzaWJsZUxpbmVzKGNtLmRpc3BsYXksIGNtLmRvYywgdmlld3BvcnQpO1xuICAgICAgICBpZiAodXBkYXRlLnZpc2libGUuZnJvbSA+PSBjbS5kaXNwbGF5LnZpZXdGcm9tICYmIHVwZGF0ZS52aXNpYmxlLnRvIDw9IGNtLmRpc3BsYXkudmlld1RvKVxuICAgICAgICAgIHsgYnJlYWsgfVxuICAgICAgfSBlbHNlIGlmIChmaXJzdCkge1xuICAgICAgICB1cGRhdGUudmlzaWJsZSA9IHZpc2libGVMaW5lcyhjbS5kaXNwbGF5LCBjbS5kb2MsIHZpZXdwb3J0KTtcbiAgICAgIH1cbiAgICAgIGlmICghdXBkYXRlRGlzcGxheUlmTmVlZGVkKGNtLCB1cGRhdGUpKSB7IGJyZWFrIH1cbiAgICAgIHVwZGF0ZUhlaWdodHNJblZpZXdwb3J0KGNtKTtcbiAgICAgIHZhciBiYXJNZWFzdXJlID0gbWVhc3VyZUZvclNjcm9sbGJhcnMoY20pO1xuICAgICAgdXBkYXRlU2VsZWN0aW9uKGNtKTtcbiAgICAgIHVwZGF0ZVNjcm9sbGJhcnMoY20sIGJhck1lYXN1cmUpO1xuICAgICAgc2V0RG9jdW1lbnRIZWlnaHQoY20sIGJhck1lYXN1cmUpO1xuICAgICAgdXBkYXRlLmZvcmNlID0gZmFsc2U7XG4gICAgfVxuXG4gICAgdXBkYXRlLnNpZ25hbChjbSwgXCJ1cGRhdGVcIiwgY20pO1xuICAgIGlmIChjbS5kaXNwbGF5LnZpZXdGcm9tICE9IGNtLmRpc3BsYXkucmVwb3J0ZWRWaWV3RnJvbSB8fCBjbS5kaXNwbGF5LnZpZXdUbyAhPSBjbS5kaXNwbGF5LnJlcG9ydGVkVmlld1RvKSB7XG4gICAgICB1cGRhdGUuc2lnbmFsKGNtLCBcInZpZXdwb3J0Q2hhbmdlXCIsIGNtLCBjbS5kaXNwbGF5LnZpZXdGcm9tLCBjbS5kaXNwbGF5LnZpZXdUbyk7XG4gICAgICBjbS5kaXNwbGF5LnJlcG9ydGVkVmlld0Zyb20gPSBjbS5kaXNwbGF5LnZpZXdGcm9tOyBjbS5kaXNwbGF5LnJlcG9ydGVkVmlld1RvID0gY20uZGlzcGxheS52aWV3VG87XG4gICAgfVxuICB9XG5cbiAgZnVuY3Rpb24gdXBkYXRlRGlzcGxheVNpbXBsZShjbSwgdmlld3BvcnQpIHtcbiAgICB2YXIgdXBkYXRlID0gbmV3IERpc3BsYXlVcGRhdGUoY20sIHZpZXdwb3J0KTtcbiAgICBpZiAodXBkYXRlRGlzcGxheUlmTmVlZGVkKGNtLCB1cGRhdGUpKSB7XG4gICAgICB1cGRhdGVIZWlnaHRzSW5WaWV3cG9ydChjbSk7XG4gICAgICBwb3N0VXBkYXRlRGlzcGxheShjbSwgdXBkYXRlKTtcbiAgICAgIHZhciBiYXJNZWFzdXJlID0gbWVhc3VyZUZvclNjcm9sbGJhcnMoY20pO1xuICAgICAgdXBkYXRlU2VsZWN0aW9uKGNtKTtcbiAgICAgIHVwZGF0ZVNjcm9sbGJhcnMoY20sIGJhck1lYXN1cmUpO1xuICAgICAgc2V0RG9jdW1lbnRIZWlnaHQoY20sIGJhck1lYXN1cmUpO1xuICAgICAgdXBkYXRlLmZpbmlzaCgpO1xuICAgIH1cbiAgfVxuXG4gIC8vIFN5bmMgdGhlIGFjdHVhbCBkaXNwbGF5IERPTSBzdHJ1Y3R1cmUgd2l0aCBkaXNwbGF5LnZpZXcsIHJlbW92aW5nXG4gIC8vIG5vZGVzIGZvciBsaW5lcyB0aGF0IGFyZSBubyBsb25nZXIgaW4gdmlldywgYW5kIGNyZWF0aW5nIHRoZSBvbmVzXG4gIC8vIHRoYXQgYXJlIG5vdCB0aGVyZSB5ZXQsIGFuZCB1cGRhdGluZyB0aGUgb25lcyB0aGF0IGFyZSBvdXQgb2ZcbiAgLy8gZGF0ZS5cbiAgZnVuY3Rpb24gcGF0Y2hEaXNwbGF5KGNtLCB1cGRhdGVOdW1iZXJzRnJvbSwgZGltcykge1xuICAgIHZhciBkaXNwbGF5ID0gY20uZGlzcGxheSwgbGluZU51bWJlcnMgPSBjbS5vcHRpb25zLmxpbmVOdW1iZXJzO1xuICAgIHZhciBjb250YWluZXIgPSBkaXNwbGF5LmxpbmVEaXYsIGN1ciA9IGNvbnRhaW5lci5maXJzdENoaWxkO1xuXG4gICAgZnVuY3Rpb24gcm0obm9kZSkge1xuICAgICAgdmFyIG5leHQgPSBub2RlLm5leHRTaWJsaW5nO1xuICAgICAgLy8gV29ya3MgYXJvdW5kIGEgdGhyb3ctc2Nyb2xsIGJ1ZyBpbiBPUyBYIFdlYmtpdFxuICAgICAgaWYgKHdlYmtpdCAmJiBtYWMgJiYgY20uZGlzcGxheS5jdXJyZW50V2hlZWxUYXJnZXQgPT0gbm9kZSlcbiAgICAgICAgeyBub2RlLnN0eWxlLmRpc3BsYXkgPSBcIm5vbmVcIjsgfVxuICAgICAgZWxzZVxuICAgICAgICB7IG5vZGUucGFyZW50Tm9kZS5yZW1vdmVDaGlsZChub2RlKTsgfVxuICAgICAgcmV0dXJuIG5leHRcbiAgICB9XG5cbiAgICB2YXIgdmlldyA9IGRpc3BsYXkudmlldywgbGluZU4gPSBkaXNwbGF5LnZpZXdGcm9tO1xuICAgIC8vIExvb3Agb3ZlciB0aGUgZWxlbWVudHMgaW4gdGhlIHZpZXcsIHN5bmNpbmcgY3VyICh0aGUgRE9NIG5vZGVzXG4gICAgLy8gaW4gZGlzcGxheS5saW5lRGl2KSB3aXRoIHRoZSB2aWV3IGFzIHdlIGdvLlxuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdmlldy5sZW5ndGg7IGkrKykge1xuICAgICAgdmFyIGxpbmVWaWV3ID0gdmlld1tpXTtcbiAgICAgIGlmIChsaW5lVmlldy5oaWRkZW4pIDsgZWxzZSBpZiAoIWxpbmVWaWV3Lm5vZGUgfHwgbGluZVZpZXcubm9kZS5wYXJlbnROb2RlICE9IGNvbnRhaW5lcikgeyAvLyBOb3QgZHJhd24geWV0XG4gICAgICAgIHZhciBub2RlID0gYnVpbGRMaW5lRWxlbWVudChjbSwgbGluZVZpZXcsIGxpbmVOLCBkaW1zKTtcbiAgICAgICAgY29udGFpbmVyLmluc2VydEJlZm9yZShub2RlLCBjdXIpO1xuICAgICAgfSBlbHNlIHsgLy8gQWxyZWFkeSBkcmF3blxuICAgICAgICB3aGlsZSAoY3VyICE9IGxpbmVWaWV3Lm5vZGUpIHsgY3VyID0gcm0oY3VyKTsgfVxuICAgICAgICB2YXIgdXBkYXRlTnVtYmVyID0gbGluZU51bWJlcnMgJiYgdXBkYXRlTnVtYmVyc0Zyb20gIT0gbnVsbCAmJlxuICAgICAgICAgIHVwZGF0ZU51bWJlcnNGcm9tIDw9IGxpbmVOICYmIGxpbmVWaWV3LmxpbmVOdW1iZXI7XG4gICAgICAgIGlmIChsaW5lVmlldy5jaGFuZ2VzKSB7XG4gICAgICAgICAgaWYgKGluZGV4T2YobGluZVZpZXcuY2hhbmdlcywgXCJndXR0ZXJcIikgPiAtMSkgeyB1cGRhdGVOdW1iZXIgPSBmYWxzZTsgfVxuICAgICAgICAgIHVwZGF0ZUxpbmVGb3JDaGFuZ2VzKGNtLCBsaW5lVmlldywgbGluZU4sIGRpbXMpO1xuICAgICAgICB9XG4gICAgICAgIGlmICh1cGRhdGVOdW1iZXIpIHtcbiAgICAgICAgICByZW1vdmVDaGlsZHJlbihsaW5lVmlldy5saW5lTnVtYmVyKTtcbiAgICAgICAgICBsaW5lVmlldy5saW5lTnVtYmVyLmFwcGVuZENoaWxkKGRvY3VtZW50LmNyZWF0ZVRleHROb2RlKGxpbmVOdW1iZXJGb3IoY20ub3B0aW9ucywgbGluZU4pKSk7XG4gICAgICAgIH1cbiAgICAgICAgY3VyID0gbGluZVZpZXcubm9kZS5uZXh0U2libGluZztcbiAgICAgIH1cbiAgICAgIGxpbmVOICs9IGxpbmVWaWV3LnNpemU7XG4gICAgfVxuICAgIHdoaWxlIChjdXIpIHsgY3VyID0gcm0oY3VyKTsgfVxuICB9XG5cbiAgZnVuY3Rpb24gdXBkYXRlR3V0dGVyU3BhY2UoZGlzcGxheSkge1xuICAgIHZhciB3aWR0aCA9IGRpc3BsYXkuZ3V0dGVycy5vZmZzZXRXaWR0aDtcbiAgICBkaXNwbGF5LnNpemVyLnN0eWxlLm1hcmdpbkxlZnQgPSB3aWR0aCArIFwicHhcIjtcbiAgICAvLyBTZW5kIGFuIGV2ZW50IHRvIGNvbnN1bWVycyByZXNwb25kaW5nIHRvIGNoYW5nZXMgaW4gZ3V0dGVyIHdpZHRoLlxuICAgIHNpZ25hbExhdGVyKGRpc3BsYXksIFwiZ3V0dGVyQ2hhbmdlZFwiLCBkaXNwbGF5KTtcbiAgfVxuXG4gIGZ1bmN0aW9uIHNldERvY3VtZW50SGVpZ2h0KGNtLCBtZWFzdXJlKSB7XG4gICAgY20uZGlzcGxheS5zaXplci5zdHlsZS5taW5IZWlnaHQgPSBtZWFzdXJlLmRvY0hlaWdodCArIFwicHhcIjtcbiAgICBjbS5kaXNwbGF5LmhlaWdodEZvcmNlci5zdHlsZS50b3AgPSBtZWFzdXJlLmRvY0hlaWdodCArIFwicHhcIjtcbiAgICBjbS5kaXNwbGF5Lmd1dHRlcnMuc3R5bGUuaGVpZ2h0ID0gKG1lYXN1cmUuZG9jSGVpZ2h0ICsgY20uZGlzcGxheS5iYXJIZWlnaHQgKyBzY3JvbGxHYXAoY20pKSArIFwicHhcIjtcbiAgfVxuXG4gIC8vIFJlLWFsaWduIGxpbmUgbnVtYmVycyBhbmQgZ3V0dGVyIG1hcmtzIHRvIGNvbXBlbnNhdGUgZm9yXG4gIC8vIGhvcml6b250YWwgc2Nyb2xsaW5nLlxuICBmdW5jdGlvbiBhbGlnbkhvcml6b250YWxseShjbSkge1xuICAgIHZhciBkaXNwbGF5ID0gY20uZGlzcGxheSwgdmlldyA9IGRpc3BsYXkudmlldztcbiAgICBpZiAoIWRpc3BsYXkuYWxpZ25XaWRnZXRzICYmICghZGlzcGxheS5ndXR0ZXJzLmZpcnN0Q2hpbGQgfHwgIWNtLm9wdGlvbnMuZml4ZWRHdXR0ZXIpKSB7IHJldHVybiB9XG4gICAgdmFyIGNvbXAgPSBjb21wZW5zYXRlRm9ySFNjcm9sbChkaXNwbGF5KSAtIGRpc3BsYXkuc2Nyb2xsZXIuc2Nyb2xsTGVmdCArIGNtLmRvYy5zY3JvbGxMZWZ0O1xuICAgIHZhciBndXR0ZXJXID0gZGlzcGxheS5ndXR0ZXJzLm9mZnNldFdpZHRoLCBsZWZ0ID0gY29tcCArIFwicHhcIjtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IHZpZXcubGVuZ3RoOyBpKyspIHsgaWYgKCF2aWV3W2ldLmhpZGRlbikge1xuICAgICAgaWYgKGNtLm9wdGlvbnMuZml4ZWRHdXR0ZXIpIHtcbiAgICAgICAgaWYgKHZpZXdbaV0uZ3V0dGVyKVxuICAgICAgICAgIHsgdmlld1tpXS5ndXR0ZXIuc3R5bGUubGVmdCA9IGxlZnQ7IH1cbiAgICAgICAgaWYgKHZpZXdbaV0uZ3V0dGVyQmFja2dyb3VuZClcbiAgICAgICAgICB7IHZpZXdbaV0uZ3V0dGVyQmFja2dyb3VuZC5zdHlsZS5sZWZ0ID0gbGVmdDsgfVxuICAgICAgfVxuICAgICAgdmFyIGFsaWduID0gdmlld1tpXS5hbGlnbmFibGU7XG4gICAgICBpZiAoYWxpZ24pIHsgZm9yICh2YXIgaiA9IDA7IGogPCBhbGlnbi5sZW5ndGg7IGorKylcbiAgICAgICAgeyBhbGlnbltqXS5zdHlsZS5sZWZ0ID0gbGVmdDsgfSB9XG4gICAgfSB9XG4gICAgaWYgKGNtLm9wdGlvbnMuZml4ZWRHdXR0ZXIpXG4gICAgICB7IGRpc3BsYXkuZ3V0dGVycy5zdHlsZS5sZWZ0ID0gKGNvbXAgKyBndXR0ZXJXKSArIFwicHhcIjsgfVxuICB9XG5cbiAgLy8gVXNlZCB0byBlbnN1cmUgdGhhdCB0aGUgbGluZSBudW1iZXIgZ3V0dGVyIGlzIHN0aWxsIHRoZSByaWdodFxuICAvLyBzaXplIGZvciB0aGUgY3VycmVudCBkb2N1bWVudCBzaXplLiBSZXR1cm5zIHRydWUgd2hlbiBhbiB1cGRhdGVcbiAgLy8gaXMgbmVlZGVkLlxuICBmdW5jdGlvbiBtYXliZVVwZGF0ZUxpbmVOdW1iZXJXaWR0aChjbSkge1xuICAgIGlmICghY20ub3B0aW9ucy5saW5lTnVtYmVycykgeyByZXR1cm4gZmFsc2UgfVxuICAgIHZhciBkb2MgPSBjbS5kb2MsIGxhc3QgPSBsaW5lTnVtYmVyRm9yKGNtLm9wdGlvbnMsIGRvYy5maXJzdCArIGRvYy5zaXplIC0gMSksIGRpc3BsYXkgPSBjbS5kaXNwbGF5O1xuICAgIGlmIChsYXN0Lmxlbmd0aCAhPSBkaXNwbGF5LmxpbmVOdW1DaGFycykge1xuICAgICAgdmFyIHRlc3QgPSBkaXNwbGF5Lm1lYXN1cmUuYXBwZW5kQ2hpbGQoZWx0KFwiZGl2XCIsIFtlbHQoXCJkaXZcIiwgbGFzdCldLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIFwiQ29kZU1pcnJvci1saW5lbnVtYmVyIENvZGVNaXJyb3ItZ3V0dGVyLWVsdFwiKSk7XG4gICAgICB2YXIgaW5uZXJXID0gdGVzdC5maXJzdENoaWxkLm9mZnNldFdpZHRoLCBwYWRkaW5nID0gdGVzdC5vZmZzZXRXaWR0aCAtIGlubmVyVztcbiAgICAgIGRpc3BsYXkubGluZUd1dHRlci5zdHlsZS53aWR0aCA9IFwiXCI7XG4gICAgICBkaXNwbGF5LmxpbmVOdW1Jbm5lcldpZHRoID0gTWF0aC5tYXgoaW5uZXJXLCBkaXNwbGF5LmxpbmVHdXR0ZXIub2Zmc2V0V2lkdGggLSBwYWRkaW5nKSArIDE7XG4gICAgICBkaXNwbGF5LmxpbmVOdW1XaWR0aCA9IGRpc3BsYXkubGluZU51bUlubmVyV2lkdGggKyBwYWRkaW5nO1xuICAgICAgZGlzcGxheS5saW5lTnVtQ2hhcnMgPSBkaXNwbGF5LmxpbmVOdW1Jbm5lcldpZHRoID8gbGFzdC5sZW5ndGggOiAtMTtcbiAgICAgIGRpc3BsYXkubGluZUd1dHRlci5zdHlsZS53aWR0aCA9IGRpc3BsYXkubGluZU51bVdpZHRoICsgXCJweFwiO1xuICAgICAgdXBkYXRlR3V0dGVyU3BhY2UoY20uZGlzcGxheSk7XG4gICAgICByZXR1cm4gdHJ1ZVxuICAgIH1cbiAgICByZXR1cm4gZmFsc2VcbiAgfVxuXG4gIGZ1bmN0aW9uIGdldEd1dHRlcnMoZ3V0dGVycywgbGluZU51bWJlcnMpIHtcbiAgICB2YXIgcmVzdWx0ID0gW10sIHNhd0xpbmVOdW1iZXJzID0gZmFsc2U7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBndXR0ZXJzLmxlbmd0aDsgaSsrKSB7XG4gICAgICB2YXIgbmFtZSA9IGd1dHRlcnNbaV0sIHN0eWxlID0gbnVsbDtcbiAgICAgIGlmICh0eXBlb2YgbmFtZSAhPSBcInN0cmluZ1wiKSB7IHN0eWxlID0gbmFtZS5zdHlsZTsgbmFtZSA9IG5hbWUuY2xhc3NOYW1lOyB9XG4gICAgICBpZiAobmFtZSA9PSBcIkNvZGVNaXJyb3ItbGluZW51bWJlcnNcIikge1xuICAgICAgICBpZiAoIWxpbmVOdW1iZXJzKSB7IGNvbnRpbnVlIH1cbiAgICAgICAgZWxzZSB7IHNhd0xpbmVOdW1iZXJzID0gdHJ1ZTsgfVxuICAgICAgfVxuICAgICAgcmVzdWx0LnB1c2goe2NsYXNzTmFtZTogbmFtZSwgc3R5bGU6IHN0eWxlfSk7XG4gICAgfVxuICAgIGlmIChsaW5lTnVtYmVycyAmJiAhc2F3TGluZU51bWJlcnMpIHsgcmVzdWx0LnB1c2goe2NsYXNzTmFtZTogXCJDb2RlTWlycm9yLWxpbmVudW1iZXJzXCIsIHN0eWxlOiBudWxsfSk7IH1cbiAgICByZXR1cm4gcmVzdWx0XG4gIH1cblxuICAvLyBSZWJ1aWxkIHRoZSBndXR0ZXIgZWxlbWVudHMsIGVuc3VyZSB0aGUgbWFyZ2luIHRvIHRoZSBsZWZ0IG9mIHRoZVxuICAvLyBjb2RlIG1hdGNoZXMgdGhlaXIgd2lkdGguXG4gIGZ1bmN0aW9uIHJlbmRlckd1dHRlcnMoZGlzcGxheSkge1xuICAgIHZhciBndXR0ZXJzID0gZGlzcGxheS5ndXR0ZXJzLCBzcGVjcyA9IGRpc3BsYXkuZ3V0dGVyU3BlY3M7XG4gICAgcmVtb3ZlQ2hpbGRyZW4oZ3V0dGVycyk7XG4gICAgZGlzcGxheS5saW5lR3V0dGVyID0gbnVsbDtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IHNwZWNzLmxlbmd0aDsgKytpKSB7XG4gICAgICB2YXIgcmVmID0gc3BlY3NbaV07XG4gICAgICB2YXIgY2xhc3NOYW1lID0gcmVmLmNsYXNzTmFtZTtcbiAgICAgIHZhciBzdHlsZSA9IHJlZi5zdHlsZTtcbiAgICAgIHZhciBnRWx0ID0gZ3V0dGVycy5hcHBlbmRDaGlsZChlbHQoXCJkaXZcIiwgbnVsbCwgXCJDb2RlTWlycm9yLWd1dHRlciBcIiArIGNsYXNzTmFtZSkpO1xuICAgICAgaWYgKHN0eWxlKSB7IGdFbHQuc3R5bGUuY3NzVGV4dCA9IHN0eWxlOyB9XG4gICAgICBpZiAoY2xhc3NOYW1lID09IFwiQ29kZU1pcnJvci1saW5lbnVtYmVyc1wiKSB7XG4gICAgICAgIGRpc3BsYXkubGluZUd1dHRlciA9IGdFbHQ7XG4gICAgICAgIGdFbHQuc3R5bGUud2lkdGggPSAoZGlzcGxheS5saW5lTnVtV2lkdGggfHwgMSkgKyBcInB4XCI7XG4gICAgICB9XG4gICAgfVxuICAgIGd1dHRlcnMuc3R5bGUuZGlzcGxheSA9IHNwZWNzLmxlbmd0aCA/IFwiXCIgOiBcIm5vbmVcIjtcbiAgICB1cGRhdGVHdXR0ZXJTcGFjZShkaXNwbGF5KTtcbiAgfVxuXG4gIGZ1bmN0aW9uIHVwZGF0ZUd1dHRlcnMoY20pIHtcbiAgICByZW5kZXJHdXR0ZXJzKGNtLmRpc3BsYXkpO1xuICAgIHJlZ0NoYW5nZShjbSk7XG4gICAgYWxpZ25Ib3Jpem9udGFsbHkoY20pO1xuICB9XG5cbiAgLy8gVGhlIGRpc3BsYXkgaGFuZGxlcyB0aGUgRE9NIGludGVncmF0aW9uLCBib3RoIGZvciBpbnB1dCByZWFkaW5nXG4gIC8vIGFuZCBjb250ZW50IGRyYXdpbmcuIEl0IGhvbGRzIHJlZmVyZW5jZXMgdG8gRE9NIG5vZGVzIGFuZFxuICAvLyBkaXNwbGF5LXJlbGF0ZWQgc3RhdGUuXG5cbiAgZnVuY3Rpb24gRGlzcGxheShwbGFjZSwgZG9jLCBpbnB1dCwgb3B0aW9ucykge1xuICAgIHZhciBkID0gdGhpcztcbiAgICB0aGlzLmlucHV0ID0gaW5wdXQ7XG5cbiAgICAvLyBDb3ZlcnMgYm90dG9tLXJpZ2h0IHNxdWFyZSB3aGVuIGJvdGggc2Nyb2xsYmFycyBhcmUgcHJlc2VudC5cbiAgICBkLnNjcm9sbGJhckZpbGxlciA9IGVsdChcImRpdlwiLCBudWxsLCBcIkNvZGVNaXJyb3Itc2Nyb2xsYmFyLWZpbGxlclwiKTtcbiAgICBkLnNjcm9sbGJhckZpbGxlci5zZXRBdHRyaWJ1dGUoXCJjbS1ub3QtY29udGVudFwiLCBcInRydWVcIik7XG4gICAgLy8gQ292ZXJzIGJvdHRvbSBvZiBndXR0ZXIgd2hlbiBjb3Zlckd1dHRlck5leHRUb1Njcm9sbGJhciBpcyBvblxuICAgIC8vIGFuZCBoIHNjcm9sbGJhciBpcyBwcmVzZW50LlxuICAgIGQuZ3V0dGVyRmlsbGVyID0gZWx0KFwiZGl2XCIsIG51bGwsIFwiQ29kZU1pcnJvci1ndXR0ZXItZmlsbGVyXCIpO1xuICAgIGQuZ3V0dGVyRmlsbGVyLnNldEF0dHJpYnV0ZShcImNtLW5vdC1jb250ZW50XCIsIFwidHJ1ZVwiKTtcbiAgICAvLyBXaWxsIGNvbnRhaW4gdGhlIGFjdHVhbCBjb2RlLCBwb3NpdGlvbmVkIHRvIGNvdmVyIHRoZSB2aWV3cG9ydC5cbiAgICBkLmxpbmVEaXYgPSBlbHRQKFwiZGl2XCIsIG51bGwsIFwiQ29kZU1pcnJvci1jb2RlXCIpO1xuICAgIC8vIEVsZW1lbnRzIGFyZSBhZGRlZCB0byB0aGVzZSB0byByZXByZXNlbnQgc2VsZWN0aW9uIGFuZCBjdXJzb3JzLlxuICAgIGQuc2VsZWN0aW9uRGl2ID0gZWx0KFwiZGl2XCIsIG51bGwsIG51bGwsIFwicG9zaXRpb246IHJlbGF0aXZlOyB6LWluZGV4OiAxXCIpO1xuICAgIGQuY3Vyc29yRGl2ID0gZWx0KFwiZGl2XCIsIG51bGwsIFwiQ29kZU1pcnJvci1jdXJzb3JzXCIpO1xuICAgIC8vIEEgdmlzaWJpbGl0eTogaGlkZGVuIGVsZW1lbnQgdXNlZCB0byBmaW5kIHRoZSBzaXplIG9mIHRoaW5ncy5cbiAgICBkLm1lYXN1cmUgPSBlbHQoXCJkaXZcIiwgbnVsbCwgXCJDb2RlTWlycm9yLW1lYXN1cmVcIik7XG4gICAgLy8gV2hlbiBsaW5lcyBvdXRzaWRlIG9mIHRoZSB2aWV3cG9ydCBhcmUgbWVhc3VyZWQsIHRoZXkgYXJlIGRyYXduIGluIHRoaXMuXG4gICAgZC5saW5lTWVhc3VyZSA9IGVsdChcImRpdlwiLCBudWxsLCBcIkNvZGVNaXJyb3ItbWVhc3VyZVwiKTtcbiAgICAvLyBXcmFwcyBldmVyeXRoaW5nIHRoYXQgbmVlZHMgdG8gZXhpc3QgaW5zaWRlIHRoZSB2ZXJ0aWNhbGx5LXBhZGRlZCBjb29yZGluYXRlIHN5c3RlbVxuICAgIGQubGluZVNwYWNlID0gZWx0UChcImRpdlwiLCBbZC5tZWFzdXJlLCBkLmxpbmVNZWFzdXJlLCBkLnNlbGVjdGlvbkRpdiwgZC5jdXJzb3JEaXYsIGQubGluZURpdl0sXG4gICAgICAgICAgICAgICAgICAgICAgbnVsbCwgXCJwb3NpdGlvbjogcmVsYXRpdmU7IG91dGxpbmU6IG5vbmVcIik7XG4gICAgdmFyIGxpbmVzID0gZWx0UChcImRpdlwiLCBbZC5saW5lU3BhY2VdLCBcIkNvZGVNaXJyb3ItbGluZXNcIik7XG4gICAgLy8gTW92ZWQgYXJvdW5kIGl0cyBwYXJlbnQgdG8gY292ZXIgdmlzaWJsZSB2aWV3LlxuICAgIGQubW92ZXIgPSBlbHQoXCJkaXZcIiwgW2xpbmVzXSwgbnVsbCwgXCJwb3NpdGlvbjogcmVsYXRpdmVcIik7XG4gICAgLy8gU2V0IHRvIHRoZSBoZWlnaHQgb2YgdGhlIGRvY3VtZW50LCBhbGxvd2luZyBzY3JvbGxpbmcuXG4gICAgZC5zaXplciA9IGVsdChcImRpdlwiLCBbZC5tb3Zlcl0sIFwiQ29kZU1pcnJvci1zaXplclwiKTtcbiAgICBkLnNpemVyV2lkdGggPSBudWxsO1xuICAgIC8vIEJlaGF2aW9yIG9mIGVsdHMgd2l0aCBvdmVyZmxvdzogYXV0byBhbmQgcGFkZGluZyBpc1xuICAgIC8vIGluY29uc2lzdGVudCBhY3Jvc3MgYnJvd3NlcnMuIFRoaXMgaXMgdXNlZCB0byBlbnN1cmUgdGhlXG4gICAgLy8gc2Nyb2xsYWJsZSBhcmVhIGlzIGJpZyBlbm91Z2guXG4gICAgZC5oZWlnaHRGb3JjZXIgPSBlbHQoXCJkaXZcIiwgbnVsbCwgbnVsbCwgXCJwb3NpdGlvbjogYWJzb2x1dGU7IGhlaWdodDogXCIgKyBzY3JvbGxlckdhcCArIFwicHg7IHdpZHRoOiAxcHg7XCIpO1xuICAgIC8vIFdpbGwgY29udGFpbiB0aGUgZ3V0dGVycywgaWYgYW55LlxuICAgIGQuZ3V0dGVycyA9IGVsdChcImRpdlwiLCBudWxsLCBcIkNvZGVNaXJyb3ItZ3V0dGVyc1wiKTtcbiAgICBkLmxpbmVHdXR0ZXIgPSBudWxsO1xuICAgIC8vIEFjdHVhbCBzY3JvbGxhYmxlIGVsZW1lbnQuXG4gICAgZC5zY3JvbGxlciA9IGVsdChcImRpdlwiLCBbZC5zaXplciwgZC5oZWlnaHRGb3JjZXIsIGQuZ3V0dGVyc10sIFwiQ29kZU1pcnJvci1zY3JvbGxcIik7XG4gICAgZC5zY3JvbGxlci5zZXRBdHRyaWJ1dGUoXCJ0YWJJbmRleFwiLCBcIi0xXCIpO1xuICAgIC8vIFRoZSBlbGVtZW50IGluIHdoaWNoIHRoZSBlZGl0b3IgbGl2ZXMuXG4gICAgZC53cmFwcGVyID0gZWx0KFwiZGl2XCIsIFtkLnNjcm9sbGJhckZpbGxlciwgZC5ndXR0ZXJGaWxsZXIsIGQuc2Nyb2xsZXJdLCBcIkNvZGVNaXJyb3JcIik7XG5cbiAgICAvLyBUaGlzIGF0dHJpYnV0ZSBpcyByZXNwZWN0ZWQgYnkgYXV0b21hdGljIHRyYW5zbGF0aW9uIHN5c3RlbXMgc3VjaCBhcyBHb29nbGUgVHJhbnNsYXRlLFxuICAgIC8vIGFuZCBtYXkgYWxzbyBiZSByZXNwZWN0ZWQgYnkgdG9vbHMgdXNlZCBieSBodW1hbiB0cmFuc2xhdG9ycy5cbiAgICBkLndyYXBwZXIuc2V0QXR0cmlidXRlKCd0cmFuc2xhdGUnLCAnbm8nKTtcblxuICAgIC8vIFdvcmsgYXJvdW5kIElFNyB6LWluZGV4IGJ1ZyAobm90IHBlcmZlY3QsIGhlbmNlIElFNyBub3QgcmVhbGx5IGJlaW5nIHN1cHBvcnRlZClcbiAgICBpZiAoaWUgJiYgaWVfdmVyc2lvbiA8IDgpIHsgZC5ndXR0ZXJzLnN0eWxlLnpJbmRleCA9IC0xOyBkLnNjcm9sbGVyLnN0eWxlLnBhZGRpbmdSaWdodCA9IDA7IH1cbiAgICBpZiAoIXdlYmtpdCAmJiAhKGdlY2tvICYmIG1vYmlsZSkpIHsgZC5zY3JvbGxlci5kcmFnZ2FibGUgPSB0cnVlOyB9XG5cbiAgICBpZiAocGxhY2UpIHtcbiAgICAgIGlmIChwbGFjZS5hcHBlbmRDaGlsZCkgeyBwbGFjZS5hcHBlbmRDaGlsZChkLndyYXBwZXIpOyB9XG4gICAgICBlbHNlIHsgcGxhY2UoZC53cmFwcGVyKTsgfVxuICAgIH1cblxuICAgIC8vIEN1cnJlbnQgcmVuZGVyZWQgcmFuZ2UgKG1heSBiZSBiaWdnZXIgdGhhbiB0aGUgdmlldyB3aW5kb3cpLlxuICAgIGQudmlld0Zyb20gPSBkLnZpZXdUbyA9IGRvYy5maXJzdDtcbiAgICBkLnJlcG9ydGVkVmlld0Zyb20gPSBkLnJlcG9ydGVkVmlld1RvID0gZG9jLmZpcnN0O1xuICAgIC8vIEluZm9ybWF0aW9uIGFib3V0IHRoZSByZW5kZXJlZCBsaW5lcy5cbiAgICBkLnZpZXcgPSBbXTtcbiAgICBkLnJlbmRlcmVkVmlldyA9IG51bGw7XG4gICAgLy8gSG9sZHMgaW5mbyBhYm91dCBhIHNpbmdsZSByZW5kZXJlZCBsaW5lIHdoZW4gaXQgd2FzIHJlbmRlcmVkXG4gICAgLy8gZm9yIG1lYXN1cmVtZW50LCB3aGlsZSBub3QgaW4gdmlldy5cbiAgICBkLmV4dGVybmFsTWVhc3VyZWQgPSBudWxsO1xuICAgIC8vIEVtcHR5IHNwYWNlIChpbiBwaXhlbHMpIGFib3ZlIHRoZSB2aWV3XG4gICAgZC52aWV3T2Zmc2V0ID0gMDtcbiAgICBkLmxhc3RXcmFwSGVpZ2h0ID0gZC5sYXN0V3JhcFdpZHRoID0gMDtcbiAgICBkLnVwZGF0ZUxpbmVOdW1iZXJzID0gbnVsbDtcblxuICAgIGQubmF0aXZlQmFyV2lkdGggPSBkLmJhckhlaWdodCA9IGQuYmFyV2lkdGggPSAwO1xuICAgIGQuc2Nyb2xsYmFyc0NsaXBwZWQgPSBmYWxzZTtcblxuICAgIC8vIFVzZWQgdG8gb25seSByZXNpemUgdGhlIGxpbmUgbnVtYmVyIGd1dHRlciB3aGVuIG5lY2Vzc2FyeSAod2hlblxuICAgIC8vIHRoZSBhbW91bnQgb2YgbGluZXMgY3Jvc3NlcyBhIGJvdW5kYXJ5IHRoYXQgbWFrZXMgaXRzIHdpZHRoIGNoYW5nZSlcbiAgICBkLmxpbmVOdW1XaWR0aCA9IGQubGluZU51bUlubmVyV2lkdGggPSBkLmxpbmVOdW1DaGFycyA9IG51bGw7XG4gICAgLy8gU2V0IHRvIHRydWUgd2hlbiBhIG5vbi1ob3Jpem9udGFsLXNjcm9sbGluZyBsaW5lIHdpZGdldCBpc1xuICAgIC8vIGFkZGVkLiBBcyBhbiBvcHRpbWl6YXRpb24sIGxpbmUgd2lkZ2V0IGFsaWduaW5nIGlzIHNraXBwZWQgd2hlblxuICAgIC8vIHRoaXMgaXMgZmFsc2UuXG4gICAgZC5hbGlnbldpZGdldHMgPSBmYWxzZTtcblxuICAgIGQuY2FjaGVkQ2hhcldpZHRoID0gZC5jYWNoZWRUZXh0SGVpZ2h0ID0gZC5jYWNoZWRQYWRkaW5nSCA9IG51bGw7XG5cbiAgICAvLyBUcmFja3MgdGhlIG1heGltdW0gbGluZSBsZW5ndGggc28gdGhhdCB0aGUgaG9yaXpvbnRhbCBzY3JvbGxiYXJcbiAgICAvLyBjYW4gYmUga2VwdCBzdGF0aWMgd2hlbiBzY3JvbGxpbmcuXG4gICAgZC5tYXhMaW5lID0gbnVsbDtcbiAgICBkLm1heExpbmVMZW5ndGggPSAwO1xuICAgIGQubWF4TGluZUNoYW5nZWQgPSBmYWxzZTtcblxuICAgIC8vIFVzZWQgZm9yIG1lYXN1cmluZyB3aGVlbCBzY3JvbGxpbmcgZ3JhbnVsYXJpdHlcbiAgICBkLndoZWVsRFggPSBkLndoZWVsRFkgPSBkLndoZWVsU3RhcnRYID0gZC53aGVlbFN0YXJ0WSA9IG51bGw7XG5cbiAgICAvLyBUcnVlIHdoZW4gc2hpZnQgaXMgaGVsZCBkb3duLlxuICAgIGQuc2hpZnQgPSBmYWxzZTtcblxuICAgIC8vIFVzZWQgdG8gdHJhY2sgd2hldGhlciBhbnl0aGluZyBoYXBwZW5lZCBzaW5jZSB0aGUgY29udGV4dCBtZW51XG4gICAgLy8gd2FzIG9wZW5lZC5cbiAgICBkLnNlbEZvckNvbnRleHRNZW51ID0gbnVsbDtcblxuICAgIGQuYWN0aXZlVG91Y2ggPSBudWxsO1xuXG4gICAgZC5ndXR0ZXJTcGVjcyA9IGdldEd1dHRlcnMob3B0aW9ucy5ndXR0ZXJzLCBvcHRpb25zLmxpbmVOdW1iZXJzKTtcbiAgICByZW5kZXJHdXR0ZXJzKGQpO1xuXG4gICAgaW5wdXQuaW5pdChkKTtcbiAgfVxuXG4gIC8vIFNpbmNlIHRoZSBkZWx0YSB2YWx1ZXMgcmVwb3J0ZWQgb24gbW91c2Ugd2hlZWwgZXZlbnRzIGFyZVxuICAvLyB1bnN0YW5kYXJkaXplZCBiZXR3ZWVuIGJyb3dzZXJzIGFuZCBldmVuIGJyb3dzZXIgdmVyc2lvbnMsIGFuZFxuICAvLyBnZW5lcmFsbHkgaG9ycmlibHkgdW5wcmVkaWN0YWJsZSwgdGhpcyBjb2RlIHN0YXJ0cyBieSBtZWFzdXJpbmdcbiAgLy8gdGhlIHNjcm9sbCBlZmZlY3QgdGhhdCB0aGUgZmlyc3QgZmV3IG1vdXNlIHdoZWVsIGV2ZW50cyBoYXZlLFxuICAvLyBhbmQsIGZyb20gdGhhdCwgZGV0ZWN0cyB0aGUgd2F5IGl0IGNhbiBjb252ZXJ0IGRlbHRhcyB0byBwaXhlbFxuICAvLyBvZmZzZXRzIGFmdGVyd2FyZHMuXG4gIC8vXG4gIC8vIFRoZSByZWFzb24gd2Ugd2FudCB0byBrbm93IHRoZSBhbW91bnQgYSB3aGVlbCBldmVudCB3aWxsIHNjcm9sbFxuICAvLyBpcyB0aGF0IGl0IGdpdmVzIHVzIGEgY2hhbmNlIHRvIHVwZGF0ZSB0aGUgZGlzcGxheSBiZWZvcmUgdGhlXG4gIC8vIGFjdHVhbCBzY3JvbGxpbmcgaGFwcGVucywgcmVkdWNpbmcgZmxpY2tlcmluZy5cblxuICB2YXIgd2hlZWxTYW1wbGVzID0gMCwgd2hlZWxQaXhlbHNQZXJVbml0ID0gbnVsbDtcbiAgLy8gRmlsbCBpbiBhIGJyb3dzZXItZGV0ZWN0ZWQgc3RhcnRpbmcgdmFsdWUgb24gYnJvd3NlcnMgd2hlcmUgd2VcbiAgLy8ga25vdyBvbmUuIFRoZXNlIGRvbid0IGhhdmUgdG8gYmUgYWNjdXJhdGUgLS0gdGhlIHJlc3VsdCBvZiB0aGVtXG4gIC8vIGJlaW5nIHdyb25nIHdvdWxkIGp1c3QgYmUgYSBzbGlnaHQgZmxpY2tlciBvbiB0aGUgZmlyc3Qgd2hlZWxcbiAgLy8gc2Nyb2xsIChpZiBpdCBpcyBsYXJnZSBlbm91Z2gpLlxuICBpZiAoaWUpIHsgd2hlZWxQaXhlbHNQZXJVbml0ID0gLS41MzsgfVxuICBlbHNlIGlmIChnZWNrbykgeyB3aGVlbFBpeGVsc1BlclVuaXQgPSAxNTsgfVxuICBlbHNlIGlmIChjaHJvbWUpIHsgd2hlZWxQaXhlbHNQZXJVbml0ID0gLS43OyB9XG4gIGVsc2UgaWYgKHNhZmFyaSkgeyB3aGVlbFBpeGVsc1BlclVuaXQgPSAtMS8zOyB9XG5cbiAgZnVuY3Rpb24gd2hlZWxFdmVudERlbHRhKGUpIHtcbiAgICB2YXIgZHggPSBlLndoZWVsRGVsdGFYLCBkeSA9IGUud2hlZWxEZWx0YVk7XG4gICAgaWYgKGR4ID09IG51bGwgJiYgZS5kZXRhaWwgJiYgZS5heGlzID09IGUuSE9SSVpPTlRBTF9BWElTKSB7IGR4ID0gZS5kZXRhaWw7IH1cbiAgICBpZiAoZHkgPT0gbnVsbCAmJiBlLmRldGFpbCAmJiBlLmF4aXMgPT0gZS5WRVJUSUNBTF9BWElTKSB7IGR5ID0gZS5kZXRhaWw7IH1cbiAgICBlbHNlIGlmIChkeSA9PSBudWxsKSB7IGR5ID0gZS53aGVlbERlbHRhOyB9XG4gICAgcmV0dXJuIHt4OiBkeCwgeTogZHl9XG4gIH1cbiAgZnVuY3Rpb24gd2hlZWxFdmVudFBpeGVscyhlKSB7XG4gICAgdmFyIGRlbHRhID0gd2hlZWxFdmVudERlbHRhKGUpO1xuICAgIGRlbHRhLnggKj0gd2hlZWxQaXhlbHNQZXJVbml0O1xuICAgIGRlbHRhLnkgKj0gd2hlZWxQaXhlbHNQZXJVbml0O1xuICAgIHJldHVybiBkZWx0YVxuICB9XG5cbiAgZnVuY3Rpb24gb25TY3JvbGxXaGVlbChjbSwgZSkge1xuICAgIHZhciBkZWx0YSA9IHdoZWVsRXZlbnREZWx0YShlKSwgZHggPSBkZWx0YS54LCBkeSA9IGRlbHRhLnk7XG4gICAgdmFyIHBpeGVsc1BlclVuaXQgPSB3aGVlbFBpeGVsc1BlclVuaXQ7XG4gICAgaWYgKGUuZGVsdGFNb2RlID09PSAwKSB7XG4gICAgICBkeCA9IGUuZGVsdGFYO1xuICAgICAgZHkgPSBlLmRlbHRhWTtcbiAgICAgIHBpeGVsc1BlclVuaXQgPSAxO1xuICAgIH1cblxuICAgIHZhciBkaXNwbGF5ID0gY20uZGlzcGxheSwgc2Nyb2xsID0gZGlzcGxheS5zY3JvbGxlcjtcbiAgICAvLyBRdWl0IGlmIHRoZXJlJ3Mgbm90aGluZyB0byBzY3JvbGwgaGVyZVxuICAgIHZhciBjYW5TY3JvbGxYID0gc2Nyb2xsLnNjcm9sbFdpZHRoID4gc2Nyb2xsLmNsaWVudFdpZHRoO1xuICAgIHZhciBjYW5TY3JvbGxZID0gc2Nyb2xsLnNjcm9sbEhlaWdodCA+IHNjcm9sbC5jbGllbnRIZWlnaHQ7XG4gICAgaWYgKCEoZHggJiYgY2FuU2Nyb2xsWCB8fCBkeSAmJiBjYW5TY3JvbGxZKSkgeyByZXR1cm4gfVxuXG4gICAgLy8gV2Via2l0IGJyb3dzZXJzIG9uIE9TIFggYWJvcnQgbW9tZW50dW0gc2Nyb2xscyB3aGVuIHRoZSB0YXJnZXRcbiAgICAvLyBvZiB0aGUgc2Nyb2xsIGV2ZW50IGlzIHJlbW92ZWQgZnJvbSB0aGUgc2Nyb2xsYWJsZSBlbGVtZW50LlxuICAgIC8vIFRoaXMgaGFjayAoc2VlIHJlbGF0ZWQgY29kZSBpbiBwYXRjaERpc3BsYXkpIG1ha2VzIHN1cmUgdGhlXG4gICAgLy8gZWxlbWVudCBpcyBrZXB0IGFyb3VuZC5cbiAgICBpZiAoZHkgJiYgbWFjICYmIHdlYmtpdCkge1xuICAgICAgb3V0ZXI6IGZvciAodmFyIGN1ciA9IGUudGFyZ2V0LCB2aWV3ID0gZGlzcGxheS52aWV3OyBjdXIgIT0gc2Nyb2xsOyBjdXIgPSBjdXIucGFyZW50Tm9kZSkge1xuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHZpZXcubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICBpZiAodmlld1tpXS5ub2RlID09IGN1cikge1xuICAgICAgICAgICAgY20uZGlzcGxheS5jdXJyZW50V2hlZWxUYXJnZXQgPSBjdXI7XG4gICAgICAgICAgICBicmVhayBvdXRlclxuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cblxuICAgIC8vIE9uIHNvbWUgYnJvd3NlcnMsIGhvcml6b250YWwgc2Nyb2xsaW5nIHdpbGwgY2F1c2UgcmVkcmF3cyB0b1xuICAgIC8vIGhhcHBlbiBiZWZvcmUgdGhlIGd1dHRlciBoYXMgYmVlbiByZWFsaWduZWQsIGNhdXNpbmcgaXQgdG9cbiAgICAvLyB3cmlnZ2xlIGFyb3VuZCBpbiBhIG1vc3QgdW5zZWVtbHkgd2F5LiBXaGVuIHdlIGhhdmUgYW5cbiAgICAvLyBlc3RpbWF0ZWQgcGl4ZWxzL2RlbHRhIHZhbHVlLCB3ZSBqdXN0IGhhbmRsZSBob3Jpem9udGFsXG4gICAgLy8gc2Nyb2xsaW5nIGVudGlyZWx5IGhlcmUuIEl0J2xsIGJlIHNsaWdodGx5IG9mZiBmcm9tIG5hdGl2ZSwgYnV0XG4gICAgLy8gYmV0dGVyIHRoYW4gZ2xpdGNoaW5nIG91dC5cbiAgICBpZiAoZHggJiYgIWdlY2tvICYmICFwcmVzdG8gJiYgcGl4ZWxzUGVyVW5pdCAhPSBudWxsKSB7XG4gICAgICBpZiAoZHkgJiYgY2FuU2Nyb2xsWSlcbiAgICAgICAgeyB1cGRhdGVTY3JvbGxUb3AoY20sIE1hdGgubWF4KDAsIHNjcm9sbC5zY3JvbGxUb3AgKyBkeSAqIHBpeGVsc1BlclVuaXQpKTsgfVxuICAgICAgc2V0U2Nyb2xsTGVmdChjbSwgTWF0aC5tYXgoMCwgc2Nyb2xsLnNjcm9sbExlZnQgKyBkeCAqIHBpeGVsc1BlclVuaXQpKTtcbiAgICAgIC8vIE9ubHkgcHJldmVudCBkZWZhdWx0IHNjcm9sbGluZyBpZiB2ZXJ0aWNhbCBzY3JvbGxpbmcgaXNcbiAgICAgIC8vIGFjdHVhbGx5IHBvc3NpYmxlLiBPdGhlcndpc2UsIGl0IGNhdXNlcyB2ZXJ0aWNhbCBzY3JvbGxcbiAgICAgIC8vIGppdHRlciBvbiBPU1ggdHJhY2twYWRzIHdoZW4gZGVsdGFYIGlzIHNtYWxsIGFuZCBkZWx0YVlcbiAgICAgIC8vIGlzIGxhcmdlIChpc3N1ZSAjMzU3OSlcbiAgICAgIGlmICghZHkgfHwgKGR5ICYmIGNhblNjcm9sbFkpKVxuICAgICAgICB7IGVfcHJldmVudERlZmF1bHQoZSk7IH1cbiAgICAgIGRpc3BsYXkud2hlZWxTdGFydFggPSBudWxsOyAvLyBBYm9ydCBtZWFzdXJlbWVudCwgaWYgaW4gcHJvZ3Jlc3NcbiAgICAgIHJldHVyblxuICAgIH1cblxuICAgIC8vICdQcm9qZWN0JyB0aGUgdmlzaWJsZSB2aWV3cG9ydCB0byBjb3ZlciB0aGUgYXJlYSB0aGF0IGlzIGJlaW5nXG4gICAgLy8gc2Nyb2xsZWQgaW50byB2aWV3IChpZiB3ZSBrbm93IGVub3VnaCB0byBlc3RpbWF0ZSBpdCkuXG4gICAgaWYgKGR5ICYmIHBpeGVsc1BlclVuaXQgIT0gbnVsbCkge1xuICAgICAgdmFyIHBpeGVscyA9IGR5ICogcGl4ZWxzUGVyVW5pdDtcbiAgICAgIHZhciB0b3AgPSBjbS5kb2Muc2Nyb2xsVG9wLCBib3QgPSB0b3AgKyBkaXNwbGF5LndyYXBwZXIuY2xpZW50SGVpZ2h0O1xuICAgICAgaWYgKHBpeGVscyA8IDApIHsgdG9wID0gTWF0aC5tYXgoMCwgdG9wICsgcGl4ZWxzIC0gNTApOyB9XG4gICAgICBlbHNlIHsgYm90ID0gTWF0aC5taW4oY20uZG9jLmhlaWdodCwgYm90ICsgcGl4ZWxzICsgNTApOyB9XG4gICAgICB1cGRhdGVEaXNwbGF5U2ltcGxlKGNtLCB7dG9wOiB0b3AsIGJvdHRvbTogYm90fSk7XG4gICAgfVxuXG4gICAgaWYgKHdoZWVsU2FtcGxlcyA8IDIwICYmIGUuZGVsdGFNb2RlICE9PSAwKSB7XG4gICAgICBpZiAoZGlzcGxheS53aGVlbFN0YXJ0WCA9PSBudWxsKSB7XG4gICAgICAgIGRpc3BsYXkud2hlZWxTdGFydFggPSBzY3JvbGwuc2Nyb2xsTGVmdDsgZGlzcGxheS53aGVlbFN0YXJ0WSA9IHNjcm9sbC5zY3JvbGxUb3A7XG4gICAgICAgIGRpc3BsYXkud2hlZWxEWCA9IGR4OyBkaXNwbGF5LndoZWVsRFkgPSBkeTtcbiAgICAgICAgc2V0VGltZW91dChmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgaWYgKGRpc3BsYXkud2hlZWxTdGFydFggPT0gbnVsbCkgeyByZXR1cm4gfVxuICAgICAgICAgIHZhciBtb3ZlZFggPSBzY3JvbGwuc2Nyb2xsTGVmdCAtIGRpc3BsYXkud2hlZWxTdGFydFg7XG4gICAgICAgICAgdmFyIG1vdmVkWSA9IHNjcm9sbC5zY3JvbGxUb3AgLSBkaXNwbGF5LndoZWVsU3RhcnRZO1xuICAgICAgICAgIHZhciBzYW1wbGUgPSAobW92ZWRZICYmIGRpc3BsYXkud2hlZWxEWSAmJiBtb3ZlZFkgLyBkaXNwbGF5LndoZWVsRFkpIHx8XG4gICAgICAgICAgICAobW92ZWRYICYmIGRpc3BsYXkud2hlZWxEWCAmJiBtb3ZlZFggLyBkaXNwbGF5LndoZWVsRFgpO1xuICAgICAgICAgIGRpc3BsYXkud2hlZWxTdGFydFggPSBkaXNwbGF5LndoZWVsU3RhcnRZID0gbnVsbDtcbiAgICAgICAgICBpZiAoIXNhbXBsZSkgeyByZXR1cm4gfVxuICAgICAgICAgIHdoZWVsUGl4ZWxzUGVyVW5pdCA9ICh3aGVlbFBpeGVsc1BlclVuaXQgKiB3aGVlbFNhbXBsZXMgKyBzYW1wbGUpIC8gKHdoZWVsU2FtcGxlcyArIDEpO1xuICAgICAgICAgICsrd2hlZWxTYW1wbGVzO1xuICAgICAgICB9LCAyMDApO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgZGlzcGxheS53aGVlbERYICs9IGR4OyBkaXNwbGF5LndoZWVsRFkgKz0gZHk7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgLy8gU2VsZWN0aW9uIG9iamVjdHMgYXJlIGltbXV0YWJsZS4gQSBuZXcgb25lIGlzIGNyZWF0ZWQgZXZlcnkgdGltZVxuICAvLyB0aGUgc2VsZWN0aW9uIGNoYW5nZXMuIEEgc2VsZWN0aW9uIGlzIG9uZSBvciBtb3JlIG5vbi1vdmVybGFwcGluZ1xuICAvLyAoYW5kIG5vbi10b3VjaGluZykgcmFuZ2VzLCBzb3J0ZWQsIGFuZCBhbiBpbnRlZ2VyIHRoYXQgaW5kaWNhdGVzXG4gIC8vIHdoaWNoIG9uZSBpcyB0aGUgcHJpbWFyeSBzZWxlY3Rpb24gKHRoZSBvbmUgdGhhdCdzIHNjcm9sbGVkIGludG9cbiAgLy8gdmlldywgdGhhdCBnZXRDdXJzb3IgcmV0dXJucywgZXRjKS5cbiAgdmFyIFNlbGVjdGlvbiA9IGZ1bmN0aW9uKHJhbmdlcywgcHJpbUluZGV4KSB7XG4gICAgdGhpcy5yYW5nZXMgPSByYW5nZXM7XG4gICAgdGhpcy5wcmltSW5kZXggPSBwcmltSW5kZXg7XG4gIH07XG5cbiAgU2VsZWN0aW9uLnByb3RvdHlwZS5wcmltYXJ5ID0gZnVuY3Rpb24gKCkgeyByZXR1cm4gdGhpcy5yYW5nZXNbdGhpcy5wcmltSW5kZXhdIH07XG5cbiAgU2VsZWN0aW9uLnByb3RvdHlwZS5lcXVhbHMgPSBmdW5jdGlvbiAob3RoZXIpIHtcbiAgICBpZiAob3RoZXIgPT0gdGhpcykgeyByZXR1cm4gdHJ1ZSB9XG4gICAgaWYgKG90aGVyLnByaW1JbmRleCAhPSB0aGlzLnByaW1JbmRleCB8fCBvdGhlci5yYW5nZXMubGVuZ3RoICE9IHRoaXMucmFuZ2VzLmxlbmd0aCkgeyByZXR1cm4gZmFsc2UgfVxuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdGhpcy5yYW5nZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgIHZhciBoZXJlID0gdGhpcy5yYW5nZXNbaV0sIHRoZXJlID0gb3RoZXIucmFuZ2VzW2ldO1xuICAgICAgaWYgKCFlcXVhbEN1cnNvclBvcyhoZXJlLmFuY2hvciwgdGhlcmUuYW5jaG9yKSB8fCAhZXF1YWxDdXJzb3JQb3MoaGVyZS5oZWFkLCB0aGVyZS5oZWFkKSkgeyByZXR1cm4gZmFsc2UgfVxuICAgIH1cbiAgICByZXR1cm4gdHJ1ZVxuICB9O1xuXG4gIFNlbGVjdGlvbi5wcm90b3R5cGUuZGVlcENvcHkgPSBmdW5jdGlvbiAoKSB7XG4gICAgdmFyIG91dCA9IFtdO1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdGhpcy5yYW5nZXMubGVuZ3RoOyBpKyspXG4gICAgICB7IG91dFtpXSA9IG5ldyBSYW5nZShjb3B5UG9zKHRoaXMucmFuZ2VzW2ldLmFuY2hvciksIGNvcHlQb3ModGhpcy5yYW5nZXNbaV0uaGVhZCkpOyB9XG4gICAgcmV0dXJuIG5ldyBTZWxlY3Rpb24ob3V0LCB0aGlzLnByaW1JbmRleClcbiAgfTtcblxuICBTZWxlY3Rpb24ucHJvdG90eXBlLnNvbWV0aGluZ1NlbGVjdGVkID0gZnVuY3Rpb24gKCkge1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdGhpcy5yYW5nZXMubGVuZ3RoOyBpKyspXG4gICAgICB7IGlmICghdGhpcy5yYW5nZXNbaV0uZW1wdHkoKSkgeyByZXR1cm4gdHJ1ZSB9IH1cbiAgICByZXR1cm4gZmFsc2VcbiAgfTtcblxuICBTZWxlY3Rpb24ucHJvdG90eXBlLmNvbnRhaW5zID0gZnVuY3Rpb24gKHBvcywgZW5kKSB7XG4gICAgaWYgKCFlbmQpIHsgZW5kID0gcG9zOyB9XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCB0aGlzLnJhbmdlcy5sZW5ndGg7IGkrKykge1xuICAgICAgdmFyIHJhbmdlID0gdGhpcy5yYW5nZXNbaV07XG4gICAgICBpZiAoY21wKGVuZCwgcmFuZ2UuZnJvbSgpKSA+PSAwICYmIGNtcChwb3MsIHJhbmdlLnRvKCkpIDw9IDApXG4gICAgICAgIHsgcmV0dXJuIGkgfVxuICAgIH1cbiAgICByZXR1cm4gLTFcbiAgfTtcblxuICB2YXIgUmFuZ2UgPSBmdW5jdGlvbihhbmNob3IsIGhlYWQpIHtcbiAgICB0aGlzLmFuY2hvciA9IGFuY2hvcjsgdGhpcy5oZWFkID0gaGVhZDtcbiAgfTtcblxuICBSYW5nZS5wcm90b3R5cGUuZnJvbSA9IGZ1bmN0aW9uICgpIHsgcmV0dXJuIG1pblBvcyh0aGlzLmFuY2hvciwgdGhpcy5oZWFkKSB9O1xuICBSYW5nZS5wcm90b3R5cGUudG8gPSBmdW5jdGlvbiAoKSB7IHJldHVybiBtYXhQb3ModGhpcy5hbmNob3IsIHRoaXMuaGVhZCkgfTtcbiAgUmFuZ2UucHJvdG90eXBlLmVtcHR5ID0gZnVuY3Rpb24gKCkgeyByZXR1cm4gdGhpcy5oZWFkLmxpbmUgPT0gdGhpcy5hbmNob3IubGluZSAmJiB0aGlzLmhlYWQuY2ggPT0gdGhpcy5hbmNob3IuY2ggfTtcblxuICAvLyBUYWtlIGFuIHVuc29ydGVkLCBwb3RlbnRpYWxseSBvdmVybGFwcGluZyBzZXQgb2YgcmFuZ2VzLCBhbmRcbiAgLy8gYnVpbGQgYSBzZWxlY3Rpb24gb3V0IG9mIGl0LiAnQ29uc3VtZXMnIHJhbmdlcyBhcnJheSAobW9kaWZ5aW5nXG4gIC8vIGl0KS5cbiAgZnVuY3Rpb24gbm9ybWFsaXplU2VsZWN0aW9uKGNtLCByYW5nZXMsIHByaW1JbmRleCkge1xuICAgIHZhciBtYXlUb3VjaCA9IGNtICYmIGNtLm9wdGlvbnMuc2VsZWN0aW9uc01heVRvdWNoO1xuICAgIHZhciBwcmltID0gcmFuZ2VzW3ByaW1JbmRleF07XG4gICAgcmFuZ2VzLnNvcnQoZnVuY3Rpb24gKGEsIGIpIHsgcmV0dXJuIGNtcChhLmZyb20oKSwgYi5mcm9tKCkpOyB9KTtcbiAgICBwcmltSW5kZXggPSBpbmRleE9mKHJhbmdlcywgcHJpbSk7XG4gICAgZm9yICh2YXIgaSA9IDE7IGkgPCByYW5nZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgIHZhciBjdXIgPSByYW5nZXNbaV0sIHByZXYgPSByYW5nZXNbaSAtIDFdO1xuICAgICAgdmFyIGRpZmYgPSBjbXAocHJldi50bygpLCBjdXIuZnJvbSgpKTtcbiAgICAgIGlmIChtYXlUb3VjaCAmJiAhY3VyLmVtcHR5KCkgPyBkaWZmID4gMCA6IGRpZmYgPj0gMCkge1xuICAgICAgICB2YXIgZnJvbSA9IG1pblBvcyhwcmV2LmZyb20oKSwgY3VyLmZyb20oKSksIHRvID0gbWF4UG9zKHByZXYudG8oKSwgY3VyLnRvKCkpO1xuICAgICAgICB2YXIgaW52ID0gcHJldi5lbXB0eSgpID8gY3VyLmZyb20oKSA9PSBjdXIuaGVhZCA6IHByZXYuZnJvbSgpID09IHByZXYuaGVhZDtcbiAgICAgICAgaWYgKGkgPD0gcHJpbUluZGV4KSB7IC0tcHJpbUluZGV4OyB9XG4gICAgICAgIHJhbmdlcy5zcGxpY2UoLS1pLCAyLCBuZXcgUmFuZ2UoaW52ID8gdG8gOiBmcm9tLCBpbnYgPyBmcm9tIDogdG8pKTtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIG5ldyBTZWxlY3Rpb24ocmFuZ2VzLCBwcmltSW5kZXgpXG4gIH1cblxuICBmdW5jdGlvbiBzaW1wbGVTZWxlY3Rpb24oYW5jaG9yLCBoZWFkKSB7XG4gICAgcmV0dXJuIG5ldyBTZWxlY3Rpb24oW25ldyBSYW5nZShhbmNob3IsIGhlYWQgfHwgYW5jaG9yKV0sIDApXG4gIH1cblxuICAvLyBDb21wdXRlIHRoZSBwb3NpdGlvbiBvZiB0aGUgZW5kIG9mIGEgY2hhbmdlIChpdHMgJ3RvJyBwcm9wZXJ0eVxuICAvLyByZWZlcnMgdG8gdGhlIHByZS1jaGFuZ2UgZW5kKS5cbiAgZnVuY3Rpb24gY2hhbmdlRW5kKGNoYW5nZSkge1xuICAgIGlmICghY2hhbmdlLnRleHQpIHsgcmV0dXJuIGNoYW5nZS50byB9XG4gICAgcmV0dXJuIFBvcyhjaGFuZ2UuZnJvbS5saW5lICsgY2hhbmdlLnRleHQubGVuZ3RoIC0gMSxcbiAgICAgICAgICAgICAgIGxzdChjaGFuZ2UudGV4dCkubGVuZ3RoICsgKGNoYW5nZS50ZXh0Lmxlbmd0aCA9PSAxID8gY2hhbmdlLmZyb20uY2ggOiAwKSlcbiAgfVxuXG4gIC8vIEFkanVzdCBhIHBvc2l0aW9uIHRvIHJlZmVyIHRvIHRoZSBwb3N0LWNoYW5nZSBwb3NpdGlvbiBvZiB0aGVcbiAgLy8gc2FtZSB0ZXh0LCBvciB0aGUgZW5kIG9mIHRoZSBjaGFuZ2UgaWYgdGhlIGNoYW5nZSBjb3ZlcnMgaXQuXG4gIGZ1bmN0aW9uIGFkanVzdEZvckNoYW5nZShwb3MsIGNoYW5nZSkge1xuICAgIGlmIChjbXAocG9zLCBjaGFuZ2UuZnJvbSkgPCAwKSB7IHJldHVybiBwb3MgfVxuICAgIGlmIChjbXAocG9zLCBjaGFuZ2UudG8pIDw9IDApIHsgcmV0dXJuIGNoYW5nZUVuZChjaGFuZ2UpIH1cblxuICAgIHZhciBsaW5lID0gcG9zLmxpbmUgKyBjaGFuZ2UudGV4dC5sZW5ndGggLSAoY2hhbmdlLnRvLmxpbmUgLSBjaGFuZ2UuZnJvbS5saW5lKSAtIDEsIGNoID0gcG9zLmNoO1xuICAgIGlmIChwb3MubGluZSA9PSBjaGFuZ2UudG8ubGluZSkgeyBjaCArPSBjaGFuZ2VFbmQoY2hhbmdlKS5jaCAtIGNoYW5nZS50by5jaDsgfVxuICAgIHJldHVybiBQb3MobGluZSwgY2gpXG4gIH1cblxuICBmdW5jdGlvbiBjb21wdXRlU2VsQWZ0ZXJDaGFuZ2UoZG9jLCBjaGFuZ2UpIHtcbiAgICB2YXIgb3V0ID0gW107XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBkb2Muc2VsLnJhbmdlcy5sZW5ndGg7IGkrKykge1xuICAgICAgdmFyIHJhbmdlID0gZG9jLnNlbC5yYW5nZXNbaV07XG4gICAgICBvdXQucHVzaChuZXcgUmFuZ2UoYWRqdXN0Rm9yQ2hhbmdlKHJhbmdlLmFuY2hvciwgY2hhbmdlKSxcbiAgICAgICAgICAgICAgICAgICAgICAgICBhZGp1c3RGb3JDaGFuZ2UocmFuZ2UuaGVhZCwgY2hhbmdlKSkpO1xuICAgIH1cbiAgICByZXR1cm4gbm9ybWFsaXplU2VsZWN0aW9uKGRvYy5jbSwgb3V0LCBkb2Muc2VsLnByaW1JbmRleClcbiAgfVxuXG4gIGZ1bmN0aW9uIG9mZnNldFBvcyhwb3MsIG9sZCwgbncpIHtcbiAgICBpZiAocG9zLmxpbmUgPT0gb2xkLmxpbmUpXG4gICAgICB7IHJldHVybiBQb3MobncubGluZSwgcG9zLmNoIC0gb2xkLmNoICsgbncuY2gpIH1cbiAgICBlbHNlXG4gICAgICB7IHJldHVybiBQb3MobncubGluZSArIChwb3MubGluZSAtIG9sZC5saW5lKSwgcG9zLmNoKSB9XG4gIH1cblxuICAvLyBVc2VkIGJ5IHJlcGxhY2VTZWxlY3Rpb25zIHRvIGFsbG93IG1vdmluZyB0aGUgc2VsZWN0aW9uIHRvIHRoZVxuICAvLyBzdGFydCBvciBhcm91bmQgdGhlIHJlcGxhY2VkIHRlc3QuIEhpbnQgbWF5IGJlIFwic3RhcnRcIiBvciBcImFyb3VuZFwiLlxuICBmdW5jdGlvbiBjb21wdXRlUmVwbGFjZWRTZWwoZG9jLCBjaGFuZ2VzLCBoaW50KSB7XG4gICAgdmFyIG91dCA9IFtdO1xuICAgIHZhciBvbGRQcmV2ID0gUG9zKGRvYy5maXJzdCwgMCksIG5ld1ByZXYgPSBvbGRQcmV2O1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgY2hhbmdlcy5sZW5ndGg7IGkrKykge1xuICAgICAgdmFyIGNoYW5nZSA9IGNoYW5nZXNbaV07XG4gICAgICB2YXIgZnJvbSA9IG9mZnNldFBvcyhjaGFuZ2UuZnJvbSwgb2xkUHJldiwgbmV3UHJldik7XG4gICAgICB2YXIgdG8gPSBvZmZzZXRQb3MoY2hhbmdlRW5kKGNoYW5nZSksIG9sZFByZXYsIG5ld1ByZXYpO1xuICAgICAgb2xkUHJldiA9IGNoYW5nZS50bztcbiAgICAgIG5ld1ByZXYgPSB0bztcbiAgICAgIGlmIChoaW50ID09IFwiYXJvdW5kXCIpIHtcbiAgICAgICAgdmFyIHJhbmdlID0gZG9jLnNlbC5yYW5nZXNbaV0sIGludiA9IGNtcChyYW5nZS5oZWFkLCByYW5nZS5hbmNob3IpIDwgMDtcbiAgICAgICAgb3V0W2ldID0gbmV3IFJhbmdlKGludiA/IHRvIDogZnJvbSwgaW52ID8gZnJvbSA6IHRvKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIG91dFtpXSA9IG5ldyBSYW5nZShmcm9tLCBmcm9tKTtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIG5ldyBTZWxlY3Rpb24ob3V0LCBkb2Muc2VsLnByaW1JbmRleClcbiAgfVxuXG4gIC8vIFVzZWQgdG8gZ2V0IHRoZSBlZGl0b3IgaW50byBhIGNvbnNpc3RlbnQgc3RhdGUgYWdhaW4gd2hlbiBvcHRpb25zIGNoYW5nZS5cblxuICBmdW5jdGlvbiBsb2FkTW9kZShjbSkge1xuICAgIGNtLmRvYy5tb2RlID0gZ2V0TW9kZShjbS5vcHRpb25zLCBjbS5kb2MubW9kZU9wdGlvbik7XG4gICAgcmVzZXRNb2RlU3RhdGUoY20pO1xuICB9XG5cbiAgZnVuY3Rpb24gcmVzZXRNb2RlU3RhdGUoY20pIHtcbiAgICBjbS5kb2MuaXRlcihmdW5jdGlvbiAobGluZSkge1xuICAgICAgaWYgKGxpbmUuc3RhdGVBZnRlcikgeyBsaW5lLnN0YXRlQWZ0ZXIgPSBudWxsOyB9XG4gICAgICBpZiAobGluZS5zdHlsZXMpIHsgbGluZS5zdHlsZXMgPSBudWxsOyB9XG4gICAgfSk7XG4gICAgY20uZG9jLm1vZGVGcm9udGllciA9IGNtLmRvYy5oaWdobGlnaHRGcm9udGllciA9IGNtLmRvYy5maXJzdDtcbiAgICBzdGFydFdvcmtlcihjbSwgMTAwKTtcbiAgICBjbS5zdGF0ZS5tb2RlR2VuKys7XG4gICAgaWYgKGNtLmN1ck9wKSB7IHJlZ0NoYW5nZShjbSk7IH1cbiAgfVxuXG4gIC8vIERPQ1VNRU5UIERBVEEgU1RSVUNUVVJFXG5cbiAgLy8gQnkgZGVmYXVsdCwgdXBkYXRlcyB0aGF0IHN0YXJ0IGFuZCBlbmQgYXQgdGhlIGJlZ2lubmluZyBvZiBhIGxpbmVcbiAgLy8gYXJlIHRyZWF0ZWQgc3BlY2lhbGx5LCBpbiBvcmRlciB0byBtYWtlIHRoZSBhc3NvY2lhdGlvbiBvZiBsaW5lXG4gIC8vIHdpZGdldHMgYW5kIG1hcmtlciBlbGVtZW50cyB3aXRoIHRoZSB0ZXh0IGJlaGF2ZSBtb3JlIGludHVpdGl2ZS5cbiAgZnVuY3Rpb24gaXNXaG9sZUxpbmVVcGRhdGUoZG9jLCBjaGFuZ2UpIHtcbiAgICByZXR1cm4gY2hhbmdlLmZyb20uY2ggPT0gMCAmJiBjaGFuZ2UudG8uY2ggPT0gMCAmJiBsc3QoY2hhbmdlLnRleHQpID09IFwiXCIgJiZcbiAgICAgICghZG9jLmNtIHx8IGRvYy5jbS5vcHRpb25zLndob2xlTGluZVVwZGF0ZUJlZm9yZSlcbiAgfVxuXG4gIC8vIFBlcmZvcm0gYSBjaGFuZ2Ugb24gdGhlIGRvY3VtZW50IGRhdGEgc3RydWN0dXJlLlxuICBmdW5jdGlvbiB1cGRhdGVEb2MoZG9jLCBjaGFuZ2UsIG1hcmtlZFNwYW5zLCBlc3RpbWF0ZUhlaWdodCkge1xuICAgIGZ1bmN0aW9uIHNwYW5zRm9yKG4pIHtyZXR1cm4gbWFya2VkU3BhbnMgPyBtYXJrZWRTcGFuc1tuXSA6IG51bGx9XG4gICAgZnVuY3Rpb24gdXBkYXRlKGxpbmUsIHRleHQsIHNwYW5zKSB7XG4gICAgICB1cGRhdGVMaW5lKGxpbmUsIHRleHQsIHNwYW5zLCBlc3RpbWF0ZUhlaWdodCk7XG4gICAgICBzaWduYWxMYXRlcihsaW5lLCBcImNoYW5nZVwiLCBsaW5lLCBjaGFuZ2UpO1xuICAgIH1cbiAgICBmdW5jdGlvbiBsaW5lc0ZvcihzdGFydCwgZW5kKSB7XG4gICAgICB2YXIgcmVzdWx0ID0gW107XG4gICAgICBmb3IgKHZhciBpID0gc3RhcnQ7IGkgPCBlbmQ7ICsraSlcbiAgICAgICAgeyByZXN1bHQucHVzaChuZXcgTGluZSh0ZXh0W2ldLCBzcGFuc0ZvcihpKSwgZXN0aW1hdGVIZWlnaHQpKTsgfVxuICAgICAgcmV0dXJuIHJlc3VsdFxuICAgIH1cblxuICAgIHZhciBmcm9tID0gY2hhbmdlLmZyb20sIHRvID0gY2hhbmdlLnRvLCB0ZXh0ID0gY2hhbmdlLnRleHQ7XG4gICAgdmFyIGZpcnN0TGluZSA9IGdldExpbmUoZG9jLCBmcm9tLmxpbmUpLCBsYXN0TGluZSA9IGdldExpbmUoZG9jLCB0by5saW5lKTtcbiAgICB2YXIgbGFzdFRleHQgPSBsc3QodGV4dCksIGxhc3RTcGFucyA9IHNwYW5zRm9yKHRleHQubGVuZ3RoIC0gMSksIG5saW5lcyA9IHRvLmxpbmUgLSBmcm9tLmxpbmU7XG5cbiAgICAvLyBBZGp1c3QgdGhlIGxpbmUgc3RydWN0dXJlXG4gICAgaWYgKGNoYW5nZS5mdWxsKSB7XG4gICAgICBkb2MuaW5zZXJ0KDAsIGxpbmVzRm9yKDAsIHRleHQubGVuZ3RoKSk7XG4gICAgICBkb2MucmVtb3ZlKHRleHQubGVuZ3RoLCBkb2Muc2l6ZSAtIHRleHQubGVuZ3RoKTtcbiAgICB9IGVsc2UgaWYgKGlzV2hvbGVMaW5lVXBkYXRlKGRvYywgY2hhbmdlKSkge1xuICAgICAgLy8gVGhpcyBpcyBhIHdob2xlLWxpbmUgcmVwbGFjZS4gVHJlYXRlZCBzcGVjaWFsbHkgdG8gbWFrZVxuICAgICAgLy8gc3VyZSBsaW5lIG9iamVjdHMgbW92ZSB0aGUgd2F5IHRoZXkgYXJlIHN1cHBvc2VkIHRvLlxuICAgICAgdmFyIGFkZGVkID0gbGluZXNGb3IoMCwgdGV4dC5sZW5ndGggLSAxKTtcbiAgICAgIHVwZGF0ZShsYXN0TGluZSwgbGFzdExpbmUudGV4dCwgbGFzdFNwYW5zKTtcbiAgICAgIGlmIChubGluZXMpIHsgZG9jLnJlbW92ZShmcm9tLmxpbmUsIG5saW5lcyk7IH1cbiAgICAgIGlmIChhZGRlZC5sZW5ndGgpIHsgZG9jLmluc2VydChmcm9tLmxpbmUsIGFkZGVkKTsgfVxuICAgIH0gZWxzZSBpZiAoZmlyc3RMaW5lID09IGxhc3RMaW5lKSB7XG4gICAgICBpZiAodGV4dC5sZW5ndGggPT0gMSkge1xuICAgICAgICB1cGRhdGUoZmlyc3RMaW5lLCBmaXJzdExpbmUudGV4dC5zbGljZSgwLCBmcm9tLmNoKSArIGxhc3RUZXh0ICsgZmlyc3RMaW5lLnRleHQuc2xpY2UodG8uY2gpLCBsYXN0U3BhbnMpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdmFyIGFkZGVkJDEgPSBsaW5lc0ZvcigxLCB0ZXh0Lmxlbmd0aCAtIDEpO1xuICAgICAgICBhZGRlZCQxLnB1c2gobmV3IExpbmUobGFzdFRleHQgKyBmaXJzdExpbmUudGV4dC5zbGljZSh0by5jaCksIGxhc3RTcGFucywgZXN0aW1hdGVIZWlnaHQpKTtcbiAgICAgICAgdXBkYXRlKGZpcnN0TGluZSwgZmlyc3RMaW5lLnRleHQuc2xpY2UoMCwgZnJvbS5jaCkgKyB0ZXh0WzBdLCBzcGFuc0ZvcigwKSk7XG4gICAgICAgIGRvYy5pbnNlcnQoZnJvbS5saW5lICsgMSwgYWRkZWQkMSk7XG4gICAgICB9XG4gICAgfSBlbHNlIGlmICh0ZXh0Lmxlbmd0aCA9PSAxKSB7XG4gICAgICB1cGRhdGUoZmlyc3RMaW5lLCBmaXJzdExpbmUudGV4dC5zbGljZSgwLCBmcm9tLmNoKSArIHRleHRbMF0gKyBsYXN0TGluZS50ZXh0LnNsaWNlKHRvLmNoKSwgc3BhbnNGb3IoMCkpO1xuICAgICAgZG9jLnJlbW92ZShmcm9tLmxpbmUgKyAxLCBubGluZXMpO1xuICAgIH0gZWxzZSB7XG4gICAgICB1cGRhdGUoZmlyc3RMaW5lLCBmaXJzdExpbmUudGV4dC5zbGljZSgwLCBmcm9tLmNoKSArIHRleHRbMF0sIHNwYW5zRm9yKDApKTtcbiAgICAgIHVwZGF0ZShsYXN0TGluZSwgbGFzdFRleHQgKyBsYXN0TGluZS50ZXh0LnNsaWNlKHRvLmNoKSwgbGFzdFNwYW5zKTtcbiAgICAgIHZhciBhZGRlZCQyID0gbGluZXNGb3IoMSwgdGV4dC5sZW5ndGggLSAxKTtcbiAgICAgIGlmIChubGluZXMgPiAxKSB7IGRvYy5yZW1vdmUoZnJvbS5saW5lICsgMSwgbmxpbmVzIC0gMSk7IH1cbiAgICAgIGRvYy5pbnNlcnQoZnJvbS5saW5lICsgMSwgYWRkZWQkMik7XG4gICAgfVxuXG4gICAgc2lnbmFsTGF0ZXIoZG9jLCBcImNoYW5nZVwiLCBkb2MsIGNoYW5nZSk7XG4gIH1cblxuICAvLyBDYWxsIGYgZm9yIGFsbCBsaW5rZWQgZG9jdW1lbnRzLlxuICBmdW5jdGlvbiBsaW5rZWREb2NzKGRvYywgZiwgc2hhcmVkSGlzdE9ubHkpIHtcbiAgICBmdW5jdGlvbiBwcm9wYWdhdGUoZG9jLCBza2lwLCBzaGFyZWRIaXN0KSB7XG4gICAgICBpZiAoZG9jLmxpbmtlZCkgeyBmb3IgKHZhciBpID0gMDsgaSA8IGRvYy5saW5rZWQubGVuZ3RoOyArK2kpIHtcbiAgICAgICAgdmFyIHJlbCA9IGRvYy5saW5rZWRbaV07XG4gICAgICAgIGlmIChyZWwuZG9jID09IHNraXApIHsgY29udGludWUgfVxuICAgICAgICB2YXIgc2hhcmVkID0gc2hhcmVkSGlzdCAmJiByZWwuc2hhcmVkSGlzdDtcbiAgICAgICAgaWYgKHNoYXJlZEhpc3RPbmx5ICYmICFzaGFyZWQpIHsgY29udGludWUgfVxuICAgICAgICBmKHJlbC5kb2MsIHNoYXJlZCk7XG4gICAgICAgIHByb3BhZ2F0ZShyZWwuZG9jLCBkb2MsIHNoYXJlZCk7XG4gICAgICB9IH1cbiAgICB9XG4gICAgcHJvcGFnYXRlKGRvYywgbnVsbCwgdHJ1ZSk7XG4gIH1cblxuICAvLyBBdHRhY2ggYSBkb2N1bWVudCB0byBhbiBlZGl0b3IuXG4gIGZ1bmN0aW9uIGF0dGFjaERvYyhjbSwgZG9jKSB7XG4gICAgaWYgKGRvYy5jbSkgeyB0aHJvdyBuZXcgRXJyb3IoXCJUaGlzIGRvY3VtZW50IGlzIGFscmVhZHkgaW4gdXNlLlwiKSB9XG4gICAgY20uZG9jID0gZG9jO1xuICAgIGRvYy5jbSA9IGNtO1xuICAgIGVzdGltYXRlTGluZUhlaWdodHMoY20pO1xuICAgIGxvYWRNb2RlKGNtKTtcbiAgICBzZXREaXJlY3Rpb25DbGFzcyhjbSk7XG4gICAgY20ub3B0aW9ucy5kaXJlY3Rpb24gPSBkb2MuZGlyZWN0aW9uO1xuICAgIGlmICghY20ub3B0aW9ucy5saW5lV3JhcHBpbmcpIHsgZmluZE1heExpbmUoY20pOyB9XG4gICAgY20ub3B0aW9ucy5tb2RlID0gZG9jLm1vZGVPcHRpb247XG4gICAgcmVnQ2hhbmdlKGNtKTtcbiAgfVxuXG4gIGZ1bmN0aW9uIHNldERpcmVjdGlvbkNsYXNzKGNtKSB7XG4gIChjbS5kb2MuZGlyZWN0aW9uID09IFwicnRsXCIgPyBhZGRDbGFzcyA6IHJtQ2xhc3MpKGNtLmRpc3BsYXkubGluZURpdiwgXCJDb2RlTWlycm9yLXJ0bFwiKTtcbiAgfVxuXG4gIGZ1bmN0aW9uIGRpcmVjdGlvbkNoYW5nZWQoY20pIHtcbiAgICBydW5Jbk9wKGNtLCBmdW5jdGlvbiAoKSB7XG4gICAgICBzZXREaXJlY3Rpb25DbGFzcyhjbSk7XG4gICAgICByZWdDaGFuZ2UoY20pO1xuICAgIH0pO1xuICB9XG5cbiAgZnVuY3Rpb24gSGlzdG9yeShwcmV2KSB7XG4gICAgLy8gQXJyYXlzIG9mIGNoYW5nZSBldmVudHMgYW5kIHNlbGVjdGlvbnMuIERvaW5nIHNvbWV0aGluZyBhZGRzIGFuXG4gICAgLy8gZXZlbnQgdG8gZG9uZSBhbmQgY2xlYXJzIHVuZG8uIFVuZG9pbmcgbW92ZXMgZXZlbnRzIGZyb20gZG9uZVxuICAgIC8vIHRvIHVuZG9uZSwgcmVkb2luZyBtb3ZlcyB0aGVtIGluIHRoZSBvdGhlciBkaXJlY3Rpb24uXG4gICAgdGhpcy5kb25lID0gW107IHRoaXMudW5kb25lID0gW107XG4gICAgdGhpcy51bmRvRGVwdGggPSBwcmV2ID8gcHJldi51bmRvRGVwdGggOiBJbmZpbml0eTtcbiAgICAvLyBVc2VkIHRvIHRyYWNrIHdoZW4gY2hhbmdlcyBjYW4gYmUgbWVyZ2VkIGludG8gYSBzaW5nbGUgdW5kb1xuICAgIC8vIGV2ZW50XG4gICAgdGhpcy5sYXN0TW9kVGltZSA9IHRoaXMubGFzdFNlbFRpbWUgPSAwO1xuICAgIHRoaXMubGFzdE9wID0gdGhpcy5sYXN0U2VsT3AgPSBudWxsO1xuICAgIHRoaXMubGFzdE9yaWdpbiA9IHRoaXMubGFzdFNlbE9yaWdpbiA9IG51bGw7XG4gICAgLy8gVXNlZCBieSB0aGUgaXNDbGVhbigpIG1ldGhvZFxuICAgIHRoaXMuZ2VuZXJhdGlvbiA9IHRoaXMubWF4R2VuZXJhdGlvbiA9IHByZXYgPyBwcmV2Lm1heEdlbmVyYXRpb24gOiAxO1xuICB9XG5cbiAgLy8gQ3JlYXRlIGEgaGlzdG9yeSBjaGFuZ2UgZXZlbnQgZnJvbSBhbiB1cGRhdGVEb2Mtc3R5bGUgY2hhbmdlXG4gIC8vIG9iamVjdC5cbiAgZnVuY3Rpb24gaGlzdG9yeUNoYW5nZUZyb21DaGFuZ2UoZG9jLCBjaGFuZ2UpIHtcbiAgICB2YXIgaGlzdENoYW5nZSA9IHtmcm9tOiBjb3B5UG9zKGNoYW5nZS5mcm9tKSwgdG86IGNoYW5nZUVuZChjaGFuZ2UpLCB0ZXh0OiBnZXRCZXR3ZWVuKGRvYywgY2hhbmdlLmZyb20sIGNoYW5nZS50byl9O1xuICAgIGF0dGFjaExvY2FsU3BhbnMoZG9jLCBoaXN0Q2hhbmdlLCBjaGFuZ2UuZnJvbS5saW5lLCBjaGFuZ2UudG8ubGluZSArIDEpO1xuICAgIGxpbmtlZERvY3MoZG9jLCBmdW5jdGlvbiAoZG9jKSB7IHJldHVybiBhdHRhY2hMb2NhbFNwYW5zKGRvYywgaGlzdENoYW5nZSwgY2hhbmdlLmZyb20ubGluZSwgY2hhbmdlLnRvLmxpbmUgKyAxKTsgfSwgdHJ1ZSk7XG4gICAgcmV0dXJuIGhpc3RDaGFuZ2VcbiAgfVxuXG4gIC8vIFBvcCBhbGwgc2VsZWN0aW9uIGV2ZW50cyBvZmYgdGhlIGVuZCBvZiBhIGhpc3RvcnkgYXJyYXkuIFN0b3AgYXRcbiAgLy8gYSBjaGFuZ2UgZXZlbnQuXG4gIGZ1bmN0aW9uIGNsZWFyU2VsZWN0aW9uRXZlbnRzKGFycmF5KSB7XG4gICAgd2hpbGUgKGFycmF5Lmxlbmd0aCkge1xuICAgICAgdmFyIGxhc3QgPSBsc3QoYXJyYXkpO1xuICAgICAgaWYgKGxhc3QucmFuZ2VzKSB7IGFycmF5LnBvcCgpOyB9XG4gICAgICBlbHNlIHsgYnJlYWsgfVxuICAgIH1cbiAgfVxuXG4gIC8vIEZpbmQgdGhlIHRvcCBjaGFuZ2UgZXZlbnQgaW4gdGhlIGhpc3RvcnkuIFBvcCBvZmYgc2VsZWN0aW9uXG4gIC8vIGV2ZW50cyB0aGF0IGFyZSBpbiB0aGUgd2F5LlxuICBmdW5jdGlvbiBsYXN0Q2hhbmdlRXZlbnQoaGlzdCwgZm9yY2UpIHtcbiAgICBpZiAoZm9yY2UpIHtcbiAgICAgIGNsZWFyU2VsZWN0aW9uRXZlbnRzKGhpc3QuZG9uZSk7XG4gICAgICByZXR1cm4gbHN0KGhpc3QuZG9uZSlcbiAgICB9IGVsc2UgaWYgKGhpc3QuZG9uZS5sZW5ndGggJiYgIWxzdChoaXN0LmRvbmUpLnJhbmdlcykge1xuICAgICAgcmV0dXJuIGxzdChoaXN0LmRvbmUpXG4gICAgfSBlbHNlIGlmIChoaXN0LmRvbmUubGVuZ3RoID4gMSAmJiAhaGlzdC5kb25lW2hpc3QuZG9uZS5sZW5ndGggLSAyXS5yYW5nZXMpIHtcbiAgICAgIGhpc3QuZG9uZS5wb3AoKTtcbiAgICAgIHJldHVybiBsc3QoaGlzdC5kb25lKVxuICAgIH1cbiAgfVxuXG4gIC8vIFJlZ2lzdGVyIGEgY2hhbmdlIGluIHRoZSBoaXN0b3J5LiBNZXJnZXMgY2hhbmdlcyB0aGF0IGFyZSB3aXRoaW5cbiAgLy8gYSBzaW5nbGUgb3BlcmF0aW9uLCBvciBhcmUgY2xvc2UgdG9nZXRoZXIgd2l0aCBhbiBvcmlnaW4gdGhhdFxuICAvLyBhbGxvd3MgbWVyZ2luZyAoc3RhcnRpbmcgd2l0aCBcIitcIikgaW50byBhIHNpbmdsZSBldmVudC5cbiAgZnVuY3Rpb24gYWRkQ2hhbmdlVG9IaXN0b3J5KGRvYywgY2hhbmdlLCBzZWxBZnRlciwgb3BJZCkge1xuICAgIHZhciBoaXN0ID0gZG9jLmhpc3Rvcnk7XG4gICAgaGlzdC51bmRvbmUubGVuZ3RoID0gMDtcbiAgICB2YXIgdGltZSA9ICtuZXcgRGF0ZSwgY3VyO1xuICAgIHZhciBsYXN0O1xuXG4gICAgaWYgKChoaXN0Lmxhc3RPcCA9PSBvcElkIHx8XG4gICAgICAgICBoaXN0Lmxhc3RPcmlnaW4gPT0gY2hhbmdlLm9yaWdpbiAmJiBjaGFuZ2Uub3JpZ2luICYmXG4gICAgICAgICAoKGNoYW5nZS5vcmlnaW4uY2hhckF0KDApID09IFwiK1wiICYmIGhpc3QubGFzdE1vZFRpbWUgPiB0aW1lIC0gKGRvYy5jbSA/IGRvYy5jbS5vcHRpb25zLmhpc3RvcnlFdmVudERlbGF5IDogNTAwKSkgfHxcbiAgICAgICAgICBjaGFuZ2Uub3JpZ2luLmNoYXJBdCgwKSA9PSBcIipcIikpICYmXG4gICAgICAgIChjdXIgPSBsYXN0Q2hhbmdlRXZlbnQoaGlzdCwgaGlzdC5sYXN0T3AgPT0gb3BJZCkpKSB7XG4gICAgICAvLyBNZXJnZSB0aGlzIGNoYW5nZSBpbnRvIHRoZSBsYXN0IGV2ZW50XG4gICAgICBsYXN0ID0gbHN0KGN1ci5jaGFuZ2VzKTtcbiAgICAgIGlmIChjbXAoY2hhbmdlLmZyb20sIGNoYW5nZS50bykgPT0gMCAmJiBjbXAoY2hhbmdlLmZyb20sIGxhc3QudG8pID09IDApIHtcbiAgICAgICAgLy8gT3B0aW1pemVkIGNhc2UgZm9yIHNpbXBsZSBpbnNlcnRpb24gLS0gZG9uJ3Qgd2FudCB0byBhZGRcbiAgICAgICAgLy8gbmV3IGNoYW5nZXNldHMgZm9yIGV2ZXJ5IGNoYXJhY3RlciB0eXBlZFxuICAgICAgICBsYXN0LnRvID0gY2hhbmdlRW5kKGNoYW5nZSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICAvLyBBZGQgbmV3IHN1Yi1ldmVudFxuICAgICAgICBjdXIuY2hhbmdlcy5wdXNoKGhpc3RvcnlDaGFuZ2VGcm9tQ2hhbmdlKGRvYywgY2hhbmdlKSk7XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIC8vIENhbiBub3QgYmUgbWVyZ2VkLCBzdGFydCBhIG5ldyBldmVudC5cbiAgICAgIHZhciBiZWZvcmUgPSBsc3QoaGlzdC5kb25lKTtcbiAgICAgIGlmICghYmVmb3JlIHx8ICFiZWZvcmUucmFuZ2VzKVxuICAgICAgICB7IHB1c2hTZWxlY3Rpb25Ub0hpc3RvcnkoZG9jLnNlbCwgaGlzdC5kb25lKTsgfVxuICAgICAgY3VyID0ge2NoYW5nZXM6IFtoaXN0b3J5Q2hhbmdlRnJvbUNoYW5nZShkb2MsIGNoYW5nZSldLFxuICAgICAgICAgICAgIGdlbmVyYXRpb246IGhpc3QuZ2VuZXJhdGlvbn07XG4gICAgICBoaXN0LmRvbmUucHVzaChjdXIpO1xuICAgICAgd2hpbGUgKGhpc3QuZG9uZS5sZW5ndGggPiBoaXN0LnVuZG9EZXB0aCkge1xuICAgICAgICBoaXN0LmRvbmUuc2hpZnQoKTtcbiAgICAgICAgaWYgKCFoaXN0LmRvbmVbMF0ucmFuZ2VzKSB7IGhpc3QuZG9uZS5zaGlmdCgpOyB9XG4gICAgICB9XG4gICAgfVxuICAgIGhpc3QuZG9uZS5wdXNoKHNlbEFmdGVyKTtcbiAgICBoaXN0LmdlbmVyYXRpb24gPSArK2hpc3QubWF4R2VuZXJhdGlvbjtcbiAgICBoaXN0Lmxhc3RNb2RUaW1lID0gaGlzdC5sYXN0U2VsVGltZSA9IHRpbWU7XG4gICAgaGlzdC5sYXN0T3AgPSBoaXN0Lmxhc3RTZWxPcCA9IG9wSWQ7XG4gICAgaGlzdC5sYXN0T3JpZ2luID0gaGlzdC5sYXN0U2VsT3JpZ2luID0gY2hhbmdlLm9yaWdpbjtcblxuICAgIGlmICghbGFzdCkgeyBzaWduYWwoZG9jLCBcImhpc3RvcnlBZGRlZFwiKTsgfVxuICB9XG5cbiAgZnVuY3Rpb24gc2VsZWN0aW9uRXZlbnRDYW5CZU1lcmdlZChkb2MsIG9yaWdpbiwgcHJldiwgc2VsKSB7XG4gICAgdmFyIGNoID0gb3JpZ2luLmNoYXJBdCgwKTtcbiAgICByZXR1cm4gY2ggPT0gXCIqXCIgfHxcbiAgICAgIGNoID09IFwiK1wiICYmXG4gICAgICBwcmV2LnJhbmdlcy5sZW5ndGggPT0gc2VsLnJhbmdlcy5sZW5ndGggJiZcbiAgICAgIHByZXYuc29tZXRoaW5nU2VsZWN0ZWQoKSA9PSBzZWwuc29tZXRoaW5nU2VsZWN0ZWQoKSAmJlxuICAgICAgbmV3IERhdGUgLSBkb2MuaGlzdG9yeS5sYXN0U2VsVGltZSA8PSAoZG9jLmNtID8gZG9jLmNtLm9wdGlvbnMuaGlzdG9yeUV2ZW50RGVsYXkgOiA1MDApXG4gIH1cblxuICAvLyBDYWxsZWQgd2hlbmV2ZXIgdGhlIHNlbGVjdGlvbiBjaGFuZ2VzLCBzZXRzIHRoZSBuZXcgc2VsZWN0aW9uIGFzXG4gIC8vIHRoZSBwZW5kaW5nIHNlbGVjdGlvbiBpbiB0aGUgaGlzdG9yeSwgYW5kIHB1c2hlcyB0aGUgb2xkIHBlbmRpbmdcbiAgLy8gc2VsZWN0aW9uIGludG8gdGhlICdkb25lJyBhcnJheSB3aGVuIGl0IHdhcyBzaWduaWZpY2FudGx5XG4gIC8vIGRpZmZlcmVudCAoaW4gbnVtYmVyIG9mIHNlbGVjdGVkIHJhbmdlcywgZW1wdGluZXNzLCBvciB0aW1lKS5cbiAgZnVuY3Rpb24gYWRkU2VsZWN0aW9uVG9IaXN0b3J5KGRvYywgc2VsLCBvcElkLCBvcHRpb25zKSB7XG4gICAgdmFyIGhpc3QgPSBkb2MuaGlzdG9yeSwgb3JpZ2luID0gb3B0aW9ucyAmJiBvcHRpb25zLm9yaWdpbjtcblxuICAgIC8vIEEgbmV3IGV2ZW50IGlzIHN0YXJ0ZWQgd2hlbiB0aGUgcHJldmlvdXMgb3JpZ2luIGRvZXMgbm90IG1hdGNoXG4gICAgLy8gdGhlIGN1cnJlbnQsIG9yIHRoZSBvcmlnaW5zIGRvbid0IGFsbG93IG1hdGNoaW5nLiBPcmlnaW5zXG4gICAgLy8gc3RhcnRpbmcgd2l0aCAqIGFyZSBhbHdheXMgbWVyZ2VkLCB0aG9zZSBzdGFydGluZyB3aXRoICsgYXJlXG4gICAgLy8gbWVyZ2VkIHdoZW4gc2ltaWxhciBhbmQgY2xvc2UgdG9nZXRoZXIgaW4gdGltZS5cbiAgICBpZiAob3BJZCA9PSBoaXN0Lmxhc3RTZWxPcCB8fFxuICAgICAgICAob3JpZ2luICYmIGhpc3QubGFzdFNlbE9yaWdpbiA9PSBvcmlnaW4gJiZcbiAgICAgICAgIChoaXN0Lmxhc3RNb2RUaW1lID09IGhpc3QubGFzdFNlbFRpbWUgJiYgaGlzdC5sYXN0T3JpZ2luID09IG9yaWdpbiB8fFxuICAgICAgICAgIHNlbGVjdGlvbkV2ZW50Q2FuQmVNZXJnZWQoZG9jLCBvcmlnaW4sIGxzdChoaXN0LmRvbmUpLCBzZWwpKSkpXG4gICAgICB7IGhpc3QuZG9uZVtoaXN0LmRvbmUubGVuZ3RoIC0gMV0gPSBzZWw7IH1cbiAgICBlbHNlXG4gICAgICB7IHB1c2hTZWxlY3Rpb25Ub0hpc3Rvcnkoc2VsLCBoaXN0LmRvbmUpOyB9XG5cbiAgICBoaXN0Lmxhc3RTZWxUaW1lID0gK25ldyBEYXRlO1xuICAgIGhpc3QubGFzdFNlbE9yaWdpbiA9IG9yaWdpbjtcbiAgICBoaXN0Lmxhc3RTZWxPcCA9IG9wSWQ7XG4gICAgaWYgKG9wdGlvbnMgJiYgb3B0aW9ucy5jbGVhclJlZG8gIT09IGZhbHNlKVxuICAgICAgeyBjbGVhclNlbGVjdGlvbkV2ZW50cyhoaXN0LnVuZG9uZSk7IH1cbiAgfVxuXG4gIGZ1bmN0aW9uIHB1c2hTZWxlY3Rpb25Ub0hpc3Rvcnkoc2VsLCBkZXN0KSB7XG4gICAgdmFyIHRvcCA9IGxzdChkZXN0KTtcbiAgICBpZiAoISh0b3AgJiYgdG9wLnJhbmdlcyAmJiB0b3AuZXF1YWxzKHNlbCkpKVxuICAgICAgeyBkZXN0LnB1c2goc2VsKTsgfVxuICB9XG5cbiAgLy8gVXNlZCB0byBzdG9yZSBtYXJrZWQgc3BhbiBpbmZvcm1hdGlvbiBpbiB0aGUgaGlzdG9yeS5cbiAgZnVuY3Rpb24gYXR0YWNoTG9jYWxTcGFucyhkb2MsIGNoYW5nZSwgZnJvbSwgdG8pIHtcbiAgICB2YXIgZXhpc3RpbmcgPSBjaGFuZ2VbXCJzcGFuc19cIiArIGRvYy5pZF0sIG4gPSAwO1xuICAgIGRvYy5pdGVyKE1hdGgubWF4KGRvYy5maXJzdCwgZnJvbSksIE1hdGgubWluKGRvYy5maXJzdCArIGRvYy5zaXplLCB0byksIGZ1bmN0aW9uIChsaW5lKSB7XG4gICAgICBpZiAobGluZS5tYXJrZWRTcGFucylcbiAgICAgICAgeyAoZXhpc3RpbmcgfHwgKGV4aXN0aW5nID0gY2hhbmdlW1wic3BhbnNfXCIgKyBkb2MuaWRdID0ge30pKVtuXSA9IGxpbmUubWFya2VkU3BhbnM7IH1cbiAgICAgICsrbjtcbiAgICB9KTtcbiAgfVxuXG4gIC8vIFdoZW4gdW4vcmUtZG9pbmcgcmVzdG9yZXMgdGV4dCBjb250YWluaW5nIG1hcmtlZCBzcGFucywgdGhvc2VcbiAgLy8gdGhhdCBoYXZlIGJlZW4gZXhwbGljaXRseSBjbGVhcmVkIHNob3VsZCBub3QgYmUgcmVzdG9yZWQuXG4gIGZ1bmN0aW9uIHJlbW92ZUNsZWFyZWRTcGFucyhzcGFucykge1xuICAgIGlmICghc3BhbnMpIHsgcmV0dXJuIG51bGwgfVxuICAgIHZhciBvdXQ7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBzcGFucy5sZW5ndGg7ICsraSkge1xuICAgICAgaWYgKHNwYW5zW2ldLm1hcmtlci5leHBsaWNpdGx5Q2xlYXJlZCkgeyBpZiAoIW91dCkgeyBvdXQgPSBzcGFucy5zbGljZSgwLCBpKTsgfSB9XG4gICAgICBlbHNlIGlmIChvdXQpIHsgb3V0LnB1c2goc3BhbnNbaV0pOyB9XG4gICAgfVxuICAgIHJldHVybiAhb3V0ID8gc3BhbnMgOiBvdXQubGVuZ3RoID8gb3V0IDogbnVsbFxuICB9XG5cbiAgLy8gUmV0cmlldmUgYW5kIGZpbHRlciB0aGUgb2xkIG1hcmtlZCBzcGFucyBzdG9yZWQgaW4gYSBjaGFuZ2UgZXZlbnQuXG4gIGZ1bmN0aW9uIGdldE9sZFNwYW5zKGRvYywgY2hhbmdlKSB7XG4gICAgdmFyIGZvdW5kID0gY2hhbmdlW1wic3BhbnNfXCIgKyBkb2MuaWRdO1xuICAgIGlmICghZm91bmQpIHsgcmV0dXJuIG51bGwgfVxuICAgIHZhciBudyA9IFtdO1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgY2hhbmdlLnRleHQubGVuZ3RoOyArK2kpXG4gICAgICB7IG53LnB1c2gocmVtb3ZlQ2xlYXJlZFNwYW5zKGZvdW5kW2ldKSk7IH1cbiAgICByZXR1cm4gbndcbiAgfVxuXG4gIC8vIFVzZWQgZm9yIHVuL3JlLWRvaW5nIGNoYW5nZXMgZnJvbSB0aGUgaGlzdG9yeS4gQ29tYmluZXMgdGhlXG4gIC8vIHJlc3VsdCBvZiBjb21wdXRpbmcgdGhlIGV4aXN0aW5nIHNwYW5zIHdpdGggdGhlIHNldCBvZiBzcGFucyB0aGF0XG4gIC8vIGV4aXN0ZWQgaW4gdGhlIGhpc3RvcnkgKHNvIHRoYXQgZGVsZXRpbmcgYXJvdW5kIGEgc3BhbiBhbmQgdGhlblxuICAvLyB1bmRvaW5nIGJyaW5ncyBiYWNrIHRoZSBzcGFuKS5cbiAgZnVuY3Rpb24gbWVyZ2VPbGRTcGFucyhkb2MsIGNoYW5nZSkge1xuICAgIHZhciBvbGQgPSBnZXRPbGRTcGFucyhkb2MsIGNoYW5nZSk7XG4gICAgdmFyIHN0cmV0Y2hlZCA9IHN0cmV0Y2hTcGFuc092ZXJDaGFuZ2UoZG9jLCBjaGFuZ2UpO1xuICAgIGlmICghb2xkKSB7IHJldHVybiBzdHJldGNoZWQgfVxuICAgIGlmICghc3RyZXRjaGVkKSB7IHJldHVybiBvbGQgfVxuXG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBvbGQubGVuZ3RoOyArK2kpIHtcbiAgICAgIHZhciBvbGRDdXIgPSBvbGRbaV0sIHN0cmV0Y2hDdXIgPSBzdHJldGNoZWRbaV07XG4gICAgICBpZiAob2xkQ3VyICYmIHN0cmV0Y2hDdXIpIHtcbiAgICAgICAgc3BhbnM6IGZvciAodmFyIGogPSAwOyBqIDwgc3RyZXRjaEN1ci5sZW5ndGg7ICsraikge1xuICAgICAgICAgIHZhciBzcGFuID0gc3RyZXRjaEN1cltqXTtcbiAgICAgICAgICBmb3IgKHZhciBrID0gMDsgayA8IG9sZEN1ci5sZW5ndGg7ICsraylcbiAgICAgICAgICAgIHsgaWYgKG9sZEN1cltrXS5tYXJrZXIgPT0gc3Bhbi5tYXJrZXIpIHsgY29udGludWUgc3BhbnMgfSB9XG4gICAgICAgICAgb2xkQ3VyLnB1c2goc3Bhbik7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSBpZiAoc3RyZXRjaEN1cikge1xuICAgICAgICBvbGRbaV0gPSBzdHJldGNoQ3VyO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gb2xkXG4gIH1cblxuICAvLyBVc2VkIGJvdGggdG8gcHJvdmlkZSBhIEpTT04tc2FmZSBvYmplY3QgaW4gLmdldEhpc3RvcnksIGFuZCwgd2hlblxuICAvLyBkZXRhY2hpbmcgYSBkb2N1bWVudCwgdG8gc3BsaXQgdGhlIGhpc3RvcnkgaW4gdHdvXG4gIGZ1bmN0aW9uIGNvcHlIaXN0b3J5QXJyYXkoZXZlbnRzLCBuZXdHcm91cCwgaW5zdGFudGlhdGVTZWwpIHtcbiAgICB2YXIgY29weSA9IFtdO1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgZXZlbnRzLmxlbmd0aDsgKytpKSB7XG4gICAgICB2YXIgZXZlbnQgPSBldmVudHNbaV07XG4gICAgICBpZiAoZXZlbnQucmFuZ2VzKSB7XG4gICAgICAgIGNvcHkucHVzaChpbnN0YW50aWF0ZVNlbCA/IFNlbGVjdGlvbi5wcm90b3R5cGUuZGVlcENvcHkuY2FsbChldmVudCkgOiBldmVudCk7XG4gICAgICAgIGNvbnRpbnVlXG4gICAgICB9XG4gICAgICB2YXIgY2hhbmdlcyA9IGV2ZW50LmNoYW5nZXMsIG5ld0NoYW5nZXMgPSBbXTtcbiAgICAgIGNvcHkucHVzaCh7Y2hhbmdlczogbmV3Q2hhbmdlc30pO1xuICAgICAgZm9yICh2YXIgaiA9IDA7IGogPCBjaGFuZ2VzLmxlbmd0aDsgKytqKSB7XG4gICAgICAgIHZhciBjaGFuZ2UgPSBjaGFuZ2VzW2pdLCBtID0gKHZvaWQgMCk7XG4gICAgICAgIG5ld0NoYW5nZXMucHVzaCh7ZnJvbTogY2hhbmdlLmZyb20sIHRvOiBjaGFuZ2UudG8sIHRleHQ6IGNoYW5nZS50ZXh0fSk7XG4gICAgICAgIGlmIChuZXdHcm91cCkgeyBmb3IgKHZhciBwcm9wIGluIGNoYW5nZSkgeyBpZiAobSA9IHByb3AubWF0Y2goL15zcGFuc18oXFxkKykkLykpIHtcbiAgICAgICAgICBpZiAoaW5kZXhPZihuZXdHcm91cCwgTnVtYmVyKG1bMV0pKSA+IC0xKSB7XG4gICAgICAgICAgICBsc3QobmV3Q2hhbmdlcylbcHJvcF0gPSBjaGFuZ2VbcHJvcF07XG4gICAgICAgICAgICBkZWxldGUgY2hhbmdlW3Byb3BdO1xuICAgICAgICAgIH1cbiAgICAgICAgfSB9IH1cbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIGNvcHlcbiAgfVxuXG4gIC8vIFRoZSAnc2Nyb2xsJyBwYXJhbWV0ZXIgZ2l2ZW4gdG8gbWFueSBvZiB0aGVzZSBpbmRpY2F0ZWQgd2hldGhlclxuICAvLyB0aGUgbmV3IGN1cnNvciBwb3NpdGlvbiBzaG91bGQgYmUgc2Nyb2xsZWQgaW50byB2aWV3IGFmdGVyXG4gIC8vIG1vZGlmeWluZyB0aGUgc2VsZWN0aW9uLlxuXG4gIC8vIElmIHNoaWZ0IGlzIGhlbGQgb3IgdGhlIGV4dGVuZCBmbGFnIGlzIHNldCwgZXh0ZW5kcyBhIHJhbmdlIHRvXG4gIC8vIGluY2x1ZGUgYSBnaXZlbiBwb3NpdGlvbiAoYW5kIG9wdGlvbmFsbHkgYSBzZWNvbmQgcG9zaXRpb24pLlxuICAvLyBPdGhlcndpc2UsIHNpbXBseSByZXR1cm5zIHRoZSByYW5nZSBiZXR3ZWVuIHRoZSBnaXZlbiBwb3NpdGlvbnMuXG4gIC8vIFVzZWQgZm9yIGN1cnNvciBtb3Rpb24gYW5kIHN1Y2guXG4gIGZ1bmN0aW9uIGV4dGVuZFJhbmdlKHJhbmdlLCBoZWFkLCBvdGhlciwgZXh0ZW5kKSB7XG4gICAgaWYgKGV4dGVuZCkge1xuICAgICAgdmFyIGFuY2hvciA9IHJhbmdlLmFuY2hvcjtcbiAgICAgIGlmIChvdGhlcikge1xuICAgICAgICB2YXIgcG9zQmVmb3JlID0gY21wKGhlYWQsIGFuY2hvcikgPCAwO1xuICAgICAgICBpZiAocG9zQmVmb3JlICE9IChjbXAob3RoZXIsIGFuY2hvcikgPCAwKSkge1xuICAgICAgICAgIGFuY2hvciA9IGhlYWQ7XG4gICAgICAgICAgaGVhZCA9IG90aGVyO1xuICAgICAgICB9IGVsc2UgaWYgKHBvc0JlZm9yZSAhPSAoY21wKGhlYWQsIG90aGVyKSA8IDApKSB7XG4gICAgICAgICAgaGVhZCA9IG90aGVyO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICByZXR1cm4gbmV3IFJhbmdlKGFuY2hvciwgaGVhZClcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuIG5ldyBSYW5nZShvdGhlciB8fCBoZWFkLCBoZWFkKVxuICAgIH1cbiAgfVxuXG4gIC8vIEV4dGVuZCB0aGUgcHJpbWFyeSBzZWxlY3Rpb24gcmFuZ2UsIGRpc2NhcmQgdGhlIHJlc3QuXG4gIGZ1bmN0aW9uIGV4dGVuZFNlbGVjdGlvbihkb2MsIGhlYWQsIG90aGVyLCBvcHRpb25zLCBleHRlbmQpIHtcbiAgICBpZiAoZXh0ZW5kID09IG51bGwpIHsgZXh0ZW5kID0gZG9jLmNtICYmIChkb2MuY20uZGlzcGxheS5zaGlmdCB8fCBkb2MuZXh0ZW5kKTsgfVxuICAgIHNldFNlbGVjdGlvbihkb2MsIG5ldyBTZWxlY3Rpb24oW2V4dGVuZFJhbmdlKGRvYy5zZWwucHJpbWFyeSgpLCBoZWFkLCBvdGhlciwgZXh0ZW5kKV0sIDApLCBvcHRpb25zKTtcbiAgfVxuXG4gIC8vIEV4dGVuZCBhbGwgc2VsZWN0aW9ucyAocG9zIGlzIGFuIGFycmF5IG9mIHNlbGVjdGlvbnMgd2l0aCBsZW5ndGhcbiAgLy8gZXF1YWwgdGhlIG51bWJlciBvZiBzZWxlY3Rpb25zKVxuICBmdW5jdGlvbiBleHRlbmRTZWxlY3Rpb25zKGRvYywgaGVhZHMsIG9wdGlvbnMpIHtcbiAgICB2YXIgb3V0ID0gW107XG4gICAgdmFyIGV4dGVuZCA9IGRvYy5jbSAmJiAoZG9jLmNtLmRpc3BsYXkuc2hpZnQgfHwgZG9jLmV4dGVuZCk7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBkb2Muc2VsLnJhbmdlcy5sZW5ndGg7IGkrKylcbiAgICAgIHsgb3V0W2ldID0gZXh0ZW5kUmFuZ2UoZG9jLnNlbC5yYW5nZXNbaV0sIGhlYWRzW2ldLCBudWxsLCBleHRlbmQpOyB9XG4gICAgdmFyIG5ld1NlbCA9IG5vcm1hbGl6ZVNlbGVjdGlvbihkb2MuY20sIG91dCwgZG9jLnNlbC5wcmltSW5kZXgpO1xuICAgIHNldFNlbGVjdGlvbihkb2MsIG5ld1NlbCwgb3B0aW9ucyk7XG4gIH1cblxuICAvLyBVcGRhdGVzIGEgc2luZ2xlIHJhbmdlIGluIHRoZSBzZWxlY3Rpb24uXG4gIGZ1bmN0aW9uIHJlcGxhY2VPbmVTZWxlY3Rpb24oZG9jLCBpLCByYW5nZSwgb3B0aW9ucykge1xuICAgIHZhciByYW5nZXMgPSBkb2Muc2VsLnJhbmdlcy5zbGljZSgwKTtcbiAgICByYW5nZXNbaV0gPSByYW5nZTtcbiAgICBzZXRTZWxlY3Rpb24oZG9jLCBub3JtYWxpemVTZWxlY3Rpb24oZG9jLmNtLCByYW5nZXMsIGRvYy5zZWwucHJpbUluZGV4KSwgb3B0aW9ucyk7XG4gIH1cblxuICAvLyBSZXNldCB0aGUgc2VsZWN0aW9uIHRvIGEgc2luZ2xlIHJhbmdlLlxuICBmdW5jdGlvbiBzZXRTaW1wbGVTZWxlY3Rpb24oZG9jLCBhbmNob3IsIGhlYWQsIG9wdGlvbnMpIHtcbiAgICBzZXRTZWxlY3Rpb24oZG9jLCBzaW1wbGVTZWxlY3Rpb24oYW5jaG9yLCBoZWFkKSwgb3B0aW9ucyk7XG4gIH1cblxuICAvLyBHaXZlIGJlZm9yZVNlbGVjdGlvbkNoYW5nZSBoYW5kbGVycyBhIGNoYW5nZSB0byBpbmZsdWVuY2UgYVxuICAvLyBzZWxlY3Rpb24gdXBkYXRlLlxuICBmdW5jdGlvbiBmaWx0ZXJTZWxlY3Rpb25DaGFuZ2UoZG9jLCBzZWwsIG9wdGlvbnMpIHtcbiAgICB2YXIgb2JqID0ge1xuICAgICAgcmFuZ2VzOiBzZWwucmFuZ2VzLFxuICAgICAgdXBkYXRlOiBmdW5jdGlvbihyYW5nZXMpIHtcbiAgICAgICAgdGhpcy5yYW5nZXMgPSBbXTtcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCByYW5nZXMubGVuZ3RoOyBpKyspXG4gICAgICAgICAgeyB0aGlzLnJhbmdlc1tpXSA9IG5ldyBSYW5nZShjbGlwUG9zKGRvYywgcmFuZ2VzW2ldLmFuY2hvciksXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY2xpcFBvcyhkb2MsIHJhbmdlc1tpXS5oZWFkKSk7IH1cbiAgICAgIH0sXG4gICAgICBvcmlnaW46IG9wdGlvbnMgJiYgb3B0aW9ucy5vcmlnaW5cbiAgICB9O1xuICAgIHNpZ25hbChkb2MsIFwiYmVmb3JlU2VsZWN0aW9uQ2hhbmdlXCIsIGRvYywgb2JqKTtcbiAgICBpZiAoZG9jLmNtKSB7IHNpZ25hbChkb2MuY20sIFwiYmVmb3JlU2VsZWN0aW9uQ2hhbmdlXCIsIGRvYy5jbSwgb2JqKTsgfVxuICAgIGlmIChvYmoucmFuZ2VzICE9IHNlbC5yYW5nZXMpIHsgcmV0dXJuIG5vcm1hbGl6ZVNlbGVjdGlvbihkb2MuY20sIG9iai5yYW5nZXMsIG9iai5yYW5nZXMubGVuZ3RoIC0gMSkgfVxuICAgIGVsc2UgeyByZXR1cm4gc2VsIH1cbiAgfVxuXG4gIGZ1bmN0aW9uIHNldFNlbGVjdGlvblJlcGxhY2VIaXN0b3J5KGRvYywgc2VsLCBvcHRpb25zKSB7XG4gICAgdmFyIGRvbmUgPSBkb2MuaGlzdG9yeS5kb25lLCBsYXN0ID0gbHN0KGRvbmUpO1xuICAgIGlmIChsYXN0ICYmIGxhc3QucmFuZ2VzKSB7XG4gICAgICBkb25lW2RvbmUubGVuZ3RoIC0gMV0gPSBzZWw7XG4gICAgICBzZXRTZWxlY3Rpb25Ob1VuZG8oZG9jLCBzZWwsIG9wdGlvbnMpO1xuICAgIH0gZWxzZSB7XG4gICAgICBzZXRTZWxlY3Rpb24oZG9jLCBzZWwsIG9wdGlvbnMpO1xuICAgIH1cbiAgfVxuXG4gIC8vIFNldCBhIG5ldyBzZWxlY3Rpb24uXG4gIGZ1bmN0aW9uIHNldFNlbGVjdGlvbihkb2MsIHNlbCwgb3B0aW9ucykge1xuICAgIHNldFNlbGVjdGlvbk5vVW5kbyhkb2MsIHNlbCwgb3B0aW9ucyk7XG4gICAgYWRkU2VsZWN0aW9uVG9IaXN0b3J5KGRvYywgZG9jLnNlbCwgZG9jLmNtID8gZG9jLmNtLmN1ck9wLmlkIDogTmFOLCBvcHRpb25zKTtcbiAgfVxuXG4gIGZ1bmN0aW9uIHNldFNlbGVjdGlvbk5vVW5kbyhkb2MsIHNlbCwgb3B0aW9ucykge1xuICAgIGlmIChoYXNIYW5kbGVyKGRvYywgXCJiZWZvcmVTZWxlY3Rpb25DaGFuZ2VcIikgfHwgZG9jLmNtICYmIGhhc0hhbmRsZXIoZG9jLmNtLCBcImJlZm9yZVNlbGVjdGlvbkNoYW5nZVwiKSlcbiAgICAgIHsgc2VsID0gZmlsdGVyU2VsZWN0aW9uQ2hhbmdlKGRvYywgc2VsLCBvcHRpb25zKTsgfVxuXG4gICAgdmFyIGJpYXMgPSBvcHRpb25zICYmIG9wdGlvbnMuYmlhcyB8fFxuICAgICAgKGNtcChzZWwucHJpbWFyeSgpLmhlYWQsIGRvYy5zZWwucHJpbWFyeSgpLmhlYWQpIDwgMCA/IC0xIDogMSk7XG4gICAgc2V0U2VsZWN0aW9uSW5uZXIoZG9jLCBza2lwQXRvbWljSW5TZWxlY3Rpb24oZG9jLCBzZWwsIGJpYXMsIHRydWUpKTtcblxuICAgIGlmICghKG9wdGlvbnMgJiYgb3B0aW9ucy5zY3JvbGwgPT09IGZhbHNlKSAmJiBkb2MuY20gJiYgZG9jLmNtLmdldE9wdGlvbihcInJlYWRPbmx5XCIpICE9IFwibm9jdXJzb3JcIilcbiAgICAgIHsgZW5zdXJlQ3Vyc29yVmlzaWJsZShkb2MuY20pOyB9XG4gIH1cblxuICBmdW5jdGlvbiBzZXRTZWxlY3Rpb25Jbm5lcihkb2MsIHNlbCkge1xuICAgIGlmIChzZWwuZXF1YWxzKGRvYy5zZWwpKSB7IHJldHVybiB9XG5cbiAgICBkb2Muc2VsID0gc2VsO1xuXG4gICAgaWYgKGRvYy5jbSkge1xuICAgICAgZG9jLmNtLmN1ck9wLnVwZGF0ZUlucHV0ID0gMTtcbiAgICAgIGRvYy5jbS5jdXJPcC5zZWxlY3Rpb25DaGFuZ2VkID0gdHJ1ZTtcbiAgICAgIHNpZ25hbEN1cnNvckFjdGl2aXR5KGRvYy5jbSk7XG4gICAgfVxuICAgIHNpZ25hbExhdGVyKGRvYywgXCJjdXJzb3JBY3Rpdml0eVwiLCBkb2MpO1xuICB9XG5cbiAgLy8gVmVyaWZ5IHRoYXQgdGhlIHNlbGVjdGlvbiBkb2VzIG5vdCBwYXJ0aWFsbHkgc2VsZWN0IGFueSBhdG9taWNcbiAgLy8gbWFya2VkIHJhbmdlcy5cbiAgZnVuY3Rpb24gcmVDaGVja1NlbGVjdGlvbihkb2MpIHtcbiAgICBzZXRTZWxlY3Rpb25Jbm5lcihkb2MsIHNraXBBdG9taWNJblNlbGVjdGlvbihkb2MsIGRvYy5zZWwsIG51bGwsIGZhbHNlKSk7XG4gIH1cblxuICAvLyBSZXR1cm4gYSBzZWxlY3Rpb24gdGhhdCBkb2VzIG5vdCBwYXJ0aWFsbHkgc2VsZWN0IGFueSBhdG9taWNcbiAgLy8gcmFuZ2VzLlxuICBmdW5jdGlvbiBza2lwQXRvbWljSW5TZWxlY3Rpb24oZG9jLCBzZWwsIGJpYXMsIG1heUNsZWFyKSB7XG4gICAgdmFyIG91dDtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IHNlbC5yYW5nZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgIHZhciByYW5nZSA9IHNlbC5yYW5nZXNbaV07XG4gICAgICB2YXIgb2xkID0gc2VsLnJhbmdlcy5sZW5ndGggPT0gZG9jLnNlbC5yYW5nZXMubGVuZ3RoICYmIGRvYy5zZWwucmFuZ2VzW2ldO1xuICAgICAgdmFyIG5ld0FuY2hvciA9IHNraXBBdG9taWMoZG9jLCByYW5nZS5hbmNob3IsIG9sZCAmJiBvbGQuYW5jaG9yLCBiaWFzLCBtYXlDbGVhcik7XG4gICAgICB2YXIgbmV3SGVhZCA9IHNraXBBdG9taWMoZG9jLCByYW5nZS5oZWFkLCBvbGQgJiYgb2xkLmhlYWQsIGJpYXMsIG1heUNsZWFyKTtcbiAgICAgIGlmIChvdXQgfHwgbmV3QW5jaG9yICE9IHJhbmdlLmFuY2hvciB8fCBuZXdIZWFkICE9IHJhbmdlLmhlYWQpIHtcbiAgICAgICAgaWYgKCFvdXQpIHsgb3V0ID0gc2VsLnJhbmdlcy5zbGljZSgwLCBpKTsgfVxuICAgICAgICBvdXRbaV0gPSBuZXcgUmFuZ2UobmV3QW5jaG9yLCBuZXdIZWFkKTtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIG91dCA/IG5vcm1hbGl6ZVNlbGVjdGlvbihkb2MuY20sIG91dCwgc2VsLnByaW1JbmRleCkgOiBzZWxcbiAgfVxuXG4gIGZ1bmN0aW9uIHNraXBBdG9taWNJbm5lcihkb2MsIHBvcywgb2xkUG9zLCBkaXIsIG1heUNsZWFyKSB7XG4gICAgdmFyIGxpbmUgPSBnZXRMaW5lKGRvYywgcG9zLmxpbmUpO1xuICAgIGlmIChsaW5lLm1hcmtlZFNwYW5zKSB7IGZvciAodmFyIGkgPSAwOyBpIDwgbGluZS5tYXJrZWRTcGFucy5sZW5ndGg7ICsraSkge1xuICAgICAgdmFyIHNwID0gbGluZS5tYXJrZWRTcGFuc1tpXSwgbSA9IHNwLm1hcmtlcjtcblxuICAgICAgLy8gRGV0ZXJtaW5lIGlmIHdlIHNob3VsZCBwcmV2ZW50IHRoZSBjdXJzb3IgYmVpbmcgcGxhY2VkIHRvIHRoZSBsZWZ0L3JpZ2h0IG9mIGFuIGF0b21pYyBtYXJrZXJcbiAgICAgIC8vIEhpc3RvcmljYWxseSB0aGlzIHdhcyBkZXRlcm1pbmVkIHVzaW5nIHRoZSBpbmNsdXNpdmVMZWZ0L1JpZ2h0IG9wdGlvbiwgYnV0IHRoZSBuZXcgd2F5IHRvIGNvbnRyb2wgaXRcbiAgICAgIC8vIGlzIHdpdGggc2VsZWN0TGVmdC9SaWdodFxuICAgICAgdmFyIHByZXZlbnRDdXJzb3JMZWZ0ID0gKFwic2VsZWN0TGVmdFwiIGluIG0pID8gIW0uc2VsZWN0TGVmdCA6IG0uaW5jbHVzaXZlTGVmdDtcbiAgICAgIHZhciBwcmV2ZW50Q3Vyc29yUmlnaHQgPSAoXCJzZWxlY3RSaWdodFwiIGluIG0pID8gIW0uc2VsZWN0UmlnaHQgOiBtLmluY2x1c2l2ZVJpZ2h0O1xuXG4gICAgICBpZiAoKHNwLmZyb20gPT0gbnVsbCB8fCAocHJldmVudEN1cnNvckxlZnQgPyBzcC5mcm9tIDw9IHBvcy5jaCA6IHNwLmZyb20gPCBwb3MuY2gpKSAmJlxuICAgICAgICAgIChzcC50byA9PSBudWxsIHx8IChwcmV2ZW50Q3Vyc29yUmlnaHQgPyBzcC50byA+PSBwb3MuY2ggOiBzcC50byA+IHBvcy5jaCkpKSB7XG4gICAgICAgIGlmIChtYXlDbGVhcikge1xuICAgICAgICAgIHNpZ25hbChtLCBcImJlZm9yZUN1cnNvckVudGVyXCIpO1xuICAgICAgICAgIGlmIChtLmV4cGxpY2l0bHlDbGVhcmVkKSB7XG4gICAgICAgICAgICBpZiAoIWxpbmUubWFya2VkU3BhbnMpIHsgYnJlYWsgfVxuICAgICAgICAgICAgZWxzZSB7LS1pOyBjb250aW51ZX1cbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCFtLmF0b21pYykgeyBjb250aW51ZSB9XG5cbiAgICAgICAgaWYgKG9sZFBvcykge1xuICAgICAgICAgIHZhciBuZWFyID0gbS5maW5kKGRpciA8IDAgPyAxIDogLTEpLCBkaWZmID0gKHZvaWQgMCk7XG4gICAgICAgICAgaWYgKGRpciA8IDAgPyBwcmV2ZW50Q3Vyc29yUmlnaHQgOiBwcmV2ZW50Q3Vyc29yTGVmdClcbiAgICAgICAgICAgIHsgbmVhciA9IG1vdmVQb3MoZG9jLCBuZWFyLCAtZGlyLCBuZWFyICYmIG5lYXIubGluZSA9PSBwb3MubGluZSA/IGxpbmUgOiBudWxsKTsgfVxuICAgICAgICAgIGlmIChuZWFyICYmIG5lYXIubGluZSA9PSBwb3MubGluZSAmJiAoZGlmZiA9IGNtcChuZWFyLCBvbGRQb3MpKSAmJiAoZGlyIDwgMCA/IGRpZmYgPCAwIDogZGlmZiA+IDApKVxuICAgICAgICAgICAgeyByZXR1cm4gc2tpcEF0b21pY0lubmVyKGRvYywgbmVhciwgcG9zLCBkaXIsIG1heUNsZWFyKSB9XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgZmFyID0gbS5maW5kKGRpciA8IDAgPyAtMSA6IDEpO1xuICAgICAgICBpZiAoZGlyIDwgMCA/IHByZXZlbnRDdXJzb3JMZWZ0IDogcHJldmVudEN1cnNvclJpZ2h0KVxuICAgICAgICAgIHsgZmFyID0gbW92ZVBvcyhkb2MsIGZhciwgZGlyLCBmYXIubGluZSA9PSBwb3MubGluZSA/IGxpbmUgOiBudWxsKTsgfVxuICAgICAgICByZXR1cm4gZmFyID8gc2tpcEF0b21pY0lubmVyKGRvYywgZmFyLCBwb3MsIGRpciwgbWF5Q2xlYXIpIDogbnVsbFxuICAgICAgfVxuICAgIH0gfVxuICAgIHJldHVybiBwb3NcbiAgfVxuXG4gIC8vIEVuc3VyZSBhIGdpdmVuIHBvc2l0aW9uIGlzIG5vdCBpbnNpZGUgYW4gYXRvbWljIHJhbmdlLlxuICBmdW5jdGlvbiBza2lwQXRvbWljKGRvYywgcG9zLCBvbGRQb3MsIGJpYXMsIG1heUNsZWFyKSB7XG4gICAgdmFyIGRpciA9IGJpYXMgfHwgMTtcbiAgICB2YXIgZm91bmQgPSBza2lwQXRvbWljSW5uZXIoZG9jLCBwb3MsIG9sZFBvcywgZGlyLCBtYXlDbGVhcikgfHxcbiAgICAgICAgKCFtYXlDbGVhciAmJiBza2lwQXRvbWljSW5uZXIoZG9jLCBwb3MsIG9sZFBvcywgZGlyLCB0cnVlKSkgfHxcbiAgICAgICAgc2tpcEF0b21pY0lubmVyKGRvYywgcG9zLCBvbGRQb3MsIC1kaXIsIG1heUNsZWFyKSB8fFxuICAgICAgICAoIW1heUNsZWFyICYmIHNraXBBdG9taWNJbm5lcihkb2MsIHBvcywgb2xkUG9zLCAtZGlyLCB0cnVlKSk7XG4gICAgaWYgKCFmb3VuZCkge1xuICAgICAgZG9jLmNhbnRFZGl0ID0gdHJ1ZTtcbiAgICAgIHJldHVybiBQb3MoZG9jLmZpcnN0LCAwKVxuICAgIH1cbiAgICByZXR1cm4gZm91bmRcbiAgfVxuXG4gIGZ1bmN0aW9uIG1vdmVQb3MoZG9jLCBwb3MsIGRpciwgbGluZSkge1xuICAgIGlmIChkaXIgPCAwICYmIHBvcy5jaCA9PSAwKSB7XG4gICAgICBpZiAocG9zLmxpbmUgPiBkb2MuZmlyc3QpIHsgcmV0dXJuIGNsaXBQb3MoZG9jLCBQb3MocG9zLmxpbmUgLSAxKSkgfVxuICAgICAgZWxzZSB7IHJldHVybiBudWxsIH1cbiAgICB9IGVsc2UgaWYgKGRpciA+IDAgJiYgcG9zLmNoID09IChsaW5lIHx8IGdldExpbmUoZG9jLCBwb3MubGluZSkpLnRleHQubGVuZ3RoKSB7XG4gICAgICBpZiAocG9zLmxpbmUgPCBkb2MuZmlyc3QgKyBkb2Muc2l6ZSAtIDEpIHsgcmV0dXJuIFBvcyhwb3MubGluZSArIDEsIDApIH1cbiAgICAgIGVsc2UgeyByZXR1cm4gbnVsbCB9XG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiBuZXcgUG9zKHBvcy5saW5lLCBwb3MuY2ggKyBkaXIpXG4gICAgfVxuICB9XG5cbiAgZnVuY3Rpb24gc2VsZWN0QWxsKGNtKSB7XG4gICAgY20uc2V0U2VsZWN0aW9uKFBvcyhjbS5maXJzdExpbmUoKSwgMCksIFBvcyhjbS5sYXN0TGluZSgpKSwgc2VsX2RvbnRTY3JvbGwpO1xuICB9XG5cbiAgLy8gVVBEQVRJTkdcblxuICAvLyBBbGxvdyBcImJlZm9yZUNoYW5nZVwiIGV2ZW50IGhhbmRsZXJzIHRvIGluZmx1ZW5jZSBhIGNoYW5nZVxuICBmdW5jdGlvbiBmaWx0ZXJDaGFuZ2UoZG9jLCBjaGFuZ2UsIHVwZGF0ZSkge1xuICAgIHZhciBvYmogPSB7XG4gICAgICBjYW5jZWxlZDogZmFsc2UsXG4gICAgICBmcm9tOiBjaGFuZ2UuZnJvbSxcbiAgICAgIHRvOiBjaGFuZ2UudG8sXG4gICAgICB0ZXh0OiBjaGFuZ2UudGV4dCxcbiAgICAgIG9yaWdpbjogY2hhbmdlLm9yaWdpbixcbiAgICAgIGNhbmNlbDogZnVuY3Rpb24gKCkgeyByZXR1cm4gb2JqLmNhbmNlbGVkID0gdHJ1ZTsgfVxuICAgIH07XG4gICAgaWYgKHVwZGF0ZSkgeyBvYmoudXBkYXRlID0gZnVuY3Rpb24gKGZyb20sIHRvLCB0ZXh0LCBvcmlnaW4pIHtcbiAgICAgIGlmIChmcm9tKSB7IG9iai5mcm9tID0gY2xpcFBvcyhkb2MsIGZyb20pOyB9XG4gICAgICBpZiAodG8pIHsgb2JqLnRvID0gY2xpcFBvcyhkb2MsIHRvKTsgfVxuICAgICAgaWYgKHRleHQpIHsgb2JqLnRleHQgPSB0ZXh0OyB9XG4gICAgICBpZiAob3JpZ2luICE9PSB1bmRlZmluZWQpIHsgb2JqLm9yaWdpbiA9IG9yaWdpbjsgfVxuICAgIH07IH1cbiAgICBzaWduYWwoZG9jLCBcImJlZm9yZUNoYW5nZVwiLCBkb2MsIG9iaik7XG4gICAgaWYgKGRvYy5jbSkgeyBzaWduYWwoZG9jLmNtLCBcImJlZm9yZUNoYW5nZVwiLCBkb2MuY20sIG9iaik7IH1cblxuICAgIGlmIChvYmouY2FuY2VsZWQpIHtcbiAgICAgIGlmIChkb2MuY20pIHsgZG9jLmNtLmN1ck9wLnVwZGF0ZUlucHV0ID0gMjsgfVxuICAgICAgcmV0dXJuIG51bGxcbiAgICB9XG4gICAgcmV0dXJuIHtmcm9tOiBvYmouZnJvbSwgdG86IG9iai50bywgdGV4dDogb2JqLnRleHQsIG9yaWdpbjogb2JqLm9yaWdpbn1cbiAgfVxuXG4gIC8vIEFwcGx5IGEgY2hhbmdlIHRvIGEgZG9jdW1lbnQsIGFuZCBhZGQgaXQgdG8gdGhlIGRvY3VtZW50J3NcbiAgLy8gaGlzdG9yeSwgYW5kIHByb3BhZ2F0aW5nIGl0IHRvIGFsbCBsaW5rZWQgZG9jdW1lbnRzLlxuICBmdW5jdGlvbiBtYWtlQ2hhbmdlKGRvYywgY2hhbmdlLCBpZ25vcmVSZWFkT25seSkge1xuICAgIGlmIChkb2MuY20pIHtcbiAgICAgIGlmICghZG9jLmNtLmN1ck9wKSB7IHJldHVybiBvcGVyYXRpb24oZG9jLmNtLCBtYWtlQ2hhbmdlKShkb2MsIGNoYW5nZSwgaWdub3JlUmVhZE9ubHkpIH1cbiAgICAgIGlmIChkb2MuY20uc3RhdGUuc3VwcHJlc3NFZGl0cykgeyByZXR1cm4gfVxuICAgIH1cblxuICAgIGlmIChoYXNIYW5kbGVyKGRvYywgXCJiZWZvcmVDaGFuZ2VcIikgfHwgZG9jLmNtICYmIGhhc0hhbmRsZXIoZG9jLmNtLCBcImJlZm9yZUNoYW5nZVwiKSkge1xuICAgICAgY2hhbmdlID0gZmlsdGVyQ2hhbmdlKGRvYywgY2hhbmdlLCB0cnVlKTtcbiAgICAgIGlmICghY2hhbmdlKSB7IHJldHVybiB9XG4gICAgfVxuXG4gICAgLy8gUG9zc2libHkgc3BsaXQgb3Igc3VwcHJlc3MgdGhlIHVwZGF0ZSBiYXNlZCBvbiB0aGUgcHJlc2VuY2VcbiAgICAvLyBvZiByZWFkLW9ubHkgc3BhbnMgaW4gaXRzIHJhbmdlLlxuICAgIHZhciBzcGxpdCA9IHNhd1JlYWRPbmx5U3BhbnMgJiYgIWlnbm9yZVJlYWRPbmx5ICYmIHJlbW92ZVJlYWRPbmx5UmFuZ2VzKGRvYywgY2hhbmdlLmZyb20sIGNoYW5nZS50byk7XG4gICAgaWYgKHNwbGl0KSB7XG4gICAgICBmb3IgKHZhciBpID0gc3BsaXQubGVuZ3RoIC0gMTsgaSA+PSAwOyAtLWkpXG4gICAgICAgIHsgbWFrZUNoYW5nZUlubmVyKGRvYywge2Zyb206IHNwbGl0W2ldLmZyb20sIHRvOiBzcGxpdFtpXS50bywgdGV4dDogaSA/IFtcIlwiXSA6IGNoYW5nZS50ZXh0LCBvcmlnaW46IGNoYW5nZS5vcmlnaW59KTsgfVxuICAgIH0gZWxzZSB7XG4gICAgICBtYWtlQ2hhbmdlSW5uZXIoZG9jLCBjaGFuZ2UpO1xuICAgIH1cbiAgfVxuXG4gIGZ1bmN0aW9uIG1ha2VDaGFuZ2VJbm5lcihkb2MsIGNoYW5nZSkge1xuICAgIGlmIChjaGFuZ2UudGV4dC5sZW5ndGggPT0gMSAmJiBjaGFuZ2UudGV4dFswXSA9PSBcIlwiICYmIGNtcChjaGFuZ2UuZnJvbSwgY2hhbmdlLnRvKSA9PSAwKSB7IHJldHVybiB9XG4gICAgdmFyIHNlbEFmdGVyID0gY29tcHV0ZVNlbEFmdGVyQ2hhbmdlKGRvYywgY2hhbmdlKTtcbiAgICBhZGRDaGFuZ2VUb0hpc3RvcnkoZG9jLCBjaGFuZ2UsIHNlbEFmdGVyLCBkb2MuY20gPyBkb2MuY20uY3VyT3AuaWQgOiBOYU4pO1xuXG4gICAgbWFrZUNoYW5nZVNpbmdsZURvYyhkb2MsIGNoYW5nZSwgc2VsQWZ0ZXIsIHN0cmV0Y2hTcGFuc092ZXJDaGFuZ2UoZG9jLCBjaGFuZ2UpKTtcbiAgICB2YXIgcmViYXNlZCA9IFtdO1xuXG4gICAgbGlua2VkRG9jcyhkb2MsIGZ1bmN0aW9uIChkb2MsIHNoYXJlZEhpc3QpIHtcbiAgICAgIGlmICghc2hhcmVkSGlzdCAmJiBpbmRleE9mKHJlYmFzZWQsIGRvYy5oaXN0b3J5KSA9PSAtMSkge1xuICAgICAgICByZWJhc2VIaXN0KGRvYy5oaXN0b3J5LCBjaGFuZ2UpO1xuICAgICAgICByZWJhc2VkLnB1c2goZG9jLmhpc3RvcnkpO1xuICAgICAgfVxuICAgICAgbWFrZUNoYW5nZVNpbmdsZURvYyhkb2MsIGNoYW5nZSwgbnVsbCwgc3RyZXRjaFNwYW5zT3ZlckNoYW5nZShkb2MsIGNoYW5nZSkpO1xuICAgIH0pO1xuICB9XG5cbiAgLy8gUmV2ZXJ0IGEgY2hhbmdlIHN0b3JlZCBpbiBhIGRvY3VtZW50J3MgaGlzdG9yeS5cbiAgZnVuY3Rpb24gbWFrZUNoYW5nZUZyb21IaXN0b3J5KGRvYywgdHlwZSwgYWxsb3dTZWxlY3Rpb25Pbmx5KSB7XG4gICAgdmFyIHN1cHByZXNzID0gZG9jLmNtICYmIGRvYy5jbS5zdGF0ZS5zdXBwcmVzc0VkaXRzO1xuICAgIGlmIChzdXBwcmVzcyAmJiAhYWxsb3dTZWxlY3Rpb25Pbmx5KSB7IHJldHVybiB9XG5cbiAgICB2YXIgaGlzdCA9IGRvYy5oaXN0b3J5LCBldmVudCwgc2VsQWZ0ZXIgPSBkb2Muc2VsO1xuICAgIHZhciBzb3VyY2UgPSB0eXBlID09IFwidW5kb1wiID8gaGlzdC5kb25lIDogaGlzdC51bmRvbmUsIGRlc3QgPSB0eXBlID09IFwidW5kb1wiID8gaGlzdC51bmRvbmUgOiBoaXN0LmRvbmU7XG5cbiAgICAvLyBWZXJpZnkgdGhhdCB0aGVyZSBpcyBhIHVzZWFibGUgZXZlbnQgKHNvIHRoYXQgY3RybC16IHdvbid0XG4gICAgLy8gbmVlZGxlc3NseSBjbGVhciBzZWxlY3Rpb24gZXZlbnRzKVxuICAgIHZhciBpID0gMDtcbiAgICBmb3IgKDsgaSA8IHNvdXJjZS5sZW5ndGg7IGkrKykge1xuICAgICAgZXZlbnQgPSBzb3VyY2VbaV07XG4gICAgICBpZiAoYWxsb3dTZWxlY3Rpb25Pbmx5ID8gZXZlbnQucmFuZ2VzICYmICFldmVudC5lcXVhbHMoZG9jLnNlbCkgOiAhZXZlbnQucmFuZ2VzKVxuICAgICAgICB7IGJyZWFrIH1cbiAgICB9XG4gICAgaWYgKGkgPT0gc291cmNlLmxlbmd0aCkgeyByZXR1cm4gfVxuICAgIGhpc3QubGFzdE9yaWdpbiA9IGhpc3QubGFzdFNlbE9yaWdpbiA9IG51bGw7XG5cbiAgICBmb3IgKDs7KSB7XG4gICAgICBldmVudCA9IHNvdXJjZS5wb3AoKTtcbiAgICAgIGlmIChldmVudC5yYW5nZXMpIHtcbiAgICAgICAgcHVzaFNlbGVjdGlvblRvSGlzdG9yeShldmVudCwgZGVzdCk7XG4gICAgICAgIGlmIChhbGxvd1NlbGVjdGlvbk9ubHkgJiYgIWV2ZW50LmVxdWFscyhkb2Muc2VsKSkge1xuICAgICAgICAgIHNldFNlbGVjdGlvbihkb2MsIGV2ZW50LCB7Y2xlYXJSZWRvOiBmYWxzZX0pO1xuICAgICAgICAgIHJldHVyblxuICAgICAgICB9XG4gICAgICAgIHNlbEFmdGVyID0gZXZlbnQ7XG4gICAgICB9IGVsc2UgaWYgKHN1cHByZXNzKSB7XG4gICAgICAgIHNvdXJjZS5wdXNoKGV2ZW50KTtcbiAgICAgICAgcmV0dXJuXG4gICAgICB9IGVsc2UgeyBicmVhayB9XG4gICAgfVxuXG4gICAgLy8gQnVpbGQgdXAgYSByZXZlcnNlIGNoYW5nZSBvYmplY3QgdG8gYWRkIHRvIHRoZSBvcHBvc2l0ZSBoaXN0b3J5XG4gICAgLy8gc3RhY2sgKHJlZG8gd2hlbiB1bmRvaW5nLCBhbmQgdmljZSB2ZXJzYSkuXG4gICAgdmFyIGFudGlDaGFuZ2VzID0gW107XG4gICAgcHVzaFNlbGVjdGlvblRvSGlzdG9yeShzZWxBZnRlciwgZGVzdCk7XG4gICAgZGVzdC5wdXNoKHtjaGFuZ2VzOiBhbnRpQ2hhbmdlcywgZ2VuZXJhdGlvbjogaGlzdC5nZW5lcmF0aW9ufSk7XG4gICAgaGlzdC5nZW5lcmF0aW9uID0gZXZlbnQuZ2VuZXJhdGlvbiB8fCArK2hpc3QubWF4R2VuZXJhdGlvbjtcblxuICAgIHZhciBmaWx0ZXIgPSBoYXNIYW5kbGVyKGRvYywgXCJiZWZvcmVDaGFuZ2VcIikgfHwgZG9jLmNtICYmIGhhc0hhbmRsZXIoZG9jLmNtLCBcImJlZm9yZUNoYW5nZVwiKTtcblxuICAgIHZhciBsb29wID0gZnVuY3Rpb24gKCBpICkge1xuICAgICAgdmFyIGNoYW5nZSA9IGV2ZW50LmNoYW5nZXNbaV07XG4gICAgICBjaGFuZ2Uub3JpZ2luID0gdHlwZTtcbiAgICAgIGlmIChmaWx0ZXIgJiYgIWZpbHRlckNoYW5nZShkb2MsIGNoYW5nZSwgZmFsc2UpKSB7XG4gICAgICAgIHNvdXJjZS5sZW5ndGggPSAwO1xuICAgICAgICByZXR1cm4ge31cbiAgICAgIH1cblxuICAgICAgYW50aUNoYW5nZXMucHVzaChoaXN0b3J5Q2hhbmdlRnJvbUNoYW5nZShkb2MsIGNoYW5nZSkpO1xuXG4gICAgICB2YXIgYWZ0ZXIgPSBpID8gY29tcHV0ZVNlbEFmdGVyQ2hhbmdlKGRvYywgY2hhbmdlKSA6IGxzdChzb3VyY2UpO1xuICAgICAgbWFrZUNoYW5nZVNpbmdsZURvYyhkb2MsIGNoYW5nZSwgYWZ0ZXIsIG1lcmdlT2xkU3BhbnMoZG9jLCBjaGFuZ2UpKTtcbiAgICAgIGlmICghaSAmJiBkb2MuY20pIHsgZG9jLmNtLnNjcm9sbEludG9WaWV3KHtmcm9tOiBjaGFuZ2UuZnJvbSwgdG86IGNoYW5nZUVuZChjaGFuZ2UpfSk7IH1cbiAgICAgIHZhciByZWJhc2VkID0gW107XG5cbiAgICAgIC8vIFByb3BhZ2F0ZSB0byB0aGUgbGlua2VkIGRvY3VtZW50c1xuICAgICAgbGlua2VkRG9jcyhkb2MsIGZ1bmN0aW9uIChkb2MsIHNoYXJlZEhpc3QpIHtcbiAgICAgICAgaWYgKCFzaGFyZWRIaXN0ICYmIGluZGV4T2YocmViYXNlZCwgZG9jLmhpc3RvcnkpID09IC0xKSB7XG4gICAgICAgICAgcmViYXNlSGlzdChkb2MuaGlzdG9yeSwgY2hhbmdlKTtcbiAgICAgICAgICByZWJhc2VkLnB1c2goZG9jLmhpc3RvcnkpO1xuICAgICAgICB9XG4gICAgICAgIG1ha2VDaGFuZ2VTaW5nbGVEb2MoZG9jLCBjaGFuZ2UsIG51bGwsIG1lcmdlT2xkU3BhbnMoZG9jLCBjaGFuZ2UpKTtcbiAgICAgIH0pO1xuICAgIH07XG5cbiAgICBmb3IgKHZhciBpJDEgPSBldmVudC5jaGFuZ2VzLmxlbmd0aCAtIDE7IGkkMSA+PSAwOyAtLWkkMSkge1xuICAgICAgdmFyIHJldHVybmVkID0gbG9vcCggaSQxICk7XG5cbiAgICAgIGlmICggcmV0dXJuZWQgKSByZXR1cm4gcmV0dXJuZWQudjtcbiAgICB9XG4gIH1cblxuICAvLyBTdWItdmlld3MgbmVlZCB0aGVpciBsaW5lIG51bWJlcnMgc2hpZnRlZCB3aGVuIHRleHQgaXMgYWRkZWRcbiAgLy8gYWJvdmUgb3IgYmVsb3cgdGhlbSBpbiB0aGUgcGFyZW50IGRvY3VtZW50LlxuICBmdW5jdGlvbiBzaGlmdERvYyhkb2MsIGRpc3RhbmNlKSB7XG4gICAgaWYgKGRpc3RhbmNlID09IDApIHsgcmV0dXJuIH1cbiAgICBkb2MuZmlyc3QgKz0gZGlzdGFuY2U7XG4gICAgZG9jLnNlbCA9IG5ldyBTZWxlY3Rpb24obWFwKGRvYy5zZWwucmFuZ2VzLCBmdW5jdGlvbiAocmFuZ2UpIHsgcmV0dXJuIG5ldyBSYW5nZShcbiAgICAgIFBvcyhyYW5nZS5hbmNob3IubGluZSArIGRpc3RhbmNlLCByYW5nZS5hbmNob3IuY2gpLFxuICAgICAgUG9zKHJhbmdlLmhlYWQubGluZSArIGRpc3RhbmNlLCByYW5nZS5oZWFkLmNoKVxuICAgICk7IH0pLCBkb2Muc2VsLnByaW1JbmRleCk7XG4gICAgaWYgKGRvYy5jbSkge1xuICAgICAgcmVnQ2hhbmdlKGRvYy5jbSwgZG9jLmZpcnN0LCBkb2MuZmlyc3QgLSBkaXN0YW5jZSwgZGlzdGFuY2UpO1xuICAgICAgZm9yICh2YXIgZCA9IGRvYy5jbS5kaXNwbGF5LCBsID0gZC52aWV3RnJvbTsgbCA8IGQudmlld1RvOyBsKyspXG4gICAgICAgIHsgcmVnTGluZUNoYW5nZShkb2MuY20sIGwsIFwiZ3V0dGVyXCIpOyB9XG4gICAgfVxuICB9XG5cbiAgLy8gTW9yZSBsb3dlci1sZXZlbCBjaGFuZ2UgZnVuY3Rpb24sIGhhbmRsaW5nIG9ubHkgYSBzaW5nbGUgZG9jdW1lbnRcbiAgLy8gKG5vdCBsaW5rZWQgb25lcykuXG4gIGZ1bmN0aW9uIG1ha2VDaGFuZ2VTaW5nbGVEb2MoZG9jLCBjaGFuZ2UsIHNlbEFmdGVyLCBzcGFucykge1xuICAgIGlmIChkb2MuY20gJiYgIWRvYy5jbS5jdXJPcClcbiAgICAgIHsgcmV0dXJuIG9wZXJhdGlvbihkb2MuY20sIG1ha2VDaGFuZ2VTaW5nbGVEb2MpKGRvYywgY2hhbmdlLCBzZWxBZnRlciwgc3BhbnMpIH1cblxuICAgIGlmIChjaGFuZ2UudG8ubGluZSA8IGRvYy5maXJzdCkge1xuICAgICAgc2hpZnREb2MoZG9jLCBjaGFuZ2UudGV4dC5sZW5ndGggLSAxIC0gKGNoYW5nZS50by5saW5lIC0gY2hhbmdlLmZyb20ubGluZSkpO1xuICAgICAgcmV0dXJuXG4gICAgfVxuICAgIGlmIChjaGFuZ2UuZnJvbS5saW5lID4gZG9jLmxhc3RMaW5lKCkpIHsgcmV0dXJuIH1cblxuICAgIC8vIENsaXAgdGhlIGNoYW5nZSB0byB0aGUgc2l6ZSBvZiB0aGlzIGRvY1xuICAgIGlmIChjaGFuZ2UuZnJvbS5saW5lIDwgZG9jLmZpcnN0KSB7XG4gICAgICB2YXIgc2hpZnQgPSBjaGFuZ2UudGV4dC5sZW5ndGggLSAxIC0gKGRvYy5maXJzdCAtIGNoYW5nZS5mcm9tLmxpbmUpO1xuICAgICAgc2hpZnREb2MoZG9jLCBzaGlmdCk7XG4gICAgICBjaGFuZ2UgPSB7ZnJvbTogUG9zKGRvYy5maXJzdCwgMCksIHRvOiBQb3MoY2hhbmdlLnRvLmxpbmUgKyBzaGlmdCwgY2hhbmdlLnRvLmNoKSxcbiAgICAgICAgICAgICAgICB0ZXh0OiBbbHN0KGNoYW5nZS50ZXh0KV0sIG9yaWdpbjogY2hhbmdlLm9yaWdpbn07XG4gICAgfVxuICAgIHZhciBsYXN0ID0gZG9jLmxhc3RMaW5lKCk7XG4gICAgaWYgKGNoYW5nZS50by5saW5lID4gbGFzdCkge1xuICAgICAgY2hhbmdlID0ge2Zyb206IGNoYW5nZS5mcm9tLCB0bzogUG9zKGxhc3QsIGdldExpbmUoZG9jLCBsYXN0KS50ZXh0Lmxlbmd0aCksXG4gICAgICAgICAgICAgICAgdGV4dDogW2NoYW5nZS50ZXh0WzBdXSwgb3JpZ2luOiBjaGFuZ2Uub3JpZ2lufTtcbiAgICB9XG5cbiAgICBjaGFuZ2UucmVtb3ZlZCA9IGdldEJldHdlZW4oZG9jLCBjaGFuZ2UuZnJvbSwgY2hhbmdlLnRvKTtcblxuICAgIGlmICghc2VsQWZ0ZXIpIHsgc2VsQWZ0ZXIgPSBjb21wdXRlU2VsQWZ0ZXJDaGFuZ2UoZG9jLCBjaGFuZ2UpOyB9XG4gICAgaWYgKGRvYy5jbSkgeyBtYWtlQ2hhbmdlU2luZ2xlRG9jSW5FZGl0b3IoZG9jLmNtLCBjaGFuZ2UsIHNwYW5zKTsgfVxuICAgIGVsc2UgeyB1cGRhdGVEb2MoZG9jLCBjaGFuZ2UsIHNwYW5zKTsgfVxuICAgIHNldFNlbGVjdGlvbk5vVW5kbyhkb2MsIHNlbEFmdGVyLCBzZWxfZG9udFNjcm9sbCk7XG5cbiAgICBpZiAoZG9jLmNhbnRFZGl0ICYmIHNraXBBdG9taWMoZG9jLCBQb3MoZG9jLmZpcnN0TGluZSgpLCAwKSkpXG4gICAgICB7IGRvYy5jYW50RWRpdCA9IGZhbHNlOyB9XG4gIH1cblxuICAvLyBIYW5kbGUgdGhlIGludGVyYWN0aW9uIG9mIGEgY2hhbmdlIHRvIGEgZG9jdW1lbnQgd2l0aCB0aGUgZWRpdG9yXG4gIC8vIHRoYXQgdGhpcyBkb2N1bWVudCBpcyBwYXJ0IG9mLlxuICBmdW5jdGlvbiBtYWtlQ2hhbmdlU2luZ2xlRG9jSW5FZGl0b3IoY20sIGNoYW5nZSwgc3BhbnMpIHtcbiAgICB2YXIgZG9jID0gY20uZG9jLCBkaXNwbGF5ID0gY20uZGlzcGxheSwgZnJvbSA9IGNoYW5nZS5mcm9tLCB0byA9IGNoYW5nZS50bztcblxuICAgIHZhciByZWNvbXB1dGVNYXhMZW5ndGggPSBmYWxzZSwgY2hlY2tXaWR0aFN0YXJ0ID0gZnJvbS5saW5lO1xuICAgIGlmICghY20ub3B0aW9ucy5saW5lV3JhcHBpbmcpIHtcbiAgICAgIGNoZWNrV2lkdGhTdGFydCA9IGxpbmVObyh2aXN1YWxMaW5lKGdldExpbmUoZG9jLCBmcm9tLmxpbmUpKSk7XG4gICAgICBkb2MuaXRlcihjaGVja1dpZHRoU3RhcnQsIHRvLmxpbmUgKyAxLCBmdW5jdGlvbiAobGluZSkge1xuICAgICAgICBpZiAobGluZSA9PSBkaXNwbGF5Lm1heExpbmUpIHtcbiAgICAgICAgICByZWNvbXB1dGVNYXhMZW5ndGggPSB0cnVlO1xuICAgICAgICAgIHJldHVybiB0cnVlXG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgIH1cblxuICAgIGlmIChkb2Muc2VsLmNvbnRhaW5zKGNoYW5nZS5mcm9tLCBjaGFuZ2UudG8pID4gLTEpXG4gICAgICB7IHNpZ25hbEN1cnNvckFjdGl2aXR5KGNtKTsgfVxuXG4gICAgdXBkYXRlRG9jKGRvYywgY2hhbmdlLCBzcGFucywgZXN0aW1hdGVIZWlnaHQoY20pKTtcblxuICAgIGlmICghY20ub3B0aW9ucy5saW5lV3JhcHBpbmcpIHtcbiAgICAgIGRvYy5pdGVyKGNoZWNrV2lkdGhTdGFydCwgZnJvbS5saW5lICsgY2hhbmdlLnRleHQubGVuZ3RoLCBmdW5jdGlvbiAobGluZSkge1xuICAgICAgICB2YXIgbGVuID0gbGluZUxlbmd0aChsaW5lKTtcbiAgICAgICAgaWYgKGxlbiA+IGRpc3BsYXkubWF4TGluZUxlbmd0aCkge1xuICAgICAgICAgIGRpc3BsYXkubWF4TGluZSA9IGxpbmU7XG4gICAgICAgICAgZGlzcGxheS5tYXhMaW5lTGVuZ3RoID0gbGVuO1xuICAgICAgICAgIGRpc3BsYXkubWF4TGluZUNoYW5nZWQgPSB0cnVlO1xuICAgICAgICAgIHJlY29tcHV0ZU1heExlbmd0aCA9IGZhbHNlO1xuICAgICAgICB9XG4gICAgICB9KTtcbiAgICAgIGlmIChyZWNvbXB1dGVNYXhMZW5ndGgpIHsgY20uY3VyT3AudXBkYXRlTWF4TGluZSA9IHRydWU7IH1cbiAgICB9XG5cbiAgICByZXRyZWF0RnJvbnRpZXIoZG9jLCBmcm9tLmxpbmUpO1xuICAgIHN0YXJ0V29ya2VyKGNtLCA0MDApO1xuXG4gICAgdmFyIGxlbmRpZmYgPSBjaGFuZ2UudGV4dC5sZW5ndGggLSAodG8ubGluZSAtIGZyb20ubGluZSkgLSAxO1xuICAgIC8vIFJlbWVtYmVyIHRoYXQgdGhlc2UgbGluZXMgY2hhbmdlZCwgZm9yIHVwZGF0aW5nIHRoZSBkaXNwbGF5XG4gICAgaWYgKGNoYW5nZS5mdWxsKVxuICAgICAgeyByZWdDaGFuZ2UoY20pOyB9XG4gICAgZWxzZSBpZiAoZnJvbS5saW5lID09IHRvLmxpbmUgJiYgY2hhbmdlLnRleHQubGVuZ3RoID09IDEgJiYgIWlzV2hvbGVMaW5lVXBkYXRlKGNtLmRvYywgY2hhbmdlKSlcbiAgICAgIHsgcmVnTGluZUNoYW5nZShjbSwgZnJvbS5saW5lLCBcInRleHRcIik7IH1cbiAgICBlbHNlXG4gICAgICB7IHJlZ0NoYW5nZShjbSwgZnJvbS5saW5lLCB0by5saW5lICsgMSwgbGVuZGlmZik7IH1cblxuICAgIHZhciBjaGFuZ2VzSGFuZGxlciA9IGhhc0hhbmRsZXIoY20sIFwiY2hhbmdlc1wiKSwgY2hhbmdlSGFuZGxlciA9IGhhc0hhbmRsZXIoY20sIFwiY2hhbmdlXCIpO1xuICAgIGlmIChjaGFuZ2VIYW5kbGVyIHx8IGNoYW5nZXNIYW5kbGVyKSB7XG4gICAgICB2YXIgb2JqID0ge1xuICAgICAgICBmcm9tOiBmcm9tLCB0bzogdG8sXG4gICAgICAgIHRleHQ6IGNoYW5nZS50ZXh0LFxuICAgICAgICByZW1vdmVkOiBjaGFuZ2UucmVtb3ZlZCxcbiAgICAgICAgb3JpZ2luOiBjaGFuZ2Uub3JpZ2luXG4gICAgICB9O1xuICAgICAgaWYgKGNoYW5nZUhhbmRsZXIpIHsgc2lnbmFsTGF0ZXIoY20sIFwiY2hhbmdlXCIsIGNtLCBvYmopOyB9XG4gICAgICBpZiAoY2hhbmdlc0hhbmRsZXIpIHsgKGNtLmN1ck9wLmNoYW5nZU9ianMgfHwgKGNtLmN1ck9wLmNoYW5nZU9ianMgPSBbXSkpLnB1c2gob2JqKTsgfVxuICAgIH1cbiAgICBjbS5kaXNwbGF5LnNlbEZvckNvbnRleHRNZW51ID0gbnVsbDtcbiAgfVxuXG4gIGZ1bmN0aW9uIHJlcGxhY2VSYW5nZShkb2MsIGNvZGUsIGZyb20sIHRvLCBvcmlnaW4pIHtcbiAgICB2YXIgYXNzaWduO1xuXG4gICAgaWYgKCF0bykgeyB0byA9IGZyb207IH1cbiAgICBpZiAoY21wKHRvLCBmcm9tKSA8IDApIHsgKGFzc2lnbiA9IFt0bywgZnJvbV0sIGZyb20gPSBhc3NpZ25bMF0sIHRvID0gYXNzaWduWzFdKTsgfVxuICAgIGlmICh0eXBlb2YgY29kZSA9PSBcInN0cmluZ1wiKSB7IGNvZGUgPSBkb2Muc3BsaXRMaW5lcyhjb2RlKTsgfVxuICAgIG1ha2VDaGFuZ2UoZG9jLCB7ZnJvbTogZnJvbSwgdG86IHRvLCB0ZXh0OiBjb2RlLCBvcmlnaW46IG9yaWdpbn0pO1xuICB9XG5cbiAgLy8gUmViYXNpbmcvcmVzZXR0aW5nIGhpc3RvcnkgdG8gZGVhbCB3aXRoIGV4dGVybmFsbHktc291cmNlZCBjaGFuZ2VzXG5cbiAgZnVuY3Rpb24gcmViYXNlSGlzdFNlbFNpbmdsZShwb3MsIGZyb20sIHRvLCBkaWZmKSB7XG4gICAgaWYgKHRvIDwgcG9zLmxpbmUpIHtcbiAgICAgIHBvcy5saW5lICs9IGRpZmY7XG4gICAgfSBlbHNlIGlmIChmcm9tIDwgcG9zLmxpbmUpIHtcbiAgICAgIHBvcy5saW5lID0gZnJvbTtcbiAgICAgIHBvcy5jaCA9IDA7XG4gICAgfVxuICB9XG5cbiAgLy8gVHJpZXMgdG8gcmViYXNlIGFuIGFycmF5IG9mIGhpc3RvcnkgZXZlbnRzIGdpdmVuIGEgY2hhbmdlIGluIHRoZVxuICAvLyBkb2N1bWVudC4gSWYgdGhlIGNoYW5nZSB0b3VjaGVzIHRoZSBzYW1lIGxpbmVzIGFzIHRoZSBldmVudCwgdGhlXG4gIC8vIGV2ZW50LCBhbmQgZXZlcnl0aGluZyAnYmVoaW5kJyBpdCwgaXMgZGlzY2FyZGVkLiBJZiB0aGUgY2hhbmdlIGlzXG4gIC8vIGJlZm9yZSB0aGUgZXZlbnQsIHRoZSBldmVudCdzIHBvc2l0aW9ucyBhcmUgdXBkYXRlZC4gVXNlcyBhXG4gIC8vIGNvcHktb24td3JpdGUgc2NoZW1lIGZvciB0aGUgcG9zaXRpb25zLCB0byBhdm9pZCBoYXZpbmcgdG9cbiAgLy8gcmVhbGxvY2F0ZSB0aGVtIGFsbCBvbiBldmVyeSByZWJhc2UsIGJ1dCBhbHNvIGF2b2lkIHByb2JsZW1zIHdpdGhcbiAgLy8gc2hhcmVkIHBvc2l0aW9uIG9iamVjdHMgYmVpbmcgdW5zYWZlbHkgdXBkYXRlZC5cbiAgZnVuY3Rpb24gcmViYXNlSGlzdEFycmF5KGFycmF5LCBmcm9tLCB0bywgZGlmZikge1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgYXJyYXkubGVuZ3RoOyArK2kpIHtcbiAgICAgIHZhciBzdWIgPSBhcnJheVtpXSwgb2sgPSB0cnVlO1xuICAgICAgaWYgKHN1Yi5yYW5nZXMpIHtcbiAgICAgICAgaWYgKCFzdWIuY29waWVkKSB7IHN1YiA9IGFycmF5W2ldID0gc3ViLmRlZXBDb3B5KCk7IHN1Yi5jb3BpZWQgPSB0cnVlOyB9XG4gICAgICAgIGZvciAodmFyIGogPSAwOyBqIDwgc3ViLnJhbmdlcy5sZW5ndGg7IGorKykge1xuICAgICAgICAgIHJlYmFzZUhpc3RTZWxTaW5nbGUoc3ViLnJhbmdlc1tqXS5hbmNob3IsIGZyb20sIHRvLCBkaWZmKTtcbiAgICAgICAgICByZWJhc2VIaXN0U2VsU2luZ2xlKHN1Yi5yYW5nZXNbal0uaGVhZCwgZnJvbSwgdG8sIGRpZmYpO1xuICAgICAgICB9XG4gICAgICAgIGNvbnRpbnVlXG4gICAgICB9XG4gICAgICBmb3IgKHZhciBqJDEgPSAwOyBqJDEgPCBzdWIuY2hhbmdlcy5sZW5ndGg7ICsraiQxKSB7XG4gICAgICAgIHZhciBjdXIgPSBzdWIuY2hhbmdlc1tqJDFdO1xuICAgICAgICBpZiAodG8gPCBjdXIuZnJvbS5saW5lKSB7XG4gICAgICAgICAgY3VyLmZyb20gPSBQb3MoY3VyLmZyb20ubGluZSArIGRpZmYsIGN1ci5mcm9tLmNoKTtcbiAgICAgICAgICBjdXIudG8gPSBQb3MoY3VyLnRvLmxpbmUgKyBkaWZmLCBjdXIudG8uY2gpO1xuICAgICAgICB9IGVsc2UgaWYgKGZyb20gPD0gY3VyLnRvLmxpbmUpIHtcbiAgICAgICAgICBvayA9IGZhbHNlO1xuICAgICAgICAgIGJyZWFrXG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGlmICghb2spIHtcbiAgICAgICAgYXJyYXkuc3BsaWNlKDAsIGkgKyAxKTtcbiAgICAgICAgaSA9IDA7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgZnVuY3Rpb24gcmViYXNlSGlzdChoaXN0LCBjaGFuZ2UpIHtcbiAgICB2YXIgZnJvbSA9IGNoYW5nZS5mcm9tLmxpbmUsIHRvID0gY2hhbmdlLnRvLmxpbmUsIGRpZmYgPSBjaGFuZ2UudGV4dC5sZW5ndGggLSAodG8gLSBmcm9tKSAtIDE7XG4gICAgcmViYXNlSGlzdEFycmF5KGhpc3QuZG9uZSwgZnJvbSwgdG8sIGRpZmYpO1xuICAgIHJlYmFzZUhpc3RBcnJheShoaXN0LnVuZG9uZSwgZnJvbSwgdG8sIGRpZmYpO1xuICB9XG5cbiAgLy8gVXRpbGl0eSBmb3IgYXBwbHlpbmcgYSBjaGFuZ2UgdG8gYSBsaW5lIGJ5IGhhbmRsZSBvciBudW1iZXIsXG4gIC8vIHJldHVybmluZyB0aGUgbnVtYmVyIGFuZCBvcHRpb25hbGx5IHJlZ2lzdGVyaW5nIHRoZSBsaW5lIGFzXG4gIC8vIGNoYW5nZWQuXG4gIGZ1bmN0aW9uIGNoYW5nZUxpbmUoZG9jLCBoYW5kbGUsIGNoYW5nZVR5cGUsIG9wKSB7XG4gICAgdmFyIG5vID0gaGFuZGxlLCBsaW5lID0gaGFuZGxlO1xuICAgIGlmICh0eXBlb2YgaGFuZGxlID09IFwibnVtYmVyXCIpIHsgbGluZSA9IGdldExpbmUoZG9jLCBjbGlwTGluZShkb2MsIGhhbmRsZSkpOyB9XG4gICAgZWxzZSB7IG5vID0gbGluZU5vKGhhbmRsZSk7IH1cbiAgICBpZiAobm8gPT0gbnVsbCkgeyByZXR1cm4gbnVsbCB9XG4gICAgaWYgKG9wKGxpbmUsIG5vKSAmJiBkb2MuY20pIHsgcmVnTGluZUNoYW5nZShkb2MuY20sIG5vLCBjaGFuZ2VUeXBlKTsgfVxuICAgIHJldHVybiBsaW5lXG4gIH1cblxuICAvLyBUaGUgZG9jdW1lbnQgaXMgcmVwcmVzZW50ZWQgYXMgYSBCVHJlZSBjb25zaXN0aW5nIG9mIGxlYXZlcywgd2l0aFxuICAvLyBjaHVuayBvZiBsaW5lcyBpbiB0aGVtLCBhbmQgYnJhbmNoZXMsIHdpdGggdXAgdG8gdGVuIGxlYXZlcyBvclxuICAvLyBvdGhlciBicmFuY2ggbm9kZXMgYmVsb3cgdGhlbS4gVGhlIHRvcCBub2RlIGlzIGFsd2F5cyBhIGJyYW5jaFxuICAvLyBub2RlLCBhbmQgaXMgdGhlIGRvY3VtZW50IG9iamVjdCBpdHNlbGYgKG1lYW5pbmcgaXQgaGFzXG4gIC8vIGFkZGl0aW9uYWwgbWV0aG9kcyBhbmQgcHJvcGVydGllcykuXG4gIC8vXG4gIC8vIEFsbCBub2RlcyBoYXZlIHBhcmVudCBsaW5rcy4gVGhlIHRyZWUgaXMgdXNlZCBib3RoIHRvIGdvIGZyb21cbiAgLy8gbGluZSBudW1iZXJzIHRvIGxpbmUgb2JqZWN0cywgYW5kIHRvIGdvIGZyb20gb2JqZWN0cyB0byBudW1iZXJzLlxuICAvLyBJdCBhbHNvIGluZGV4ZXMgYnkgaGVpZ2h0LCBhbmQgaXMgdXNlZCB0byBjb252ZXJ0IGJldHdlZW4gaGVpZ2h0XG4gIC8vIGFuZCBsaW5lIG9iamVjdCwgYW5kIHRvIGZpbmQgdGhlIHRvdGFsIGhlaWdodCBvZiB0aGUgZG9jdW1lbnQuXG4gIC8vXG4gIC8vIFNlZSBhbHNvIGh0dHA6Ly9tYXJpam5oYXZlcmJla2UubmwvYmxvZy9jb2RlbWlycm9yLWxpbmUtdHJlZS5odG1sXG5cbiAgZnVuY3Rpb24gTGVhZkNodW5rKGxpbmVzKSB7XG4gICAgdGhpcy5saW5lcyA9IGxpbmVzO1xuICAgIHRoaXMucGFyZW50ID0gbnVsbDtcbiAgICB2YXIgaGVpZ2h0ID0gMDtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGxpbmVzLmxlbmd0aDsgKytpKSB7XG4gICAgICBsaW5lc1tpXS5wYXJlbnQgPSB0aGlzO1xuICAgICAgaGVpZ2h0ICs9IGxpbmVzW2ldLmhlaWdodDtcbiAgICB9XG4gICAgdGhpcy5oZWlnaHQgPSBoZWlnaHQ7XG4gIH1cblxuICBMZWFmQ2h1bmsucHJvdG90eXBlID0ge1xuICAgIGNodW5rU2l6ZTogZnVuY3Rpb24oKSB7IHJldHVybiB0aGlzLmxpbmVzLmxlbmd0aCB9LFxuXG4gICAgLy8gUmVtb3ZlIHRoZSBuIGxpbmVzIGF0IG9mZnNldCAnYXQnLlxuICAgIHJlbW92ZUlubmVyOiBmdW5jdGlvbihhdCwgbikge1xuICAgICAgZm9yICh2YXIgaSA9IGF0LCBlID0gYXQgKyBuOyBpIDwgZTsgKytpKSB7XG4gICAgICAgIHZhciBsaW5lID0gdGhpcy5saW5lc1tpXTtcbiAgICAgICAgdGhpcy5oZWlnaHQgLT0gbGluZS5oZWlnaHQ7XG4gICAgICAgIGNsZWFuVXBMaW5lKGxpbmUpO1xuICAgICAgICBzaWduYWxMYXRlcihsaW5lLCBcImRlbGV0ZVwiKTtcbiAgICAgIH1cbiAgICAgIHRoaXMubGluZXMuc3BsaWNlKGF0LCBuKTtcbiAgICB9LFxuXG4gICAgLy8gSGVscGVyIHVzZWQgdG8gY29sbGFwc2UgYSBzbWFsbCBicmFuY2ggaW50byBhIHNpbmdsZSBsZWFmLlxuICAgIGNvbGxhcHNlOiBmdW5jdGlvbihsaW5lcykge1xuICAgICAgbGluZXMucHVzaC5hcHBseShsaW5lcywgdGhpcy5saW5lcyk7XG4gICAgfSxcblxuICAgIC8vIEluc2VydCB0aGUgZ2l2ZW4gYXJyYXkgb2YgbGluZXMgYXQgb2Zmc2V0ICdhdCcsIGNvdW50IHRoZW0gYXNcbiAgICAvLyBoYXZpbmcgdGhlIGdpdmVuIGhlaWdodC5cbiAgICBpbnNlcnRJbm5lcjogZnVuY3Rpb24oYXQsIGxpbmVzLCBoZWlnaHQpIHtcbiAgICAgIHRoaXMuaGVpZ2h0ICs9IGhlaWdodDtcbiAgICAgIHRoaXMubGluZXMgPSB0aGlzLmxpbmVzLnNsaWNlKDAsIGF0KS5jb25jYXQobGluZXMpLmNvbmNhdCh0aGlzLmxpbmVzLnNsaWNlKGF0KSk7XG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGxpbmVzLmxlbmd0aDsgKytpKSB7IGxpbmVzW2ldLnBhcmVudCA9IHRoaXM7IH1cbiAgICB9LFxuXG4gICAgLy8gVXNlZCB0byBpdGVyYXRlIG92ZXIgYSBwYXJ0IG9mIHRoZSB0cmVlLlxuICAgIGl0ZXJOOiBmdW5jdGlvbihhdCwgbiwgb3ApIHtcbiAgICAgIGZvciAodmFyIGUgPSBhdCArIG47IGF0IDwgZTsgKythdClcbiAgICAgICAgeyBpZiAob3AodGhpcy5saW5lc1thdF0pKSB7IHJldHVybiB0cnVlIH0gfVxuICAgIH1cbiAgfTtcblxuICBmdW5jdGlvbiBCcmFuY2hDaHVuayhjaGlsZHJlbikge1xuICAgIHRoaXMuY2hpbGRyZW4gPSBjaGlsZHJlbjtcbiAgICB2YXIgc2l6ZSA9IDAsIGhlaWdodCA9IDA7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBjaGlsZHJlbi5sZW5ndGg7ICsraSkge1xuICAgICAgdmFyIGNoID0gY2hpbGRyZW5baV07XG4gICAgICBzaXplICs9IGNoLmNodW5rU2l6ZSgpOyBoZWlnaHQgKz0gY2guaGVpZ2h0O1xuICAgICAgY2gucGFyZW50ID0gdGhpcztcbiAgICB9XG4gICAgdGhpcy5zaXplID0gc2l6ZTtcbiAgICB0aGlzLmhlaWdodCA9IGhlaWdodDtcbiAgICB0aGlzLnBhcmVudCA9IG51bGw7XG4gIH1cblxuICBCcmFuY2hDaHVuay5wcm90b3R5cGUgPSB7XG4gICAgY2h1bmtTaXplOiBmdW5jdGlvbigpIHsgcmV0dXJuIHRoaXMuc2l6ZSB9LFxuXG4gICAgcmVtb3ZlSW5uZXI6IGZ1bmN0aW9uKGF0LCBuKSB7XG4gICAgICB0aGlzLnNpemUgLT0gbjtcbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdGhpcy5jaGlsZHJlbi5sZW5ndGg7ICsraSkge1xuICAgICAgICB2YXIgY2hpbGQgPSB0aGlzLmNoaWxkcmVuW2ldLCBzeiA9IGNoaWxkLmNodW5rU2l6ZSgpO1xuICAgICAgICBpZiAoYXQgPCBzeikge1xuICAgICAgICAgIHZhciBybSA9IE1hdGgubWluKG4sIHN6IC0gYXQpLCBvbGRIZWlnaHQgPSBjaGlsZC5oZWlnaHQ7XG4gICAgICAgICAgY2hpbGQucmVtb3ZlSW5uZXIoYXQsIHJtKTtcbiAgICAgICAgICB0aGlzLmhlaWdodCAtPSBvbGRIZWlnaHQgLSBjaGlsZC5oZWlnaHQ7XG4gICAgICAgICAgaWYgKHN6ID09IHJtKSB7IHRoaXMuY2hpbGRyZW4uc3BsaWNlKGktLSwgMSk7IGNoaWxkLnBhcmVudCA9IG51bGw7IH1cbiAgICAgICAgICBpZiAoKG4gLT0gcm0pID09IDApIHsgYnJlYWsgfVxuICAgICAgICAgIGF0ID0gMDtcbiAgICAgICAgfSBlbHNlIHsgYXQgLT0gc3o7IH1cbiAgICAgIH1cbiAgICAgIC8vIElmIHRoZSByZXN1bHQgaXMgc21hbGxlciB0aGFuIDI1IGxpbmVzLCBlbnN1cmUgdGhhdCBpdCBpcyBhXG4gICAgICAvLyBzaW5nbGUgbGVhZiBub2RlLlxuICAgICAgaWYgKHRoaXMuc2l6ZSAtIG4gPCAyNSAmJlxuICAgICAgICAgICh0aGlzLmNoaWxkcmVuLmxlbmd0aCA+IDEgfHwgISh0aGlzLmNoaWxkcmVuWzBdIGluc3RhbmNlb2YgTGVhZkNodW5rKSkpIHtcbiAgICAgICAgdmFyIGxpbmVzID0gW107XG4gICAgICAgIHRoaXMuY29sbGFwc2UobGluZXMpO1xuICAgICAgICB0aGlzLmNoaWxkcmVuID0gW25ldyBMZWFmQ2h1bmsobGluZXMpXTtcbiAgICAgICAgdGhpcy5jaGlsZHJlblswXS5wYXJlbnQgPSB0aGlzO1xuICAgICAgfVxuICAgIH0sXG5cbiAgICBjb2xsYXBzZTogZnVuY3Rpb24obGluZXMpIHtcbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdGhpcy5jaGlsZHJlbi5sZW5ndGg7ICsraSkgeyB0aGlzLmNoaWxkcmVuW2ldLmNvbGxhcHNlKGxpbmVzKTsgfVxuICAgIH0sXG5cbiAgICBpbnNlcnRJbm5lcjogZnVuY3Rpb24oYXQsIGxpbmVzLCBoZWlnaHQpIHtcbiAgICAgIHRoaXMuc2l6ZSArPSBsaW5lcy5sZW5ndGg7XG4gICAgICB0aGlzLmhlaWdodCArPSBoZWlnaHQ7XG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHRoaXMuY2hpbGRyZW4ubGVuZ3RoOyArK2kpIHtcbiAgICAgICAgdmFyIGNoaWxkID0gdGhpcy5jaGlsZHJlbltpXSwgc3ogPSBjaGlsZC5jaHVua1NpemUoKTtcbiAgICAgICAgaWYgKGF0IDw9IHN6KSB7XG4gICAgICAgICAgY2hpbGQuaW5zZXJ0SW5uZXIoYXQsIGxpbmVzLCBoZWlnaHQpO1xuICAgICAgICAgIGlmIChjaGlsZC5saW5lcyAmJiBjaGlsZC5saW5lcy5sZW5ndGggPiA1MCkge1xuICAgICAgICAgICAgLy8gVG8gYXZvaWQgbWVtb3J5IHRocmFzaGluZyB3aGVuIGNoaWxkLmxpbmVzIGlzIGh1Z2UgKGUuZy4gZmlyc3QgdmlldyBvZiBhIGxhcmdlIGZpbGUpLCBpdCdzIG5ldmVyIHNwbGljZWQuXG4gICAgICAgICAgICAvLyBJbnN0ZWFkLCBzbWFsbCBzbGljZXMgYXJlIHRha2VuLiBUaGV5J3JlIHRha2VuIGluIG9yZGVyIGJlY2F1c2Ugc2VxdWVudGlhbCBtZW1vcnkgYWNjZXNzZXMgYXJlIGZhc3Rlc3QuXG4gICAgICAgICAgICB2YXIgcmVtYWluaW5nID0gY2hpbGQubGluZXMubGVuZ3RoICUgMjUgKyAyNTtcbiAgICAgICAgICAgIGZvciAodmFyIHBvcyA9IHJlbWFpbmluZzsgcG9zIDwgY2hpbGQubGluZXMubGVuZ3RoOykge1xuICAgICAgICAgICAgICB2YXIgbGVhZiA9IG5ldyBMZWFmQ2h1bmsoY2hpbGQubGluZXMuc2xpY2UocG9zLCBwb3MgKz0gMjUpKTtcbiAgICAgICAgICAgICAgY2hpbGQuaGVpZ2h0IC09IGxlYWYuaGVpZ2h0O1xuICAgICAgICAgICAgICB0aGlzLmNoaWxkcmVuLnNwbGljZSgrK2ksIDAsIGxlYWYpO1xuICAgICAgICAgICAgICBsZWFmLnBhcmVudCA9IHRoaXM7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjaGlsZC5saW5lcyA9IGNoaWxkLmxpbmVzLnNsaWNlKDAsIHJlbWFpbmluZyk7XG4gICAgICAgICAgICB0aGlzLm1heWJlU3BpbGwoKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgYnJlYWtcbiAgICAgICAgfVxuICAgICAgICBhdCAtPSBzejtcbiAgICAgIH1cbiAgICB9LFxuXG4gICAgLy8gV2hlbiBhIG5vZGUgaGFzIGdyb3duLCBjaGVjayB3aGV0aGVyIGl0IHNob3VsZCBiZSBzcGxpdC5cbiAgICBtYXliZVNwaWxsOiBmdW5jdGlvbigpIHtcbiAgICAgIGlmICh0aGlzLmNoaWxkcmVuLmxlbmd0aCA8PSAxMCkgeyByZXR1cm4gfVxuICAgICAgdmFyIG1lID0gdGhpcztcbiAgICAgIGRvIHtcbiAgICAgICAgdmFyIHNwaWxsZWQgPSBtZS5jaGlsZHJlbi5zcGxpY2UobWUuY2hpbGRyZW4ubGVuZ3RoIC0gNSwgNSk7XG4gICAgICAgIHZhciBzaWJsaW5nID0gbmV3IEJyYW5jaENodW5rKHNwaWxsZWQpO1xuICAgICAgICBpZiAoIW1lLnBhcmVudCkgeyAvLyBCZWNvbWUgdGhlIHBhcmVudCBub2RlXG4gICAgICAgICAgdmFyIGNvcHkgPSBuZXcgQnJhbmNoQ2h1bmsobWUuY2hpbGRyZW4pO1xuICAgICAgICAgIGNvcHkucGFyZW50ID0gbWU7XG4gICAgICAgICAgbWUuY2hpbGRyZW4gPSBbY29weSwgc2libGluZ107XG4gICAgICAgICAgbWUgPSBjb3B5O1xuICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgbWUuc2l6ZSAtPSBzaWJsaW5nLnNpemU7XG4gICAgICAgICAgbWUuaGVpZ2h0IC09IHNpYmxpbmcuaGVpZ2h0O1xuICAgICAgICAgIHZhciBteUluZGV4ID0gaW5kZXhPZihtZS5wYXJlbnQuY2hpbGRyZW4sIG1lKTtcbiAgICAgICAgICBtZS5wYXJlbnQuY2hpbGRyZW4uc3BsaWNlKG15SW5kZXggKyAxLCAwLCBzaWJsaW5nKTtcbiAgICAgICAgfVxuICAgICAgICBzaWJsaW5nLnBhcmVudCA9IG1lLnBhcmVudDtcbiAgICAgIH0gd2hpbGUgKG1lLmNoaWxkcmVuLmxlbmd0aCA+IDEwKVxuICAgICAgbWUucGFyZW50Lm1heWJlU3BpbGwoKTtcbiAgICB9LFxuXG4gICAgaXRlck46IGZ1bmN0aW9uKGF0LCBuLCBvcCkge1xuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCB0aGlzLmNoaWxkcmVuLmxlbmd0aDsgKytpKSB7XG4gICAgICAgIHZhciBjaGlsZCA9IHRoaXMuY2hpbGRyZW5baV0sIHN6ID0gY2hpbGQuY2h1bmtTaXplKCk7XG4gICAgICAgIGlmIChhdCA8IHN6KSB7XG4gICAgICAgICAgdmFyIHVzZWQgPSBNYXRoLm1pbihuLCBzeiAtIGF0KTtcbiAgICAgICAgICBpZiAoY2hpbGQuaXRlck4oYXQsIHVzZWQsIG9wKSkgeyByZXR1cm4gdHJ1ZSB9XG4gICAgICAgICAgaWYgKChuIC09IHVzZWQpID09IDApIHsgYnJlYWsgfVxuICAgICAgICAgIGF0ID0gMDtcbiAgICAgICAgfSBlbHNlIHsgYXQgLT0gc3o7IH1cbiAgICAgIH1cbiAgICB9XG4gIH07XG5cbiAgLy8gTGluZSB3aWRnZXRzIGFyZSBibG9jayBlbGVtZW50cyBkaXNwbGF5ZWQgYWJvdmUgb3IgYmVsb3cgYSBsaW5lLlxuXG4gIHZhciBMaW5lV2lkZ2V0ID0gZnVuY3Rpb24oZG9jLCBub2RlLCBvcHRpb25zKSB7XG4gICAgaWYgKG9wdGlvbnMpIHsgZm9yICh2YXIgb3B0IGluIG9wdGlvbnMpIHsgaWYgKG9wdGlvbnMuaGFzT3duUHJvcGVydHkob3B0KSlcbiAgICAgIHsgdGhpc1tvcHRdID0gb3B0aW9uc1tvcHRdOyB9IH0gfVxuICAgIHRoaXMuZG9jID0gZG9jO1xuICAgIHRoaXMubm9kZSA9IG5vZGU7XG4gIH07XG5cbiAgTGluZVdpZGdldC5wcm90b3R5cGUuY2xlYXIgPSBmdW5jdGlvbiAoKSB7XG4gICAgdmFyIGNtID0gdGhpcy5kb2MuY20sIHdzID0gdGhpcy5saW5lLndpZGdldHMsIGxpbmUgPSB0aGlzLmxpbmUsIG5vID0gbGluZU5vKGxpbmUpO1xuICAgIGlmIChubyA9PSBudWxsIHx8ICF3cykgeyByZXR1cm4gfVxuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgd3MubGVuZ3RoOyArK2kpIHsgaWYgKHdzW2ldID09IHRoaXMpIHsgd3Muc3BsaWNlKGktLSwgMSk7IH0gfVxuICAgIGlmICghd3MubGVuZ3RoKSB7IGxpbmUud2lkZ2V0cyA9IG51bGw7IH1cbiAgICB2YXIgaGVpZ2h0ID0gd2lkZ2V0SGVpZ2h0KHRoaXMpO1xuICAgIHVwZGF0ZUxpbmVIZWlnaHQobGluZSwgTWF0aC5tYXgoMCwgbGluZS5oZWlnaHQgLSBoZWlnaHQpKTtcbiAgICBpZiAoY20pIHtcbiAgICAgIHJ1bkluT3AoY20sIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgYWRqdXN0U2Nyb2xsV2hlbkFib3ZlVmlzaWJsZShjbSwgbGluZSwgLWhlaWdodCk7XG4gICAgICAgIHJlZ0xpbmVDaGFuZ2UoY20sIG5vLCBcIndpZGdldFwiKTtcbiAgICAgIH0pO1xuICAgICAgc2lnbmFsTGF0ZXIoY20sIFwibGluZVdpZGdldENsZWFyZWRcIiwgY20sIHRoaXMsIG5vKTtcbiAgICB9XG4gIH07XG5cbiAgTGluZVdpZGdldC5wcm90b3R5cGUuY2hhbmdlZCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgIHZhciB0aGlzJDEgPSB0aGlzO1xuXG4gICAgdmFyIG9sZEggPSB0aGlzLmhlaWdodCwgY20gPSB0aGlzLmRvYy5jbSwgbGluZSA9IHRoaXMubGluZTtcbiAgICB0aGlzLmhlaWdodCA9IG51bGw7XG4gICAgdmFyIGRpZmYgPSB3aWRnZXRIZWlnaHQodGhpcykgLSBvbGRIO1xuICAgIGlmICghZGlmZikgeyByZXR1cm4gfVxuICAgIGlmICghbGluZUlzSGlkZGVuKHRoaXMuZG9jLCBsaW5lKSkgeyB1cGRhdGVMaW5lSGVpZ2h0KGxpbmUsIGxpbmUuaGVpZ2h0ICsgZGlmZik7IH1cbiAgICBpZiAoY20pIHtcbiAgICAgIHJ1bkluT3AoY20sIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgY20uY3VyT3AuZm9yY2VVcGRhdGUgPSB0cnVlO1xuICAgICAgICBhZGp1c3RTY3JvbGxXaGVuQWJvdmVWaXNpYmxlKGNtLCBsaW5lLCBkaWZmKTtcbiAgICAgICAgc2lnbmFsTGF0ZXIoY20sIFwibGluZVdpZGdldENoYW5nZWRcIiwgY20sIHRoaXMkMSwgbGluZU5vKGxpbmUpKTtcbiAgICAgIH0pO1xuICAgIH1cbiAgfTtcbiAgZXZlbnRNaXhpbihMaW5lV2lkZ2V0KTtcblxuICBmdW5jdGlvbiBhZGp1c3RTY3JvbGxXaGVuQWJvdmVWaXNpYmxlKGNtLCBsaW5lLCBkaWZmKSB7XG4gICAgaWYgKGhlaWdodEF0TGluZShsaW5lKSA8ICgoY20uY3VyT3AgJiYgY20uY3VyT3Auc2Nyb2xsVG9wKSB8fCBjbS5kb2Muc2Nyb2xsVG9wKSlcbiAgICAgIHsgYWRkVG9TY3JvbGxUb3AoY20sIGRpZmYpOyB9XG4gIH1cblxuICBmdW5jdGlvbiBhZGRMaW5lV2lkZ2V0KGRvYywgaGFuZGxlLCBub2RlLCBvcHRpb25zKSB7XG4gICAgdmFyIHdpZGdldCA9IG5ldyBMaW5lV2lkZ2V0KGRvYywgbm9kZSwgb3B0aW9ucyk7XG4gICAgdmFyIGNtID0gZG9jLmNtO1xuICAgIGlmIChjbSAmJiB3aWRnZXQubm9IU2Nyb2xsKSB7IGNtLmRpc3BsYXkuYWxpZ25XaWRnZXRzID0gdHJ1ZTsgfVxuICAgIGNoYW5nZUxpbmUoZG9jLCBoYW5kbGUsIFwid2lkZ2V0XCIsIGZ1bmN0aW9uIChsaW5lKSB7XG4gICAgICB2YXIgd2lkZ2V0cyA9IGxpbmUud2lkZ2V0cyB8fCAobGluZS53aWRnZXRzID0gW10pO1xuICAgICAgaWYgKHdpZGdldC5pbnNlcnRBdCA9PSBudWxsKSB7IHdpZGdldHMucHVzaCh3aWRnZXQpOyB9XG4gICAgICBlbHNlIHsgd2lkZ2V0cy5zcGxpY2UoTWF0aC5taW4od2lkZ2V0cy5sZW5ndGgsIE1hdGgubWF4KDAsIHdpZGdldC5pbnNlcnRBdCkpLCAwLCB3aWRnZXQpOyB9XG4gICAgICB3aWRnZXQubGluZSA9IGxpbmU7XG4gICAgICBpZiAoY20gJiYgIWxpbmVJc0hpZGRlbihkb2MsIGxpbmUpKSB7XG4gICAgICAgIHZhciBhYm92ZVZpc2libGUgPSBoZWlnaHRBdExpbmUobGluZSkgPCBkb2Muc2Nyb2xsVG9wO1xuICAgICAgICB1cGRhdGVMaW5lSGVpZ2h0KGxpbmUsIGxpbmUuaGVpZ2h0ICsgd2lkZ2V0SGVpZ2h0KHdpZGdldCkpO1xuICAgICAgICBpZiAoYWJvdmVWaXNpYmxlKSB7IGFkZFRvU2Nyb2xsVG9wKGNtLCB3aWRnZXQuaGVpZ2h0KTsgfVxuICAgICAgICBjbS5jdXJPcC5mb3JjZVVwZGF0ZSA9IHRydWU7XG4gICAgICB9XG4gICAgICByZXR1cm4gdHJ1ZVxuICAgIH0pO1xuICAgIGlmIChjbSkgeyBzaWduYWxMYXRlcihjbSwgXCJsaW5lV2lkZ2V0QWRkZWRcIiwgY20sIHdpZGdldCwgdHlwZW9mIGhhbmRsZSA9PSBcIm51bWJlclwiID8gaGFuZGxlIDogbGluZU5vKGhhbmRsZSkpOyB9XG4gICAgcmV0dXJuIHdpZGdldFxuICB9XG5cbiAgLy8gVEVYVE1BUktFUlNcblxuICAvLyBDcmVhdGVkIHdpdGggbWFya1RleHQgYW5kIHNldEJvb2ttYXJrIG1ldGhvZHMuIEEgVGV4dE1hcmtlciBpcyBhXG4gIC8vIGhhbmRsZSB0aGF0IGNhbiBiZSB1c2VkIHRvIGNsZWFyIG9yIGZpbmQgYSBtYXJrZWQgcG9zaXRpb24gaW4gdGhlXG4gIC8vIGRvY3VtZW50LiBMaW5lIG9iamVjdHMgaG9sZCBhcnJheXMgKG1hcmtlZFNwYW5zKSBjb250YWluaW5nXG4gIC8vIHtmcm9tLCB0bywgbWFya2VyfSBvYmplY3QgcG9pbnRpbmcgdG8gc3VjaCBtYXJrZXIgb2JqZWN0cywgYW5kXG4gIC8vIGluZGljYXRpbmcgdGhhdCBzdWNoIGEgbWFya2VyIGlzIHByZXNlbnQgb24gdGhhdCBsaW5lLiBNdWx0aXBsZVxuICAvLyBsaW5lcyBtYXkgcG9pbnQgdG8gdGhlIHNhbWUgbWFya2VyIHdoZW4gaXQgc3BhbnMgYWNyb3NzIGxpbmVzLlxuICAvLyBUaGUgc3BhbnMgd2lsbCBoYXZlIG51bGwgZm9yIHRoZWlyIGZyb20vdG8gcHJvcGVydGllcyB3aGVuIHRoZVxuICAvLyBtYXJrZXIgY29udGludWVzIGJleW9uZCB0aGUgc3RhcnQvZW5kIG9mIHRoZSBsaW5lLiBNYXJrZXJzIGhhdmVcbiAgLy8gbGlua3MgYmFjayB0byB0aGUgbGluZXMgdGhleSBjdXJyZW50bHkgdG91Y2guXG5cbiAgLy8gQ29sbGFwc2VkIG1hcmtlcnMgaGF2ZSB1bmlxdWUgaWRzLCBpbiBvcmRlciB0byBiZSBhYmxlIHRvIG9yZGVyXG4gIC8vIHRoZW0sIHdoaWNoIGlzIG5lZWRlZCBmb3IgdW5pcXVlbHkgZGV0ZXJtaW5pbmcgYW4gb3V0ZXIgbWFya2VyXG4gIC8vIHdoZW4gdGhleSBvdmVybGFwICh0aGV5IG1heSBuZXN0LCBidXQgbm90IHBhcnRpYWxseSBvdmVybGFwKS5cbiAgdmFyIG5leHRNYXJrZXJJZCA9IDA7XG5cbiAgdmFyIFRleHRNYXJrZXIgPSBmdW5jdGlvbihkb2MsIHR5cGUpIHtcbiAgICB0aGlzLmxpbmVzID0gW107XG4gICAgdGhpcy50eXBlID0gdHlwZTtcbiAgICB0aGlzLmRvYyA9IGRvYztcbiAgICB0aGlzLmlkID0gKytuZXh0TWFya2VySWQ7XG4gIH07XG5cbiAgLy8gQ2xlYXIgdGhlIG1hcmtlci5cbiAgVGV4dE1hcmtlci5wcm90b3R5cGUuY2xlYXIgPSBmdW5jdGlvbiAoKSB7XG4gICAgaWYgKHRoaXMuZXhwbGljaXRseUNsZWFyZWQpIHsgcmV0dXJuIH1cbiAgICB2YXIgY20gPSB0aGlzLmRvYy5jbSwgd2l0aE9wID0gY20gJiYgIWNtLmN1ck9wO1xuICAgIGlmICh3aXRoT3ApIHsgc3RhcnRPcGVyYXRpb24oY20pOyB9XG4gICAgaWYgKGhhc0hhbmRsZXIodGhpcywgXCJjbGVhclwiKSkge1xuICAgICAgdmFyIGZvdW5kID0gdGhpcy5maW5kKCk7XG4gICAgICBpZiAoZm91bmQpIHsgc2lnbmFsTGF0ZXIodGhpcywgXCJjbGVhclwiLCBmb3VuZC5mcm9tLCBmb3VuZC50byk7IH1cbiAgICB9XG4gICAgdmFyIG1pbiA9IG51bGwsIG1heCA9IG51bGw7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCB0aGlzLmxpbmVzLmxlbmd0aDsgKytpKSB7XG4gICAgICB2YXIgbGluZSA9IHRoaXMubGluZXNbaV07XG4gICAgICB2YXIgc3BhbiA9IGdldE1hcmtlZFNwYW5Gb3IobGluZS5tYXJrZWRTcGFucywgdGhpcyk7XG4gICAgICBpZiAoY20gJiYgIXRoaXMuY29sbGFwc2VkKSB7IHJlZ0xpbmVDaGFuZ2UoY20sIGxpbmVObyhsaW5lKSwgXCJ0ZXh0XCIpOyB9XG4gICAgICBlbHNlIGlmIChjbSkge1xuICAgICAgICBpZiAoc3Bhbi50byAhPSBudWxsKSB7IG1heCA9IGxpbmVObyhsaW5lKTsgfVxuICAgICAgICBpZiAoc3Bhbi5mcm9tICE9IG51bGwpIHsgbWluID0gbGluZU5vKGxpbmUpOyB9XG4gICAgICB9XG4gICAgICBsaW5lLm1hcmtlZFNwYW5zID0gcmVtb3ZlTWFya2VkU3BhbihsaW5lLm1hcmtlZFNwYW5zLCBzcGFuKTtcbiAgICAgIGlmIChzcGFuLmZyb20gPT0gbnVsbCAmJiB0aGlzLmNvbGxhcHNlZCAmJiAhbGluZUlzSGlkZGVuKHRoaXMuZG9jLCBsaW5lKSAmJiBjbSlcbiAgICAgICAgeyB1cGRhdGVMaW5lSGVpZ2h0KGxpbmUsIHRleHRIZWlnaHQoY20uZGlzcGxheSkpOyB9XG4gICAgfVxuICAgIGlmIChjbSAmJiB0aGlzLmNvbGxhcHNlZCAmJiAhY20ub3B0aW9ucy5saW5lV3JhcHBpbmcpIHsgZm9yICh2YXIgaSQxID0gMDsgaSQxIDwgdGhpcy5saW5lcy5sZW5ndGg7ICsraSQxKSB7XG4gICAgICB2YXIgdmlzdWFsID0gdmlzdWFsTGluZSh0aGlzLmxpbmVzW2kkMV0pLCBsZW4gPSBsaW5lTGVuZ3RoKHZpc3VhbCk7XG4gICAgICBpZiAobGVuID4gY20uZGlzcGxheS5tYXhMaW5lTGVuZ3RoKSB7XG4gICAgICAgIGNtLmRpc3BsYXkubWF4TGluZSA9IHZpc3VhbDtcbiAgICAgICAgY20uZGlzcGxheS5tYXhMaW5lTGVuZ3RoID0gbGVuO1xuICAgICAgICBjbS5kaXNwbGF5Lm1heExpbmVDaGFuZ2VkID0gdHJ1ZTtcbiAgICAgIH1cbiAgICB9IH1cblxuICAgIGlmIChtaW4gIT0gbnVsbCAmJiBjbSAmJiB0aGlzLmNvbGxhcHNlZCkgeyByZWdDaGFuZ2UoY20sIG1pbiwgbWF4ICsgMSk7IH1cbiAgICB0aGlzLmxpbmVzLmxlbmd0aCA9IDA7XG4gICAgdGhpcy5leHBsaWNpdGx5Q2xlYXJlZCA9IHRydWU7XG4gICAgaWYgKHRoaXMuYXRvbWljICYmIHRoaXMuZG9jLmNhbnRFZGl0KSB7XG4gICAgICB0aGlzLmRvYy5jYW50RWRpdCA9IGZhbHNlO1xuICAgICAgaWYgKGNtKSB7IHJlQ2hlY2tTZWxlY3Rpb24oY20uZG9jKTsgfVxuICAgIH1cbiAgICBpZiAoY20pIHsgc2lnbmFsTGF0ZXIoY20sIFwibWFya2VyQ2xlYXJlZFwiLCBjbSwgdGhpcywgbWluLCBtYXgpOyB9XG4gICAgaWYgKHdpdGhPcCkgeyBlbmRPcGVyYXRpb24oY20pOyB9XG4gICAgaWYgKHRoaXMucGFyZW50KSB7IHRoaXMucGFyZW50LmNsZWFyKCk7IH1cbiAgfTtcblxuICAvLyBGaW5kIHRoZSBwb3NpdGlvbiBvZiB0aGUgbWFya2VyIGluIHRoZSBkb2N1bWVudC4gUmV0dXJucyBhIHtmcm9tLFxuICAvLyB0b30gb2JqZWN0IGJ5IGRlZmF1bHQuIFNpZGUgY2FuIGJlIHBhc3NlZCB0byBnZXQgYSBzcGVjaWZpYyBzaWRlXG4gIC8vIC0tIDAgKGJvdGgpLCAtMSAobGVmdCksIG9yIDEgKHJpZ2h0KS4gV2hlbiBsaW5lT2JqIGlzIHRydWUsIHRoZVxuICAvLyBQb3Mgb2JqZWN0cyByZXR1cm5lZCBjb250YWluIGEgbGluZSBvYmplY3QsIHJhdGhlciB0aGFuIGEgbGluZVxuICAvLyBudW1iZXIgKHVzZWQgdG8gcHJldmVudCBsb29raW5nIHVwIHRoZSBzYW1lIGxpbmUgdHdpY2UpLlxuICBUZXh0TWFya2VyLnByb3RvdHlwZS5maW5kID0gZnVuY3Rpb24gKHNpZGUsIGxpbmVPYmopIHtcbiAgICBpZiAoc2lkZSA9PSBudWxsICYmIHRoaXMudHlwZSA9PSBcImJvb2ttYXJrXCIpIHsgc2lkZSA9IDE7IH1cbiAgICB2YXIgZnJvbSwgdG87XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCB0aGlzLmxpbmVzLmxlbmd0aDsgKytpKSB7XG4gICAgICB2YXIgbGluZSA9IHRoaXMubGluZXNbaV07XG4gICAgICB2YXIgc3BhbiA9IGdldE1hcmtlZFNwYW5Gb3IobGluZS5tYXJrZWRTcGFucywgdGhpcyk7XG4gICAgICBpZiAoc3Bhbi5mcm9tICE9IG51bGwpIHtcbiAgICAgICAgZnJvbSA9IFBvcyhsaW5lT2JqID8gbGluZSA6IGxpbmVObyhsaW5lKSwgc3Bhbi5mcm9tKTtcbiAgICAgICAgaWYgKHNpZGUgPT0gLTEpIHsgcmV0dXJuIGZyb20gfVxuICAgICAgfVxuICAgICAgaWYgKHNwYW4udG8gIT0gbnVsbCkge1xuICAgICAgICB0byA9IFBvcyhsaW5lT2JqID8gbGluZSA6IGxpbmVObyhsaW5lKSwgc3Bhbi50byk7XG4gICAgICAgIGlmIChzaWRlID09IDEpIHsgcmV0dXJuIHRvIH1cbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIGZyb20gJiYge2Zyb206IGZyb20sIHRvOiB0b31cbiAgfTtcblxuICAvLyBTaWduYWxzIHRoYXQgdGhlIG1hcmtlcidzIHdpZGdldCBjaGFuZ2VkLCBhbmQgc3Vycm91bmRpbmcgbGF5b3V0XG4gIC8vIHNob3VsZCBiZSByZWNvbXB1dGVkLlxuICBUZXh0TWFya2VyLnByb3RvdHlwZS5jaGFuZ2VkID0gZnVuY3Rpb24gKCkge1xuICAgICAgdmFyIHRoaXMkMSA9IHRoaXM7XG5cbiAgICB2YXIgcG9zID0gdGhpcy5maW5kKC0xLCB0cnVlKSwgd2lkZ2V0ID0gdGhpcywgY20gPSB0aGlzLmRvYy5jbTtcbiAgICBpZiAoIXBvcyB8fCAhY20pIHsgcmV0dXJuIH1cbiAgICBydW5Jbk9wKGNtLCBmdW5jdGlvbiAoKSB7XG4gICAgICB2YXIgbGluZSA9IHBvcy5saW5lLCBsaW5lTiA9IGxpbmVObyhwb3MubGluZSk7XG4gICAgICB2YXIgdmlldyA9IGZpbmRWaWV3Rm9yTGluZShjbSwgbGluZU4pO1xuICAgICAgaWYgKHZpZXcpIHtcbiAgICAgICAgY2xlYXJMaW5lTWVhc3VyZW1lbnRDYWNoZUZvcih2aWV3KTtcbiAgICAgICAgY20uY3VyT3Auc2VsZWN0aW9uQ2hhbmdlZCA9IGNtLmN1ck9wLmZvcmNlVXBkYXRlID0gdHJ1ZTtcbiAgICAgIH1cbiAgICAgIGNtLmN1ck9wLnVwZGF0ZU1heExpbmUgPSB0cnVlO1xuICAgICAgaWYgKCFsaW5lSXNIaWRkZW4od2lkZ2V0LmRvYywgbGluZSkgJiYgd2lkZ2V0LmhlaWdodCAhPSBudWxsKSB7XG4gICAgICAgIHZhciBvbGRIZWlnaHQgPSB3aWRnZXQuaGVpZ2h0O1xuICAgICAgICB3aWRnZXQuaGVpZ2h0ID0gbnVsbDtcbiAgICAgICAgdmFyIGRIZWlnaHQgPSB3aWRnZXRIZWlnaHQod2lkZ2V0KSAtIG9sZEhlaWdodDtcbiAgICAgICAgaWYgKGRIZWlnaHQpXG4gICAgICAgICAgeyB1cGRhdGVMaW5lSGVpZ2h0KGxpbmUsIGxpbmUuaGVpZ2h0ICsgZEhlaWdodCk7IH1cbiAgICAgIH1cbiAgICAgIHNpZ25hbExhdGVyKGNtLCBcIm1hcmtlckNoYW5nZWRcIiwgY20sIHRoaXMkMSk7XG4gICAgfSk7XG4gIH07XG5cbiAgVGV4dE1hcmtlci5wcm90b3R5cGUuYXR0YWNoTGluZSA9IGZ1bmN0aW9uIChsaW5lKSB7XG4gICAgaWYgKCF0aGlzLmxpbmVzLmxlbmd0aCAmJiB0aGlzLmRvYy5jbSkge1xuICAgICAgdmFyIG9wID0gdGhpcy5kb2MuY20uY3VyT3A7XG4gICAgICBpZiAoIW9wLm1heWJlSGlkZGVuTWFya2VycyB8fCBpbmRleE9mKG9wLm1heWJlSGlkZGVuTWFya2VycywgdGhpcykgPT0gLTEpXG4gICAgICAgIHsgKG9wLm1heWJlVW5oaWRkZW5NYXJrZXJzIHx8IChvcC5tYXliZVVuaGlkZGVuTWFya2VycyA9IFtdKSkucHVzaCh0aGlzKTsgfVxuICAgIH1cbiAgICB0aGlzLmxpbmVzLnB1c2gobGluZSk7XG4gIH07XG5cbiAgVGV4dE1hcmtlci5wcm90b3R5cGUuZGV0YWNoTGluZSA9IGZ1bmN0aW9uIChsaW5lKSB7XG4gICAgdGhpcy5saW5lcy5zcGxpY2UoaW5kZXhPZih0aGlzLmxpbmVzLCBsaW5lKSwgMSk7XG4gICAgaWYgKCF0aGlzLmxpbmVzLmxlbmd0aCAmJiB0aGlzLmRvYy5jbSkge1xuICAgICAgdmFyIG9wID0gdGhpcy5kb2MuY20uY3VyT3BcbiAgICAgIDsob3AubWF5YmVIaWRkZW5NYXJrZXJzIHx8IChvcC5tYXliZUhpZGRlbk1hcmtlcnMgPSBbXSkpLnB1c2godGhpcyk7XG4gICAgfVxuICB9O1xuICBldmVudE1peGluKFRleHRNYXJrZXIpO1xuXG4gIC8vIENyZWF0ZSBhIG1hcmtlciwgd2lyZSBpdCB1cCB0byB0aGUgcmlnaHQgbGluZXMsIGFuZFxuICBmdW5jdGlvbiBtYXJrVGV4dChkb2MsIGZyb20sIHRvLCBvcHRpb25zLCB0eXBlKSB7XG4gICAgLy8gU2hhcmVkIG1hcmtlcnMgKGFjcm9zcyBsaW5rZWQgZG9jdW1lbnRzKSBhcmUgaGFuZGxlZCBzZXBhcmF0ZWx5XG4gICAgLy8gKG1hcmtUZXh0U2hhcmVkIHdpbGwgY2FsbCBvdXQgdG8gdGhpcyBhZ2Fpbiwgb25jZSBwZXJcbiAgICAvLyBkb2N1bWVudCkuXG4gICAgaWYgKG9wdGlvbnMgJiYgb3B0aW9ucy5zaGFyZWQpIHsgcmV0dXJuIG1hcmtUZXh0U2hhcmVkKGRvYywgZnJvbSwgdG8sIG9wdGlvbnMsIHR5cGUpIH1cbiAgICAvLyBFbnN1cmUgd2UgYXJlIGluIGFuIG9wZXJhdGlvbi5cbiAgICBpZiAoZG9jLmNtICYmICFkb2MuY20uY3VyT3ApIHsgcmV0dXJuIG9wZXJhdGlvbihkb2MuY20sIG1hcmtUZXh0KShkb2MsIGZyb20sIHRvLCBvcHRpb25zLCB0eXBlKSB9XG5cbiAgICB2YXIgbWFya2VyID0gbmV3IFRleHRNYXJrZXIoZG9jLCB0eXBlKSwgZGlmZiA9IGNtcChmcm9tLCB0byk7XG4gICAgaWYgKG9wdGlvbnMpIHsgY29weU9iaihvcHRpb25zLCBtYXJrZXIsIGZhbHNlKTsgfVxuICAgIC8vIERvbid0IGNvbm5lY3QgZW1wdHkgbWFya2VycyB1bmxlc3MgY2xlYXJXaGVuRW1wdHkgaXMgZmFsc2VcbiAgICBpZiAoZGlmZiA+IDAgfHwgZGlmZiA9PSAwICYmIG1hcmtlci5jbGVhcldoZW5FbXB0eSAhPT0gZmFsc2UpXG4gICAgICB7IHJldHVybiBtYXJrZXIgfVxuICAgIGlmIChtYXJrZXIucmVwbGFjZWRXaXRoKSB7XG4gICAgICAvLyBTaG93aW5nIHVwIGFzIGEgd2lkZ2V0IGltcGxpZXMgY29sbGFwc2VkICh3aWRnZXQgcmVwbGFjZXMgdGV4dClcbiAgICAgIG1hcmtlci5jb2xsYXBzZWQgPSB0cnVlO1xuICAgICAgbWFya2VyLndpZGdldE5vZGUgPSBlbHRQKFwic3BhblwiLCBbbWFya2VyLnJlcGxhY2VkV2l0aF0sIFwiQ29kZU1pcnJvci13aWRnZXRcIik7XG4gICAgICBpZiAoIW9wdGlvbnMuaGFuZGxlTW91c2VFdmVudHMpIHsgbWFya2VyLndpZGdldE5vZGUuc2V0QXR0cmlidXRlKFwiY20taWdub3JlLWV2ZW50c1wiLCBcInRydWVcIik7IH1cbiAgICAgIGlmIChvcHRpb25zLmluc2VydExlZnQpIHsgbWFya2VyLndpZGdldE5vZGUuaW5zZXJ0TGVmdCA9IHRydWU7IH1cbiAgICB9XG4gICAgaWYgKG1hcmtlci5jb2xsYXBzZWQpIHtcbiAgICAgIGlmIChjb25mbGljdGluZ0NvbGxhcHNlZFJhbmdlKGRvYywgZnJvbS5saW5lLCBmcm9tLCB0bywgbWFya2VyKSB8fFxuICAgICAgICAgIGZyb20ubGluZSAhPSB0by5saW5lICYmIGNvbmZsaWN0aW5nQ29sbGFwc2VkUmFuZ2UoZG9jLCB0by5saW5lLCBmcm9tLCB0bywgbWFya2VyKSlcbiAgICAgICAgeyB0aHJvdyBuZXcgRXJyb3IoXCJJbnNlcnRpbmcgY29sbGFwc2VkIG1hcmtlciBwYXJ0aWFsbHkgb3ZlcmxhcHBpbmcgYW4gZXhpc3Rpbmcgb25lXCIpIH1cbiAgICAgIHNlZUNvbGxhcHNlZFNwYW5zKCk7XG4gICAgfVxuXG4gICAgaWYgKG1hcmtlci5hZGRUb0hpc3RvcnkpXG4gICAgICB7IGFkZENoYW5nZVRvSGlzdG9yeShkb2MsIHtmcm9tOiBmcm9tLCB0bzogdG8sIG9yaWdpbjogXCJtYXJrVGV4dFwifSwgZG9jLnNlbCwgTmFOKTsgfVxuXG4gICAgdmFyIGN1ckxpbmUgPSBmcm9tLmxpbmUsIGNtID0gZG9jLmNtLCB1cGRhdGVNYXhMaW5lO1xuICAgIGRvYy5pdGVyKGN1ckxpbmUsIHRvLmxpbmUgKyAxLCBmdW5jdGlvbiAobGluZSkge1xuICAgICAgaWYgKGNtICYmIG1hcmtlci5jb2xsYXBzZWQgJiYgIWNtLm9wdGlvbnMubGluZVdyYXBwaW5nICYmIHZpc3VhbExpbmUobGluZSkgPT0gY20uZGlzcGxheS5tYXhMaW5lKVxuICAgICAgICB7IHVwZGF0ZU1heExpbmUgPSB0cnVlOyB9XG4gICAgICBpZiAobWFya2VyLmNvbGxhcHNlZCAmJiBjdXJMaW5lICE9IGZyb20ubGluZSkgeyB1cGRhdGVMaW5lSGVpZ2h0KGxpbmUsIDApOyB9XG4gICAgICBhZGRNYXJrZWRTcGFuKGxpbmUsIG5ldyBNYXJrZWRTcGFuKG1hcmtlcixcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY3VyTGluZSA9PSBmcm9tLmxpbmUgPyBmcm9tLmNoIDogbnVsbCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY3VyTGluZSA9PSB0by5saW5lID8gdG8uY2ggOiBudWxsKSwgZG9jLmNtICYmIGRvYy5jbS5jdXJPcCk7XG4gICAgICArK2N1ckxpbmU7XG4gICAgfSk7XG4gICAgLy8gbGluZUlzSGlkZGVuIGRlcGVuZHMgb24gdGhlIHByZXNlbmNlIG9mIHRoZSBzcGFucywgc28gbmVlZHMgYSBzZWNvbmQgcGFzc1xuICAgIGlmIChtYXJrZXIuY29sbGFwc2VkKSB7IGRvYy5pdGVyKGZyb20ubGluZSwgdG8ubGluZSArIDEsIGZ1bmN0aW9uIChsaW5lKSB7XG4gICAgICBpZiAobGluZUlzSGlkZGVuKGRvYywgbGluZSkpIHsgdXBkYXRlTGluZUhlaWdodChsaW5lLCAwKTsgfVxuICAgIH0pOyB9XG5cbiAgICBpZiAobWFya2VyLmNsZWFyT25FbnRlcikgeyBvbihtYXJrZXIsIFwiYmVmb3JlQ3Vyc29yRW50ZXJcIiwgZnVuY3Rpb24gKCkgeyByZXR1cm4gbWFya2VyLmNsZWFyKCk7IH0pOyB9XG5cbiAgICBpZiAobWFya2VyLnJlYWRPbmx5KSB7XG4gICAgICBzZWVSZWFkT25seVNwYW5zKCk7XG4gICAgICBpZiAoZG9jLmhpc3RvcnkuZG9uZS5sZW5ndGggfHwgZG9jLmhpc3RvcnkudW5kb25lLmxlbmd0aClcbiAgICAgICAgeyBkb2MuY2xlYXJIaXN0b3J5KCk7IH1cbiAgICB9XG4gICAgaWYgKG1hcmtlci5jb2xsYXBzZWQpIHtcbiAgICAgIG1hcmtlci5pZCA9ICsrbmV4dE1hcmtlcklkO1xuICAgICAgbWFya2VyLmF0b21pYyA9IHRydWU7XG4gICAgfVxuICAgIGlmIChjbSkge1xuICAgICAgLy8gU3luYyBlZGl0b3Igc3RhdGVcbiAgICAgIGlmICh1cGRhdGVNYXhMaW5lKSB7IGNtLmN1ck9wLnVwZGF0ZU1heExpbmUgPSB0cnVlOyB9XG4gICAgICBpZiAobWFya2VyLmNvbGxhcHNlZClcbiAgICAgICAgeyByZWdDaGFuZ2UoY20sIGZyb20ubGluZSwgdG8ubGluZSArIDEpOyB9XG4gICAgICBlbHNlIGlmIChtYXJrZXIuY2xhc3NOYW1lIHx8IG1hcmtlci5zdGFydFN0eWxlIHx8IG1hcmtlci5lbmRTdHlsZSB8fCBtYXJrZXIuY3NzIHx8XG4gICAgICAgICAgICAgICBtYXJrZXIuYXR0cmlidXRlcyB8fCBtYXJrZXIudGl0bGUpXG4gICAgICAgIHsgZm9yICh2YXIgaSA9IGZyb20ubGluZTsgaSA8PSB0by5saW5lOyBpKyspIHsgcmVnTGluZUNoYW5nZShjbSwgaSwgXCJ0ZXh0XCIpOyB9IH1cbiAgICAgIGlmIChtYXJrZXIuYXRvbWljKSB7IHJlQ2hlY2tTZWxlY3Rpb24oY20uZG9jKTsgfVxuICAgICAgc2lnbmFsTGF0ZXIoY20sIFwibWFya2VyQWRkZWRcIiwgY20sIG1hcmtlcik7XG4gICAgfVxuICAgIHJldHVybiBtYXJrZXJcbiAgfVxuXG4gIC8vIFNIQVJFRCBURVhUTUFSS0VSU1xuXG4gIC8vIEEgc2hhcmVkIG1hcmtlciBzcGFucyBtdWx0aXBsZSBsaW5rZWQgZG9jdW1lbnRzLiBJdCBpc1xuICAvLyBpbXBsZW1lbnRlZCBhcyBhIG1ldGEtbWFya2VyLW9iamVjdCBjb250cm9sbGluZyBtdWx0aXBsZSBub3JtYWxcbiAgLy8gbWFya2Vycy5cbiAgdmFyIFNoYXJlZFRleHRNYXJrZXIgPSBmdW5jdGlvbihtYXJrZXJzLCBwcmltYXJ5KSB7XG4gICAgdGhpcy5tYXJrZXJzID0gbWFya2VycztcbiAgICB0aGlzLnByaW1hcnkgPSBwcmltYXJ5O1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbWFya2Vycy5sZW5ndGg7ICsraSlcbiAgICAgIHsgbWFya2Vyc1tpXS5wYXJlbnQgPSB0aGlzOyB9XG4gIH07XG5cbiAgU2hhcmVkVGV4dE1hcmtlci5wcm90b3R5cGUuY2xlYXIgPSBmdW5jdGlvbiAoKSB7XG4gICAgaWYgKHRoaXMuZXhwbGljaXRseUNsZWFyZWQpIHsgcmV0dXJuIH1cbiAgICB0aGlzLmV4cGxpY2l0bHlDbGVhcmVkID0gdHJ1ZTtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IHRoaXMubWFya2Vycy5sZW5ndGg7ICsraSlcbiAgICAgIHsgdGhpcy5tYXJrZXJzW2ldLmNsZWFyKCk7IH1cbiAgICBzaWduYWxMYXRlcih0aGlzLCBcImNsZWFyXCIpO1xuICB9O1xuXG4gIFNoYXJlZFRleHRNYXJrZXIucHJvdG90eXBlLmZpbmQgPSBmdW5jdGlvbiAoc2lkZSwgbGluZU9iaikge1xuICAgIHJldHVybiB0aGlzLnByaW1hcnkuZmluZChzaWRlLCBsaW5lT2JqKVxuICB9O1xuICBldmVudE1peGluKFNoYXJlZFRleHRNYXJrZXIpO1xuXG4gIGZ1bmN0aW9uIG1hcmtUZXh0U2hhcmVkKGRvYywgZnJvbSwgdG8sIG9wdGlvbnMsIHR5cGUpIHtcbiAgICBvcHRpb25zID0gY29weU9iaihvcHRpb25zKTtcbiAgICBvcHRpb25zLnNoYXJlZCA9IGZhbHNlO1xuICAgIHZhciBtYXJrZXJzID0gW21hcmtUZXh0KGRvYywgZnJvbSwgdG8sIG9wdGlvbnMsIHR5cGUpXSwgcHJpbWFyeSA9IG1hcmtlcnNbMF07XG4gICAgdmFyIHdpZGdldCA9IG9wdGlvbnMud2lkZ2V0Tm9kZTtcbiAgICBsaW5rZWREb2NzKGRvYywgZnVuY3Rpb24gKGRvYykge1xuICAgICAgaWYgKHdpZGdldCkgeyBvcHRpb25zLndpZGdldE5vZGUgPSB3aWRnZXQuY2xvbmVOb2RlKHRydWUpOyB9XG4gICAgICBtYXJrZXJzLnB1c2gobWFya1RleHQoZG9jLCBjbGlwUG9zKGRvYywgZnJvbSksIGNsaXBQb3MoZG9jLCB0byksIG9wdGlvbnMsIHR5cGUpKTtcbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgZG9jLmxpbmtlZC5sZW5ndGg7ICsraSlcbiAgICAgICAgeyBpZiAoZG9jLmxpbmtlZFtpXS5pc1BhcmVudCkgeyByZXR1cm4gfSB9XG4gICAgICBwcmltYXJ5ID0gbHN0KG1hcmtlcnMpO1xuICAgIH0pO1xuICAgIHJldHVybiBuZXcgU2hhcmVkVGV4dE1hcmtlcihtYXJrZXJzLCBwcmltYXJ5KVxuICB9XG5cbiAgZnVuY3Rpb24gZmluZFNoYXJlZE1hcmtlcnMoZG9jKSB7XG4gICAgcmV0dXJuIGRvYy5maW5kTWFya3MoUG9zKGRvYy5maXJzdCwgMCksIGRvYy5jbGlwUG9zKFBvcyhkb2MubGFzdExpbmUoKSkpLCBmdW5jdGlvbiAobSkgeyByZXR1cm4gbS5wYXJlbnQ7IH0pXG4gIH1cblxuICBmdW5jdGlvbiBjb3B5U2hhcmVkTWFya2Vycyhkb2MsIG1hcmtlcnMpIHtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IG1hcmtlcnMubGVuZ3RoOyBpKyspIHtcbiAgICAgIHZhciBtYXJrZXIgPSBtYXJrZXJzW2ldLCBwb3MgPSBtYXJrZXIuZmluZCgpO1xuICAgICAgdmFyIG1Gcm9tID0gZG9jLmNsaXBQb3MocG9zLmZyb20pLCBtVG8gPSBkb2MuY2xpcFBvcyhwb3MudG8pO1xuICAgICAgaWYgKGNtcChtRnJvbSwgbVRvKSkge1xuICAgICAgICB2YXIgc3ViTWFyayA9IG1hcmtUZXh0KGRvYywgbUZyb20sIG1UbywgbWFya2VyLnByaW1hcnksIG1hcmtlci5wcmltYXJ5LnR5cGUpO1xuICAgICAgICBtYXJrZXIubWFya2Vycy5wdXNoKHN1Yk1hcmspO1xuICAgICAgICBzdWJNYXJrLnBhcmVudCA9IG1hcmtlcjtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICBmdW5jdGlvbiBkZXRhY2hTaGFyZWRNYXJrZXJzKG1hcmtlcnMpIHtcbiAgICB2YXIgbG9vcCA9IGZ1bmN0aW9uICggaSApIHtcbiAgICAgIHZhciBtYXJrZXIgPSBtYXJrZXJzW2ldLCBsaW5rZWQgPSBbbWFya2VyLnByaW1hcnkuZG9jXTtcbiAgICAgIGxpbmtlZERvY3MobWFya2VyLnByaW1hcnkuZG9jLCBmdW5jdGlvbiAoZCkgeyByZXR1cm4gbGlua2VkLnB1c2goZCk7IH0pO1xuICAgICAgZm9yICh2YXIgaiA9IDA7IGogPCBtYXJrZXIubWFya2Vycy5sZW5ndGg7IGorKykge1xuICAgICAgICB2YXIgc3ViTWFya2VyID0gbWFya2VyLm1hcmtlcnNbal07XG4gICAgICAgIGlmIChpbmRleE9mKGxpbmtlZCwgc3ViTWFya2VyLmRvYykgPT0gLTEpIHtcbiAgICAgICAgICBzdWJNYXJrZXIucGFyZW50ID0gbnVsbDtcbiAgICAgICAgICBtYXJrZXIubWFya2Vycy5zcGxpY2Uoai0tLCAxKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH07XG5cbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IG1hcmtlcnMubGVuZ3RoOyBpKyspIGxvb3AoIGkgKTtcbiAgfVxuXG4gIHZhciBuZXh0RG9jSWQgPSAwO1xuICB2YXIgRG9jID0gZnVuY3Rpb24odGV4dCwgbW9kZSwgZmlyc3RMaW5lLCBsaW5lU2VwLCBkaXJlY3Rpb24pIHtcbiAgICBpZiAoISh0aGlzIGluc3RhbmNlb2YgRG9jKSkgeyByZXR1cm4gbmV3IERvYyh0ZXh0LCBtb2RlLCBmaXJzdExpbmUsIGxpbmVTZXAsIGRpcmVjdGlvbikgfVxuICAgIGlmIChmaXJzdExpbmUgPT0gbnVsbCkgeyBmaXJzdExpbmUgPSAwOyB9XG5cbiAgICBCcmFuY2hDaHVuay5jYWxsKHRoaXMsIFtuZXcgTGVhZkNodW5rKFtuZXcgTGluZShcIlwiLCBudWxsKV0pXSk7XG4gICAgdGhpcy5maXJzdCA9IGZpcnN0TGluZTtcbiAgICB0aGlzLnNjcm9sbFRvcCA9IHRoaXMuc2Nyb2xsTGVmdCA9IDA7XG4gICAgdGhpcy5jYW50RWRpdCA9IGZhbHNlO1xuICAgIHRoaXMuY2xlYW5HZW5lcmF0aW9uID0gMTtcbiAgICB0aGlzLm1vZGVGcm9udGllciA9IHRoaXMuaGlnaGxpZ2h0RnJvbnRpZXIgPSBmaXJzdExpbmU7XG4gICAgdmFyIHN0YXJ0ID0gUG9zKGZpcnN0TGluZSwgMCk7XG4gICAgdGhpcy5zZWwgPSBzaW1wbGVTZWxlY3Rpb24oc3RhcnQpO1xuICAgIHRoaXMuaGlzdG9yeSA9IG5ldyBIaXN0b3J5KG51bGwpO1xuICAgIHRoaXMuaWQgPSArK25leHREb2NJZDtcbiAgICB0aGlzLm1vZGVPcHRpb24gPSBtb2RlO1xuICAgIHRoaXMubGluZVNlcCA9IGxpbmVTZXA7XG4gICAgdGhpcy5kaXJlY3Rpb24gPSAoZGlyZWN0aW9uID09IFwicnRsXCIpID8gXCJydGxcIiA6IFwibHRyXCI7XG4gICAgdGhpcy5leHRlbmQgPSBmYWxzZTtcblxuICAgIGlmICh0eXBlb2YgdGV4dCA9PSBcInN0cmluZ1wiKSB7IHRleHQgPSB0aGlzLnNwbGl0TGluZXModGV4dCk7IH1cbiAgICB1cGRhdGVEb2ModGhpcywge2Zyb206IHN0YXJ0LCB0bzogc3RhcnQsIHRleHQ6IHRleHR9KTtcbiAgICBzZXRTZWxlY3Rpb24odGhpcywgc2ltcGxlU2VsZWN0aW9uKHN0YXJ0KSwgc2VsX2RvbnRTY3JvbGwpO1xuICB9O1xuXG4gIERvYy5wcm90b3R5cGUgPSBjcmVhdGVPYmooQnJhbmNoQ2h1bmsucHJvdG90eXBlLCB7XG4gICAgY29uc3RydWN0b3I6IERvYyxcbiAgICAvLyBJdGVyYXRlIG92ZXIgdGhlIGRvY3VtZW50LiBTdXBwb3J0cyB0d28gZm9ybXMgLS0gd2l0aCBvbmx5IG9uZVxuICAgIC8vIGFyZ3VtZW50LCBpdCBjYWxscyB0aGF0IGZvciBlYWNoIGxpbmUgaW4gdGhlIGRvY3VtZW50LiBXaXRoXG4gICAgLy8gdGhyZWUsIGl0IGl0ZXJhdGVzIG92ZXIgdGhlIHJhbmdlIGdpdmVuIGJ5IHRoZSBmaXJzdCB0d28gKHdpdGhcbiAgICAvLyB0aGUgc2Vjb25kIGJlaW5nIG5vbi1pbmNsdXNpdmUpLlxuICAgIGl0ZXI6IGZ1bmN0aW9uKGZyb20sIHRvLCBvcCkge1xuICAgICAgaWYgKG9wKSB7IHRoaXMuaXRlck4oZnJvbSAtIHRoaXMuZmlyc3QsIHRvIC0gZnJvbSwgb3ApOyB9XG4gICAgICBlbHNlIHsgdGhpcy5pdGVyTih0aGlzLmZpcnN0LCB0aGlzLmZpcnN0ICsgdGhpcy5zaXplLCBmcm9tKTsgfVxuICAgIH0sXG5cbiAgICAvLyBOb24tcHVibGljIGludGVyZmFjZSBmb3IgYWRkaW5nIGFuZCByZW1vdmluZyBsaW5lcy5cbiAgICBpbnNlcnQ6IGZ1bmN0aW9uKGF0LCBsaW5lcykge1xuICAgICAgdmFyIGhlaWdodCA9IDA7XG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGxpbmVzLmxlbmd0aDsgKytpKSB7IGhlaWdodCArPSBsaW5lc1tpXS5oZWlnaHQ7IH1cbiAgICAgIHRoaXMuaW5zZXJ0SW5uZXIoYXQgLSB0aGlzLmZpcnN0LCBsaW5lcywgaGVpZ2h0KTtcbiAgICB9LFxuICAgIHJlbW92ZTogZnVuY3Rpb24oYXQsIG4pIHsgdGhpcy5yZW1vdmVJbm5lcihhdCAtIHRoaXMuZmlyc3QsIG4pOyB9LFxuXG4gICAgLy8gRnJvbSBoZXJlLCB0aGUgbWV0aG9kcyBhcmUgcGFydCBvZiB0aGUgcHVibGljIGludGVyZmFjZS4gTW9zdFxuICAgIC8vIGFyZSBhbHNvIGF2YWlsYWJsZSBmcm9tIENvZGVNaXJyb3IgKGVkaXRvcikgaW5zdGFuY2VzLlxuXG4gICAgZ2V0VmFsdWU6IGZ1bmN0aW9uKGxpbmVTZXApIHtcbiAgICAgIHZhciBsaW5lcyA9IGdldExpbmVzKHRoaXMsIHRoaXMuZmlyc3QsIHRoaXMuZmlyc3QgKyB0aGlzLnNpemUpO1xuICAgICAgaWYgKGxpbmVTZXAgPT09IGZhbHNlKSB7IHJldHVybiBsaW5lcyB9XG4gICAgICByZXR1cm4gbGluZXMuam9pbihsaW5lU2VwIHx8IHRoaXMubGluZVNlcGFyYXRvcigpKVxuICAgIH0sXG4gICAgc2V0VmFsdWU6IGRvY01ldGhvZE9wKGZ1bmN0aW9uKGNvZGUpIHtcbiAgICAgIHZhciB0b3AgPSBQb3ModGhpcy5maXJzdCwgMCksIGxhc3QgPSB0aGlzLmZpcnN0ICsgdGhpcy5zaXplIC0gMTtcbiAgICAgIG1ha2VDaGFuZ2UodGhpcywge2Zyb206IHRvcCwgdG86IFBvcyhsYXN0LCBnZXRMaW5lKHRoaXMsIGxhc3QpLnRleHQubGVuZ3RoKSxcbiAgICAgICAgICAgICAgICAgICAgICAgIHRleHQ6IHRoaXMuc3BsaXRMaW5lcyhjb2RlKSwgb3JpZ2luOiBcInNldFZhbHVlXCIsIGZ1bGw6IHRydWV9LCB0cnVlKTtcbiAgICAgIGlmICh0aGlzLmNtKSB7IHNjcm9sbFRvQ29vcmRzKHRoaXMuY20sIDAsIDApOyB9XG4gICAgICBzZXRTZWxlY3Rpb24odGhpcywgc2ltcGxlU2VsZWN0aW9uKHRvcCksIHNlbF9kb250U2Nyb2xsKTtcbiAgICB9KSxcbiAgICByZXBsYWNlUmFuZ2U6IGZ1bmN0aW9uKGNvZGUsIGZyb20sIHRvLCBvcmlnaW4pIHtcbiAgICAgIGZyb20gPSBjbGlwUG9zKHRoaXMsIGZyb20pO1xuICAgICAgdG8gPSB0byA/IGNsaXBQb3ModGhpcywgdG8pIDogZnJvbTtcbiAgICAgIHJlcGxhY2VSYW5nZSh0aGlzLCBjb2RlLCBmcm9tLCB0bywgb3JpZ2luKTtcbiAgICB9LFxuICAgIGdldFJhbmdlOiBmdW5jdGlvbihmcm9tLCB0bywgbGluZVNlcCkge1xuICAgICAgdmFyIGxpbmVzID0gZ2V0QmV0d2Vlbih0aGlzLCBjbGlwUG9zKHRoaXMsIGZyb20pLCBjbGlwUG9zKHRoaXMsIHRvKSk7XG4gICAgICBpZiAobGluZVNlcCA9PT0gZmFsc2UpIHsgcmV0dXJuIGxpbmVzIH1cbiAgICAgIGlmIChsaW5lU2VwID09PSAnJykgeyByZXR1cm4gbGluZXMuam9pbignJykgfVxuICAgICAgcmV0dXJuIGxpbmVzLmpvaW4obGluZVNlcCB8fCB0aGlzLmxpbmVTZXBhcmF0b3IoKSlcbiAgICB9LFxuXG4gICAgZ2V0TGluZTogZnVuY3Rpb24obGluZSkge3ZhciBsID0gdGhpcy5nZXRMaW5lSGFuZGxlKGxpbmUpOyByZXR1cm4gbCAmJiBsLnRleHR9LFxuXG4gICAgZ2V0TGluZUhhbmRsZTogZnVuY3Rpb24obGluZSkge2lmIChpc0xpbmUodGhpcywgbGluZSkpIHsgcmV0dXJuIGdldExpbmUodGhpcywgbGluZSkgfX0sXG4gICAgZ2V0TGluZU51bWJlcjogZnVuY3Rpb24obGluZSkge3JldHVybiBsaW5lTm8obGluZSl9LFxuXG4gICAgZ2V0TGluZUhhbmRsZVZpc3VhbFN0YXJ0OiBmdW5jdGlvbihsaW5lKSB7XG4gICAgICBpZiAodHlwZW9mIGxpbmUgPT0gXCJudW1iZXJcIikgeyBsaW5lID0gZ2V0TGluZSh0aGlzLCBsaW5lKTsgfVxuICAgICAgcmV0dXJuIHZpc3VhbExpbmUobGluZSlcbiAgICB9LFxuXG4gICAgbGluZUNvdW50OiBmdW5jdGlvbigpIHtyZXR1cm4gdGhpcy5zaXplfSxcbiAgICBmaXJzdExpbmU6IGZ1bmN0aW9uKCkge3JldHVybiB0aGlzLmZpcnN0fSxcbiAgICBsYXN0TGluZTogZnVuY3Rpb24oKSB7cmV0dXJuIHRoaXMuZmlyc3QgKyB0aGlzLnNpemUgLSAxfSxcblxuICAgIGNsaXBQb3M6IGZ1bmN0aW9uKHBvcykge3JldHVybiBjbGlwUG9zKHRoaXMsIHBvcyl9LFxuXG4gICAgZ2V0Q3Vyc29yOiBmdW5jdGlvbihzdGFydCkge1xuICAgICAgdmFyIHJhbmdlID0gdGhpcy5zZWwucHJpbWFyeSgpLCBwb3M7XG4gICAgICBpZiAoc3RhcnQgPT0gbnVsbCB8fCBzdGFydCA9PSBcImhlYWRcIikgeyBwb3MgPSByYW5nZS5oZWFkOyB9XG4gICAgICBlbHNlIGlmIChzdGFydCA9PSBcImFuY2hvclwiKSB7IHBvcyA9IHJhbmdlLmFuY2hvcjsgfVxuICAgICAgZWxzZSBpZiAoc3RhcnQgPT0gXCJlbmRcIiB8fCBzdGFydCA9PSBcInRvXCIgfHwgc3RhcnQgPT09IGZhbHNlKSB7IHBvcyA9IHJhbmdlLnRvKCk7IH1cbiAgICAgIGVsc2UgeyBwb3MgPSByYW5nZS5mcm9tKCk7IH1cbiAgICAgIHJldHVybiBwb3NcbiAgICB9LFxuICAgIGxpc3RTZWxlY3Rpb25zOiBmdW5jdGlvbigpIHsgcmV0dXJuIHRoaXMuc2VsLnJhbmdlcyB9LFxuICAgIHNvbWV0aGluZ1NlbGVjdGVkOiBmdW5jdGlvbigpIHtyZXR1cm4gdGhpcy5zZWwuc29tZXRoaW5nU2VsZWN0ZWQoKX0sXG5cbiAgICBzZXRDdXJzb3I6IGRvY01ldGhvZE9wKGZ1bmN0aW9uKGxpbmUsIGNoLCBvcHRpb25zKSB7XG4gICAgICBzZXRTaW1wbGVTZWxlY3Rpb24odGhpcywgY2xpcFBvcyh0aGlzLCB0eXBlb2YgbGluZSA9PSBcIm51bWJlclwiID8gUG9zKGxpbmUsIGNoIHx8IDApIDogbGluZSksIG51bGwsIG9wdGlvbnMpO1xuICAgIH0pLFxuICAgIHNldFNlbGVjdGlvbjogZG9jTWV0aG9kT3AoZnVuY3Rpb24oYW5jaG9yLCBoZWFkLCBvcHRpb25zKSB7XG4gICAgICBzZXRTaW1wbGVTZWxlY3Rpb24odGhpcywgY2xpcFBvcyh0aGlzLCBhbmNob3IpLCBjbGlwUG9zKHRoaXMsIGhlYWQgfHwgYW5jaG9yKSwgb3B0aW9ucyk7XG4gICAgfSksXG4gICAgZXh0ZW5kU2VsZWN0aW9uOiBkb2NNZXRob2RPcChmdW5jdGlvbihoZWFkLCBvdGhlciwgb3B0aW9ucykge1xuICAgICAgZXh0ZW5kU2VsZWN0aW9uKHRoaXMsIGNsaXBQb3ModGhpcywgaGVhZCksIG90aGVyICYmIGNsaXBQb3ModGhpcywgb3RoZXIpLCBvcHRpb25zKTtcbiAgICB9KSxcbiAgICBleHRlbmRTZWxlY3Rpb25zOiBkb2NNZXRob2RPcChmdW5jdGlvbihoZWFkcywgb3B0aW9ucykge1xuICAgICAgZXh0ZW5kU2VsZWN0aW9ucyh0aGlzLCBjbGlwUG9zQXJyYXkodGhpcywgaGVhZHMpLCBvcHRpb25zKTtcbiAgICB9KSxcbiAgICBleHRlbmRTZWxlY3Rpb25zQnk6IGRvY01ldGhvZE9wKGZ1bmN0aW9uKGYsIG9wdGlvbnMpIHtcbiAgICAgIHZhciBoZWFkcyA9IG1hcCh0aGlzLnNlbC5yYW5nZXMsIGYpO1xuICAgICAgZXh0ZW5kU2VsZWN0aW9ucyh0aGlzLCBjbGlwUG9zQXJyYXkodGhpcywgaGVhZHMpLCBvcHRpb25zKTtcbiAgICB9KSxcbiAgICBzZXRTZWxlY3Rpb25zOiBkb2NNZXRob2RPcChmdW5jdGlvbihyYW5nZXMsIHByaW1hcnksIG9wdGlvbnMpIHtcbiAgICAgIGlmICghcmFuZ2VzLmxlbmd0aCkgeyByZXR1cm4gfVxuICAgICAgdmFyIG91dCA9IFtdO1xuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCByYW5nZXMubGVuZ3RoOyBpKyspXG4gICAgICAgIHsgb3V0W2ldID0gbmV3IFJhbmdlKGNsaXBQb3ModGhpcywgcmFuZ2VzW2ldLmFuY2hvciksXG4gICAgICAgICAgICAgICAgICAgICAgICAgICBjbGlwUG9zKHRoaXMsIHJhbmdlc1tpXS5oZWFkIHx8IHJhbmdlc1tpXS5hbmNob3IpKTsgfVxuICAgICAgaWYgKHByaW1hcnkgPT0gbnVsbCkgeyBwcmltYXJ5ID0gTWF0aC5taW4ocmFuZ2VzLmxlbmd0aCAtIDEsIHRoaXMuc2VsLnByaW1JbmRleCk7IH1cbiAgICAgIHNldFNlbGVjdGlvbih0aGlzLCBub3JtYWxpemVTZWxlY3Rpb24odGhpcy5jbSwgb3V0LCBwcmltYXJ5KSwgb3B0aW9ucyk7XG4gICAgfSksXG4gICAgYWRkU2VsZWN0aW9uOiBkb2NNZXRob2RPcChmdW5jdGlvbihhbmNob3IsIGhlYWQsIG9wdGlvbnMpIHtcbiAgICAgIHZhciByYW5nZXMgPSB0aGlzLnNlbC5yYW5nZXMuc2xpY2UoMCk7XG4gICAgICByYW5nZXMucHVzaChuZXcgUmFuZ2UoY2xpcFBvcyh0aGlzLCBhbmNob3IpLCBjbGlwUG9zKHRoaXMsIGhlYWQgfHwgYW5jaG9yKSkpO1xuICAgICAgc2V0U2VsZWN0aW9uKHRoaXMsIG5vcm1hbGl6ZVNlbGVjdGlvbih0aGlzLmNtLCByYW5nZXMsIHJhbmdlcy5sZW5ndGggLSAxKSwgb3B0aW9ucyk7XG4gICAgfSksXG5cbiAgICBnZXRTZWxlY3Rpb246IGZ1bmN0aW9uKGxpbmVTZXApIHtcbiAgICAgIHZhciByYW5nZXMgPSB0aGlzLnNlbC5yYW5nZXMsIGxpbmVzO1xuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCByYW5nZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgdmFyIHNlbCA9IGdldEJldHdlZW4odGhpcywgcmFuZ2VzW2ldLmZyb20oKSwgcmFuZ2VzW2ldLnRvKCkpO1xuICAgICAgICBsaW5lcyA9IGxpbmVzID8gbGluZXMuY29uY2F0KHNlbCkgOiBzZWw7XG4gICAgICB9XG4gICAgICBpZiAobGluZVNlcCA9PT0gZmFsc2UpIHsgcmV0dXJuIGxpbmVzIH1cbiAgICAgIGVsc2UgeyByZXR1cm4gbGluZXMuam9pbihsaW5lU2VwIHx8IHRoaXMubGluZVNlcGFyYXRvcigpKSB9XG4gICAgfSxcbiAgICBnZXRTZWxlY3Rpb25zOiBmdW5jdGlvbihsaW5lU2VwKSB7XG4gICAgICB2YXIgcGFydHMgPSBbXSwgcmFuZ2VzID0gdGhpcy5zZWwucmFuZ2VzO1xuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCByYW5nZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgdmFyIHNlbCA9IGdldEJldHdlZW4odGhpcywgcmFuZ2VzW2ldLmZyb20oKSwgcmFuZ2VzW2ldLnRvKCkpO1xuICAgICAgICBpZiAobGluZVNlcCAhPT0gZmFsc2UpIHsgc2VsID0gc2VsLmpvaW4obGluZVNlcCB8fCB0aGlzLmxpbmVTZXBhcmF0b3IoKSk7IH1cbiAgICAgICAgcGFydHNbaV0gPSBzZWw7XG4gICAgICB9XG4gICAgICByZXR1cm4gcGFydHNcbiAgICB9LFxuICAgIHJlcGxhY2VTZWxlY3Rpb246IGZ1bmN0aW9uKGNvZGUsIGNvbGxhcHNlLCBvcmlnaW4pIHtcbiAgICAgIHZhciBkdXAgPSBbXTtcbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdGhpcy5zZWwucmFuZ2VzLmxlbmd0aDsgaSsrKVxuICAgICAgICB7IGR1cFtpXSA9IGNvZGU7IH1cbiAgICAgIHRoaXMucmVwbGFjZVNlbGVjdGlvbnMoZHVwLCBjb2xsYXBzZSwgb3JpZ2luIHx8IFwiK2lucHV0XCIpO1xuICAgIH0sXG4gICAgcmVwbGFjZVNlbGVjdGlvbnM6IGRvY01ldGhvZE9wKGZ1bmN0aW9uKGNvZGUsIGNvbGxhcHNlLCBvcmlnaW4pIHtcbiAgICAgIHZhciBjaGFuZ2VzID0gW10sIHNlbCA9IHRoaXMuc2VsO1xuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBzZWwucmFuZ2VzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIHZhciByYW5nZSA9IHNlbC5yYW5nZXNbaV07XG4gICAgICAgIGNoYW5nZXNbaV0gPSB7ZnJvbTogcmFuZ2UuZnJvbSgpLCB0bzogcmFuZ2UudG8oKSwgdGV4dDogdGhpcy5zcGxpdExpbmVzKGNvZGVbaV0pLCBvcmlnaW46IG9yaWdpbn07XG4gICAgICB9XG4gICAgICB2YXIgbmV3U2VsID0gY29sbGFwc2UgJiYgY29sbGFwc2UgIT0gXCJlbmRcIiAmJiBjb21wdXRlUmVwbGFjZWRTZWwodGhpcywgY2hhbmdlcywgY29sbGFwc2UpO1xuICAgICAgZm9yICh2YXIgaSQxID0gY2hhbmdlcy5sZW5ndGggLSAxOyBpJDEgPj0gMDsgaSQxLS0pXG4gICAgICAgIHsgbWFrZUNoYW5nZSh0aGlzLCBjaGFuZ2VzW2kkMV0pOyB9XG4gICAgICBpZiAobmV3U2VsKSB7IHNldFNlbGVjdGlvblJlcGxhY2VIaXN0b3J5KHRoaXMsIG5ld1NlbCk7IH1cbiAgICAgIGVsc2UgaWYgKHRoaXMuY20pIHsgZW5zdXJlQ3Vyc29yVmlzaWJsZSh0aGlzLmNtKTsgfVxuICAgIH0pLFxuICAgIHVuZG86IGRvY01ldGhvZE9wKGZ1bmN0aW9uKCkge21ha2VDaGFuZ2VGcm9tSGlzdG9yeSh0aGlzLCBcInVuZG9cIik7fSksXG4gICAgcmVkbzogZG9jTWV0aG9kT3AoZnVuY3Rpb24oKSB7bWFrZUNoYW5nZUZyb21IaXN0b3J5KHRoaXMsIFwicmVkb1wiKTt9KSxcbiAgICB1bmRvU2VsZWN0aW9uOiBkb2NNZXRob2RPcChmdW5jdGlvbigpIHttYWtlQ2hhbmdlRnJvbUhpc3RvcnkodGhpcywgXCJ1bmRvXCIsIHRydWUpO30pLFxuICAgIHJlZG9TZWxlY3Rpb246IGRvY01ldGhvZE9wKGZ1bmN0aW9uKCkge21ha2VDaGFuZ2VGcm9tSGlzdG9yeSh0aGlzLCBcInJlZG9cIiwgdHJ1ZSk7fSksXG5cbiAgICBzZXRFeHRlbmRpbmc6IGZ1bmN0aW9uKHZhbCkge3RoaXMuZXh0ZW5kID0gdmFsO30sXG4gICAgZ2V0RXh0ZW5kaW5nOiBmdW5jdGlvbigpIHtyZXR1cm4gdGhpcy5leHRlbmR9LFxuXG4gICAgaGlzdG9yeVNpemU6IGZ1bmN0aW9uKCkge1xuICAgICAgdmFyIGhpc3QgPSB0aGlzLmhpc3RvcnksIGRvbmUgPSAwLCB1bmRvbmUgPSAwO1xuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBoaXN0LmRvbmUubGVuZ3RoOyBpKyspIHsgaWYgKCFoaXN0LmRvbmVbaV0ucmFuZ2VzKSB7ICsrZG9uZTsgfSB9XG4gICAgICBmb3IgKHZhciBpJDEgPSAwOyBpJDEgPCBoaXN0LnVuZG9uZS5sZW5ndGg7IGkkMSsrKSB7IGlmICghaGlzdC51bmRvbmVbaSQxXS5yYW5nZXMpIHsgKyt1bmRvbmU7IH0gfVxuICAgICAgcmV0dXJuIHt1bmRvOiBkb25lLCByZWRvOiB1bmRvbmV9XG4gICAgfSxcbiAgICBjbGVhckhpc3Rvcnk6IGZ1bmN0aW9uKCkge1xuICAgICAgdmFyIHRoaXMkMSA9IHRoaXM7XG5cbiAgICAgIHRoaXMuaGlzdG9yeSA9IG5ldyBIaXN0b3J5KHRoaXMuaGlzdG9yeSk7XG4gICAgICBsaW5rZWREb2NzKHRoaXMsIGZ1bmN0aW9uIChkb2MpIHsgcmV0dXJuIGRvYy5oaXN0b3J5ID0gdGhpcyQxLmhpc3Rvcnk7IH0sIHRydWUpO1xuICAgIH0sXG5cbiAgICBtYXJrQ2xlYW46IGZ1bmN0aW9uKCkge1xuICAgICAgdGhpcy5jbGVhbkdlbmVyYXRpb24gPSB0aGlzLmNoYW5nZUdlbmVyYXRpb24odHJ1ZSk7XG4gICAgfSxcbiAgICBjaGFuZ2VHZW5lcmF0aW9uOiBmdW5jdGlvbihmb3JjZVNwbGl0KSB7XG4gICAgICBpZiAoZm9yY2VTcGxpdClcbiAgICAgICAgeyB0aGlzLmhpc3RvcnkubGFzdE9wID0gdGhpcy5oaXN0b3J5Lmxhc3RTZWxPcCA9IHRoaXMuaGlzdG9yeS5sYXN0T3JpZ2luID0gbnVsbDsgfVxuICAgICAgcmV0dXJuIHRoaXMuaGlzdG9yeS5nZW5lcmF0aW9uXG4gICAgfSxcbiAgICBpc0NsZWFuOiBmdW5jdGlvbiAoZ2VuKSB7XG4gICAgICByZXR1cm4gdGhpcy5oaXN0b3J5LmdlbmVyYXRpb24gPT0gKGdlbiB8fCB0aGlzLmNsZWFuR2VuZXJhdGlvbilcbiAgICB9LFxuXG4gICAgZ2V0SGlzdG9yeTogZnVuY3Rpb24oKSB7XG4gICAgICByZXR1cm4ge2RvbmU6IGNvcHlIaXN0b3J5QXJyYXkodGhpcy5oaXN0b3J5LmRvbmUpLFxuICAgICAgICAgICAgICB1bmRvbmU6IGNvcHlIaXN0b3J5QXJyYXkodGhpcy5oaXN0b3J5LnVuZG9uZSl9XG4gICAgfSxcbiAgICBzZXRIaXN0b3J5OiBmdW5jdGlvbihoaXN0RGF0YSkge1xuICAgICAgdmFyIGhpc3QgPSB0aGlzLmhpc3RvcnkgPSBuZXcgSGlzdG9yeSh0aGlzLmhpc3RvcnkpO1xuICAgICAgaGlzdC5kb25lID0gY29weUhpc3RvcnlBcnJheShoaXN0RGF0YS5kb25lLnNsaWNlKDApLCBudWxsLCB0cnVlKTtcbiAgICAgIGhpc3QudW5kb25lID0gY29weUhpc3RvcnlBcnJheShoaXN0RGF0YS51bmRvbmUuc2xpY2UoMCksIG51bGwsIHRydWUpO1xuICAgIH0sXG5cbiAgICBzZXRHdXR0ZXJNYXJrZXI6IGRvY01ldGhvZE9wKGZ1bmN0aW9uKGxpbmUsIGd1dHRlcklELCB2YWx1ZSkge1xuICAgICAgcmV0dXJuIGNoYW5nZUxpbmUodGhpcywgbGluZSwgXCJndXR0ZXJcIiwgZnVuY3Rpb24gKGxpbmUpIHtcbiAgICAgICAgdmFyIG1hcmtlcnMgPSBsaW5lLmd1dHRlck1hcmtlcnMgfHwgKGxpbmUuZ3V0dGVyTWFya2VycyA9IHt9KTtcbiAgICAgICAgbWFya2Vyc1tndXR0ZXJJRF0gPSB2YWx1ZTtcbiAgICAgICAgaWYgKCF2YWx1ZSAmJiBpc0VtcHR5KG1hcmtlcnMpKSB7IGxpbmUuZ3V0dGVyTWFya2VycyA9IG51bGw7IH1cbiAgICAgICAgcmV0dXJuIHRydWVcbiAgICAgIH0pXG4gICAgfSksXG5cbiAgICBjbGVhckd1dHRlcjogZG9jTWV0aG9kT3AoZnVuY3Rpb24oZ3V0dGVySUQpIHtcbiAgICAgIHZhciB0aGlzJDEgPSB0aGlzO1xuXG4gICAgICB0aGlzLml0ZXIoZnVuY3Rpb24gKGxpbmUpIHtcbiAgICAgICAgaWYgKGxpbmUuZ3V0dGVyTWFya2VycyAmJiBsaW5lLmd1dHRlck1hcmtlcnNbZ3V0dGVySURdKSB7XG4gICAgICAgICAgY2hhbmdlTGluZSh0aGlzJDEsIGxpbmUsIFwiZ3V0dGVyXCIsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIGxpbmUuZ3V0dGVyTWFya2Vyc1tndXR0ZXJJRF0gPSBudWxsO1xuICAgICAgICAgICAgaWYgKGlzRW1wdHkobGluZS5ndXR0ZXJNYXJrZXJzKSkgeyBsaW5lLmd1dHRlck1hcmtlcnMgPSBudWxsOyB9XG4gICAgICAgICAgICByZXR1cm4gdHJ1ZVxuICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICB9KTtcbiAgICB9KSxcblxuICAgIGxpbmVJbmZvOiBmdW5jdGlvbihsaW5lKSB7XG4gICAgICB2YXIgbjtcbiAgICAgIGlmICh0eXBlb2YgbGluZSA9PSBcIm51bWJlclwiKSB7XG4gICAgICAgIGlmICghaXNMaW5lKHRoaXMsIGxpbmUpKSB7IHJldHVybiBudWxsIH1cbiAgICAgICAgbiA9IGxpbmU7XG4gICAgICAgIGxpbmUgPSBnZXRMaW5lKHRoaXMsIGxpbmUpO1xuICAgICAgICBpZiAoIWxpbmUpIHsgcmV0dXJuIG51bGwgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgbiA9IGxpbmVObyhsaW5lKTtcbiAgICAgICAgaWYgKG4gPT0gbnVsbCkgeyByZXR1cm4gbnVsbCB9XG4gICAgICB9XG4gICAgICByZXR1cm4ge2xpbmU6IG4sIGhhbmRsZTogbGluZSwgdGV4dDogbGluZS50ZXh0LCBndXR0ZXJNYXJrZXJzOiBsaW5lLmd1dHRlck1hcmtlcnMsXG4gICAgICAgICAgICAgIHRleHRDbGFzczogbGluZS50ZXh0Q2xhc3MsIGJnQ2xhc3M6IGxpbmUuYmdDbGFzcywgd3JhcENsYXNzOiBsaW5lLndyYXBDbGFzcyxcbiAgICAgICAgICAgICAgd2lkZ2V0czogbGluZS53aWRnZXRzfVxuICAgIH0sXG5cbiAgICBhZGRMaW5lQ2xhc3M6IGRvY01ldGhvZE9wKGZ1bmN0aW9uKGhhbmRsZSwgd2hlcmUsIGNscykge1xuICAgICAgcmV0dXJuIGNoYW5nZUxpbmUodGhpcywgaGFuZGxlLCB3aGVyZSA9PSBcImd1dHRlclwiID8gXCJndXR0ZXJcIiA6IFwiY2xhc3NcIiwgZnVuY3Rpb24gKGxpbmUpIHtcbiAgICAgICAgdmFyIHByb3AgPSB3aGVyZSA9PSBcInRleHRcIiA/IFwidGV4dENsYXNzXCJcbiAgICAgICAgICAgICAgICAgOiB3aGVyZSA9PSBcImJhY2tncm91bmRcIiA/IFwiYmdDbGFzc1wiXG4gICAgICAgICAgICAgICAgIDogd2hlcmUgPT0gXCJndXR0ZXJcIiA/IFwiZ3V0dGVyQ2xhc3NcIiA6IFwid3JhcENsYXNzXCI7XG4gICAgICAgIGlmICghbGluZVtwcm9wXSkgeyBsaW5lW3Byb3BdID0gY2xzOyB9XG4gICAgICAgIGVsc2UgaWYgKGNsYXNzVGVzdChjbHMpLnRlc3QobGluZVtwcm9wXSkpIHsgcmV0dXJuIGZhbHNlIH1cbiAgICAgICAgZWxzZSB7IGxpbmVbcHJvcF0gKz0gXCIgXCIgKyBjbHM7IH1cbiAgICAgICAgcmV0dXJuIHRydWVcbiAgICAgIH0pXG4gICAgfSksXG4gICAgcmVtb3ZlTGluZUNsYXNzOiBkb2NNZXRob2RPcChmdW5jdGlvbihoYW5kbGUsIHdoZXJlLCBjbHMpIHtcbiAgICAgIHJldHVybiBjaGFuZ2VMaW5lKHRoaXMsIGhhbmRsZSwgd2hlcmUgPT0gXCJndXR0ZXJcIiA/IFwiZ3V0dGVyXCIgOiBcImNsYXNzXCIsIGZ1bmN0aW9uIChsaW5lKSB7XG4gICAgICAgIHZhciBwcm9wID0gd2hlcmUgPT0gXCJ0ZXh0XCIgPyBcInRleHRDbGFzc1wiXG4gICAgICAgICAgICAgICAgIDogd2hlcmUgPT0gXCJiYWNrZ3JvdW5kXCIgPyBcImJnQ2xhc3NcIlxuICAgICAgICAgICAgICAgICA6IHdoZXJlID09IFwiZ3V0dGVyXCIgPyBcImd1dHRlckNsYXNzXCIgOiBcIndyYXBDbGFzc1wiO1xuICAgICAgICB2YXIgY3VyID0gbGluZVtwcm9wXTtcbiAgICAgICAgaWYgKCFjdXIpIHsgcmV0dXJuIGZhbHNlIH1cbiAgICAgICAgZWxzZSBpZiAoY2xzID09IG51bGwpIHsgbGluZVtwcm9wXSA9IG51bGw7IH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgdmFyIGZvdW5kID0gY3VyLm1hdGNoKGNsYXNzVGVzdChjbHMpKTtcbiAgICAgICAgICBpZiAoIWZvdW5kKSB7IHJldHVybiBmYWxzZSB9XG4gICAgICAgICAgdmFyIGVuZCA9IGZvdW5kLmluZGV4ICsgZm91bmRbMF0ubGVuZ3RoO1xuICAgICAgICAgIGxpbmVbcHJvcF0gPSBjdXIuc2xpY2UoMCwgZm91bmQuaW5kZXgpICsgKCFmb3VuZC5pbmRleCB8fCBlbmQgPT0gY3VyLmxlbmd0aCA/IFwiXCIgOiBcIiBcIikgKyBjdXIuc2xpY2UoZW5kKSB8fCBudWxsO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0cnVlXG4gICAgICB9KVxuICAgIH0pLFxuXG4gICAgYWRkTGluZVdpZGdldDogZG9jTWV0aG9kT3AoZnVuY3Rpb24oaGFuZGxlLCBub2RlLCBvcHRpb25zKSB7XG4gICAgICByZXR1cm4gYWRkTGluZVdpZGdldCh0aGlzLCBoYW5kbGUsIG5vZGUsIG9wdGlvbnMpXG4gICAgfSksXG4gICAgcmVtb3ZlTGluZVdpZGdldDogZnVuY3Rpb24od2lkZ2V0KSB7IHdpZGdldC5jbGVhcigpOyB9LFxuXG4gICAgbWFya1RleHQ6IGZ1bmN0aW9uKGZyb20sIHRvLCBvcHRpb25zKSB7XG4gICAgICByZXR1cm4gbWFya1RleHQodGhpcywgY2xpcFBvcyh0aGlzLCBmcm9tKSwgY2xpcFBvcyh0aGlzLCB0byksIG9wdGlvbnMsIG9wdGlvbnMgJiYgb3B0aW9ucy50eXBlIHx8IFwicmFuZ2VcIilcbiAgICB9LFxuICAgIHNldEJvb2ttYXJrOiBmdW5jdGlvbihwb3MsIG9wdGlvbnMpIHtcbiAgICAgIHZhciByZWFsT3B0cyA9IHtyZXBsYWNlZFdpdGg6IG9wdGlvbnMgJiYgKG9wdGlvbnMubm9kZVR5cGUgPT0gbnVsbCA/IG9wdGlvbnMud2lkZ2V0IDogb3B0aW9ucyksXG4gICAgICAgICAgICAgICAgICAgICAgaW5zZXJ0TGVmdDogb3B0aW9ucyAmJiBvcHRpb25zLmluc2VydExlZnQsXG4gICAgICAgICAgICAgICAgICAgICAgY2xlYXJXaGVuRW1wdHk6IGZhbHNlLCBzaGFyZWQ6IG9wdGlvbnMgJiYgb3B0aW9ucy5zaGFyZWQsXG4gICAgICAgICAgICAgICAgICAgICAgaGFuZGxlTW91c2VFdmVudHM6IG9wdGlvbnMgJiYgb3B0aW9ucy5oYW5kbGVNb3VzZUV2ZW50c307XG4gICAgICBwb3MgPSBjbGlwUG9zKHRoaXMsIHBvcyk7XG4gICAgICByZXR1cm4gbWFya1RleHQodGhpcywgcG9zLCBwb3MsIHJlYWxPcHRzLCBcImJvb2ttYXJrXCIpXG4gICAgfSxcbiAgICBmaW5kTWFya3NBdDogZnVuY3Rpb24ocG9zKSB7XG4gICAgICBwb3MgPSBjbGlwUG9zKHRoaXMsIHBvcyk7XG4gICAgICB2YXIgbWFya2VycyA9IFtdLCBzcGFucyA9IGdldExpbmUodGhpcywgcG9zLmxpbmUpLm1hcmtlZFNwYW5zO1xuICAgICAgaWYgKHNwYW5zKSB7IGZvciAodmFyIGkgPSAwOyBpIDwgc3BhbnMubGVuZ3RoOyArK2kpIHtcbiAgICAgICAgdmFyIHNwYW4gPSBzcGFuc1tpXTtcbiAgICAgICAgaWYgKChzcGFuLmZyb20gPT0gbnVsbCB8fCBzcGFuLmZyb20gPD0gcG9zLmNoKSAmJlxuICAgICAgICAgICAgKHNwYW4udG8gPT0gbnVsbCB8fCBzcGFuLnRvID49IHBvcy5jaCkpXG4gICAgICAgICAgeyBtYXJrZXJzLnB1c2goc3Bhbi5tYXJrZXIucGFyZW50IHx8IHNwYW4ubWFya2VyKTsgfVxuICAgICAgfSB9XG4gICAgICByZXR1cm4gbWFya2Vyc1xuICAgIH0sXG4gICAgZmluZE1hcmtzOiBmdW5jdGlvbihmcm9tLCB0bywgZmlsdGVyKSB7XG4gICAgICBmcm9tID0gY2xpcFBvcyh0aGlzLCBmcm9tKTsgdG8gPSBjbGlwUG9zKHRoaXMsIHRvKTtcbiAgICAgIHZhciBmb3VuZCA9IFtdLCBsaW5lTm8gPSBmcm9tLmxpbmU7XG4gICAgICB0aGlzLml0ZXIoZnJvbS5saW5lLCB0by5saW5lICsgMSwgZnVuY3Rpb24gKGxpbmUpIHtcbiAgICAgICAgdmFyIHNwYW5zID0gbGluZS5tYXJrZWRTcGFucztcbiAgICAgICAgaWYgKHNwYW5zKSB7IGZvciAodmFyIGkgPSAwOyBpIDwgc3BhbnMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICB2YXIgc3BhbiA9IHNwYW5zW2ldO1xuICAgICAgICAgIGlmICghKHNwYW4udG8gIT0gbnVsbCAmJiBsaW5lTm8gPT0gZnJvbS5saW5lICYmIGZyb20uY2ggPj0gc3Bhbi50byB8fFxuICAgICAgICAgICAgICAgIHNwYW4uZnJvbSA9PSBudWxsICYmIGxpbmVObyAhPSBmcm9tLmxpbmUgfHxcbiAgICAgICAgICAgICAgICBzcGFuLmZyb20gIT0gbnVsbCAmJiBsaW5lTm8gPT0gdG8ubGluZSAmJiBzcGFuLmZyb20gPj0gdG8uY2gpICYmXG4gICAgICAgICAgICAgICghZmlsdGVyIHx8IGZpbHRlcihzcGFuLm1hcmtlcikpKVxuICAgICAgICAgICAgeyBmb3VuZC5wdXNoKHNwYW4ubWFya2VyLnBhcmVudCB8fCBzcGFuLm1hcmtlcik7IH1cbiAgICAgICAgfSB9XG4gICAgICAgICsrbGluZU5vO1xuICAgICAgfSk7XG4gICAgICByZXR1cm4gZm91bmRcbiAgICB9LFxuICAgIGdldEFsbE1hcmtzOiBmdW5jdGlvbigpIHtcbiAgICAgIHZhciBtYXJrZXJzID0gW107XG4gICAgICB0aGlzLml0ZXIoZnVuY3Rpb24gKGxpbmUpIHtcbiAgICAgICAgdmFyIHNwcyA9IGxpbmUubWFya2VkU3BhbnM7XG4gICAgICAgIGlmIChzcHMpIHsgZm9yICh2YXIgaSA9IDA7IGkgPCBzcHMubGVuZ3RoOyArK2kpXG4gICAgICAgICAgeyBpZiAoc3BzW2ldLmZyb20gIT0gbnVsbCkgeyBtYXJrZXJzLnB1c2goc3BzW2ldLm1hcmtlcik7IH0gfSB9XG4gICAgICB9KTtcbiAgICAgIHJldHVybiBtYXJrZXJzXG4gICAgfSxcblxuICAgIHBvc0Zyb21JbmRleDogZnVuY3Rpb24ob2ZmKSB7XG4gICAgICB2YXIgY2gsIGxpbmVObyA9IHRoaXMuZmlyc3QsIHNlcFNpemUgPSB0aGlzLmxpbmVTZXBhcmF0b3IoKS5sZW5ndGg7XG4gICAgICB0aGlzLml0ZXIoZnVuY3Rpb24gKGxpbmUpIHtcbiAgICAgICAgdmFyIHN6ID0gbGluZS50ZXh0Lmxlbmd0aCArIHNlcFNpemU7XG4gICAgICAgIGlmIChzeiA+IG9mZikgeyBjaCA9IG9mZjsgcmV0dXJuIHRydWUgfVxuICAgICAgICBvZmYgLT0gc3o7XG4gICAgICAgICsrbGluZU5vO1xuICAgICAgfSk7XG4gICAgICByZXR1cm4gY2xpcFBvcyh0aGlzLCBQb3MobGluZU5vLCBjaCkpXG4gICAgfSxcbiAgICBpbmRleEZyb21Qb3M6IGZ1bmN0aW9uIChjb29yZHMpIHtcbiAgICAgIGNvb3JkcyA9IGNsaXBQb3ModGhpcywgY29vcmRzKTtcbiAgICAgIHZhciBpbmRleCA9IGNvb3Jkcy5jaDtcbiAgICAgIGlmIChjb29yZHMubGluZSA8IHRoaXMuZmlyc3QgfHwgY29vcmRzLmNoIDwgMCkgeyByZXR1cm4gMCB9XG4gICAgICB2YXIgc2VwU2l6ZSA9IHRoaXMubGluZVNlcGFyYXRvcigpLmxlbmd0aDtcbiAgICAgIHRoaXMuaXRlcih0aGlzLmZpcnN0LCBjb29yZHMubGluZSwgZnVuY3Rpb24gKGxpbmUpIHsgLy8gaXRlciBhYm9ydHMgd2hlbiBjYWxsYmFjayByZXR1cm5zIGEgdHJ1dGh5IHZhbHVlXG4gICAgICAgIGluZGV4ICs9IGxpbmUudGV4dC5sZW5ndGggKyBzZXBTaXplO1xuICAgICAgfSk7XG4gICAgICByZXR1cm4gaW5kZXhcbiAgICB9LFxuXG4gICAgY29weTogZnVuY3Rpb24oY29weUhpc3RvcnkpIHtcbiAgICAgIHZhciBkb2MgPSBuZXcgRG9jKGdldExpbmVzKHRoaXMsIHRoaXMuZmlyc3QsIHRoaXMuZmlyc3QgKyB0aGlzLnNpemUpLFxuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5tb2RlT3B0aW9uLCB0aGlzLmZpcnN0LCB0aGlzLmxpbmVTZXAsIHRoaXMuZGlyZWN0aW9uKTtcbiAgICAgIGRvYy5zY3JvbGxUb3AgPSB0aGlzLnNjcm9sbFRvcDsgZG9jLnNjcm9sbExlZnQgPSB0aGlzLnNjcm9sbExlZnQ7XG4gICAgICBkb2Muc2VsID0gdGhpcy5zZWw7XG4gICAgICBkb2MuZXh0ZW5kID0gZmFsc2U7XG4gICAgICBpZiAoY29weUhpc3RvcnkpIHtcbiAgICAgICAgZG9jLmhpc3RvcnkudW5kb0RlcHRoID0gdGhpcy5oaXN0b3J5LnVuZG9EZXB0aDtcbiAgICAgICAgZG9jLnNldEhpc3RvcnkodGhpcy5nZXRIaXN0b3J5KCkpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIGRvY1xuICAgIH0sXG5cbiAgICBsaW5rZWREb2M6IGZ1bmN0aW9uKG9wdGlvbnMpIHtcbiAgICAgIGlmICghb3B0aW9ucykgeyBvcHRpb25zID0ge307IH1cbiAgICAgIHZhciBmcm9tID0gdGhpcy5maXJzdCwgdG8gPSB0aGlzLmZpcnN0ICsgdGhpcy5zaXplO1xuICAgICAgaWYgKG9wdGlvbnMuZnJvbSAhPSBudWxsICYmIG9wdGlvbnMuZnJvbSA+IGZyb20pIHsgZnJvbSA9IG9wdGlvbnMuZnJvbTsgfVxuICAgICAgaWYgKG9wdGlvbnMudG8gIT0gbnVsbCAmJiBvcHRpb25zLnRvIDwgdG8pIHsgdG8gPSBvcHRpb25zLnRvOyB9XG4gICAgICB2YXIgY29weSA9IG5ldyBEb2MoZ2V0TGluZXModGhpcywgZnJvbSwgdG8pLCBvcHRpb25zLm1vZGUgfHwgdGhpcy5tb2RlT3B0aW9uLCBmcm9tLCB0aGlzLmxpbmVTZXAsIHRoaXMuZGlyZWN0aW9uKTtcbiAgICAgIGlmIChvcHRpb25zLnNoYXJlZEhpc3QpIHsgY29weS5oaXN0b3J5ID0gdGhpcy5oaXN0b3J5XG4gICAgICA7IH0odGhpcy5saW5rZWQgfHwgKHRoaXMubGlua2VkID0gW10pKS5wdXNoKHtkb2M6IGNvcHksIHNoYXJlZEhpc3Q6IG9wdGlvbnMuc2hhcmVkSGlzdH0pO1xuICAgICAgY29weS5saW5rZWQgPSBbe2RvYzogdGhpcywgaXNQYXJlbnQ6IHRydWUsIHNoYXJlZEhpc3Q6IG9wdGlvbnMuc2hhcmVkSGlzdH1dO1xuICAgICAgY29weVNoYXJlZE1hcmtlcnMoY29weSwgZmluZFNoYXJlZE1hcmtlcnModGhpcykpO1xuICAgICAgcmV0dXJuIGNvcHlcbiAgICB9LFxuICAgIHVubGlua0RvYzogZnVuY3Rpb24ob3RoZXIpIHtcbiAgICAgIGlmIChvdGhlciBpbnN0YW5jZW9mIENvZGVNaXJyb3IpIHsgb3RoZXIgPSBvdGhlci5kb2M7IH1cbiAgICAgIGlmICh0aGlzLmxpbmtlZCkgeyBmb3IgKHZhciBpID0gMDsgaSA8IHRoaXMubGlua2VkLmxlbmd0aDsgKytpKSB7XG4gICAgICAgIHZhciBsaW5rID0gdGhpcy5saW5rZWRbaV07XG4gICAgICAgIGlmIChsaW5rLmRvYyAhPSBvdGhlcikgeyBjb250aW51ZSB9XG4gICAgICAgIHRoaXMubGlua2VkLnNwbGljZShpLCAxKTtcbiAgICAgICAgb3RoZXIudW5saW5rRG9jKHRoaXMpO1xuICAgICAgICBkZXRhY2hTaGFyZWRNYXJrZXJzKGZpbmRTaGFyZWRNYXJrZXJzKHRoaXMpKTtcbiAgICAgICAgYnJlYWtcbiAgICAgIH0gfVxuICAgICAgLy8gSWYgdGhlIGhpc3RvcmllcyB3ZXJlIHNoYXJlZCwgc3BsaXQgdGhlbSBhZ2FpblxuICAgICAgaWYgKG90aGVyLmhpc3RvcnkgPT0gdGhpcy5oaXN0b3J5KSB7XG4gICAgICAgIHZhciBzcGxpdElkcyA9IFtvdGhlci5pZF07XG4gICAgICAgIGxpbmtlZERvY3Mob3RoZXIsIGZ1bmN0aW9uIChkb2MpIHsgcmV0dXJuIHNwbGl0SWRzLnB1c2goZG9jLmlkKTsgfSwgdHJ1ZSk7XG4gICAgICAgIG90aGVyLmhpc3RvcnkgPSBuZXcgSGlzdG9yeShudWxsKTtcbiAgICAgICAgb3RoZXIuaGlzdG9yeS5kb25lID0gY29weUhpc3RvcnlBcnJheSh0aGlzLmhpc3RvcnkuZG9uZSwgc3BsaXRJZHMpO1xuICAgICAgICBvdGhlci5oaXN0b3J5LnVuZG9uZSA9IGNvcHlIaXN0b3J5QXJyYXkodGhpcy5oaXN0b3J5LnVuZG9uZSwgc3BsaXRJZHMpO1xuICAgICAgfVxuICAgIH0sXG4gICAgaXRlckxpbmtlZERvY3M6IGZ1bmN0aW9uKGYpIHtsaW5rZWREb2NzKHRoaXMsIGYpO30sXG5cbiAgICBnZXRNb2RlOiBmdW5jdGlvbigpIHtyZXR1cm4gdGhpcy5tb2RlfSxcbiAgICBnZXRFZGl0b3I6IGZ1bmN0aW9uKCkge3JldHVybiB0aGlzLmNtfSxcblxuICAgIHNwbGl0TGluZXM6IGZ1bmN0aW9uKHN0cikge1xuICAgICAgaWYgKHRoaXMubGluZVNlcCkgeyByZXR1cm4gc3RyLnNwbGl0KHRoaXMubGluZVNlcCkgfVxuICAgICAgcmV0dXJuIHNwbGl0TGluZXNBdXRvKHN0cilcbiAgICB9LFxuICAgIGxpbmVTZXBhcmF0b3I6IGZ1bmN0aW9uKCkgeyByZXR1cm4gdGhpcy5saW5lU2VwIHx8IFwiXFxuXCIgfSxcblxuICAgIHNldERpcmVjdGlvbjogZG9jTWV0aG9kT3AoZnVuY3Rpb24gKGRpcikge1xuICAgICAgaWYgKGRpciAhPSBcInJ0bFwiKSB7IGRpciA9IFwibHRyXCI7IH1cbiAgICAgIGlmIChkaXIgPT0gdGhpcy5kaXJlY3Rpb24pIHsgcmV0dXJuIH1cbiAgICAgIHRoaXMuZGlyZWN0aW9uID0gZGlyO1xuICAgICAgdGhpcy5pdGVyKGZ1bmN0aW9uIChsaW5lKSB7IHJldHVybiBsaW5lLm9yZGVyID0gbnVsbDsgfSk7XG4gICAgICBpZiAodGhpcy5jbSkgeyBkaXJlY3Rpb25DaGFuZ2VkKHRoaXMuY20pOyB9XG4gICAgfSlcbiAgfSk7XG5cbiAgLy8gUHVibGljIGFsaWFzLlxuICBEb2MucHJvdG90eXBlLmVhY2hMaW5lID0gRG9jLnByb3RvdHlwZS5pdGVyO1xuXG4gIC8vIEtsdWRnZSB0byB3b3JrIGFyb3VuZCBzdHJhbmdlIElFIGJlaGF2aW9yIHdoZXJlIGl0J2xsIHNvbWV0aW1lc1xuICAvLyByZS1maXJlIGEgc2VyaWVzIG9mIGRyYWctcmVsYXRlZCBldmVudHMgcmlnaHQgYWZ0ZXIgdGhlIGRyb3AgKCMxNTUxKVxuICB2YXIgbGFzdERyb3AgPSAwO1xuXG4gIGZ1bmN0aW9uIG9uRHJvcChlKSB7XG4gICAgdmFyIGNtID0gdGhpcztcbiAgICBjbGVhckRyYWdDdXJzb3IoY20pO1xuICAgIGlmIChzaWduYWxET01FdmVudChjbSwgZSkgfHwgZXZlbnRJbldpZGdldChjbS5kaXNwbGF5LCBlKSlcbiAgICAgIHsgcmV0dXJuIH1cbiAgICBlX3ByZXZlbnREZWZhdWx0KGUpO1xuICAgIGlmIChpZSkgeyBsYXN0RHJvcCA9ICtuZXcgRGF0ZTsgfVxuICAgIHZhciBwb3MgPSBwb3NGcm9tTW91c2UoY20sIGUsIHRydWUpLCBmaWxlcyA9IGUuZGF0YVRyYW5zZmVyLmZpbGVzO1xuICAgIGlmICghcG9zIHx8IGNtLmlzUmVhZE9ubHkoKSkgeyByZXR1cm4gfVxuICAgIC8vIE1pZ2h0IGJlIGEgZmlsZSBkcm9wLCBpbiB3aGljaCBjYXNlIHdlIHNpbXBseSBleHRyYWN0IHRoZSB0ZXh0XG4gICAgLy8gYW5kIGluc2VydCBpdC5cbiAgICBpZiAoZmlsZXMgJiYgZmlsZXMubGVuZ3RoICYmIHdpbmRvdy5GaWxlUmVhZGVyICYmIHdpbmRvdy5GaWxlKSB7XG4gICAgICB2YXIgbiA9IGZpbGVzLmxlbmd0aCwgdGV4dCA9IEFycmF5KG4pLCByZWFkID0gMDtcbiAgICAgIHZhciBtYXJrQXNSZWFkQW5kUGFzdGVJZkFsbEZpbGVzQXJlUmVhZCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgaWYgKCsrcmVhZCA9PSBuKSB7XG4gICAgICAgICAgb3BlcmF0aW9uKGNtLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICBwb3MgPSBjbGlwUG9zKGNtLmRvYywgcG9zKTtcbiAgICAgICAgICAgIHZhciBjaGFuZ2UgPSB7ZnJvbTogcG9zLCB0bzogcG9zLFxuICAgICAgICAgICAgICAgICAgICAgICAgICB0ZXh0OiBjbS5kb2Muc3BsaXRMaW5lcyhcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRleHQuZmlsdGVyKGZ1bmN0aW9uICh0KSB7IHJldHVybiB0ICE9IG51bGw7IH0pLmpvaW4oY20uZG9jLmxpbmVTZXBhcmF0b3IoKSkpLFxuICAgICAgICAgICAgICAgICAgICAgICAgICBvcmlnaW46IFwicGFzdGVcIn07XG4gICAgICAgICAgICBtYWtlQ2hhbmdlKGNtLmRvYywgY2hhbmdlKTtcbiAgICAgICAgICAgIHNldFNlbGVjdGlvblJlcGxhY2VIaXN0b3J5KGNtLmRvYywgc2ltcGxlU2VsZWN0aW9uKGNsaXBQb3MoY20uZG9jLCBwb3MpLCBjbGlwUG9zKGNtLmRvYywgY2hhbmdlRW5kKGNoYW5nZSkpKSk7XG4gICAgICAgICAgfSkoKTtcbiAgICAgICAgfVxuICAgICAgfTtcbiAgICAgIHZhciByZWFkVGV4dEZyb21GaWxlID0gZnVuY3Rpb24gKGZpbGUsIGkpIHtcbiAgICAgICAgaWYgKGNtLm9wdGlvbnMuYWxsb3dEcm9wRmlsZVR5cGVzICYmXG4gICAgICAgICAgICBpbmRleE9mKGNtLm9wdGlvbnMuYWxsb3dEcm9wRmlsZVR5cGVzLCBmaWxlLnR5cGUpID09IC0xKSB7XG4gICAgICAgICAgbWFya0FzUmVhZEFuZFBhc3RlSWZBbGxGaWxlc0FyZVJlYWQoKTtcbiAgICAgICAgICByZXR1cm5cbiAgICAgICAgfVxuICAgICAgICB2YXIgcmVhZGVyID0gbmV3IEZpbGVSZWFkZXI7XG4gICAgICAgIHJlYWRlci5vbmVycm9yID0gZnVuY3Rpb24gKCkgeyByZXR1cm4gbWFya0FzUmVhZEFuZFBhc3RlSWZBbGxGaWxlc0FyZVJlYWQoKTsgfTtcbiAgICAgICAgcmVhZGVyLm9ubG9hZCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICB2YXIgY29udGVudCA9IHJlYWRlci5yZXN1bHQ7XG4gICAgICAgICAgaWYgKC9bXFx4MDAtXFx4MDhcXHgwZS1cXHgxZl17Mn0vLnRlc3QoY29udGVudCkpIHtcbiAgICAgICAgICAgIG1hcmtBc1JlYWRBbmRQYXN0ZUlmQWxsRmlsZXNBcmVSZWFkKCk7XG4gICAgICAgICAgICByZXR1cm5cbiAgICAgICAgICB9XG4gICAgICAgICAgdGV4dFtpXSA9IGNvbnRlbnQ7XG4gICAgICAgICAgbWFya0FzUmVhZEFuZFBhc3RlSWZBbGxGaWxlc0FyZVJlYWQoKTtcbiAgICAgICAgfTtcbiAgICAgICAgcmVhZGVyLnJlYWRBc1RleHQoZmlsZSk7XG4gICAgICB9O1xuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBmaWxlcy5sZW5ndGg7IGkrKykgeyByZWFkVGV4dEZyb21GaWxlKGZpbGVzW2ldLCBpKTsgfVxuICAgIH0gZWxzZSB7IC8vIE5vcm1hbCBkcm9wXG4gICAgICAvLyBEb24ndCBkbyBhIHJlcGxhY2UgaWYgdGhlIGRyb3AgaGFwcGVuZWQgaW5zaWRlIG9mIHRoZSBzZWxlY3RlZCB0ZXh0LlxuICAgICAgaWYgKGNtLnN0YXRlLmRyYWdnaW5nVGV4dCAmJiBjbS5kb2Muc2VsLmNvbnRhaW5zKHBvcykgPiAtMSkge1xuICAgICAgICBjbS5zdGF0ZS5kcmFnZ2luZ1RleHQoZSk7XG4gICAgICAgIC8vIEVuc3VyZSB0aGUgZWRpdG9yIGlzIHJlLWZvY3VzZWRcbiAgICAgICAgc2V0VGltZW91dChmdW5jdGlvbiAoKSB7IHJldHVybiBjbS5kaXNwbGF5LmlucHV0LmZvY3VzKCk7IH0sIDIwKTtcbiAgICAgICAgcmV0dXJuXG4gICAgICB9XG4gICAgICB0cnkge1xuICAgICAgICB2YXIgdGV4dCQxID0gZS5kYXRhVHJhbnNmZXIuZ2V0RGF0YShcIlRleHRcIik7XG4gICAgICAgIGlmICh0ZXh0JDEpIHtcbiAgICAgICAgICB2YXIgc2VsZWN0ZWQ7XG4gICAgICAgICAgaWYgKGNtLnN0YXRlLmRyYWdnaW5nVGV4dCAmJiAhY20uc3RhdGUuZHJhZ2dpbmdUZXh0LmNvcHkpXG4gICAgICAgICAgICB7IHNlbGVjdGVkID0gY20ubGlzdFNlbGVjdGlvbnMoKTsgfVxuICAgICAgICAgIHNldFNlbGVjdGlvbk5vVW5kbyhjbS5kb2MsIHNpbXBsZVNlbGVjdGlvbihwb3MsIHBvcykpO1xuICAgICAgICAgIGlmIChzZWxlY3RlZCkgeyBmb3IgKHZhciBpJDEgPSAwOyBpJDEgPCBzZWxlY3RlZC5sZW5ndGg7ICsraSQxKVxuICAgICAgICAgICAgeyByZXBsYWNlUmFuZ2UoY20uZG9jLCBcIlwiLCBzZWxlY3RlZFtpJDFdLmFuY2hvciwgc2VsZWN0ZWRbaSQxXS5oZWFkLCBcImRyYWdcIik7IH0gfVxuICAgICAgICAgIGNtLnJlcGxhY2VTZWxlY3Rpb24odGV4dCQxLCBcImFyb3VuZFwiLCBcInBhc3RlXCIpO1xuICAgICAgICAgIGNtLmRpc3BsYXkuaW5wdXQuZm9jdXMoKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgY2F0Y2goZSQxKXt9XG4gICAgfVxuICB9XG5cbiAgZnVuY3Rpb24gb25EcmFnU3RhcnQoY20sIGUpIHtcbiAgICBpZiAoaWUgJiYgKCFjbS5zdGF0ZS5kcmFnZ2luZ1RleHQgfHwgK25ldyBEYXRlIC0gbGFzdERyb3AgPCAxMDApKSB7IGVfc3RvcChlKTsgcmV0dXJuIH1cbiAgICBpZiAoc2lnbmFsRE9NRXZlbnQoY20sIGUpIHx8IGV2ZW50SW5XaWRnZXQoY20uZGlzcGxheSwgZSkpIHsgcmV0dXJuIH1cblxuICAgIGUuZGF0YVRyYW5zZmVyLnNldERhdGEoXCJUZXh0XCIsIGNtLmdldFNlbGVjdGlvbigpKTtcbiAgICBlLmRhdGFUcmFuc2Zlci5lZmZlY3RBbGxvd2VkID0gXCJjb3B5TW92ZVwiO1xuXG4gICAgLy8gVXNlIGR1bW15IGltYWdlIGluc3RlYWQgb2YgZGVmYXVsdCBicm93c2VycyBpbWFnZS5cbiAgICAvLyBSZWNlbnQgU2FmYXJpICh+Ni4wLjIpIGhhdmUgYSB0ZW5kZW5jeSB0byBzZWdmYXVsdCB3aGVuIHRoaXMgaGFwcGVucywgc28gd2UgZG9uJ3QgZG8gaXQgdGhlcmUuXG4gICAgaWYgKGUuZGF0YVRyYW5zZmVyLnNldERyYWdJbWFnZSAmJiAhc2FmYXJpKSB7XG4gICAgICB2YXIgaW1nID0gZWx0KFwiaW1nXCIsIG51bGwsIG51bGwsIFwicG9zaXRpb246IGZpeGVkOyBsZWZ0OiAwOyB0b3A6IDA7XCIpO1xuICAgICAgaW1nLnNyYyA9IFwiZGF0YTppbWFnZS9naWY7YmFzZTY0LFIwbEdPRGxoQVFBQkFBQUFBQ0g1QkFFS0FBRUFMQUFBQUFBQkFBRUFBQUlDVEFFQU93PT1cIjtcbiAgICAgIGlmIChwcmVzdG8pIHtcbiAgICAgICAgaW1nLndpZHRoID0gaW1nLmhlaWdodCA9IDE7XG4gICAgICAgIGNtLmRpc3BsYXkud3JhcHBlci5hcHBlbmRDaGlsZChpbWcpO1xuICAgICAgICAvLyBGb3JjZSBhIHJlbGF5b3V0LCBvciBPcGVyYSB3b24ndCB1c2Ugb3VyIGltYWdlIGZvciBzb21lIG9ic2N1cmUgcmVhc29uXG4gICAgICAgIGltZy5fdG9wID0gaW1nLm9mZnNldFRvcDtcbiAgICAgIH1cbiAgICAgIGUuZGF0YVRyYW5zZmVyLnNldERyYWdJbWFnZShpbWcsIDAsIDApO1xuICAgICAgaWYgKHByZXN0bykgeyBpbWcucGFyZW50Tm9kZS5yZW1vdmVDaGlsZChpbWcpOyB9XG4gICAgfVxuICB9XG5cbiAgZnVuY3Rpb24gb25EcmFnT3ZlcihjbSwgZSkge1xuICAgIHZhciBwb3MgPSBwb3NGcm9tTW91c2UoY20sIGUpO1xuICAgIGlmICghcG9zKSB7IHJldHVybiB9XG4gICAgdmFyIGZyYWcgPSBkb2N1bWVudC5jcmVhdGVEb2N1bWVudEZyYWdtZW50KCk7XG4gICAgZHJhd1NlbGVjdGlvbkN1cnNvcihjbSwgcG9zLCBmcmFnKTtcbiAgICBpZiAoIWNtLmRpc3BsYXkuZHJhZ0N1cnNvcikge1xuICAgICAgY20uZGlzcGxheS5kcmFnQ3Vyc29yID0gZWx0KFwiZGl2XCIsIG51bGwsIFwiQ29kZU1pcnJvci1jdXJzb3JzIENvZGVNaXJyb3ItZHJhZ2N1cnNvcnNcIik7XG4gICAgICBjbS5kaXNwbGF5LmxpbmVTcGFjZS5pbnNlcnRCZWZvcmUoY20uZGlzcGxheS5kcmFnQ3Vyc29yLCBjbS5kaXNwbGF5LmN1cnNvckRpdik7XG4gICAgfVxuICAgIHJlbW92ZUNoaWxkcmVuQW5kQWRkKGNtLmRpc3BsYXkuZHJhZ0N1cnNvciwgZnJhZyk7XG4gIH1cblxuICBmdW5jdGlvbiBjbGVhckRyYWdDdXJzb3IoY20pIHtcbiAgICBpZiAoY20uZGlzcGxheS5kcmFnQ3Vyc29yKSB7XG4gICAgICBjbS5kaXNwbGF5LmxpbmVTcGFjZS5yZW1vdmVDaGlsZChjbS5kaXNwbGF5LmRyYWdDdXJzb3IpO1xuICAgICAgY20uZGlzcGxheS5kcmFnQ3Vyc29yID0gbnVsbDtcbiAgICB9XG4gIH1cblxuICAvLyBUaGVzZSBtdXN0IGJlIGhhbmRsZWQgY2FyZWZ1bGx5LCBiZWNhdXNlIG5haXZlbHkgcmVnaXN0ZXJpbmcgYVxuICAvLyBoYW5kbGVyIGZvciBlYWNoIGVkaXRvciB3aWxsIGNhdXNlIHRoZSBlZGl0b3JzIHRvIG5ldmVyIGJlXG4gIC8vIGdhcmJhZ2UgY29sbGVjdGVkLlxuXG4gIGZ1bmN0aW9uIGZvckVhY2hDb2RlTWlycm9yKGYpIHtcbiAgICBpZiAoIWRvY3VtZW50LmdldEVsZW1lbnRzQnlDbGFzc05hbWUpIHsgcmV0dXJuIH1cbiAgICB2YXIgYnlDbGFzcyA9IGRvY3VtZW50LmdldEVsZW1lbnRzQnlDbGFzc05hbWUoXCJDb2RlTWlycm9yXCIpLCBlZGl0b3JzID0gW107XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBieUNsYXNzLmxlbmd0aDsgaSsrKSB7XG4gICAgICB2YXIgY20gPSBieUNsYXNzW2ldLkNvZGVNaXJyb3I7XG4gICAgICBpZiAoY20pIHsgZWRpdG9ycy5wdXNoKGNtKTsgfVxuICAgIH1cbiAgICBpZiAoZWRpdG9ycy5sZW5ndGgpIHsgZWRpdG9yc1swXS5vcGVyYXRpb24oZnVuY3Rpb24gKCkge1xuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBlZGl0b3JzLmxlbmd0aDsgaSsrKSB7IGYoZWRpdG9yc1tpXSk7IH1cbiAgICB9KTsgfVxuICB9XG5cbiAgdmFyIGdsb2JhbHNSZWdpc3RlcmVkID0gZmFsc2U7XG4gIGZ1bmN0aW9uIGVuc3VyZUdsb2JhbEhhbmRsZXJzKCkge1xuICAgIGlmIChnbG9iYWxzUmVnaXN0ZXJlZCkgeyByZXR1cm4gfVxuICAgIHJlZ2lzdGVyR2xvYmFsSGFuZGxlcnMoKTtcbiAgICBnbG9iYWxzUmVnaXN0ZXJlZCA9IHRydWU7XG4gIH1cbiAgZnVuY3Rpb24gcmVnaXN0ZXJHbG9iYWxIYW5kbGVycygpIHtcbiAgICAvLyBXaGVuIHRoZSB3aW5kb3cgcmVzaXplcywgd2UgbmVlZCB0byByZWZyZXNoIGFjdGl2ZSBlZGl0b3JzLlxuICAgIHZhciByZXNpemVUaW1lcjtcbiAgICBvbih3aW5kb3csIFwicmVzaXplXCIsIGZ1bmN0aW9uICgpIHtcbiAgICAgIGlmIChyZXNpemVUaW1lciA9PSBudWxsKSB7IHJlc2l6ZVRpbWVyID0gc2V0VGltZW91dChmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJlc2l6ZVRpbWVyID0gbnVsbDtcbiAgICAgICAgZm9yRWFjaENvZGVNaXJyb3Iob25SZXNpemUpO1xuICAgICAgfSwgMTAwKTsgfVxuICAgIH0pO1xuICAgIC8vIFdoZW4gdGhlIHdpbmRvdyBsb3NlcyBmb2N1cywgd2Ugd2FudCB0byBzaG93IHRoZSBlZGl0b3IgYXMgYmx1cnJlZFxuICAgIG9uKHdpbmRvdywgXCJibHVyXCIsIGZ1bmN0aW9uICgpIHsgcmV0dXJuIGZvckVhY2hDb2RlTWlycm9yKG9uQmx1cik7IH0pO1xuICB9XG4gIC8vIENhbGxlZCB3aGVuIHRoZSB3aW5kb3cgcmVzaXplc1xuICBmdW5jdGlvbiBvblJlc2l6ZShjbSkge1xuICAgIHZhciBkID0gY20uZGlzcGxheTtcbiAgICAvLyBNaWdodCBiZSBhIHRleHQgc2NhbGluZyBvcGVyYXRpb24sIGNsZWFyIHNpemUgY2FjaGVzLlxuICAgIGQuY2FjaGVkQ2hhcldpZHRoID0gZC5jYWNoZWRUZXh0SGVpZ2h0ID0gZC5jYWNoZWRQYWRkaW5nSCA9IG51bGw7XG4gICAgZC5zY3JvbGxiYXJzQ2xpcHBlZCA9IGZhbHNlO1xuICAgIGNtLnNldFNpemUoKTtcbiAgfVxuXG4gIHZhciBrZXlOYW1lcyA9IHtcbiAgICAzOiBcIlBhdXNlXCIsIDg6IFwiQmFja3NwYWNlXCIsIDk6IFwiVGFiXCIsIDEzOiBcIkVudGVyXCIsIDE2OiBcIlNoaWZ0XCIsIDE3OiBcIkN0cmxcIiwgMTg6IFwiQWx0XCIsXG4gICAgMTk6IFwiUGF1c2VcIiwgMjA6IFwiQ2Fwc0xvY2tcIiwgMjc6IFwiRXNjXCIsIDMyOiBcIlNwYWNlXCIsIDMzOiBcIlBhZ2VVcFwiLCAzNDogXCJQYWdlRG93blwiLCAzNTogXCJFbmRcIixcbiAgICAzNjogXCJIb21lXCIsIDM3OiBcIkxlZnRcIiwgMzg6IFwiVXBcIiwgMzk6IFwiUmlnaHRcIiwgNDA6IFwiRG93blwiLCA0NDogXCJQcmludFNjcm5cIiwgNDU6IFwiSW5zZXJ0XCIsXG4gICAgNDY6IFwiRGVsZXRlXCIsIDU5OiBcIjtcIiwgNjE6IFwiPVwiLCA5MTogXCJNb2RcIiwgOTI6IFwiTW9kXCIsIDkzOiBcIk1vZFwiLFxuICAgIDEwNjogXCIqXCIsIDEwNzogXCI9XCIsIDEwOTogXCItXCIsIDExMDogXCIuXCIsIDExMTogXCIvXCIsIDE0NTogXCJTY3JvbGxMb2NrXCIsXG4gICAgMTczOiBcIi1cIiwgMTg2OiBcIjtcIiwgMTg3OiBcIj1cIiwgMTg4OiBcIixcIiwgMTg5OiBcIi1cIiwgMTkwOiBcIi5cIiwgMTkxOiBcIi9cIiwgMTkyOiBcImBcIiwgMjE5OiBcIltcIiwgMjIwOiBcIlxcXFxcIixcbiAgICAyMjE6IFwiXVwiLCAyMjI6IFwiJ1wiLCAyMjQ6IFwiTW9kXCIsIDYzMjMyOiBcIlVwXCIsIDYzMjMzOiBcIkRvd25cIiwgNjMyMzQ6IFwiTGVmdFwiLCA2MzIzNTogXCJSaWdodFwiLCA2MzI3MjogXCJEZWxldGVcIixcbiAgICA2MzI3MzogXCJIb21lXCIsIDYzMjc1OiBcIkVuZFwiLCA2MzI3NjogXCJQYWdlVXBcIiwgNjMyNzc6IFwiUGFnZURvd25cIiwgNjMzMDI6IFwiSW5zZXJ0XCJcbiAgfTtcblxuICAvLyBOdW1iZXIga2V5c1xuICBmb3IgKHZhciBpID0gMDsgaSA8IDEwOyBpKyspIHsga2V5TmFtZXNbaSArIDQ4XSA9IGtleU5hbWVzW2kgKyA5Nl0gPSBTdHJpbmcoaSk7IH1cbiAgLy8gQWxwaGFiZXRpYyBrZXlzXG4gIGZvciAodmFyIGkkMSA9IDY1OyBpJDEgPD0gOTA7IGkkMSsrKSB7IGtleU5hbWVzW2kkMV0gPSBTdHJpbmcuZnJvbUNoYXJDb2RlKGkkMSk7IH1cbiAgLy8gRnVuY3Rpb24ga2V5c1xuICBmb3IgKHZhciBpJDIgPSAxOyBpJDIgPD0gMTI7IGkkMisrKSB7IGtleU5hbWVzW2kkMiArIDExMV0gPSBrZXlOYW1lc1tpJDIgKyA2MzIzNV0gPSBcIkZcIiArIGkkMjsgfVxuXG4gIHZhciBrZXlNYXAgPSB7fTtcblxuICBrZXlNYXAuYmFzaWMgPSB7XG4gICAgXCJMZWZ0XCI6IFwiZ29DaGFyTGVmdFwiLCBcIlJpZ2h0XCI6IFwiZ29DaGFyUmlnaHRcIiwgXCJVcFwiOiBcImdvTGluZVVwXCIsIFwiRG93blwiOiBcImdvTGluZURvd25cIixcbiAgICBcIkVuZFwiOiBcImdvTGluZUVuZFwiLCBcIkhvbWVcIjogXCJnb0xpbmVTdGFydFNtYXJ0XCIsIFwiUGFnZVVwXCI6IFwiZ29QYWdlVXBcIiwgXCJQYWdlRG93blwiOiBcImdvUGFnZURvd25cIixcbiAgICBcIkRlbGV0ZVwiOiBcImRlbENoYXJBZnRlclwiLCBcIkJhY2tzcGFjZVwiOiBcImRlbENoYXJCZWZvcmVcIiwgXCJTaGlmdC1CYWNrc3BhY2VcIjogXCJkZWxDaGFyQmVmb3JlXCIsXG4gICAgXCJUYWJcIjogXCJkZWZhdWx0VGFiXCIsIFwiU2hpZnQtVGFiXCI6IFwiaW5kZW50QXV0b1wiLFxuICAgIFwiRW50ZXJcIjogXCJuZXdsaW5lQW5kSW5kZW50XCIsIFwiSW5zZXJ0XCI6IFwidG9nZ2xlT3ZlcndyaXRlXCIsXG4gICAgXCJFc2NcIjogXCJzaW5nbGVTZWxlY3Rpb25cIlxuICB9O1xuICAvLyBOb3RlIHRoYXQgdGhlIHNhdmUgYW5kIGZpbmQtcmVsYXRlZCBjb21tYW5kcyBhcmVuJ3QgZGVmaW5lZCBieVxuICAvLyBkZWZhdWx0LiBVc2VyIGNvZGUgb3IgYWRkb25zIGNhbiBkZWZpbmUgdGhlbS4gVW5rbm93biBjb21tYW5kc1xuICAvLyBhcmUgc2ltcGx5IGlnbm9yZWQuXG4gIGtleU1hcC5wY0RlZmF1bHQgPSB7XG4gICAgXCJDdHJsLUFcIjogXCJzZWxlY3RBbGxcIiwgXCJDdHJsLURcIjogXCJkZWxldGVMaW5lXCIsIFwiQ3RybC1aXCI6IFwidW5kb1wiLCBcIlNoaWZ0LUN0cmwtWlwiOiBcInJlZG9cIiwgXCJDdHJsLVlcIjogXCJyZWRvXCIsXG4gICAgXCJDdHJsLUhvbWVcIjogXCJnb0RvY1N0YXJ0XCIsIFwiQ3RybC1FbmRcIjogXCJnb0RvY0VuZFwiLCBcIkN0cmwtVXBcIjogXCJnb0xpbmVVcFwiLCBcIkN0cmwtRG93blwiOiBcImdvTGluZURvd25cIixcbiAgICBcIkN0cmwtTGVmdFwiOiBcImdvR3JvdXBMZWZ0XCIsIFwiQ3RybC1SaWdodFwiOiBcImdvR3JvdXBSaWdodFwiLCBcIkFsdC1MZWZ0XCI6IFwiZ29MaW5lU3RhcnRcIiwgXCJBbHQtUmlnaHRcIjogXCJnb0xpbmVFbmRcIixcbiAgICBcIkN0cmwtQmFja3NwYWNlXCI6IFwiZGVsR3JvdXBCZWZvcmVcIiwgXCJDdHJsLURlbGV0ZVwiOiBcImRlbEdyb3VwQWZ0ZXJcIiwgXCJDdHJsLVNcIjogXCJzYXZlXCIsIFwiQ3RybC1GXCI6IFwiZmluZFwiLFxuICAgIFwiQ3RybC1HXCI6IFwiZmluZE5leHRcIiwgXCJTaGlmdC1DdHJsLUdcIjogXCJmaW5kUHJldlwiLCBcIlNoaWZ0LUN0cmwtRlwiOiBcInJlcGxhY2VcIiwgXCJTaGlmdC1DdHJsLVJcIjogXCJyZXBsYWNlQWxsXCIsXG4gICAgXCJDdHJsLVtcIjogXCJpbmRlbnRMZXNzXCIsIFwiQ3RybC1dXCI6IFwiaW5kZW50TW9yZVwiLFxuICAgIFwiQ3RybC1VXCI6IFwidW5kb1NlbGVjdGlvblwiLCBcIlNoaWZ0LUN0cmwtVVwiOiBcInJlZG9TZWxlY3Rpb25cIiwgXCJBbHQtVVwiOiBcInJlZG9TZWxlY3Rpb25cIixcbiAgICBcImZhbGx0aHJvdWdoXCI6IFwiYmFzaWNcIlxuICB9O1xuICAvLyBWZXJ5IGJhc2ljIHJlYWRsaW5lL2VtYWNzLXN0eWxlIGJpbmRpbmdzLCB3aGljaCBhcmUgc3RhbmRhcmQgb24gTWFjLlxuICBrZXlNYXAuZW1hY3N5ID0ge1xuICAgIFwiQ3RybC1GXCI6IFwiZ29DaGFyUmlnaHRcIiwgXCJDdHJsLUJcIjogXCJnb0NoYXJMZWZ0XCIsIFwiQ3RybC1QXCI6IFwiZ29MaW5lVXBcIiwgXCJDdHJsLU5cIjogXCJnb0xpbmVEb3duXCIsXG4gICAgXCJDdHJsLUFcIjogXCJnb0xpbmVTdGFydFwiLCBcIkN0cmwtRVwiOiBcImdvTGluZUVuZFwiLCBcIkN0cmwtVlwiOiBcImdvUGFnZURvd25cIiwgXCJTaGlmdC1DdHJsLVZcIjogXCJnb1BhZ2VVcFwiLFxuICAgIFwiQ3RybC1EXCI6IFwiZGVsQ2hhckFmdGVyXCIsIFwiQ3RybC1IXCI6IFwiZGVsQ2hhckJlZm9yZVwiLCBcIkFsdC1CYWNrc3BhY2VcIjogXCJkZWxXb3JkQmVmb3JlXCIsIFwiQ3RybC1LXCI6IFwia2lsbExpbmVcIixcbiAgICBcIkN0cmwtVFwiOiBcInRyYW5zcG9zZUNoYXJzXCIsIFwiQ3RybC1PXCI6IFwib3BlbkxpbmVcIlxuICB9O1xuICBrZXlNYXAubWFjRGVmYXVsdCA9IHtcbiAgICBcIkNtZC1BXCI6IFwic2VsZWN0QWxsXCIsIFwiQ21kLURcIjogXCJkZWxldGVMaW5lXCIsIFwiQ21kLVpcIjogXCJ1bmRvXCIsIFwiU2hpZnQtQ21kLVpcIjogXCJyZWRvXCIsIFwiQ21kLVlcIjogXCJyZWRvXCIsXG4gICAgXCJDbWQtSG9tZVwiOiBcImdvRG9jU3RhcnRcIiwgXCJDbWQtVXBcIjogXCJnb0RvY1N0YXJ0XCIsIFwiQ21kLUVuZFwiOiBcImdvRG9jRW5kXCIsIFwiQ21kLURvd25cIjogXCJnb0RvY0VuZFwiLCBcIkFsdC1MZWZ0XCI6IFwiZ29Hcm91cExlZnRcIixcbiAgICBcIkFsdC1SaWdodFwiOiBcImdvR3JvdXBSaWdodFwiLCBcIkNtZC1MZWZ0XCI6IFwiZ29MaW5lTGVmdFwiLCBcIkNtZC1SaWdodFwiOiBcImdvTGluZVJpZ2h0XCIsIFwiQWx0LUJhY2tzcGFjZVwiOiBcImRlbEdyb3VwQmVmb3JlXCIsXG4gICAgXCJDdHJsLUFsdC1CYWNrc3BhY2VcIjogXCJkZWxHcm91cEFmdGVyXCIsIFwiQWx0LURlbGV0ZVwiOiBcImRlbEdyb3VwQWZ0ZXJcIiwgXCJDbWQtU1wiOiBcInNhdmVcIiwgXCJDbWQtRlwiOiBcImZpbmRcIixcbiAgICBcIkNtZC1HXCI6IFwiZmluZE5leHRcIiwgXCJTaGlmdC1DbWQtR1wiOiBcImZpbmRQcmV2XCIsIFwiQ21kLUFsdC1GXCI6IFwicmVwbGFjZVwiLCBcIlNoaWZ0LUNtZC1BbHQtRlwiOiBcInJlcGxhY2VBbGxcIixcbiAgICBcIkNtZC1bXCI6IFwiaW5kZW50TGVzc1wiLCBcIkNtZC1dXCI6IFwiaW5kZW50TW9yZVwiLCBcIkNtZC1CYWNrc3BhY2VcIjogXCJkZWxXcmFwcGVkTGluZUxlZnRcIiwgXCJDbWQtRGVsZXRlXCI6IFwiZGVsV3JhcHBlZExpbmVSaWdodFwiLFxuICAgIFwiQ21kLVVcIjogXCJ1bmRvU2VsZWN0aW9uXCIsIFwiU2hpZnQtQ21kLVVcIjogXCJyZWRvU2VsZWN0aW9uXCIsIFwiQ3RybC1VcFwiOiBcImdvRG9jU3RhcnRcIiwgXCJDdHJsLURvd25cIjogXCJnb0RvY0VuZFwiLFxuICAgIFwiZmFsbHRocm91Z2hcIjogW1wiYmFzaWNcIiwgXCJlbWFjc3lcIl1cbiAgfTtcbiAga2V5TWFwW1wiZGVmYXVsdFwiXSA9IG1hYyA/IGtleU1hcC5tYWNEZWZhdWx0IDoga2V5TWFwLnBjRGVmYXVsdDtcblxuICAvLyBLRVlNQVAgRElTUEFUQ0hcblxuICBmdW5jdGlvbiBub3JtYWxpemVLZXlOYW1lKG5hbWUpIHtcbiAgICB2YXIgcGFydHMgPSBuYW1lLnNwbGl0KC8tKD8hJCkvKTtcbiAgICBuYW1lID0gcGFydHNbcGFydHMubGVuZ3RoIC0gMV07XG4gICAgdmFyIGFsdCwgY3RybCwgc2hpZnQsIGNtZDtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IHBhcnRzLmxlbmd0aCAtIDE7IGkrKykge1xuICAgICAgdmFyIG1vZCA9IHBhcnRzW2ldO1xuICAgICAgaWYgKC9eKGNtZHxtZXRhfG0pJC9pLnRlc3QobW9kKSkgeyBjbWQgPSB0cnVlOyB9XG4gICAgICBlbHNlIGlmICgvXmEobHQpPyQvaS50ZXN0KG1vZCkpIHsgYWx0ID0gdHJ1ZTsgfVxuICAgICAgZWxzZSBpZiAoL14oY3xjdHJsfGNvbnRyb2wpJC9pLnRlc3QobW9kKSkgeyBjdHJsID0gdHJ1ZTsgfVxuICAgICAgZWxzZSBpZiAoL15zKGhpZnQpPyQvaS50ZXN0KG1vZCkpIHsgc2hpZnQgPSB0cnVlOyB9XG4gICAgICBlbHNlIHsgdGhyb3cgbmV3IEVycm9yKFwiVW5yZWNvZ25pemVkIG1vZGlmaWVyIG5hbWU6IFwiICsgbW9kKSB9XG4gICAgfVxuICAgIGlmIChhbHQpIHsgbmFtZSA9IFwiQWx0LVwiICsgbmFtZTsgfVxuICAgIGlmIChjdHJsKSB7IG5hbWUgPSBcIkN0cmwtXCIgKyBuYW1lOyB9XG4gICAgaWYgKGNtZCkgeyBuYW1lID0gXCJDbWQtXCIgKyBuYW1lOyB9XG4gICAgaWYgKHNoaWZ0KSB7IG5hbWUgPSBcIlNoaWZ0LVwiICsgbmFtZTsgfVxuICAgIHJldHVybiBuYW1lXG4gIH1cblxuICAvLyBUaGlzIGlzIGEga2x1ZGdlIHRvIGtlZXAga2V5bWFwcyBtb3N0bHkgd29ya2luZyBhcyByYXcgb2JqZWN0c1xuICAvLyAoYmFja3dhcmRzIGNvbXBhdGliaWxpdHkpIHdoaWxlIGF0IHRoZSBzYW1lIHRpbWUgc3VwcG9ydCBmZWF0dXJlc1xuICAvLyBsaWtlIG5vcm1hbGl6YXRpb24gYW5kIG11bHRpLXN0cm9rZSBrZXkgYmluZGluZ3MuIEl0IGNvbXBpbGVzIGFcbiAgLy8gbmV3IG5vcm1hbGl6ZWQga2V5bWFwLCBhbmQgdGhlbiB1cGRhdGVzIHRoZSBvbGQgb2JqZWN0IHRvIHJlZmxlY3RcbiAgLy8gdGhpcy5cbiAgZnVuY3Rpb24gbm9ybWFsaXplS2V5TWFwKGtleW1hcCkge1xuICAgIHZhciBjb3B5ID0ge307XG4gICAgZm9yICh2YXIga2V5bmFtZSBpbiBrZXltYXApIHsgaWYgKGtleW1hcC5oYXNPd25Qcm9wZXJ0eShrZXluYW1lKSkge1xuICAgICAgdmFyIHZhbHVlID0ga2V5bWFwW2tleW5hbWVdO1xuICAgICAgaWYgKC9eKG5hbWV8ZmFsbHRocm91Z2h8KGRlfGF0KXRhY2gpJC8udGVzdChrZXluYW1lKSkgeyBjb250aW51ZSB9XG4gICAgICBpZiAodmFsdWUgPT0gXCIuLi5cIikgeyBkZWxldGUga2V5bWFwW2tleW5hbWVdOyBjb250aW51ZSB9XG5cbiAgICAgIHZhciBrZXlzID0gbWFwKGtleW5hbWUuc3BsaXQoXCIgXCIpLCBub3JtYWxpemVLZXlOYW1lKTtcbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwga2V5cy5sZW5ndGg7IGkrKykge1xuICAgICAgICB2YXIgdmFsID0gKHZvaWQgMCksIG5hbWUgPSAodm9pZCAwKTtcbiAgICAgICAgaWYgKGkgPT0ga2V5cy5sZW5ndGggLSAxKSB7XG4gICAgICAgICAgbmFtZSA9IGtleXMuam9pbihcIiBcIik7XG4gICAgICAgICAgdmFsID0gdmFsdWU7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgbmFtZSA9IGtleXMuc2xpY2UoMCwgaSArIDEpLmpvaW4oXCIgXCIpO1xuICAgICAgICAgIHZhbCA9IFwiLi4uXCI7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIHByZXYgPSBjb3B5W25hbWVdO1xuICAgICAgICBpZiAoIXByZXYpIHsgY29weVtuYW1lXSA9IHZhbDsgfVxuICAgICAgICBlbHNlIGlmIChwcmV2ICE9IHZhbCkgeyB0aHJvdyBuZXcgRXJyb3IoXCJJbmNvbnNpc3RlbnQgYmluZGluZ3MgZm9yIFwiICsgbmFtZSkgfVxuICAgICAgfVxuICAgICAgZGVsZXRlIGtleW1hcFtrZXluYW1lXTtcbiAgICB9IH1cbiAgICBmb3IgKHZhciBwcm9wIGluIGNvcHkpIHsga2V5bWFwW3Byb3BdID0gY29weVtwcm9wXTsgfVxuICAgIHJldHVybiBrZXltYXBcbiAgfVxuXG4gIGZ1bmN0aW9uIGxvb2t1cEtleShrZXksIG1hcCwgaGFuZGxlLCBjb250ZXh0KSB7XG4gICAgbWFwID0gZ2V0S2V5TWFwKG1hcCk7XG4gICAgdmFyIGZvdW5kID0gbWFwLmNhbGwgPyBtYXAuY2FsbChrZXksIGNvbnRleHQpIDogbWFwW2tleV07XG4gICAgaWYgKGZvdW5kID09PSBmYWxzZSkgeyByZXR1cm4gXCJub3RoaW5nXCIgfVxuICAgIGlmIChmb3VuZCA9PT0gXCIuLi5cIikgeyByZXR1cm4gXCJtdWx0aVwiIH1cbiAgICBpZiAoZm91bmQgIT0gbnVsbCAmJiBoYW5kbGUoZm91bmQpKSB7IHJldHVybiBcImhhbmRsZWRcIiB9XG5cbiAgICBpZiAobWFwLmZhbGx0aHJvdWdoKSB7XG4gICAgICBpZiAoT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZy5jYWxsKG1hcC5mYWxsdGhyb3VnaCkgIT0gXCJbb2JqZWN0IEFycmF5XVwiKVxuICAgICAgICB7IHJldHVybiBsb29rdXBLZXkoa2V5LCBtYXAuZmFsbHRocm91Z2gsIGhhbmRsZSwgY29udGV4dCkgfVxuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBtYXAuZmFsbHRocm91Z2gubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgdmFyIHJlc3VsdCA9IGxvb2t1cEtleShrZXksIG1hcC5mYWxsdGhyb3VnaFtpXSwgaGFuZGxlLCBjb250ZXh0KTtcbiAgICAgICAgaWYgKHJlc3VsdCkgeyByZXR1cm4gcmVzdWx0IH1cbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICAvLyBNb2RpZmllciBrZXkgcHJlc3NlcyBkb24ndCBjb3VudCBhcyAncmVhbCcga2V5IHByZXNzZXMgZm9yIHRoZVxuICAvLyBwdXJwb3NlIG9mIGtleW1hcCBmYWxsdGhyb3VnaC5cbiAgZnVuY3Rpb24gaXNNb2RpZmllcktleSh2YWx1ZSkge1xuICAgIHZhciBuYW1lID0gdHlwZW9mIHZhbHVlID09IFwic3RyaW5nXCIgPyB2YWx1ZSA6IGtleU5hbWVzW3ZhbHVlLmtleUNvZGVdO1xuICAgIHJldHVybiBuYW1lID09IFwiQ3RybFwiIHx8IG5hbWUgPT0gXCJBbHRcIiB8fCBuYW1lID09IFwiU2hpZnRcIiB8fCBuYW1lID09IFwiTW9kXCJcbiAgfVxuXG4gIGZ1bmN0aW9uIGFkZE1vZGlmaWVyTmFtZXMobmFtZSwgZXZlbnQsIG5vU2hpZnQpIHtcbiAgICB2YXIgYmFzZSA9IG5hbWU7XG4gICAgaWYgKGV2ZW50LmFsdEtleSAmJiBiYXNlICE9IFwiQWx0XCIpIHsgbmFtZSA9IFwiQWx0LVwiICsgbmFtZTsgfVxuICAgIGlmICgoZmxpcEN0cmxDbWQgPyBldmVudC5tZXRhS2V5IDogZXZlbnQuY3RybEtleSkgJiYgYmFzZSAhPSBcIkN0cmxcIikgeyBuYW1lID0gXCJDdHJsLVwiICsgbmFtZTsgfVxuICAgIGlmICgoZmxpcEN0cmxDbWQgPyBldmVudC5jdHJsS2V5IDogZXZlbnQubWV0YUtleSkgJiYgYmFzZSAhPSBcIk1vZFwiKSB7IG5hbWUgPSBcIkNtZC1cIiArIG5hbWU7IH1cbiAgICBpZiAoIW5vU2hpZnQgJiYgZXZlbnQuc2hpZnRLZXkgJiYgYmFzZSAhPSBcIlNoaWZ0XCIpIHsgbmFtZSA9IFwiU2hpZnQtXCIgKyBuYW1lOyB9XG4gICAgcmV0dXJuIG5hbWVcbiAgfVxuXG4gIC8vIExvb2sgdXAgdGhlIG5hbWUgb2YgYSBrZXkgYXMgaW5kaWNhdGVkIGJ5IGFuIGV2ZW50IG9iamVjdC5cbiAgZnVuY3Rpb24ga2V5TmFtZShldmVudCwgbm9TaGlmdCkge1xuICAgIGlmIChwcmVzdG8gJiYgZXZlbnQua2V5Q29kZSA9PSAzNCAmJiBldmVudFtcImNoYXJcIl0pIHsgcmV0dXJuIGZhbHNlIH1cbiAgICB2YXIgbmFtZSA9IGtleU5hbWVzW2V2ZW50LmtleUNvZGVdO1xuICAgIGlmIChuYW1lID09IG51bGwgfHwgZXZlbnQuYWx0R3JhcGhLZXkpIHsgcmV0dXJuIGZhbHNlIH1cbiAgICAvLyBDdHJsLVNjcm9sbExvY2sgaGFzIGtleUNvZGUgMywgc2FtZSBhcyBDdHJsLVBhdXNlLFxuICAgIC8vIHNvIHdlJ2xsIHVzZSBldmVudC5jb2RlIHdoZW4gYXZhaWxhYmxlIChDaHJvbWUgNDgrLCBGRiAzOCssIFNhZmFyaSAxMC4xKylcbiAgICBpZiAoZXZlbnQua2V5Q29kZSA9PSAzICYmIGV2ZW50LmNvZGUpIHsgbmFtZSA9IGV2ZW50LmNvZGU7IH1cbiAgICByZXR1cm4gYWRkTW9kaWZpZXJOYW1lcyhuYW1lLCBldmVudCwgbm9TaGlmdClcbiAgfVxuXG4gIGZ1bmN0aW9uIGdldEtleU1hcCh2YWwpIHtcbiAgICByZXR1cm4gdHlwZW9mIHZhbCA9PSBcInN0cmluZ1wiID8ga2V5TWFwW3ZhbF0gOiB2YWxcbiAgfVxuXG4gIC8vIEhlbHBlciBmb3IgZGVsZXRpbmcgdGV4dCBuZWFyIHRoZSBzZWxlY3Rpb24ocyksIHVzZWQgdG8gaW1wbGVtZW50XG4gIC8vIGJhY2tzcGFjZSwgZGVsZXRlLCBhbmQgc2ltaWxhciBmdW5jdGlvbmFsaXR5LlxuICBmdW5jdGlvbiBkZWxldGVOZWFyU2VsZWN0aW9uKGNtLCBjb21wdXRlKSB7XG4gICAgdmFyIHJhbmdlcyA9IGNtLmRvYy5zZWwucmFuZ2VzLCBraWxsID0gW107XG4gICAgLy8gQnVpbGQgdXAgYSBzZXQgb2YgcmFuZ2VzIHRvIGtpbGwgZmlyc3QsIG1lcmdpbmcgb3ZlcmxhcHBpbmdcbiAgICAvLyByYW5nZXMuXG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCByYW5nZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgIHZhciB0b0tpbGwgPSBjb21wdXRlKHJhbmdlc1tpXSk7XG4gICAgICB3aGlsZSAoa2lsbC5sZW5ndGggJiYgY21wKHRvS2lsbC5mcm9tLCBsc3Qoa2lsbCkudG8pIDw9IDApIHtcbiAgICAgICAgdmFyIHJlcGxhY2VkID0ga2lsbC5wb3AoKTtcbiAgICAgICAgaWYgKGNtcChyZXBsYWNlZC5mcm9tLCB0b0tpbGwuZnJvbSkgPCAwKSB7XG4gICAgICAgICAgdG9LaWxsLmZyb20gPSByZXBsYWNlZC5mcm9tO1xuICAgICAgICAgIGJyZWFrXG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGtpbGwucHVzaCh0b0tpbGwpO1xuICAgIH1cbiAgICAvLyBOZXh0LCByZW1vdmUgdGhvc2UgYWN0dWFsIHJhbmdlcy5cbiAgICBydW5Jbk9wKGNtLCBmdW5jdGlvbiAoKSB7XG4gICAgICBmb3IgKHZhciBpID0ga2lsbC5sZW5ndGggLSAxOyBpID49IDA7IGktLSlcbiAgICAgICAgeyByZXBsYWNlUmFuZ2UoY20uZG9jLCBcIlwiLCBraWxsW2ldLmZyb20sIGtpbGxbaV0udG8sIFwiK2RlbGV0ZVwiKTsgfVxuICAgICAgZW5zdXJlQ3Vyc29yVmlzaWJsZShjbSk7XG4gICAgfSk7XG4gIH1cblxuICBmdW5jdGlvbiBtb3ZlQ2hhckxvZ2ljYWxseShsaW5lLCBjaCwgZGlyKSB7XG4gICAgdmFyIHRhcmdldCA9IHNraXBFeHRlbmRpbmdDaGFycyhsaW5lLnRleHQsIGNoICsgZGlyLCBkaXIpO1xuICAgIHJldHVybiB0YXJnZXQgPCAwIHx8IHRhcmdldCA+IGxpbmUudGV4dC5sZW5ndGggPyBudWxsIDogdGFyZ2V0XG4gIH1cblxuICBmdW5jdGlvbiBtb3ZlTG9naWNhbGx5KGxpbmUsIHN0YXJ0LCBkaXIpIHtcbiAgICB2YXIgY2ggPSBtb3ZlQ2hhckxvZ2ljYWxseShsaW5lLCBzdGFydC5jaCwgZGlyKTtcbiAgICByZXR1cm4gY2ggPT0gbnVsbCA/IG51bGwgOiBuZXcgUG9zKHN0YXJ0LmxpbmUsIGNoLCBkaXIgPCAwID8gXCJhZnRlclwiIDogXCJiZWZvcmVcIilcbiAgfVxuXG4gIGZ1bmN0aW9uIGVuZE9mTGluZSh2aXN1YWxseSwgY20sIGxpbmVPYmosIGxpbmVObywgZGlyKSB7XG4gICAgaWYgKHZpc3VhbGx5KSB7XG4gICAgICBpZiAoY20uZG9jLmRpcmVjdGlvbiA9PSBcInJ0bFwiKSB7IGRpciA9IC1kaXI7IH1cbiAgICAgIHZhciBvcmRlciA9IGdldE9yZGVyKGxpbmVPYmosIGNtLmRvYy5kaXJlY3Rpb24pO1xuICAgICAgaWYgKG9yZGVyKSB7XG4gICAgICAgIHZhciBwYXJ0ID0gZGlyIDwgMCA/IGxzdChvcmRlcikgOiBvcmRlclswXTtcbiAgICAgICAgdmFyIG1vdmVJblN0b3JhZ2VPcmRlciA9IChkaXIgPCAwKSA9PSAocGFydC5sZXZlbCA9PSAxKTtcbiAgICAgICAgdmFyIHN0aWNreSA9IG1vdmVJblN0b3JhZ2VPcmRlciA/IFwiYWZ0ZXJcIiA6IFwiYmVmb3JlXCI7XG4gICAgICAgIHZhciBjaDtcbiAgICAgICAgLy8gV2l0aCBhIHdyYXBwZWQgcnRsIGNodW5rIChwb3NzaWJseSBzcGFubmluZyBtdWx0aXBsZSBiaWRpIHBhcnRzKSxcbiAgICAgICAgLy8gaXQgY291bGQgYmUgdGhhdCB0aGUgbGFzdCBiaWRpIHBhcnQgaXMgbm90IG9uIHRoZSBsYXN0IHZpc3VhbCBsaW5lLFxuICAgICAgICAvLyBzaW5jZSB2aXN1YWwgbGluZXMgY29udGFpbiBjb250ZW50IG9yZGVyLWNvbnNlY3V0aXZlIGNodW5rcy5cbiAgICAgICAgLy8gVGh1cywgaW4gcnRsLCB3ZSBhcmUgbG9va2luZyBmb3IgdGhlIGZpcnN0IChjb250ZW50LW9yZGVyKSBjaGFyYWN0ZXJcbiAgICAgICAgLy8gaW4gdGhlIHJ0bCBjaHVuayB0aGF0IGlzIG9uIHRoZSBsYXN0IGxpbmUgKHRoYXQgaXMsIHRoZSBzYW1lIGxpbmVcbiAgICAgICAgLy8gYXMgdGhlIGxhc3QgKGNvbnRlbnQtb3JkZXIpIGNoYXJhY3RlcikuXG4gICAgICAgIGlmIChwYXJ0LmxldmVsID4gMCB8fCBjbS5kb2MuZGlyZWN0aW9uID09IFwicnRsXCIpIHtcbiAgICAgICAgICB2YXIgcHJlcCA9IHByZXBhcmVNZWFzdXJlRm9yTGluZShjbSwgbGluZU9iaik7XG4gICAgICAgICAgY2ggPSBkaXIgPCAwID8gbGluZU9iai50ZXh0Lmxlbmd0aCAtIDEgOiAwO1xuICAgICAgICAgIHZhciB0YXJnZXRUb3AgPSBtZWFzdXJlQ2hhclByZXBhcmVkKGNtLCBwcmVwLCBjaCkudG9wO1xuICAgICAgICAgIGNoID0gZmluZEZpcnN0KGZ1bmN0aW9uIChjaCkgeyByZXR1cm4gbWVhc3VyZUNoYXJQcmVwYXJlZChjbSwgcHJlcCwgY2gpLnRvcCA9PSB0YXJnZXRUb3A7IH0sIChkaXIgPCAwKSA9PSAocGFydC5sZXZlbCA9PSAxKSA/IHBhcnQuZnJvbSA6IHBhcnQudG8gLSAxLCBjaCk7XG4gICAgICAgICAgaWYgKHN0aWNreSA9PSBcImJlZm9yZVwiKSB7IGNoID0gbW92ZUNoYXJMb2dpY2FsbHkobGluZU9iaiwgY2gsIDEpOyB9XG4gICAgICAgIH0gZWxzZSB7IGNoID0gZGlyIDwgMCA/IHBhcnQudG8gOiBwYXJ0LmZyb207IH1cbiAgICAgICAgcmV0dXJuIG5ldyBQb3MobGluZU5vLCBjaCwgc3RpY2t5KVxuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gbmV3IFBvcyhsaW5lTm8sIGRpciA8IDAgPyBsaW5lT2JqLnRleHQubGVuZ3RoIDogMCwgZGlyIDwgMCA/IFwiYmVmb3JlXCIgOiBcImFmdGVyXCIpXG4gIH1cblxuICBmdW5jdGlvbiBtb3ZlVmlzdWFsbHkoY20sIGxpbmUsIHN0YXJ0LCBkaXIpIHtcbiAgICB2YXIgYmlkaSA9IGdldE9yZGVyKGxpbmUsIGNtLmRvYy5kaXJlY3Rpb24pO1xuICAgIGlmICghYmlkaSkgeyByZXR1cm4gbW92ZUxvZ2ljYWxseShsaW5lLCBzdGFydCwgZGlyKSB9XG4gICAgaWYgKHN0YXJ0LmNoID49IGxpbmUudGV4dC5sZW5ndGgpIHtcbiAgICAgIHN0YXJ0LmNoID0gbGluZS50ZXh0Lmxlbmd0aDtcbiAgICAgIHN0YXJ0LnN0aWNreSA9IFwiYmVmb3JlXCI7XG4gICAgfSBlbHNlIGlmIChzdGFydC5jaCA8PSAwKSB7XG4gICAgICBzdGFydC5jaCA9IDA7XG4gICAgICBzdGFydC5zdGlja3kgPSBcImFmdGVyXCI7XG4gICAgfVxuICAgIHZhciBwYXJ0UG9zID0gZ2V0QmlkaVBhcnRBdChiaWRpLCBzdGFydC5jaCwgc3RhcnQuc3RpY2t5KSwgcGFydCA9IGJpZGlbcGFydFBvc107XG4gICAgaWYgKGNtLmRvYy5kaXJlY3Rpb24gPT0gXCJsdHJcIiAmJiBwYXJ0LmxldmVsICUgMiA9PSAwICYmIChkaXIgPiAwID8gcGFydC50byA+IHN0YXJ0LmNoIDogcGFydC5mcm9tIDwgc3RhcnQuY2gpKSB7XG4gICAgICAvLyBDYXNlIDE6IFdlIG1vdmUgd2l0aGluIGFuIGx0ciBwYXJ0IGluIGFuIGx0ciBlZGl0b3IuIEV2ZW4gd2l0aCB3cmFwcGVkIGxpbmVzLFxuICAgICAgLy8gbm90aGluZyBpbnRlcmVzdGluZyBoYXBwZW5zLlxuICAgICAgcmV0dXJuIG1vdmVMb2dpY2FsbHkobGluZSwgc3RhcnQsIGRpcilcbiAgICB9XG5cbiAgICB2YXIgbXYgPSBmdW5jdGlvbiAocG9zLCBkaXIpIHsgcmV0dXJuIG1vdmVDaGFyTG9naWNhbGx5KGxpbmUsIHBvcyBpbnN0YW5jZW9mIFBvcyA/IHBvcy5jaCA6IHBvcywgZGlyKTsgfTtcbiAgICB2YXIgcHJlcDtcbiAgICB2YXIgZ2V0V3JhcHBlZExpbmVFeHRlbnQgPSBmdW5jdGlvbiAoY2gpIHtcbiAgICAgIGlmICghY20ub3B0aW9ucy5saW5lV3JhcHBpbmcpIHsgcmV0dXJuIHtiZWdpbjogMCwgZW5kOiBsaW5lLnRleHQubGVuZ3RofSB9XG4gICAgICBwcmVwID0gcHJlcCB8fCBwcmVwYXJlTWVhc3VyZUZvckxpbmUoY20sIGxpbmUpO1xuICAgICAgcmV0dXJuIHdyYXBwZWRMaW5lRXh0ZW50Q2hhcihjbSwgbGluZSwgcHJlcCwgY2gpXG4gICAgfTtcbiAgICB2YXIgd3JhcHBlZExpbmVFeHRlbnQgPSBnZXRXcmFwcGVkTGluZUV4dGVudChzdGFydC5zdGlja3kgPT0gXCJiZWZvcmVcIiA/IG12KHN0YXJ0LCAtMSkgOiBzdGFydC5jaCk7XG5cbiAgICBpZiAoY20uZG9jLmRpcmVjdGlvbiA9PSBcInJ0bFwiIHx8IHBhcnQubGV2ZWwgPT0gMSkge1xuICAgICAgdmFyIG1vdmVJblN0b3JhZ2VPcmRlciA9IChwYXJ0LmxldmVsID09IDEpID09IChkaXIgPCAwKTtcbiAgICAgIHZhciBjaCA9IG12KHN0YXJ0LCBtb3ZlSW5TdG9yYWdlT3JkZXIgPyAxIDogLTEpO1xuICAgICAgaWYgKGNoICE9IG51bGwgJiYgKCFtb3ZlSW5TdG9yYWdlT3JkZXIgPyBjaCA+PSBwYXJ0LmZyb20gJiYgY2ggPj0gd3JhcHBlZExpbmVFeHRlbnQuYmVnaW4gOiBjaCA8PSBwYXJ0LnRvICYmIGNoIDw9IHdyYXBwZWRMaW5lRXh0ZW50LmVuZCkpIHtcbiAgICAgICAgLy8gQ2FzZSAyOiBXZSBtb3ZlIHdpdGhpbiBhbiBydGwgcGFydCBvciBpbiBhbiBydGwgZWRpdG9yIG9uIHRoZSBzYW1lIHZpc3VhbCBsaW5lXG4gICAgICAgIHZhciBzdGlja3kgPSBtb3ZlSW5TdG9yYWdlT3JkZXIgPyBcImJlZm9yZVwiIDogXCJhZnRlclwiO1xuICAgICAgICByZXR1cm4gbmV3IFBvcyhzdGFydC5saW5lLCBjaCwgc3RpY2t5KVxuICAgICAgfVxuICAgIH1cblxuICAgIC8vIENhc2UgMzogQ291bGQgbm90IG1vdmUgd2l0aGluIHRoaXMgYmlkaSBwYXJ0IGluIHRoaXMgdmlzdWFsIGxpbmUsIHNvIGxlYXZlXG4gICAgLy8gdGhlIGN1cnJlbnQgYmlkaSBwYXJ0XG5cbiAgICB2YXIgc2VhcmNoSW5WaXN1YWxMaW5lID0gZnVuY3Rpb24gKHBhcnRQb3MsIGRpciwgd3JhcHBlZExpbmVFeHRlbnQpIHtcbiAgICAgIHZhciBnZXRSZXMgPSBmdW5jdGlvbiAoY2gsIG1vdmVJblN0b3JhZ2VPcmRlcikgeyByZXR1cm4gbW92ZUluU3RvcmFnZU9yZGVyXG4gICAgICAgID8gbmV3IFBvcyhzdGFydC5saW5lLCBtdihjaCwgMSksIFwiYmVmb3JlXCIpXG4gICAgICAgIDogbmV3IFBvcyhzdGFydC5saW5lLCBjaCwgXCJhZnRlclwiKTsgfTtcblxuICAgICAgZm9yICg7IHBhcnRQb3MgPj0gMCAmJiBwYXJ0UG9zIDwgYmlkaS5sZW5ndGg7IHBhcnRQb3MgKz0gZGlyKSB7XG4gICAgICAgIHZhciBwYXJ0ID0gYmlkaVtwYXJ0UG9zXTtcbiAgICAgICAgdmFyIG1vdmVJblN0b3JhZ2VPcmRlciA9IChkaXIgPiAwKSA9PSAocGFydC5sZXZlbCAhPSAxKTtcbiAgICAgICAgdmFyIGNoID0gbW92ZUluU3RvcmFnZU9yZGVyID8gd3JhcHBlZExpbmVFeHRlbnQuYmVnaW4gOiBtdih3cmFwcGVkTGluZUV4dGVudC5lbmQsIC0xKTtcbiAgICAgICAgaWYgKHBhcnQuZnJvbSA8PSBjaCAmJiBjaCA8IHBhcnQudG8pIHsgcmV0dXJuIGdldFJlcyhjaCwgbW92ZUluU3RvcmFnZU9yZGVyKSB9XG4gICAgICAgIGNoID0gbW92ZUluU3RvcmFnZU9yZGVyID8gcGFydC5mcm9tIDogbXYocGFydC50bywgLTEpO1xuICAgICAgICBpZiAod3JhcHBlZExpbmVFeHRlbnQuYmVnaW4gPD0gY2ggJiYgY2ggPCB3cmFwcGVkTGluZUV4dGVudC5lbmQpIHsgcmV0dXJuIGdldFJlcyhjaCwgbW92ZUluU3RvcmFnZU9yZGVyKSB9XG4gICAgICB9XG4gICAgfTtcblxuICAgIC8vIENhc2UgM2E6IExvb2sgZm9yIG90aGVyIGJpZGkgcGFydHMgb24gdGhlIHNhbWUgdmlzdWFsIGxpbmVcbiAgICB2YXIgcmVzID0gc2VhcmNoSW5WaXN1YWxMaW5lKHBhcnRQb3MgKyBkaXIsIGRpciwgd3JhcHBlZExpbmVFeHRlbnQpO1xuICAgIGlmIChyZXMpIHsgcmV0dXJuIHJlcyB9XG5cbiAgICAvLyBDYXNlIDNiOiBMb29rIGZvciBvdGhlciBiaWRpIHBhcnRzIG9uIHRoZSBuZXh0IHZpc3VhbCBsaW5lXG4gICAgdmFyIG5leHRDaCA9IGRpciA+IDAgPyB3cmFwcGVkTGluZUV4dGVudC5lbmQgOiBtdih3cmFwcGVkTGluZUV4dGVudC5iZWdpbiwgLTEpO1xuICAgIGlmIChuZXh0Q2ggIT0gbnVsbCAmJiAhKGRpciA+IDAgJiYgbmV4dENoID09IGxpbmUudGV4dC5sZW5ndGgpKSB7XG4gICAgICByZXMgPSBzZWFyY2hJblZpc3VhbExpbmUoZGlyID4gMCA/IDAgOiBiaWRpLmxlbmd0aCAtIDEsIGRpciwgZ2V0V3JhcHBlZExpbmVFeHRlbnQobmV4dENoKSk7XG4gICAgICBpZiAocmVzKSB7IHJldHVybiByZXMgfVxuICAgIH1cblxuICAgIC8vIENhc2UgNDogTm93aGVyZSB0byBtb3ZlXG4gICAgcmV0dXJuIG51bGxcbiAgfVxuXG4gIC8vIENvbW1hbmRzIGFyZSBwYXJhbWV0ZXItbGVzcyBhY3Rpb25zIHRoYXQgY2FuIGJlIHBlcmZvcm1lZCBvbiBhblxuICAvLyBlZGl0b3IsIG1vc3RseSB1c2VkIGZvciBrZXliaW5kaW5ncy5cbiAgdmFyIGNvbW1hbmRzID0ge1xuICAgIHNlbGVjdEFsbDogc2VsZWN0QWxsLFxuICAgIHNpbmdsZVNlbGVjdGlvbjogZnVuY3Rpb24gKGNtKSB7IHJldHVybiBjbS5zZXRTZWxlY3Rpb24oY20uZ2V0Q3Vyc29yKFwiYW5jaG9yXCIpLCBjbS5nZXRDdXJzb3IoXCJoZWFkXCIpLCBzZWxfZG9udFNjcm9sbCk7IH0sXG4gICAga2lsbExpbmU6IGZ1bmN0aW9uIChjbSkgeyByZXR1cm4gZGVsZXRlTmVhclNlbGVjdGlvbihjbSwgZnVuY3Rpb24gKHJhbmdlKSB7XG4gICAgICBpZiAocmFuZ2UuZW1wdHkoKSkge1xuICAgICAgICB2YXIgbGVuID0gZ2V0TGluZShjbS5kb2MsIHJhbmdlLmhlYWQubGluZSkudGV4dC5sZW5ndGg7XG4gICAgICAgIGlmIChyYW5nZS5oZWFkLmNoID09IGxlbiAmJiByYW5nZS5oZWFkLmxpbmUgPCBjbS5sYXN0TGluZSgpKVxuICAgICAgICAgIHsgcmV0dXJuIHtmcm9tOiByYW5nZS5oZWFkLCB0bzogUG9zKHJhbmdlLmhlYWQubGluZSArIDEsIDApfSB9XG4gICAgICAgIGVsc2VcbiAgICAgICAgICB7IHJldHVybiB7ZnJvbTogcmFuZ2UuaGVhZCwgdG86IFBvcyhyYW5nZS5oZWFkLmxpbmUsIGxlbil9IH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHJldHVybiB7ZnJvbTogcmFuZ2UuZnJvbSgpLCB0bzogcmFuZ2UudG8oKX1cbiAgICAgIH1cbiAgICB9KTsgfSxcbiAgICBkZWxldGVMaW5lOiBmdW5jdGlvbiAoY20pIHsgcmV0dXJuIGRlbGV0ZU5lYXJTZWxlY3Rpb24oY20sIGZ1bmN0aW9uIChyYW5nZSkgeyByZXR1cm4gKHtcbiAgICAgIGZyb206IFBvcyhyYW5nZS5mcm9tKCkubGluZSwgMCksXG4gICAgICB0bzogY2xpcFBvcyhjbS5kb2MsIFBvcyhyYW5nZS50bygpLmxpbmUgKyAxLCAwKSlcbiAgICB9KTsgfSk7IH0sXG4gICAgZGVsTGluZUxlZnQ6IGZ1bmN0aW9uIChjbSkgeyByZXR1cm4gZGVsZXRlTmVhclNlbGVjdGlvbihjbSwgZnVuY3Rpb24gKHJhbmdlKSB7IHJldHVybiAoe1xuICAgICAgZnJvbTogUG9zKHJhbmdlLmZyb20oKS5saW5lLCAwKSwgdG86IHJhbmdlLmZyb20oKVxuICAgIH0pOyB9KTsgfSxcbiAgICBkZWxXcmFwcGVkTGluZUxlZnQ6IGZ1bmN0aW9uIChjbSkgeyByZXR1cm4gZGVsZXRlTmVhclNlbGVjdGlvbihjbSwgZnVuY3Rpb24gKHJhbmdlKSB7XG4gICAgICB2YXIgdG9wID0gY20uY2hhckNvb3JkcyhyYW5nZS5oZWFkLCBcImRpdlwiKS50b3AgKyA1O1xuICAgICAgdmFyIGxlZnRQb3MgPSBjbS5jb29yZHNDaGFyKHtsZWZ0OiAwLCB0b3A6IHRvcH0sIFwiZGl2XCIpO1xuICAgICAgcmV0dXJuIHtmcm9tOiBsZWZ0UG9zLCB0bzogcmFuZ2UuZnJvbSgpfVxuICAgIH0pOyB9LFxuICAgIGRlbFdyYXBwZWRMaW5lUmlnaHQ6IGZ1bmN0aW9uIChjbSkgeyByZXR1cm4gZGVsZXRlTmVhclNlbGVjdGlvbihjbSwgZnVuY3Rpb24gKHJhbmdlKSB7XG4gICAgICB2YXIgdG9wID0gY20uY2hhckNvb3JkcyhyYW5nZS5oZWFkLCBcImRpdlwiKS50b3AgKyA1O1xuICAgICAgdmFyIHJpZ2h0UG9zID0gY20uY29vcmRzQ2hhcih7bGVmdDogY20uZGlzcGxheS5saW5lRGl2Lm9mZnNldFdpZHRoICsgMTAwLCB0b3A6IHRvcH0sIFwiZGl2XCIpO1xuICAgICAgcmV0dXJuIHtmcm9tOiByYW5nZS5mcm9tKCksIHRvOiByaWdodFBvcyB9XG4gICAgfSk7IH0sXG4gICAgdW5kbzogZnVuY3Rpb24gKGNtKSB7IHJldHVybiBjbS51bmRvKCk7IH0sXG4gICAgcmVkbzogZnVuY3Rpb24gKGNtKSB7IHJldHVybiBjbS5yZWRvKCk7IH0sXG4gICAgdW5kb1NlbGVjdGlvbjogZnVuY3Rpb24gKGNtKSB7IHJldHVybiBjbS51bmRvU2VsZWN0aW9uKCk7IH0sXG4gICAgcmVkb1NlbGVjdGlvbjogZnVuY3Rpb24gKGNtKSB7IHJldHVybiBjbS5yZWRvU2VsZWN0aW9uKCk7IH0sXG4gICAgZ29Eb2NTdGFydDogZnVuY3Rpb24gKGNtKSB7IHJldHVybiBjbS5leHRlbmRTZWxlY3Rpb24oUG9zKGNtLmZpcnN0TGluZSgpLCAwKSk7IH0sXG4gICAgZ29Eb2NFbmQ6IGZ1bmN0aW9uIChjbSkgeyByZXR1cm4gY20uZXh0ZW5kU2VsZWN0aW9uKFBvcyhjbS5sYXN0TGluZSgpKSk7IH0sXG4gICAgZ29MaW5lU3RhcnQ6IGZ1bmN0aW9uIChjbSkgeyByZXR1cm4gY20uZXh0ZW5kU2VsZWN0aW9uc0J5KGZ1bmN0aW9uIChyYW5nZSkgeyByZXR1cm4gbGluZVN0YXJ0KGNtLCByYW5nZS5oZWFkLmxpbmUpOyB9LFxuICAgICAge29yaWdpbjogXCIrbW92ZVwiLCBiaWFzOiAxfVxuICAgICk7IH0sXG4gICAgZ29MaW5lU3RhcnRTbWFydDogZnVuY3Rpb24gKGNtKSB7IHJldHVybiBjbS5leHRlbmRTZWxlY3Rpb25zQnkoZnVuY3Rpb24gKHJhbmdlKSB7IHJldHVybiBsaW5lU3RhcnRTbWFydChjbSwgcmFuZ2UuaGVhZCk7IH0sXG4gICAgICB7b3JpZ2luOiBcIittb3ZlXCIsIGJpYXM6IDF9XG4gICAgKTsgfSxcbiAgICBnb0xpbmVFbmQ6IGZ1bmN0aW9uIChjbSkgeyByZXR1cm4gY20uZXh0ZW5kU2VsZWN0aW9uc0J5KGZ1bmN0aW9uIChyYW5nZSkgeyByZXR1cm4gbGluZUVuZChjbSwgcmFuZ2UuaGVhZC5saW5lKTsgfSxcbiAgICAgIHtvcmlnaW46IFwiK21vdmVcIiwgYmlhczogLTF9XG4gICAgKTsgfSxcbiAgICBnb0xpbmVSaWdodDogZnVuY3Rpb24gKGNtKSB7IHJldHVybiBjbS5leHRlbmRTZWxlY3Rpb25zQnkoZnVuY3Rpb24gKHJhbmdlKSB7XG4gICAgICB2YXIgdG9wID0gY20uY3Vyc29yQ29vcmRzKHJhbmdlLmhlYWQsIFwiZGl2XCIpLnRvcCArIDU7XG4gICAgICByZXR1cm4gY20uY29vcmRzQ2hhcih7bGVmdDogY20uZGlzcGxheS5saW5lRGl2Lm9mZnNldFdpZHRoICsgMTAwLCB0b3A6IHRvcH0sIFwiZGl2XCIpXG4gICAgfSwgc2VsX21vdmUpOyB9LFxuICAgIGdvTGluZUxlZnQ6IGZ1bmN0aW9uIChjbSkgeyByZXR1cm4gY20uZXh0ZW5kU2VsZWN0aW9uc0J5KGZ1bmN0aW9uIChyYW5nZSkge1xuICAgICAgdmFyIHRvcCA9IGNtLmN1cnNvckNvb3JkcyhyYW5nZS5oZWFkLCBcImRpdlwiKS50b3AgKyA1O1xuICAgICAgcmV0dXJuIGNtLmNvb3Jkc0NoYXIoe2xlZnQ6IDAsIHRvcDogdG9wfSwgXCJkaXZcIilcbiAgICB9LCBzZWxfbW92ZSk7IH0sXG4gICAgZ29MaW5lTGVmdFNtYXJ0OiBmdW5jdGlvbiAoY20pIHsgcmV0dXJuIGNtLmV4dGVuZFNlbGVjdGlvbnNCeShmdW5jdGlvbiAocmFuZ2UpIHtcbiAgICAgIHZhciB0b3AgPSBjbS5jdXJzb3JDb29yZHMocmFuZ2UuaGVhZCwgXCJkaXZcIikudG9wICsgNTtcbiAgICAgIHZhciBwb3MgPSBjbS5jb29yZHNDaGFyKHtsZWZ0OiAwLCB0b3A6IHRvcH0sIFwiZGl2XCIpO1xuICAgICAgaWYgKHBvcy5jaCA8IGNtLmdldExpbmUocG9zLmxpbmUpLnNlYXJjaCgvXFxTLykpIHsgcmV0dXJuIGxpbmVTdGFydFNtYXJ0KGNtLCByYW5nZS5oZWFkKSB9XG4gICAgICByZXR1cm4gcG9zXG4gICAgfSwgc2VsX21vdmUpOyB9LFxuICAgIGdvTGluZVVwOiBmdW5jdGlvbiAoY20pIHsgcmV0dXJuIGNtLm1vdmVWKC0xLCBcImxpbmVcIik7IH0sXG4gICAgZ29MaW5lRG93bjogZnVuY3Rpb24gKGNtKSB7IHJldHVybiBjbS5tb3ZlVigxLCBcImxpbmVcIik7IH0sXG4gICAgZ29QYWdlVXA6IGZ1bmN0aW9uIChjbSkgeyByZXR1cm4gY20ubW92ZVYoLTEsIFwicGFnZVwiKTsgfSxcbiAgICBnb1BhZ2VEb3duOiBmdW5jdGlvbiAoY20pIHsgcmV0dXJuIGNtLm1vdmVWKDEsIFwicGFnZVwiKTsgfSxcbiAgICBnb0NoYXJMZWZ0OiBmdW5jdGlvbiAoY20pIHsgcmV0dXJuIGNtLm1vdmVIKC0xLCBcImNoYXJcIik7IH0sXG4gICAgZ29DaGFyUmlnaHQ6IGZ1bmN0aW9uIChjbSkgeyByZXR1cm4gY20ubW92ZUgoMSwgXCJjaGFyXCIpOyB9LFxuICAgIGdvQ29sdW1uTGVmdDogZnVuY3Rpb24gKGNtKSB7IHJldHVybiBjbS5tb3ZlSCgtMSwgXCJjb2x1bW5cIik7IH0sXG4gICAgZ29Db2x1bW5SaWdodDogZnVuY3Rpb24gKGNtKSB7IHJldHVybiBjbS5tb3ZlSCgxLCBcImNvbHVtblwiKTsgfSxcbiAgICBnb1dvcmRMZWZ0OiBmdW5jdGlvbiAoY20pIHsgcmV0dXJuIGNtLm1vdmVIKC0xLCBcIndvcmRcIik7IH0sXG4gICAgZ29Hcm91cFJpZ2h0OiBmdW5jdGlvbiAoY20pIHsgcmV0dXJuIGNtLm1vdmVIKDEsIFwiZ3JvdXBcIik7IH0sXG4gICAgZ29Hcm91cExlZnQ6IGZ1bmN0aW9uIChjbSkgeyByZXR1cm4gY20ubW92ZUgoLTEsIFwiZ3JvdXBcIik7IH0sXG4gICAgZ29Xb3JkUmlnaHQ6IGZ1bmN0aW9uIChjbSkgeyByZXR1cm4gY20ubW92ZUgoMSwgXCJ3b3JkXCIpOyB9LFxuICAgIGRlbENoYXJCZWZvcmU6IGZ1bmN0aW9uIChjbSkgeyByZXR1cm4gY20uZGVsZXRlSCgtMSwgXCJjb2RlcG9pbnRcIik7IH0sXG4gICAgZGVsQ2hhckFmdGVyOiBmdW5jdGlvbiAoY20pIHsgcmV0dXJuIGNtLmRlbGV0ZUgoMSwgXCJjaGFyXCIpOyB9LFxuICAgIGRlbFdvcmRCZWZvcmU6IGZ1bmN0aW9uIChjbSkgeyByZXR1cm4gY20uZGVsZXRlSCgtMSwgXCJ3b3JkXCIpOyB9LFxuICAgIGRlbFdvcmRBZnRlcjogZnVuY3Rpb24gKGNtKSB7IHJldHVybiBjbS5kZWxldGVIKDEsIFwid29yZFwiKTsgfSxcbiAgICBkZWxHcm91cEJlZm9yZTogZnVuY3Rpb24gKGNtKSB7IHJldHVybiBjbS5kZWxldGVIKC0xLCBcImdyb3VwXCIpOyB9LFxuICAgIGRlbEdyb3VwQWZ0ZXI6IGZ1bmN0aW9uIChjbSkgeyByZXR1cm4gY20uZGVsZXRlSCgxLCBcImdyb3VwXCIpOyB9LFxuICAgIGluZGVudEF1dG86IGZ1bmN0aW9uIChjbSkgeyByZXR1cm4gY20uaW5kZW50U2VsZWN0aW9uKFwic21hcnRcIik7IH0sXG4gICAgaW5kZW50TW9yZTogZnVuY3Rpb24gKGNtKSB7IHJldHVybiBjbS5pbmRlbnRTZWxlY3Rpb24oXCJhZGRcIik7IH0sXG4gICAgaW5kZW50TGVzczogZnVuY3Rpb24gKGNtKSB7IHJldHVybiBjbS5pbmRlbnRTZWxlY3Rpb24oXCJzdWJ0cmFjdFwiKTsgfSxcbiAgICBpbnNlcnRUYWI6IGZ1bmN0aW9uIChjbSkgeyByZXR1cm4gY20ucmVwbGFjZVNlbGVjdGlvbihcIlxcdFwiKTsgfSxcbiAgICBpbnNlcnRTb2Z0VGFiOiBmdW5jdGlvbiAoY20pIHtcbiAgICAgIHZhciBzcGFjZXMgPSBbXSwgcmFuZ2VzID0gY20ubGlzdFNlbGVjdGlvbnMoKSwgdGFiU2l6ZSA9IGNtLm9wdGlvbnMudGFiU2l6ZTtcbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgcmFuZ2VzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIHZhciBwb3MgPSByYW5nZXNbaV0uZnJvbSgpO1xuICAgICAgICB2YXIgY29sID0gY291bnRDb2x1bW4oY20uZ2V0TGluZShwb3MubGluZSksIHBvcy5jaCwgdGFiU2l6ZSk7XG4gICAgICAgIHNwYWNlcy5wdXNoKHNwYWNlU3RyKHRhYlNpemUgLSBjb2wgJSB0YWJTaXplKSk7XG4gICAgICB9XG4gICAgICBjbS5yZXBsYWNlU2VsZWN0aW9ucyhzcGFjZXMpO1xuICAgIH0sXG4gICAgZGVmYXVsdFRhYjogZnVuY3Rpb24gKGNtKSB7XG4gICAgICBpZiAoY20uc29tZXRoaW5nU2VsZWN0ZWQoKSkgeyBjbS5pbmRlbnRTZWxlY3Rpb24oXCJhZGRcIik7IH1cbiAgICAgIGVsc2UgeyBjbS5leGVjQ29tbWFuZChcImluc2VydFRhYlwiKTsgfVxuICAgIH0sXG4gICAgLy8gU3dhcCB0aGUgdHdvIGNoYXJzIGxlZnQgYW5kIHJpZ2h0IG9mIGVhY2ggc2VsZWN0aW9uJ3MgaGVhZC5cbiAgICAvLyBNb3ZlIGN1cnNvciBiZWhpbmQgdGhlIHR3byBzd2FwcGVkIGNoYXJhY3RlcnMgYWZ0ZXJ3YXJkcy5cbiAgICAvL1xuICAgIC8vIERvZXNuJ3QgY29uc2lkZXIgbGluZSBmZWVkcyBhIGNoYXJhY3Rlci5cbiAgICAvLyBEb2Vzbid0IHNjYW4gbW9yZSB0aGFuIG9uZSBsaW5lIGFib3ZlIHRvIGZpbmQgYSBjaGFyYWN0ZXIuXG4gICAgLy8gRG9lc24ndCBkbyBhbnl0aGluZyBvbiBhbiBlbXB0eSBsaW5lLlxuICAgIC8vIERvZXNuJ3QgZG8gYW55dGhpbmcgd2l0aCBub24tZW1wdHkgc2VsZWN0aW9ucy5cbiAgICB0cmFuc3Bvc2VDaGFyczogZnVuY3Rpb24gKGNtKSB7IHJldHVybiBydW5Jbk9wKGNtLCBmdW5jdGlvbiAoKSB7XG4gICAgICB2YXIgcmFuZ2VzID0gY20ubGlzdFNlbGVjdGlvbnMoKSwgbmV3U2VsID0gW107XG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHJhbmdlcy5sZW5ndGg7IGkrKykge1xuICAgICAgICBpZiAoIXJhbmdlc1tpXS5lbXB0eSgpKSB7IGNvbnRpbnVlIH1cbiAgICAgICAgdmFyIGN1ciA9IHJhbmdlc1tpXS5oZWFkLCBsaW5lID0gZ2V0TGluZShjbS5kb2MsIGN1ci5saW5lKS50ZXh0O1xuICAgICAgICBpZiAobGluZSkge1xuICAgICAgICAgIGlmIChjdXIuY2ggPT0gbGluZS5sZW5ndGgpIHsgY3VyID0gbmV3IFBvcyhjdXIubGluZSwgY3VyLmNoIC0gMSk7IH1cbiAgICAgICAgICBpZiAoY3VyLmNoID4gMCkge1xuICAgICAgICAgICAgY3VyID0gbmV3IFBvcyhjdXIubGluZSwgY3VyLmNoICsgMSk7XG4gICAgICAgICAgICBjbS5yZXBsYWNlUmFuZ2UobGluZS5jaGFyQXQoY3VyLmNoIC0gMSkgKyBsaW5lLmNoYXJBdChjdXIuY2ggLSAyKSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBQb3MoY3VyLmxpbmUsIGN1ci5jaCAtIDIpLCBjdXIsIFwiK3RyYW5zcG9zZVwiKTtcbiAgICAgICAgICB9IGVsc2UgaWYgKGN1ci5saW5lID4gY20uZG9jLmZpcnN0KSB7XG4gICAgICAgICAgICB2YXIgcHJldiA9IGdldExpbmUoY20uZG9jLCBjdXIubGluZSAtIDEpLnRleHQ7XG4gICAgICAgICAgICBpZiAocHJldikge1xuICAgICAgICAgICAgICBjdXIgPSBuZXcgUG9zKGN1ci5saW5lLCAxKTtcbiAgICAgICAgICAgICAgY20ucmVwbGFjZVJhbmdlKGxpbmUuY2hhckF0KDApICsgY20uZG9jLmxpbmVTZXBhcmF0b3IoKSArXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICBwcmV2LmNoYXJBdChwcmV2Lmxlbmd0aCAtIDEpLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgUG9zKGN1ci5saW5lIC0gMSwgcHJldi5sZW5ndGggLSAxKSwgY3VyLCBcIit0cmFuc3Bvc2VcIik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIG5ld1NlbC5wdXNoKG5ldyBSYW5nZShjdXIsIGN1cikpO1xuICAgICAgfVxuICAgICAgY20uc2V0U2VsZWN0aW9ucyhuZXdTZWwpO1xuICAgIH0pOyB9LFxuICAgIG5ld2xpbmVBbmRJbmRlbnQ6IGZ1bmN0aW9uIChjbSkgeyByZXR1cm4gcnVuSW5PcChjbSwgZnVuY3Rpb24gKCkge1xuICAgICAgdmFyIHNlbHMgPSBjbS5saXN0U2VsZWN0aW9ucygpO1xuICAgICAgZm9yICh2YXIgaSA9IHNlbHMubGVuZ3RoIC0gMTsgaSA+PSAwOyBpLS0pXG4gICAgICAgIHsgY20ucmVwbGFjZVJhbmdlKGNtLmRvYy5saW5lU2VwYXJhdG9yKCksIHNlbHNbaV0uYW5jaG9yLCBzZWxzW2ldLmhlYWQsIFwiK2lucHV0XCIpOyB9XG4gICAgICBzZWxzID0gY20ubGlzdFNlbGVjdGlvbnMoKTtcbiAgICAgIGZvciAodmFyIGkkMSA9IDA7IGkkMSA8IHNlbHMubGVuZ3RoOyBpJDErKylcbiAgICAgICAgeyBjbS5pbmRlbnRMaW5lKHNlbHNbaSQxXS5mcm9tKCkubGluZSwgbnVsbCwgdHJ1ZSk7IH1cbiAgICAgIGVuc3VyZUN1cnNvclZpc2libGUoY20pO1xuICAgIH0pOyB9LFxuICAgIG9wZW5MaW5lOiBmdW5jdGlvbiAoY20pIHsgcmV0dXJuIGNtLnJlcGxhY2VTZWxlY3Rpb24oXCJcXG5cIiwgXCJzdGFydFwiKTsgfSxcbiAgICB0b2dnbGVPdmVyd3JpdGU6IGZ1bmN0aW9uIChjbSkgeyByZXR1cm4gY20udG9nZ2xlT3ZlcndyaXRlKCk7IH1cbiAgfTtcblxuXG4gIGZ1bmN0aW9uIGxpbmVTdGFydChjbSwgbGluZU4pIHtcbiAgICB2YXIgbGluZSA9IGdldExpbmUoY20uZG9jLCBsaW5lTik7XG4gICAgdmFyIHZpc3VhbCA9IHZpc3VhbExpbmUobGluZSk7XG4gICAgaWYgKHZpc3VhbCAhPSBsaW5lKSB7IGxpbmVOID0gbGluZU5vKHZpc3VhbCk7IH1cbiAgICByZXR1cm4gZW5kT2ZMaW5lKHRydWUsIGNtLCB2aXN1YWwsIGxpbmVOLCAxKVxuICB9XG4gIGZ1bmN0aW9uIGxpbmVFbmQoY20sIGxpbmVOKSB7XG4gICAgdmFyIGxpbmUgPSBnZXRMaW5lKGNtLmRvYywgbGluZU4pO1xuICAgIHZhciB2aXN1YWwgPSB2aXN1YWxMaW5lRW5kKGxpbmUpO1xuICAgIGlmICh2aXN1YWwgIT0gbGluZSkgeyBsaW5lTiA9IGxpbmVObyh2aXN1YWwpOyB9XG4gICAgcmV0dXJuIGVuZE9mTGluZSh0cnVlLCBjbSwgbGluZSwgbGluZU4sIC0xKVxuICB9XG4gIGZ1bmN0aW9uIGxpbmVTdGFydFNtYXJ0KGNtLCBwb3MpIHtcbiAgICB2YXIgc3RhcnQgPSBsaW5lU3RhcnQoY20sIHBvcy5saW5lKTtcbiAgICB2YXIgbGluZSA9IGdldExpbmUoY20uZG9jLCBzdGFydC5saW5lKTtcbiAgICB2YXIgb3JkZXIgPSBnZXRPcmRlcihsaW5lLCBjbS5kb2MuZGlyZWN0aW9uKTtcbiAgICBpZiAoIW9yZGVyIHx8IG9yZGVyWzBdLmxldmVsID09IDApIHtcbiAgICAgIHZhciBmaXJzdE5vbldTID0gTWF0aC5tYXgoc3RhcnQuY2gsIGxpbmUudGV4dC5zZWFyY2goL1xcUy8pKTtcbiAgICAgIHZhciBpbldTID0gcG9zLmxpbmUgPT0gc3RhcnQubGluZSAmJiBwb3MuY2ggPD0gZmlyc3ROb25XUyAmJiBwb3MuY2g7XG4gICAgICByZXR1cm4gUG9zKHN0YXJ0LmxpbmUsIGluV1MgPyAwIDogZmlyc3ROb25XUywgc3RhcnQuc3RpY2t5KVxuICAgIH1cbiAgICByZXR1cm4gc3RhcnRcbiAgfVxuXG4gIC8vIFJ1biBhIGhhbmRsZXIgdGhhdCB3YXMgYm91bmQgdG8gYSBrZXkuXG4gIGZ1bmN0aW9uIGRvSGFuZGxlQmluZGluZyhjbSwgYm91bmQsIGRyb3BTaGlmdCkge1xuICAgIGlmICh0eXBlb2YgYm91bmQgPT0gXCJzdHJpbmdcIikge1xuICAgICAgYm91bmQgPSBjb21tYW5kc1tib3VuZF07XG4gICAgICBpZiAoIWJvdW5kKSB7IHJldHVybiBmYWxzZSB9XG4gICAgfVxuICAgIC8vIEVuc3VyZSBwcmV2aW91cyBpbnB1dCBoYXMgYmVlbiByZWFkLCBzbyB0aGF0IHRoZSBoYW5kbGVyIHNlZXMgYVxuICAgIC8vIGNvbnNpc3RlbnQgdmlldyBvZiB0aGUgZG9jdW1lbnRcbiAgICBjbS5kaXNwbGF5LmlucHV0LmVuc3VyZVBvbGxlZCgpO1xuICAgIHZhciBwcmV2U2hpZnQgPSBjbS5kaXNwbGF5LnNoaWZ0LCBkb25lID0gZmFsc2U7XG4gICAgdHJ5IHtcbiAgICAgIGlmIChjbS5pc1JlYWRPbmx5KCkpIHsgY20uc3RhdGUuc3VwcHJlc3NFZGl0cyA9IHRydWU7IH1cbiAgICAgIGlmIChkcm9wU2hpZnQpIHsgY20uZGlzcGxheS5zaGlmdCA9IGZhbHNlOyB9XG4gICAgICBkb25lID0gYm91bmQoY20pICE9IFBhc3M7XG4gICAgfSBmaW5hbGx5IHtcbiAgICAgIGNtLmRpc3BsYXkuc2hpZnQgPSBwcmV2U2hpZnQ7XG4gICAgICBjbS5zdGF0ZS5zdXBwcmVzc0VkaXRzID0gZmFsc2U7XG4gICAgfVxuICAgIHJldHVybiBkb25lXG4gIH1cblxuICBmdW5jdGlvbiBsb29rdXBLZXlGb3JFZGl0b3IoY20sIG5hbWUsIGhhbmRsZSkge1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgY20uc3RhdGUua2V5TWFwcy5sZW5ndGg7IGkrKykge1xuICAgICAgdmFyIHJlc3VsdCA9IGxvb2t1cEtleShuYW1lLCBjbS5zdGF0ZS5rZXlNYXBzW2ldLCBoYW5kbGUsIGNtKTtcbiAgICAgIGlmIChyZXN1bHQpIHsgcmV0dXJuIHJlc3VsdCB9XG4gICAgfVxuICAgIHJldHVybiAoY20ub3B0aW9ucy5leHRyYUtleXMgJiYgbG9va3VwS2V5KG5hbWUsIGNtLm9wdGlvbnMuZXh0cmFLZXlzLCBoYW5kbGUsIGNtKSlcbiAgICAgIHx8IGxvb2t1cEtleShuYW1lLCBjbS5vcHRpb25zLmtleU1hcCwgaGFuZGxlLCBjbSlcbiAgfVxuXG4gIC8vIE5vdGUgdGhhdCwgZGVzcGl0ZSB0aGUgbmFtZSwgdGhpcyBmdW5jdGlvbiBpcyBhbHNvIHVzZWQgdG8gY2hlY2tcbiAgLy8gZm9yIGJvdW5kIG1vdXNlIGNsaWNrcy5cblxuICB2YXIgc3RvcFNlcSA9IG5ldyBEZWxheWVkO1xuXG4gIGZ1bmN0aW9uIGRpc3BhdGNoS2V5KGNtLCBuYW1lLCBlLCBoYW5kbGUpIHtcbiAgICB2YXIgc2VxID0gY20uc3RhdGUua2V5U2VxO1xuICAgIGlmIChzZXEpIHtcbiAgICAgIGlmIChpc01vZGlmaWVyS2V5KG5hbWUpKSB7IHJldHVybiBcImhhbmRsZWRcIiB9XG4gICAgICBpZiAoL1xcJyQvLnRlc3QobmFtZSkpXG4gICAgICAgIHsgY20uc3RhdGUua2V5U2VxID0gbnVsbDsgfVxuICAgICAgZWxzZVxuICAgICAgICB7IHN0b3BTZXEuc2V0KDUwLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgaWYgKGNtLnN0YXRlLmtleVNlcSA9PSBzZXEpIHtcbiAgICAgICAgICAgIGNtLnN0YXRlLmtleVNlcSA9IG51bGw7XG4gICAgICAgICAgICBjbS5kaXNwbGF5LmlucHV0LnJlc2V0KCk7XG4gICAgICAgICAgfVxuICAgICAgICB9KTsgfVxuICAgICAgaWYgKGRpc3BhdGNoS2V5SW5uZXIoY20sIHNlcSArIFwiIFwiICsgbmFtZSwgZSwgaGFuZGxlKSkgeyByZXR1cm4gdHJ1ZSB9XG4gICAgfVxuICAgIHJldHVybiBkaXNwYXRjaEtleUlubmVyKGNtLCBuYW1lLCBlLCBoYW5kbGUpXG4gIH1cblxuICBmdW5jdGlvbiBkaXNwYXRjaEtleUlubmVyKGNtLCBuYW1lLCBlLCBoYW5kbGUpIHtcbiAgICB2YXIgcmVzdWx0ID0gbG9va3VwS2V5Rm9yRWRpdG9yKGNtLCBuYW1lLCBoYW5kbGUpO1xuXG4gICAgaWYgKHJlc3VsdCA9PSBcIm11bHRpXCIpXG4gICAgICB7IGNtLnN0YXRlLmtleVNlcSA9IG5hbWU7IH1cbiAgICBpZiAocmVzdWx0ID09IFwiaGFuZGxlZFwiKVxuICAgICAgeyBzaWduYWxMYXRlcihjbSwgXCJrZXlIYW5kbGVkXCIsIGNtLCBuYW1lLCBlKTsgfVxuXG4gICAgaWYgKHJlc3VsdCA9PSBcImhhbmRsZWRcIiB8fCByZXN1bHQgPT0gXCJtdWx0aVwiKSB7XG4gICAgICBlX3ByZXZlbnREZWZhdWx0KGUpO1xuICAgICAgcmVzdGFydEJsaW5rKGNtKTtcbiAgICB9XG5cbiAgICByZXR1cm4gISFyZXN1bHRcbiAgfVxuXG4gIC8vIEhhbmRsZSBhIGtleSBmcm9tIHRoZSBrZXlkb3duIGV2ZW50LlxuICBmdW5jdGlvbiBoYW5kbGVLZXlCaW5kaW5nKGNtLCBlKSB7XG4gICAgdmFyIG5hbWUgPSBrZXlOYW1lKGUsIHRydWUpO1xuICAgIGlmICghbmFtZSkgeyByZXR1cm4gZmFsc2UgfVxuXG4gICAgaWYgKGUuc2hpZnRLZXkgJiYgIWNtLnN0YXRlLmtleVNlcSkge1xuICAgICAgLy8gRmlyc3QgdHJ5IHRvIHJlc29sdmUgZnVsbCBuYW1lIChpbmNsdWRpbmcgJ1NoaWZ0LScpLiBGYWlsaW5nXG4gICAgICAvLyB0aGF0LCBzZWUgaWYgdGhlcmUgaXMgYSBjdXJzb3ItbW90aW9uIGNvbW1hbmQgKHN0YXJ0aW5nIHdpdGhcbiAgICAgIC8vICdnbycpIGJvdW5kIHRvIHRoZSBrZXluYW1lIHdpdGhvdXQgJ1NoaWZ0LScuXG4gICAgICByZXR1cm4gZGlzcGF0Y2hLZXkoY20sIFwiU2hpZnQtXCIgKyBuYW1lLCBlLCBmdW5jdGlvbiAoYikgeyByZXR1cm4gZG9IYW5kbGVCaW5kaW5nKGNtLCBiLCB0cnVlKTsgfSlcbiAgICAgICAgICB8fCBkaXNwYXRjaEtleShjbSwgbmFtZSwgZSwgZnVuY3Rpb24gKGIpIHtcbiAgICAgICAgICAgICAgIGlmICh0eXBlb2YgYiA9PSBcInN0cmluZ1wiID8gL15nb1tBLVpdLy50ZXN0KGIpIDogYi5tb3Rpb24pXG4gICAgICAgICAgICAgICAgIHsgcmV0dXJuIGRvSGFuZGxlQmluZGluZyhjbSwgYikgfVxuICAgICAgICAgICAgIH0pXG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiBkaXNwYXRjaEtleShjbSwgbmFtZSwgZSwgZnVuY3Rpb24gKGIpIHsgcmV0dXJuIGRvSGFuZGxlQmluZGluZyhjbSwgYik7IH0pXG4gICAgfVxuICB9XG5cbiAgLy8gSGFuZGxlIGEga2V5IGZyb20gdGhlIGtleXByZXNzIGV2ZW50XG4gIGZ1bmN0aW9uIGhhbmRsZUNoYXJCaW5kaW5nKGNtLCBlLCBjaCkge1xuICAgIHJldHVybiBkaXNwYXRjaEtleShjbSwgXCInXCIgKyBjaCArIFwiJ1wiLCBlLCBmdW5jdGlvbiAoYikgeyByZXR1cm4gZG9IYW5kbGVCaW5kaW5nKGNtLCBiLCB0cnVlKTsgfSlcbiAgfVxuXG4gIHZhciBsYXN0U3RvcHBlZEtleSA9IG51bGw7XG4gIGZ1bmN0aW9uIG9uS2V5RG93bihlKSB7XG4gICAgdmFyIGNtID0gdGhpcztcbiAgICBpZiAoZS50YXJnZXQgJiYgZS50YXJnZXQgIT0gY20uZGlzcGxheS5pbnB1dC5nZXRGaWVsZCgpKSB7IHJldHVybiB9XG4gICAgY20uY3VyT3AuZm9jdXMgPSBhY3RpdmVFbHQoKTtcbiAgICBpZiAoc2lnbmFsRE9NRXZlbnQoY20sIGUpKSB7IHJldHVybiB9XG4gICAgLy8gSUUgZG9lcyBzdHJhbmdlIHRoaW5ncyB3aXRoIGVzY2FwZS5cbiAgICBpZiAoaWUgJiYgaWVfdmVyc2lvbiA8IDExICYmIGUua2V5Q29kZSA9PSAyNykgeyBlLnJldHVyblZhbHVlID0gZmFsc2U7IH1cbiAgICB2YXIgY29kZSA9IGUua2V5Q29kZTtcbiAgICBjbS5kaXNwbGF5LnNoaWZ0ID0gY29kZSA9PSAxNiB8fCBlLnNoaWZ0S2V5O1xuICAgIHZhciBoYW5kbGVkID0gaGFuZGxlS2V5QmluZGluZyhjbSwgZSk7XG4gICAgaWYgKHByZXN0bykge1xuICAgICAgbGFzdFN0b3BwZWRLZXkgPSBoYW5kbGVkID8gY29kZSA6IG51bGw7XG4gICAgICAvLyBPcGVyYSBoYXMgbm8gY3V0IGV2ZW50Li4uIHdlIHRyeSB0byBhdCBsZWFzdCBjYXRjaCB0aGUga2V5IGNvbWJvXG4gICAgICBpZiAoIWhhbmRsZWQgJiYgY29kZSA9PSA4OCAmJiAhaGFzQ29weUV2ZW50ICYmIChtYWMgPyBlLm1ldGFLZXkgOiBlLmN0cmxLZXkpKVxuICAgICAgICB7IGNtLnJlcGxhY2VTZWxlY3Rpb24oXCJcIiwgbnVsbCwgXCJjdXRcIik7IH1cbiAgICB9XG4gICAgaWYgKGdlY2tvICYmICFtYWMgJiYgIWhhbmRsZWQgJiYgY29kZSA9PSA0NiAmJiBlLnNoaWZ0S2V5ICYmICFlLmN0cmxLZXkgJiYgZG9jdW1lbnQuZXhlY0NvbW1hbmQpXG4gICAgICB7IGRvY3VtZW50LmV4ZWNDb21tYW5kKFwiY3V0XCIpOyB9XG5cbiAgICAvLyBUdXJuIG1vdXNlIGludG8gY3Jvc3NoYWlyIHdoZW4gQWx0IGlzIGhlbGQgb24gTWFjLlxuICAgIGlmIChjb2RlID09IDE4ICYmICEvXFxiQ29kZU1pcnJvci1jcm9zc2hhaXJcXGIvLnRlc3QoY20uZGlzcGxheS5saW5lRGl2LmNsYXNzTmFtZSkpXG4gICAgICB7IHNob3dDcm9zc0hhaXIoY20pOyB9XG4gIH1cblxuICBmdW5jdGlvbiBzaG93Q3Jvc3NIYWlyKGNtKSB7XG4gICAgdmFyIGxpbmVEaXYgPSBjbS5kaXNwbGF5LmxpbmVEaXY7XG4gICAgYWRkQ2xhc3MobGluZURpdiwgXCJDb2RlTWlycm9yLWNyb3NzaGFpclwiKTtcblxuICAgIGZ1bmN0aW9uIHVwKGUpIHtcbiAgICAgIGlmIChlLmtleUNvZGUgPT0gMTggfHwgIWUuYWx0S2V5KSB7XG4gICAgICAgIHJtQ2xhc3MobGluZURpdiwgXCJDb2RlTWlycm9yLWNyb3NzaGFpclwiKTtcbiAgICAgICAgb2ZmKGRvY3VtZW50LCBcImtleXVwXCIsIHVwKTtcbiAgICAgICAgb2ZmKGRvY3VtZW50LCBcIm1vdXNlb3ZlclwiLCB1cCk7XG4gICAgICB9XG4gICAgfVxuICAgIG9uKGRvY3VtZW50LCBcImtleXVwXCIsIHVwKTtcbiAgICBvbihkb2N1bWVudCwgXCJtb3VzZW92ZXJcIiwgdXApO1xuICB9XG5cbiAgZnVuY3Rpb24gb25LZXlVcChlKSB7XG4gICAgaWYgKGUua2V5Q29kZSA9PSAxNikgeyB0aGlzLmRvYy5zZWwuc2hpZnQgPSBmYWxzZTsgfVxuICAgIHNpZ25hbERPTUV2ZW50KHRoaXMsIGUpO1xuICB9XG5cbiAgZnVuY3Rpb24gb25LZXlQcmVzcyhlKSB7XG4gICAgdmFyIGNtID0gdGhpcztcbiAgICBpZiAoZS50YXJnZXQgJiYgZS50YXJnZXQgIT0gY20uZGlzcGxheS5pbnB1dC5nZXRGaWVsZCgpKSB7IHJldHVybiB9XG4gICAgaWYgKGV2ZW50SW5XaWRnZXQoY20uZGlzcGxheSwgZSkgfHwgc2lnbmFsRE9NRXZlbnQoY20sIGUpIHx8IGUuY3RybEtleSAmJiAhZS5hbHRLZXkgfHwgbWFjICYmIGUubWV0YUtleSkgeyByZXR1cm4gfVxuICAgIHZhciBrZXlDb2RlID0gZS5rZXlDb2RlLCBjaGFyQ29kZSA9IGUuY2hhckNvZGU7XG4gICAgaWYgKHByZXN0byAmJiBrZXlDb2RlID09IGxhc3RTdG9wcGVkS2V5KSB7bGFzdFN0b3BwZWRLZXkgPSBudWxsOyBlX3ByZXZlbnREZWZhdWx0KGUpOyByZXR1cm59XG4gICAgaWYgKChwcmVzdG8gJiYgKCFlLndoaWNoIHx8IGUud2hpY2ggPCAxMCkpICYmIGhhbmRsZUtleUJpbmRpbmcoY20sIGUpKSB7IHJldHVybiB9XG4gICAgdmFyIGNoID0gU3RyaW5nLmZyb21DaGFyQ29kZShjaGFyQ29kZSA9PSBudWxsID8ga2V5Q29kZSA6IGNoYXJDb2RlKTtcbiAgICAvLyBTb21lIGJyb3dzZXJzIGZpcmUga2V5cHJlc3MgZXZlbnRzIGZvciBiYWNrc3BhY2VcbiAgICBpZiAoY2ggPT0gXCJcXHgwOFwiKSB7IHJldHVybiB9XG4gICAgaWYgKGhhbmRsZUNoYXJCaW5kaW5nKGNtLCBlLCBjaCkpIHsgcmV0dXJuIH1cbiAgICBjbS5kaXNwbGF5LmlucHV0Lm9uS2V5UHJlc3MoZSk7XG4gIH1cblxuICB2YXIgRE9VQkxFQ0xJQ0tfREVMQVkgPSA0MDA7XG5cbiAgdmFyIFBhc3RDbGljayA9IGZ1bmN0aW9uKHRpbWUsIHBvcywgYnV0dG9uKSB7XG4gICAgdGhpcy50aW1lID0gdGltZTtcbiAgICB0aGlzLnBvcyA9IHBvcztcbiAgICB0aGlzLmJ1dHRvbiA9IGJ1dHRvbjtcbiAgfTtcblxuICBQYXN0Q2xpY2sucHJvdG90eXBlLmNvbXBhcmUgPSBmdW5jdGlvbiAodGltZSwgcG9zLCBidXR0b24pIHtcbiAgICByZXR1cm4gdGhpcy50aW1lICsgRE9VQkxFQ0xJQ0tfREVMQVkgPiB0aW1lICYmXG4gICAgICBjbXAocG9zLCB0aGlzLnBvcykgPT0gMCAmJiBidXR0b24gPT0gdGhpcy5idXR0b25cbiAgfTtcblxuICB2YXIgbGFzdENsaWNrLCBsYXN0RG91YmxlQ2xpY2s7XG4gIGZ1bmN0aW9uIGNsaWNrUmVwZWF0KHBvcywgYnV0dG9uKSB7XG4gICAgdmFyIG5vdyA9ICtuZXcgRGF0ZTtcbiAgICBpZiAobGFzdERvdWJsZUNsaWNrICYmIGxhc3REb3VibGVDbGljay5jb21wYXJlKG5vdywgcG9zLCBidXR0b24pKSB7XG4gICAgICBsYXN0Q2xpY2sgPSBsYXN0RG91YmxlQ2xpY2sgPSBudWxsO1xuICAgICAgcmV0dXJuIFwidHJpcGxlXCJcbiAgICB9IGVsc2UgaWYgKGxhc3RDbGljayAmJiBsYXN0Q2xpY2suY29tcGFyZShub3csIHBvcywgYnV0dG9uKSkge1xuICAgICAgbGFzdERvdWJsZUNsaWNrID0gbmV3IFBhc3RDbGljayhub3csIHBvcywgYnV0dG9uKTtcbiAgICAgIGxhc3RDbGljayA9IG51bGw7XG4gICAgICByZXR1cm4gXCJkb3VibGVcIlxuICAgIH0gZWxzZSB7XG4gICAgICBsYXN0Q2xpY2sgPSBuZXcgUGFzdENsaWNrKG5vdywgcG9zLCBidXR0b24pO1xuICAgICAgbGFzdERvdWJsZUNsaWNrID0gbnVsbDtcbiAgICAgIHJldHVybiBcInNpbmdsZVwiXG4gICAgfVxuICB9XG5cbiAgLy8gQSBtb3VzZSBkb3duIGNhbiBiZSBhIHNpbmdsZSBjbGljaywgZG91YmxlIGNsaWNrLCB0cmlwbGUgY2xpY2ssXG4gIC8vIHN0YXJ0IG9mIHNlbGVjdGlvbiBkcmFnLCBzdGFydCBvZiB0ZXh0IGRyYWcsIG5ldyBjdXJzb3JcbiAgLy8gKGN0cmwtY2xpY2spLCByZWN0YW5nbGUgZHJhZyAoYWx0LWRyYWcpLCBvciB4d2luXG4gIC8vIG1pZGRsZS1jbGljay1wYXN0ZS4gT3IgaXQgbWlnaHQgYmUgYSBjbGljayBvbiBzb21ldGhpbmcgd2Ugc2hvdWxkXG4gIC8vIG5vdCBpbnRlcmZlcmUgd2l0aCwgc3VjaCBhcyBhIHNjcm9sbGJhciBvciB3aWRnZXQuXG4gIGZ1bmN0aW9uIG9uTW91c2VEb3duKGUpIHtcbiAgICB2YXIgY20gPSB0aGlzLCBkaXNwbGF5ID0gY20uZGlzcGxheTtcbiAgICBpZiAoc2lnbmFsRE9NRXZlbnQoY20sIGUpIHx8IGRpc3BsYXkuYWN0aXZlVG91Y2ggJiYgZGlzcGxheS5pbnB1dC5zdXBwb3J0c1RvdWNoKCkpIHsgcmV0dXJuIH1cbiAgICBkaXNwbGF5LmlucHV0LmVuc3VyZVBvbGxlZCgpO1xuICAgIGRpc3BsYXkuc2hpZnQgPSBlLnNoaWZ0S2V5O1xuXG4gICAgaWYgKGV2ZW50SW5XaWRnZXQoZGlzcGxheSwgZSkpIHtcbiAgICAgIGlmICghd2Via2l0KSB7XG4gICAgICAgIC8vIEJyaWVmbHkgdHVybiBvZmYgZHJhZ2dhYmlsaXR5LCB0byBhbGxvdyB3aWRnZXRzIHRvIGRvXG4gICAgICAgIC8vIG5vcm1hbCBkcmFnZ2luZyB0aGluZ3MuXG4gICAgICAgIGRpc3BsYXkuc2Nyb2xsZXIuZHJhZ2dhYmxlID0gZmFsc2U7XG4gICAgICAgIHNldFRpbWVvdXQoZnVuY3Rpb24gKCkgeyByZXR1cm4gZGlzcGxheS5zY3JvbGxlci5kcmFnZ2FibGUgPSB0cnVlOyB9LCAxMDApO1xuICAgICAgfVxuICAgICAgcmV0dXJuXG4gICAgfVxuICAgIGlmIChjbGlja0luR3V0dGVyKGNtLCBlKSkgeyByZXR1cm4gfVxuICAgIHZhciBwb3MgPSBwb3NGcm9tTW91c2UoY20sIGUpLCBidXR0b24gPSBlX2J1dHRvbihlKSwgcmVwZWF0ID0gcG9zID8gY2xpY2tSZXBlYXQocG9zLCBidXR0b24pIDogXCJzaW5nbGVcIjtcbiAgICB3aW5kb3cuZm9jdXMoKTtcblxuICAgIC8vICMzMjYxOiBtYWtlIHN1cmUsIHRoYXQgd2UncmUgbm90IHN0YXJ0aW5nIGEgc2Vjb25kIHNlbGVjdGlvblxuICAgIGlmIChidXR0b24gPT0gMSAmJiBjbS5zdGF0ZS5zZWxlY3RpbmdUZXh0KVxuICAgICAgeyBjbS5zdGF0ZS5zZWxlY3RpbmdUZXh0KGUpOyB9XG5cbiAgICBpZiAocG9zICYmIGhhbmRsZU1hcHBlZEJ1dHRvbihjbSwgYnV0dG9uLCBwb3MsIHJlcGVhdCwgZSkpIHsgcmV0dXJuIH1cblxuICAgIGlmIChidXR0b24gPT0gMSkge1xuICAgICAgaWYgKHBvcykgeyBsZWZ0QnV0dG9uRG93bihjbSwgcG9zLCByZXBlYXQsIGUpOyB9XG4gICAgICBlbHNlIGlmIChlX3RhcmdldChlKSA9PSBkaXNwbGF5LnNjcm9sbGVyKSB7IGVfcHJldmVudERlZmF1bHQoZSk7IH1cbiAgICB9IGVsc2UgaWYgKGJ1dHRvbiA9PSAyKSB7XG4gICAgICBpZiAocG9zKSB7IGV4dGVuZFNlbGVjdGlvbihjbS5kb2MsIHBvcyk7IH1cbiAgICAgIHNldFRpbWVvdXQoZnVuY3Rpb24gKCkgeyByZXR1cm4gZGlzcGxheS5pbnB1dC5mb2N1cygpOyB9LCAyMCk7XG4gICAgfSBlbHNlIGlmIChidXR0b24gPT0gMykge1xuICAgICAgaWYgKGNhcHR1cmVSaWdodENsaWNrKSB7IGNtLmRpc3BsYXkuaW5wdXQub25Db250ZXh0TWVudShlKTsgfVxuICAgICAgZWxzZSB7IGRlbGF5Qmx1ckV2ZW50KGNtKTsgfVxuICAgIH1cbiAgfVxuXG4gIGZ1bmN0aW9uIGhhbmRsZU1hcHBlZEJ1dHRvbihjbSwgYnV0dG9uLCBwb3MsIHJlcGVhdCwgZXZlbnQpIHtcbiAgICB2YXIgbmFtZSA9IFwiQ2xpY2tcIjtcbiAgICBpZiAocmVwZWF0ID09IFwiZG91YmxlXCIpIHsgbmFtZSA9IFwiRG91YmxlXCIgKyBuYW1lOyB9XG4gICAgZWxzZSBpZiAocmVwZWF0ID09IFwidHJpcGxlXCIpIHsgbmFtZSA9IFwiVHJpcGxlXCIgKyBuYW1lOyB9XG4gICAgbmFtZSA9IChidXR0b24gPT0gMSA/IFwiTGVmdFwiIDogYnV0dG9uID09IDIgPyBcIk1pZGRsZVwiIDogXCJSaWdodFwiKSArIG5hbWU7XG5cbiAgICByZXR1cm4gZGlzcGF0Y2hLZXkoY20sICBhZGRNb2RpZmllck5hbWVzKG5hbWUsIGV2ZW50KSwgZXZlbnQsIGZ1bmN0aW9uIChib3VuZCkge1xuICAgICAgaWYgKHR5cGVvZiBib3VuZCA9PSBcInN0cmluZ1wiKSB7IGJvdW5kID0gY29tbWFuZHNbYm91bmRdOyB9XG4gICAgICBpZiAoIWJvdW5kKSB7IHJldHVybiBmYWxzZSB9XG4gICAgICB2YXIgZG9uZSA9IGZhbHNlO1xuICAgICAgdHJ5IHtcbiAgICAgICAgaWYgKGNtLmlzUmVhZE9ubHkoKSkgeyBjbS5zdGF0ZS5zdXBwcmVzc0VkaXRzID0gdHJ1ZTsgfVxuICAgICAgICBkb25lID0gYm91bmQoY20sIHBvcykgIT0gUGFzcztcbiAgICAgIH0gZmluYWxseSB7XG4gICAgICAgIGNtLnN0YXRlLnN1cHByZXNzRWRpdHMgPSBmYWxzZTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBkb25lXG4gICAgfSlcbiAgfVxuXG4gIGZ1bmN0aW9uIGNvbmZpZ3VyZU1vdXNlKGNtLCByZXBlYXQsIGV2ZW50KSB7XG4gICAgdmFyIG9wdGlvbiA9IGNtLmdldE9wdGlvbihcImNvbmZpZ3VyZU1vdXNlXCIpO1xuICAgIHZhciB2YWx1ZSA9IG9wdGlvbiA/IG9wdGlvbihjbSwgcmVwZWF0LCBldmVudCkgOiB7fTtcbiAgICBpZiAodmFsdWUudW5pdCA9PSBudWxsKSB7XG4gICAgICB2YXIgcmVjdCA9IGNocm9tZU9TID8gZXZlbnQuc2hpZnRLZXkgJiYgZXZlbnQubWV0YUtleSA6IGV2ZW50LmFsdEtleTtcbiAgICAgIHZhbHVlLnVuaXQgPSByZWN0ID8gXCJyZWN0YW5nbGVcIiA6IHJlcGVhdCA9PSBcInNpbmdsZVwiID8gXCJjaGFyXCIgOiByZXBlYXQgPT0gXCJkb3VibGVcIiA/IFwid29yZFwiIDogXCJsaW5lXCI7XG4gICAgfVxuICAgIGlmICh2YWx1ZS5leHRlbmQgPT0gbnVsbCB8fCBjbS5kb2MuZXh0ZW5kKSB7IHZhbHVlLmV4dGVuZCA9IGNtLmRvYy5leHRlbmQgfHwgZXZlbnQuc2hpZnRLZXk7IH1cbiAgICBpZiAodmFsdWUuYWRkTmV3ID09IG51bGwpIHsgdmFsdWUuYWRkTmV3ID0gbWFjID8gZXZlbnQubWV0YUtleSA6IGV2ZW50LmN0cmxLZXk7IH1cbiAgICBpZiAodmFsdWUubW92ZU9uRHJhZyA9PSBudWxsKSB7IHZhbHVlLm1vdmVPbkRyYWcgPSAhKG1hYyA/IGV2ZW50LmFsdEtleSA6IGV2ZW50LmN0cmxLZXkpOyB9XG4gICAgcmV0dXJuIHZhbHVlXG4gIH1cblxuICBmdW5jdGlvbiBsZWZ0QnV0dG9uRG93bihjbSwgcG9zLCByZXBlYXQsIGV2ZW50KSB7XG4gICAgaWYgKGllKSB7IHNldFRpbWVvdXQoYmluZChlbnN1cmVGb2N1cywgY20pLCAwKTsgfVxuICAgIGVsc2UgeyBjbS5jdXJPcC5mb2N1cyA9IGFjdGl2ZUVsdCgpOyB9XG5cbiAgICB2YXIgYmVoYXZpb3IgPSBjb25maWd1cmVNb3VzZShjbSwgcmVwZWF0LCBldmVudCk7XG5cbiAgICB2YXIgc2VsID0gY20uZG9jLnNlbCwgY29udGFpbmVkO1xuICAgIGlmIChjbS5vcHRpb25zLmRyYWdEcm9wICYmIGRyYWdBbmREcm9wICYmICFjbS5pc1JlYWRPbmx5KCkgJiZcbiAgICAgICAgcmVwZWF0ID09IFwic2luZ2xlXCIgJiYgKGNvbnRhaW5lZCA9IHNlbC5jb250YWlucyhwb3MpKSA+IC0xICYmXG4gICAgICAgIChjbXAoKGNvbnRhaW5lZCA9IHNlbC5yYW5nZXNbY29udGFpbmVkXSkuZnJvbSgpLCBwb3MpIDwgMCB8fCBwb3MueFJlbCA+IDApICYmXG4gICAgICAgIChjbXAoY29udGFpbmVkLnRvKCksIHBvcykgPiAwIHx8IHBvcy54UmVsIDwgMCkpXG4gICAgICB7IGxlZnRCdXR0b25TdGFydERyYWcoY20sIGV2ZW50LCBwb3MsIGJlaGF2aW9yKTsgfVxuICAgIGVsc2VcbiAgICAgIHsgbGVmdEJ1dHRvblNlbGVjdChjbSwgZXZlbnQsIHBvcywgYmVoYXZpb3IpOyB9XG4gIH1cblxuICAvLyBTdGFydCBhIHRleHQgZHJhZy4gV2hlbiBpdCBlbmRzLCBzZWUgaWYgYW55IGRyYWdnaW5nIGFjdHVhbGx5XG4gIC8vIGhhcHBlbiwgYW5kIHRyZWF0IGFzIGEgY2xpY2sgaWYgaXQgZGlkbid0LlxuICBmdW5jdGlvbiBsZWZ0QnV0dG9uU3RhcnREcmFnKGNtLCBldmVudCwgcG9zLCBiZWhhdmlvcikge1xuICAgIHZhciBkaXNwbGF5ID0gY20uZGlzcGxheSwgbW92ZWQgPSBmYWxzZTtcbiAgICB2YXIgZHJhZ0VuZCA9IG9wZXJhdGlvbihjbSwgZnVuY3Rpb24gKGUpIHtcbiAgICAgIGlmICh3ZWJraXQpIHsgZGlzcGxheS5zY3JvbGxlci5kcmFnZ2FibGUgPSBmYWxzZTsgfVxuICAgICAgY20uc3RhdGUuZHJhZ2dpbmdUZXh0ID0gZmFsc2U7XG4gICAgICBpZiAoY20uc3RhdGUuZGVsYXlpbmdCbHVyRXZlbnQpIHtcbiAgICAgICAgaWYgKGNtLmhhc0ZvY3VzKCkpIHsgY20uc3RhdGUuZGVsYXlpbmdCbHVyRXZlbnQgPSBmYWxzZTsgfVxuICAgICAgICBlbHNlIHsgZGVsYXlCbHVyRXZlbnQoY20pOyB9XG4gICAgICB9XG4gICAgICBvZmYoZGlzcGxheS53cmFwcGVyLm93bmVyRG9jdW1lbnQsIFwibW91c2V1cFwiLCBkcmFnRW5kKTtcbiAgICAgIG9mZihkaXNwbGF5LndyYXBwZXIub3duZXJEb2N1bWVudCwgXCJtb3VzZW1vdmVcIiwgbW91c2VNb3ZlKTtcbiAgICAgIG9mZihkaXNwbGF5LnNjcm9sbGVyLCBcImRyYWdzdGFydFwiLCBkcmFnU3RhcnQpO1xuICAgICAgb2ZmKGRpc3BsYXkuc2Nyb2xsZXIsIFwiZHJvcFwiLCBkcmFnRW5kKTtcbiAgICAgIGlmICghbW92ZWQpIHtcbiAgICAgICAgZV9wcmV2ZW50RGVmYXVsdChlKTtcbiAgICAgICAgaWYgKCFiZWhhdmlvci5hZGROZXcpXG4gICAgICAgICAgeyBleHRlbmRTZWxlY3Rpb24oY20uZG9jLCBwb3MsIG51bGwsIG51bGwsIGJlaGF2aW9yLmV4dGVuZCk7IH1cbiAgICAgICAgLy8gV29yayBhcm91bmQgdW5leHBsYWluYWJsZSBmb2N1cyBwcm9ibGVtIGluIElFOSAoIzIxMjcpIGFuZCBDaHJvbWUgKCMzMDgxKVxuICAgICAgICBpZiAoKHdlYmtpdCAmJiAhc2FmYXJpKSB8fCBpZSAmJiBpZV92ZXJzaW9uID09IDkpXG4gICAgICAgICAgeyBzZXRUaW1lb3V0KGZ1bmN0aW9uICgpIHtkaXNwbGF5LndyYXBwZXIub3duZXJEb2N1bWVudC5ib2R5LmZvY3VzKHtwcmV2ZW50U2Nyb2xsOiB0cnVlfSk7IGRpc3BsYXkuaW5wdXQuZm9jdXMoKTt9LCAyMCk7IH1cbiAgICAgICAgZWxzZVxuICAgICAgICAgIHsgZGlzcGxheS5pbnB1dC5mb2N1cygpOyB9XG4gICAgICB9XG4gICAgfSk7XG4gICAgdmFyIG1vdXNlTW92ZSA9IGZ1bmN0aW9uKGUyKSB7XG4gICAgICBtb3ZlZCA9IG1vdmVkIHx8IE1hdGguYWJzKGV2ZW50LmNsaWVudFggLSBlMi5jbGllbnRYKSArIE1hdGguYWJzKGV2ZW50LmNsaWVudFkgLSBlMi5jbGllbnRZKSA+PSAxMDtcbiAgICB9O1xuICAgIHZhciBkcmFnU3RhcnQgPSBmdW5jdGlvbiAoKSB7IHJldHVybiBtb3ZlZCA9IHRydWU7IH07XG4gICAgLy8gTGV0IHRoZSBkcmFnIGhhbmRsZXIgaGFuZGxlIHRoaXMuXG4gICAgaWYgKHdlYmtpdCkgeyBkaXNwbGF5LnNjcm9sbGVyLmRyYWdnYWJsZSA9IHRydWU7IH1cbiAgICBjbS5zdGF0ZS5kcmFnZ2luZ1RleHQgPSBkcmFnRW5kO1xuICAgIGRyYWdFbmQuY29weSA9ICFiZWhhdmlvci5tb3ZlT25EcmFnO1xuICAgIG9uKGRpc3BsYXkud3JhcHBlci5vd25lckRvY3VtZW50LCBcIm1vdXNldXBcIiwgZHJhZ0VuZCk7XG4gICAgb24oZGlzcGxheS53cmFwcGVyLm93bmVyRG9jdW1lbnQsIFwibW91c2Vtb3ZlXCIsIG1vdXNlTW92ZSk7XG4gICAgb24oZGlzcGxheS5zY3JvbGxlciwgXCJkcmFnc3RhcnRcIiwgZHJhZ1N0YXJ0KTtcbiAgICBvbihkaXNwbGF5LnNjcm9sbGVyLCBcImRyb3BcIiwgZHJhZ0VuZCk7XG5cbiAgICBjbS5zdGF0ZS5kZWxheWluZ0JsdXJFdmVudCA9IHRydWU7XG4gICAgc2V0VGltZW91dChmdW5jdGlvbiAoKSB7IHJldHVybiBkaXNwbGF5LmlucHV0LmZvY3VzKCk7IH0sIDIwKTtcbiAgICAvLyBJRSdzIGFwcHJvYWNoIHRvIGRyYWdnYWJsZVxuICAgIGlmIChkaXNwbGF5LnNjcm9sbGVyLmRyYWdEcm9wKSB7IGRpc3BsYXkuc2Nyb2xsZXIuZHJhZ0Ryb3AoKTsgfVxuICB9XG5cbiAgZnVuY3Rpb24gcmFuZ2VGb3JVbml0KGNtLCBwb3MsIHVuaXQpIHtcbiAgICBpZiAodW5pdCA9PSBcImNoYXJcIikgeyByZXR1cm4gbmV3IFJhbmdlKHBvcywgcG9zKSB9XG4gICAgaWYgKHVuaXQgPT0gXCJ3b3JkXCIpIHsgcmV0dXJuIGNtLmZpbmRXb3JkQXQocG9zKSB9XG4gICAgaWYgKHVuaXQgPT0gXCJsaW5lXCIpIHsgcmV0dXJuIG5ldyBSYW5nZShQb3MocG9zLmxpbmUsIDApLCBjbGlwUG9zKGNtLmRvYywgUG9zKHBvcy5saW5lICsgMSwgMCkpKSB9XG4gICAgdmFyIHJlc3VsdCA9IHVuaXQoY20sIHBvcyk7XG4gICAgcmV0dXJuIG5ldyBSYW5nZShyZXN1bHQuZnJvbSwgcmVzdWx0LnRvKVxuICB9XG5cbiAgLy8gTm9ybWFsIHNlbGVjdGlvbiwgYXMgb3Bwb3NlZCB0byB0ZXh0IGRyYWdnaW5nLlxuICBmdW5jdGlvbiBsZWZ0QnV0dG9uU2VsZWN0KGNtLCBldmVudCwgc3RhcnQsIGJlaGF2aW9yKSB7XG4gICAgaWYgKGllKSB7IGRlbGF5Qmx1ckV2ZW50KGNtKTsgfVxuICAgIHZhciBkaXNwbGF5ID0gY20uZGlzcGxheSwgZG9jID0gY20uZG9jO1xuICAgIGVfcHJldmVudERlZmF1bHQoZXZlbnQpO1xuXG4gICAgdmFyIG91clJhbmdlLCBvdXJJbmRleCwgc3RhcnRTZWwgPSBkb2Muc2VsLCByYW5nZXMgPSBzdGFydFNlbC5yYW5nZXM7XG4gICAgaWYgKGJlaGF2aW9yLmFkZE5ldyAmJiAhYmVoYXZpb3IuZXh0ZW5kKSB7XG4gICAgICBvdXJJbmRleCA9IGRvYy5zZWwuY29udGFpbnMoc3RhcnQpO1xuICAgICAgaWYgKG91ckluZGV4ID4gLTEpXG4gICAgICAgIHsgb3VyUmFuZ2UgPSByYW5nZXNbb3VySW5kZXhdOyB9XG4gICAgICBlbHNlXG4gICAgICAgIHsgb3VyUmFuZ2UgPSBuZXcgUmFuZ2Uoc3RhcnQsIHN0YXJ0KTsgfVxuICAgIH0gZWxzZSB7XG4gICAgICBvdXJSYW5nZSA9IGRvYy5zZWwucHJpbWFyeSgpO1xuICAgICAgb3VySW5kZXggPSBkb2Muc2VsLnByaW1JbmRleDtcbiAgICB9XG5cbiAgICBpZiAoYmVoYXZpb3IudW5pdCA9PSBcInJlY3RhbmdsZVwiKSB7XG4gICAgICBpZiAoIWJlaGF2aW9yLmFkZE5ldykgeyBvdXJSYW5nZSA9IG5ldyBSYW5nZShzdGFydCwgc3RhcnQpOyB9XG4gICAgICBzdGFydCA9IHBvc0Zyb21Nb3VzZShjbSwgZXZlbnQsIHRydWUsIHRydWUpO1xuICAgICAgb3VySW5kZXggPSAtMTtcbiAgICB9IGVsc2Uge1xuICAgICAgdmFyIHJhbmdlID0gcmFuZ2VGb3JVbml0KGNtLCBzdGFydCwgYmVoYXZpb3IudW5pdCk7XG4gICAgICBpZiAoYmVoYXZpb3IuZXh0ZW5kKVxuICAgICAgICB7IG91clJhbmdlID0gZXh0ZW5kUmFuZ2Uob3VyUmFuZ2UsIHJhbmdlLmFuY2hvciwgcmFuZ2UuaGVhZCwgYmVoYXZpb3IuZXh0ZW5kKTsgfVxuICAgICAgZWxzZVxuICAgICAgICB7IG91clJhbmdlID0gcmFuZ2U7IH1cbiAgICB9XG5cbiAgICBpZiAoIWJlaGF2aW9yLmFkZE5ldykge1xuICAgICAgb3VySW5kZXggPSAwO1xuICAgICAgc2V0U2VsZWN0aW9uKGRvYywgbmV3IFNlbGVjdGlvbihbb3VyUmFuZ2VdLCAwKSwgc2VsX21vdXNlKTtcbiAgICAgIHN0YXJ0U2VsID0gZG9jLnNlbDtcbiAgICB9IGVsc2UgaWYgKG91ckluZGV4ID09IC0xKSB7XG4gICAgICBvdXJJbmRleCA9IHJhbmdlcy5sZW5ndGg7XG4gICAgICBzZXRTZWxlY3Rpb24oZG9jLCBub3JtYWxpemVTZWxlY3Rpb24oY20sIHJhbmdlcy5jb25jYXQoW291clJhbmdlXSksIG91ckluZGV4KSxcbiAgICAgICAgICAgICAgICAgICB7c2Nyb2xsOiBmYWxzZSwgb3JpZ2luOiBcIiptb3VzZVwifSk7XG4gICAgfSBlbHNlIGlmIChyYW5nZXMubGVuZ3RoID4gMSAmJiByYW5nZXNbb3VySW5kZXhdLmVtcHR5KCkgJiYgYmVoYXZpb3IudW5pdCA9PSBcImNoYXJcIiAmJiAhYmVoYXZpb3IuZXh0ZW5kKSB7XG4gICAgICBzZXRTZWxlY3Rpb24oZG9jLCBub3JtYWxpemVTZWxlY3Rpb24oY20sIHJhbmdlcy5zbGljZSgwLCBvdXJJbmRleCkuY29uY2F0KHJhbmdlcy5zbGljZShvdXJJbmRleCArIDEpKSwgMCksXG4gICAgICAgICAgICAgICAgICAge3Njcm9sbDogZmFsc2UsIG9yaWdpbjogXCIqbW91c2VcIn0pO1xuICAgICAgc3RhcnRTZWwgPSBkb2Muc2VsO1xuICAgIH0gZWxzZSB7XG4gICAgICByZXBsYWNlT25lU2VsZWN0aW9uKGRvYywgb3VySW5kZXgsIG91clJhbmdlLCBzZWxfbW91c2UpO1xuICAgIH1cblxuICAgIHZhciBsYXN0UG9zID0gc3RhcnQ7XG4gICAgZnVuY3Rpb24gZXh0ZW5kVG8ocG9zKSB7XG4gICAgICBpZiAoY21wKGxhc3RQb3MsIHBvcykgPT0gMCkgeyByZXR1cm4gfVxuICAgICAgbGFzdFBvcyA9IHBvcztcblxuICAgICAgaWYgKGJlaGF2aW9yLnVuaXQgPT0gXCJyZWN0YW5nbGVcIikge1xuICAgICAgICB2YXIgcmFuZ2VzID0gW10sIHRhYlNpemUgPSBjbS5vcHRpb25zLnRhYlNpemU7XG4gICAgICAgIHZhciBzdGFydENvbCA9IGNvdW50Q29sdW1uKGdldExpbmUoZG9jLCBzdGFydC5saW5lKS50ZXh0LCBzdGFydC5jaCwgdGFiU2l6ZSk7XG4gICAgICAgIHZhciBwb3NDb2wgPSBjb3VudENvbHVtbihnZXRMaW5lKGRvYywgcG9zLmxpbmUpLnRleHQsIHBvcy5jaCwgdGFiU2l6ZSk7XG4gICAgICAgIHZhciBsZWZ0ID0gTWF0aC5taW4oc3RhcnRDb2wsIHBvc0NvbCksIHJpZ2h0ID0gTWF0aC5tYXgoc3RhcnRDb2wsIHBvc0NvbCk7XG4gICAgICAgIGZvciAodmFyIGxpbmUgPSBNYXRoLm1pbihzdGFydC5saW5lLCBwb3MubGluZSksIGVuZCA9IE1hdGgubWluKGNtLmxhc3RMaW5lKCksIE1hdGgubWF4KHN0YXJ0LmxpbmUsIHBvcy5saW5lKSk7XG4gICAgICAgICAgICAgbGluZSA8PSBlbmQ7IGxpbmUrKykge1xuICAgICAgICAgIHZhciB0ZXh0ID0gZ2V0TGluZShkb2MsIGxpbmUpLnRleHQsIGxlZnRQb3MgPSBmaW5kQ29sdW1uKHRleHQsIGxlZnQsIHRhYlNpemUpO1xuICAgICAgICAgIGlmIChsZWZ0ID09IHJpZ2h0KVxuICAgICAgICAgICAgeyByYW5nZXMucHVzaChuZXcgUmFuZ2UoUG9zKGxpbmUsIGxlZnRQb3MpLCBQb3MobGluZSwgbGVmdFBvcykpKTsgfVxuICAgICAgICAgIGVsc2UgaWYgKHRleHQubGVuZ3RoID4gbGVmdFBvcylcbiAgICAgICAgICAgIHsgcmFuZ2VzLnB1c2gobmV3IFJhbmdlKFBvcyhsaW5lLCBsZWZ0UG9zKSwgUG9zKGxpbmUsIGZpbmRDb2x1bW4odGV4dCwgcmlnaHQsIHRhYlNpemUpKSkpOyB9XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCFyYW5nZXMubGVuZ3RoKSB7IHJhbmdlcy5wdXNoKG5ldyBSYW5nZShzdGFydCwgc3RhcnQpKTsgfVxuICAgICAgICBzZXRTZWxlY3Rpb24oZG9jLCBub3JtYWxpemVTZWxlY3Rpb24oY20sIHN0YXJ0U2VsLnJhbmdlcy5zbGljZSgwLCBvdXJJbmRleCkuY29uY2F0KHJhbmdlcyksIG91ckluZGV4KSxcbiAgICAgICAgICAgICAgICAgICAgIHtvcmlnaW46IFwiKm1vdXNlXCIsIHNjcm9sbDogZmFsc2V9KTtcbiAgICAgICAgY20uc2Nyb2xsSW50b1ZpZXcocG9zKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHZhciBvbGRSYW5nZSA9IG91clJhbmdlO1xuICAgICAgICB2YXIgcmFuZ2UgPSByYW5nZUZvclVuaXQoY20sIHBvcywgYmVoYXZpb3IudW5pdCk7XG4gICAgICAgIHZhciBhbmNob3IgPSBvbGRSYW5nZS5hbmNob3IsIGhlYWQ7XG4gICAgICAgIGlmIChjbXAocmFuZ2UuYW5jaG9yLCBhbmNob3IpID4gMCkge1xuICAgICAgICAgIGhlYWQgPSByYW5nZS5oZWFkO1xuICAgICAgICAgIGFuY2hvciA9IG1pblBvcyhvbGRSYW5nZS5mcm9tKCksIHJhbmdlLmFuY2hvcik7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgaGVhZCA9IHJhbmdlLmFuY2hvcjtcbiAgICAgICAgICBhbmNob3IgPSBtYXhQb3Mob2xkUmFuZ2UudG8oKSwgcmFuZ2UuaGVhZCk7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIHJhbmdlcyQxID0gc3RhcnRTZWwucmFuZ2VzLnNsaWNlKDApO1xuICAgICAgICByYW5nZXMkMVtvdXJJbmRleF0gPSBiaWRpU2ltcGxpZnkoY20sIG5ldyBSYW5nZShjbGlwUG9zKGRvYywgYW5jaG9yKSwgaGVhZCkpO1xuICAgICAgICBzZXRTZWxlY3Rpb24oZG9jLCBub3JtYWxpemVTZWxlY3Rpb24oY20sIHJhbmdlcyQxLCBvdXJJbmRleCksIHNlbF9tb3VzZSk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgdmFyIGVkaXRvclNpemUgPSBkaXNwbGF5LndyYXBwZXIuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCk7XG4gICAgLy8gVXNlZCB0byBlbnN1cmUgdGltZW91dCByZS10cmllcyBkb24ndCBmaXJlIHdoZW4gYW5vdGhlciBleHRlbmRcbiAgICAvLyBoYXBwZW5lZCBpbiB0aGUgbWVhbnRpbWUgKGNsZWFyVGltZW91dCBpc24ndCByZWxpYWJsZSAtLSBhdFxuICAgIC8vIGxlYXN0IG9uIENocm9tZSwgdGhlIHRpbWVvdXRzIHN0aWxsIGhhcHBlbiBldmVuIHdoZW4gY2xlYXJlZCxcbiAgICAvLyBpZiB0aGUgY2xlYXIgaGFwcGVucyBhZnRlciB0aGVpciBzY2hlZHVsZWQgZmlyaW5nIHRpbWUpLlxuICAgIHZhciBjb3VudGVyID0gMDtcblxuICAgIGZ1bmN0aW9uIGV4dGVuZChlKSB7XG4gICAgICB2YXIgY3VyQ291bnQgPSArK2NvdW50ZXI7XG4gICAgICB2YXIgY3VyID0gcG9zRnJvbU1vdXNlKGNtLCBlLCB0cnVlLCBiZWhhdmlvci51bml0ID09IFwicmVjdGFuZ2xlXCIpO1xuICAgICAgaWYgKCFjdXIpIHsgcmV0dXJuIH1cbiAgICAgIGlmIChjbXAoY3VyLCBsYXN0UG9zKSAhPSAwKSB7XG4gICAgICAgIGNtLmN1ck9wLmZvY3VzID0gYWN0aXZlRWx0KCk7XG4gICAgICAgIGV4dGVuZFRvKGN1cik7XG4gICAgICAgIHZhciB2aXNpYmxlID0gdmlzaWJsZUxpbmVzKGRpc3BsYXksIGRvYyk7XG4gICAgICAgIGlmIChjdXIubGluZSA+PSB2aXNpYmxlLnRvIHx8IGN1ci5saW5lIDwgdmlzaWJsZS5mcm9tKVxuICAgICAgICAgIHsgc2V0VGltZW91dChvcGVyYXRpb24oY20sIGZ1bmN0aW9uICgpIHtpZiAoY291bnRlciA9PSBjdXJDb3VudCkgeyBleHRlbmQoZSk7IH19KSwgMTUwKTsgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdmFyIG91dHNpZGUgPSBlLmNsaWVudFkgPCBlZGl0b3JTaXplLnRvcCA/IC0yMCA6IGUuY2xpZW50WSA+IGVkaXRvclNpemUuYm90dG9tID8gMjAgOiAwO1xuICAgICAgICBpZiAob3V0c2lkZSkgeyBzZXRUaW1lb3V0KG9wZXJhdGlvbihjbSwgZnVuY3Rpb24gKCkge1xuICAgICAgICAgIGlmIChjb3VudGVyICE9IGN1ckNvdW50KSB7IHJldHVybiB9XG4gICAgICAgICAgZGlzcGxheS5zY3JvbGxlci5zY3JvbGxUb3AgKz0gb3V0c2lkZTtcbiAgICAgICAgICBleHRlbmQoZSk7XG4gICAgICAgIH0pLCA1MCk7IH1cbiAgICAgIH1cbiAgICB9XG5cbiAgICBmdW5jdGlvbiBkb25lKGUpIHtcbiAgICAgIGNtLnN0YXRlLnNlbGVjdGluZ1RleHQgPSBmYWxzZTtcbiAgICAgIGNvdW50ZXIgPSBJbmZpbml0eTtcbiAgICAgIC8vIElmIGUgaXMgbnVsbCBvciB1bmRlZmluZWQgd2UgaW50ZXJwcmV0IHRoaXMgYXMgc29tZW9uZSB0cnlpbmdcbiAgICAgIC8vIHRvIGV4cGxpY2l0bHkgY2FuY2VsIHRoZSBzZWxlY3Rpb24gcmF0aGVyIHRoYW4gdGhlIHVzZXJcbiAgICAgIC8vIGxldHRpbmcgZ28gb2YgdGhlIG1vdXNlIGJ1dHRvbi5cbiAgICAgIGlmIChlKSB7XG4gICAgICAgIGVfcHJldmVudERlZmF1bHQoZSk7XG4gICAgICAgIGRpc3BsYXkuaW5wdXQuZm9jdXMoKTtcbiAgICAgIH1cbiAgICAgIG9mZihkaXNwbGF5LndyYXBwZXIub3duZXJEb2N1bWVudCwgXCJtb3VzZW1vdmVcIiwgbW92ZSk7XG4gICAgICBvZmYoZGlzcGxheS53cmFwcGVyLm93bmVyRG9jdW1lbnQsIFwibW91c2V1cFwiLCB1cCk7XG4gICAgICBkb2MuaGlzdG9yeS5sYXN0U2VsT3JpZ2luID0gbnVsbDtcbiAgICB9XG5cbiAgICB2YXIgbW92ZSA9IG9wZXJhdGlvbihjbSwgZnVuY3Rpb24gKGUpIHtcbiAgICAgIGlmIChlLmJ1dHRvbnMgPT09IDAgfHwgIWVfYnV0dG9uKGUpKSB7IGRvbmUoZSk7IH1cbiAgICAgIGVsc2UgeyBleHRlbmQoZSk7IH1cbiAgICB9KTtcbiAgICB2YXIgdXAgPSBvcGVyYXRpb24oY20sIGRvbmUpO1xuICAgIGNtLnN0YXRlLnNlbGVjdGluZ1RleHQgPSB1cDtcbiAgICBvbihkaXNwbGF5LndyYXBwZXIub3duZXJEb2N1bWVudCwgXCJtb3VzZW1vdmVcIiwgbW92ZSk7XG4gICAgb24oZGlzcGxheS53cmFwcGVyLm93bmVyRG9jdW1lbnQsIFwibW91c2V1cFwiLCB1cCk7XG4gIH1cblxuICAvLyBVc2VkIHdoZW4gbW91c2Utc2VsZWN0aW5nIHRvIGFkanVzdCB0aGUgYW5jaG9yIHRvIHRoZSBwcm9wZXIgc2lkZVxuICAvLyBvZiBhIGJpZGkganVtcCBkZXBlbmRpbmcgb24gdGhlIHZpc3VhbCBwb3NpdGlvbiBvZiB0aGUgaGVhZC5cbiAgZnVuY3Rpb24gYmlkaVNpbXBsaWZ5KGNtLCByYW5nZSkge1xuICAgIHZhciBhbmNob3IgPSByYW5nZS5hbmNob3I7XG4gICAgdmFyIGhlYWQgPSByYW5nZS5oZWFkO1xuICAgIHZhciBhbmNob3JMaW5lID0gZ2V0TGluZShjbS5kb2MsIGFuY2hvci5saW5lKTtcbiAgICBpZiAoY21wKGFuY2hvciwgaGVhZCkgPT0gMCAmJiBhbmNob3Iuc3RpY2t5ID09IGhlYWQuc3RpY2t5KSB7IHJldHVybiByYW5nZSB9XG4gICAgdmFyIG9yZGVyID0gZ2V0T3JkZXIoYW5jaG9yTGluZSk7XG4gICAgaWYgKCFvcmRlcikgeyByZXR1cm4gcmFuZ2UgfVxuICAgIHZhciBpbmRleCA9IGdldEJpZGlQYXJ0QXQob3JkZXIsIGFuY2hvci5jaCwgYW5jaG9yLnN0aWNreSksIHBhcnQgPSBvcmRlcltpbmRleF07XG4gICAgaWYgKHBhcnQuZnJvbSAhPSBhbmNob3IuY2ggJiYgcGFydC50byAhPSBhbmNob3IuY2gpIHsgcmV0dXJuIHJhbmdlIH1cbiAgICB2YXIgYm91bmRhcnkgPSBpbmRleCArICgocGFydC5mcm9tID09IGFuY2hvci5jaCkgPT0gKHBhcnQubGV2ZWwgIT0gMSkgPyAwIDogMSk7XG4gICAgaWYgKGJvdW5kYXJ5ID09IDAgfHwgYm91bmRhcnkgPT0gb3JkZXIubGVuZ3RoKSB7IHJldHVybiByYW5nZSB9XG5cbiAgICAvLyBDb21wdXRlIHRoZSByZWxhdGl2ZSB2aXN1YWwgcG9zaXRpb24gb2YgdGhlIGhlYWQgY29tcGFyZWQgdG8gdGhlXG4gICAgLy8gYW5jaG9yICg8MCBpcyB0byB0aGUgbGVmdCwgPjAgdG8gdGhlIHJpZ2h0KVxuICAgIHZhciBsZWZ0U2lkZTtcbiAgICBpZiAoaGVhZC5saW5lICE9IGFuY2hvci5saW5lKSB7XG4gICAgICBsZWZ0U2lkZSA9IChoZWFkLmxpbmUgLSBhbmNob3IubGluZSkgKiAoY20uZG9jLmRpcmVjdGlvbiA9PSBcImx0clwiID8gMSA6IC0xKSA+IDA7XG4gICAgfSBlbHNlIHtcbiAgICAgIHZhciBoZWFkSW5kZXggPSBnZXRCaWRpUGFydEF0KG9yZGVyLCBoZWFkLmNoLCBoZWFkLnN0aWNreSk7XG4gICAgICB2YXIgZGlyID0gaGVhZEluZGV4IC0gaW5kZXggfHwgKGhlYWQuY2ggLSBhbmNob3IuY2gpICogKHBhcnQubGV2ZWwgPT0gMSA/IC0xIDogMSk7XG4gICAgICBpZiAoaGVhZEluZGV4ID09IGJvdW5kYXJ5IC0gMSB8fCBoZWFkSW5kZXggPT0gYm91bmRhcnkpXG4gICAgICAgIHsgbGVmdFNpZGUgPSBkaXIgPCAwOyB9XG4gICAgICBlbHNlXG4gICAgICAgIHsgbGVmdFNpZGUgPSBkaXIgPiAwOyB9XG4gICAgfVxuXG4gICAgdmFyIHVzZVBhcnQgPSBvcmRlcltib3VuZGFyeSArIChsZWZ0U2lkZSA/IC0xIDogMCldO1xuICAgIHZhciBmcm9tID0gbGVmdFNpZGUgPT0gKHVzZVBhcnQubGV2ZWwgPT0gMSk7XG4gICAgdmFyIGNoID0gZnJvbSA/IHVzZVBhcnQuZnJvbSA6IHVzZVBhcnQudG8sIHN0aWNreSA9IGZyb20gPyBcImFmdGVyXCIgOiBcImJlZm9yZVwiO1xuICAgIHJldHVybiBhbmNob3IuY2ggPT0gY2ggJiYgYW5jaG9yLnN0aWNreSA9PSBzdGlja3kgPyByYW5nZSA6IG5ldyBSYW5nZShuZXcgUG9zKGFuY2hvci5saW5lLCBjaCwgc3RpY2t5KSwgaGVhZClcbiAgfVxuXG5cbiAgLy8gRGV0ZXJtaW5lcyB3aGV0aGVyIGFuIGV2ZW50IGhhcHBlbmVkIGluIHRoZSBndXR0ZXIsIGFuZCBmaXJlcyB0aGVcbiAgLy8gaGFuZGxlcnMgZm9yIHRoZSBjb3JyZXNwb25kaW5nIGV2ZW50LlxuICBmdW5jdGlvbiBndXR0ZXJFdmVudChjbSwgZSwgdHlwZSwgcHJldmVudCkge1xuICAgIHZhciBtWCwgbVk7XG4gICAgaWYgKGUudG91Y2hlcykge1xuICAgICAgbVggPSBlLnRvdWNoZXNbMF0uY2xpZW50WDtcbiAgICAgIG1ZID0gZS50b3VjaGVzWzBdLmNsaWVudFk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRyeSB7IG1YID0gZS5jbGllbnRYOyBtWSA9IGUuY2xpZW50WTsgfVxuICAgICAgY2F0Y2goZSQxKSB7IHJldHVybiBmYWxzZSB9XG4gICAgfVxuICAgIGlmIChtWCA+PSBNYXRoLmZsb29yKGNtLmRpc3BsYXkuZ3V0dGVycy5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKS5yaWdodCkpIHsgcmV0dXJuIGZhbHNlIH1cbiAgICBpZiAocHJldmVudCkgeyBlX3ByZXZlbnREZWZhdWx0KGUpOyB9XG5cbiAgICB2YXIgZGlzcGxheSA9IGNtLmRpc3BsYXk7XG4gICAgdmFyIGxpbmVCb3ggPSBkaXNwbGF5LmxpbmVEaXYuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCk7XG5cbiAgICBpZiAobVkgPiBsaW5lQm94LmJvdHRvbSB8fCAhaGFzSGFuZGxlcihjbSwgdHlwZSkpIHsgcmV0dXJuIGVfZGVmYXVsdFByZXZlbnRlZChlKSB9XG4gICAgbVkgLT0gbGluZUJveC50b3AgLSBkaXNwbGF5LnZpZXdPZmZzZXQ7XG5cbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGNtLmRpc3BsYXkuZ3V0dGVyU3BlY3MubGVuZ3RoOyArK2kpIHtcbiAgICAgIHZhciBnID0gZGlzcGxheS5ndXR0ZXJzLmNoaWxkTm9kZXNbaV07XG4gICAgICBpZiAoZyAmJiBnLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpLnJpZ2h0ID49IG1YKSB7XG4gICAgICAgIHZhciBsaW5lID0gbGluZUF0SGVpZ2h0KGNtLmRvYywgbVkpO1xuICAgICAgICB2YXIgZ3V0dGVyID0gY20uZGlzcGxheS5ndXR0ZXJTcGVjc1tpXTtcbiAgICAgICAgc2lnbmFsKGNtLCB0eXBlLCBjbSwgbGluZSwgZ3V0dGVyLmNsYXNzTmFtZSwgZSk7XG4gICAgICAgIHJldHVybiBlX2RlZmF1bHRQcmV2ZW50ZWQoZSlcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICBmdW5jdGlvbiBjbGlja0luR3V0dGVyKGNtLCBlKSB7XG4gICAgcmV0dXJuIGd1dHRlckV2ZW50KGNtLCBlLCBcImd1dHRlckNsaWNrXCIsIHRydWUpXG4gIH1cblxuICAvLyBDT05URVhUIE1FTlUgSEFORExJTkdcblxuICAvLyBUbyBtYWtlIHRoZSBjb250ZXh0IG1lbnUgd29yaywgd2UgbmVlZCB0byBicmllZmx5IHVuaGlkZSB0aGVcbiAgLy8gdGV4dGFyZWEgKG1ha2luZyBpdCBhcyB1bm9idHJ1c2l2ZSBhcyBwb3NzaWJsZSkgdG8gbGV0IHRoZVxuICAvLyByaWdodC1jbGljayB0YWtlIGVmZmVjdCBvbiBpdC5cbiAgZnVuY3Rpb24gb25Db250ZXh0TWVudShjbSwgZSkge1xuICAgIGlmIChldmVudEluV2lkZ2V0KGNtLmRpc3BsYXksIGUpIHx8IGNvbnRleHRNZW51SW5HdXR0ZXIoY20sIGUpKSB7IHJldHVybiB9XG4gICAgaWYgKHNpZ25hbERPTUV2ZW50KGNtLCBlLCBcImNvbnRleHRtZW51XCIpKSB7IHJldHVybiB9XG4gICAgaWYgKCFjYXB0dXJlUmlnaHRDbGljaykgeyBjbS5kaXNwbGF5LmlucHV0Lm9uQ29udGV4dE1lbnUoZSk7IH1cbiAgfVxuXG4gIGZ1bmN0aW9uIGNvbnRleHRNZW51SW5HdXR0ZXIoY20sIGUpIHtcbiAgICBpZiAoIWhhc0hhbmRsZXIoY20sIFwiZ3V0dGVyQ29udGV4dE1lbnVcIikpIHsgcmV0dXJuIGZhbHNlIH1cbiAgICByZXR1cm4gZ3V0dGVyRXZlbnQoY20sIGUsIFwiZ3V0dGVyQ29udGV4dE1lbnVcIiwgZmFsc2UpXG4gIH1cblxuICBmdW5jdGlvbiB0aGVtZUNoYW5nZWQoY20pIHtcbiAgICBjbS5kaXNwbGF5LndyYXBwZXIuY2xhc3NOYW1lID0gY20uZGlzcGxheS53cmFwcGVyLmNsYXNzTmFtZS5yZXBsYWNlKC9cXHMqY20tcy1cXFMrL2csIFwiXCIpICtcbiAgICAgIGNtLm9wdGlvbnMudGhlbWUucmVwbGFjZSgvKF58XFxzKVxccyovZywgXCIgY20tcy1cIik7XG4gICAgY2xlYXJDYWNoZXMoY20pO1xuICB9XG5cbiAgdmFyIEluaXQgPSB7dG9TdHJpbmc6IGZ1bmN0aW9uKCl7cmV0dXJuIFwiQ29kZU1pcnJvci5Jbml0XCJ9fTtcblxuICB2YXIgZGVmYXVsdHMgPSB7fTtcbiAgdmFyIG9wdGlvbkhhbmRsZXJzID0ge307XG5cbiAgZnVuY3Rpb24gZGVmaW5lT3B0aW9ucyhDb2RlTWlycm9yKSB7XG4gICAgdmFyIG9wdGlvbkhhbmRsZXJzID0gQ29kZU1pcnJvci5vcHRpb25IYW5kbGVycztcblxuICAgIGZ1bmN0aW9uIG9wdGlvbihuYW1lLCBkZWZsdCwgaGFuZGxlLCBub3RPbkluaXQpIHtcbiAgICAgIENvZGVNaXJyb3IuZGVmYXVsdHNbbmFtZV0gPSBkZWZsdDtcbiAgICAgIGlmIChoYW5kbGUpIHsgb3B0aW9uSGFuZGxlcnNbbmFtZV0gPVxuICAgICAgICBub3RPbkluaXQgPyBmdW5jdGlvbiAoY20sIHZhbCwgb2xkKSB7aWYgKG9sZCAhPSBJbml0KSB7IGhhbmRsZShjbSwgdmFsLCBvbGQpOyB9fSA6IGhhbmRsZTsgfVxuICAgIH1cblxuICAgIENvZGVNaXJyb3IuZGVmaW5lT3B0aW9uID0gb3B0aW9uO1xuXG4gICAgLy8gUGFzc2VkIHRvIG9wdGlvbiBoYW5kbGVycyB3aGVuIHRoZXJlIGlzIG5vIG9sZCB2YWx1ZS5cbiAgICBDb2RlTWlycm9yLkluaXQgPSBJbml0O1xuXG4gICAgLy8gVGhlc2UgdHdvIGFyZSwgb24gaW5pdCwgY2FsbGVkIGZyb20gdGhlIGNvbnN0cnVjdG9yIGJlY2F1c2UgdGhleVxuICAgIC8vIGhhdmUgdG8gYmUgaW5pdGlhbGl6ZWQgYmVmb3JlIHRoZSBlZGl0b3IgY2FuIHN0YXJ0IGF0IGFsbC5cbiAgICBvcHRpb24oXCJ2YWx1ZVwiLCBcIlwiLCBmdW5jdGlvbiAoY20sIHZhbCkgeyByZXR1cm4gY20uc2V0VmFsdWUodmFsKTsgfSwgdHJ1ZSk7XG4gICAgb3B0aW9uKFwibW9kZVwiLCBudWxsLCBmdW5jdGlvbiAoY20sIHZhbCkge1xuICAgICAgY20uZG9jLm1vZGVPcHRpb24gPSB2YWw7XG4gICAgICBsb2FkTW9kZShjbSk7XG4gICAgfSwgdHJ1ZSk7XG5cbiAgICBvcHRpb24oXCJpbmRlbnRVbml0XCIsIDIsIGxvYWRNb2RlLCB0cnVlKTtcbiAgICBvcHRpb24oXCJpbmRlbnRXaXRoVGFic1wiLCBmYWxzZSk7XG4gICAgb3B0aW9uKFwic21hcnRJbmRlbnRcIiwgdHJ1ZSk7XG4gICAgb3B0aW9uKFwidGFiU2l6ZVwiLCA0LCBmdW5jdGlvbiAoY20pIHtcbiAgICAgIHJlc2V0TW9kZVN0YXRlKGNtKTtcbiAgICAgIGNsZWFyQ2FjaGVzKGNtKTtcbiAgICAgIHJlZ0NoYW5nZShjbSk7XG4gICAgfSwgdHJ1ZSk7XG5cbiAgICBvcHRpb24oXCJsaW5lU2VwYXJhdG9yXCIsIG51bGwsIGZ1bmN0aW9uIChjbSwgdmFsKSB7XG4gICAgICBjbS5kb2MubGluZVNlcCA9IHZhbDtcbiAgICAgIGlmICghdmFsKSB7IHJldHVybiB9XG4gICAgICB2YXIgbmV3QnJlYWtzID0gW10sIGxpbmVObyA9IGNtLmRvYy5maXJzdDtcbiAgICAgIGNtLmRvYy5pdGVyKGZ1bmN0aW9uIChsaW5lKSB7XG4gICAgICAgIGZvciAodmFyIHBvcyA9IDA7Oykge1xuICAgICAgICAgIHZhciBmb3VuZCA9IGxpbmUudGV4dC5pbmRleE9mKHZhbCwgcG9zKTtcbiAgICAgICAgICBpZiAoZm91bmQgPT0gLTEpIHsgYnJlYWsgfVxuICAgICAgICAgIHBvcyA9IGZvdW5kICsgdmFsLmxlbmd0aDtcbiAgICAgICAgICBuZXdCcmVha3MucHVzaChQb3MobGluZU5vLCBmb3VuZCkpO1xuICAgICAgICB9XG4gICAgICAgIGxpbmVObysrO1xuICAgICAgfSk7XG4gICAgICBmb3IgKHZhciBpID0gbmV3QnJlYWtzLmxlbmd0aCAtIDE7IGkgPj0gMDsgaS0tKVxuICAgICAgICB7IHJlcGxhY2VSYW5nZShjbS5kb2MsIHZhbCwgbmV3QnJlYWtzW2ldLCBQb3MobmV3QnJlYWtzW2ldLmxpbmUsIG5ld0JyZWFrc1tpXS5jaCArIHZhbC5sZW5ndGgpKTsgfVxuICAgIH0pO1xuICAgIG9wdGlvbihcInNwZWNpYWxDaGFyc1wiLCAvW1xcdTAwMDAtXFx1MDAxZlxcdTAwN2YtXFx1MDA5ZlxcdTAwYWRcXHUwNjFjXFx1MjAwYlxcdTIwMGVcXHUyMDBmXFx1MjAyOFxcdTIwMjlcXHVmZWZmXFx1ZmZmOS1cXHVmZmZjXS9nLCBmdW5jdGlvbiAoY20sIHZhbCwgb2xkKSB7XG4gICAgICBjbS5zdGF0ZS5zcGVjaWFsQ2hhcnMgPSBuZXcgUmVnRXhwKHZhbC5zb3VyY2UgKyAodmFsLnRlc3QoXCJcXHRcIikgPyBcIlwiIDogXCJ8XFx0XCIpLCBcImdcIik7XG4gICAgICBpZiAob2xkICE9IEluaXQpIHsgY20ucmVmcmVzaCgpOyB9XG4gICAgfSk7XG4gICAgb3B0aW9uKFwic3BlY2lhbENoYXJQbGFjZWhvbGRlclwiLCBkZWZhdWx0U3BlY2lhbENoYXJQbGFjZWhvbGRlciwgZnVuY3Rpb24gKGNtKSB7IHJldHVybiBjbS5yZWZyZXNoKCk7IH0sIHRydWUpO1xuICAgIG9wdGlvbihcImVsZWN0cmljQ2hhcnNcIiwgdHJ1ZSk7XG4gICAgb3B0aW9uKFwiaW5wdXRTdHlsZVwiLCBtb2JpbGUgPyBcImNvbnRlbnRlZGl0YWJsZVwiIDogXCJ0ZXh0YXJlYVwiLCBmdW5jdGlvbiAoKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXCJpbnB1dFN0eWxlIGNhbiBub3QgKHlldCkgYmUgY2hhbmdlZCBpbiBhIHJ1bm5pbmcgZWRpdG9yXCIpIC8vIEZJWE1FXG4gICAgfSwgdHJ1ZSk7XG4gICAgb3B0aW9uKFwic3BlbGxjaGVja1wiLCBmYWxzZSwgZnVuY3Rpb24gKGNtLCB2YWwpIHsgcmV0dXJuIGNtLmdldElucHV0RmllbGQoKS5zcGVsbGNoZWNrID0gdmFsOyB9LCB0cnVlKTtcbiAgICBvcHRpb24oXCJhdXRvY29ycmVjdFwiLCBmYWxzZSwgZnVuY3Rpb24gKGNtLCB2YWwpIHsgcmV0dXJuIGNtLmdldElucHV0RmllbGQoKS5hdXRvY29ycmVjdCA9IHZhbDsgfSwgdHJ1ZSk7XG4gICAgb3B0aW9uKFwiYXV0b2NhcGl0YWxpemVcIiwgZmFsc2UsIGZ1bmN0aW9uIChjbSwgdmFsKSB7IHJldHVybiBjbS5nZXRJbnB1dEZpZWxkKCkuYXV0b2NhcGl0YWxpemUgPSB2YWw7IH0sIHRydWUpO1xuICAgIG9wdGlvbihcInJ0bE1vdmVWaXN1YWxseVwiLCAhd2luZG93cyk7XG4gICAgb3B0aW9uKFwid2hvbGVMaW5lVXBkYXRlQmVmb3JlXCIsIHRydWUpO1xuXG4gICAgb3B0aW9uKFwidGhlbWVcIiwgXCJkZWZhdWx0XCIsIGZ1bmN0aW9uIChjbSkge1xuICAgICAgdGhlbWVDaGFuZ2VkKGNtKTtcbiAgICAgIHVwZGF0ZUd1dHRlcnMoY20pO1xuICAgIH0sIHRydWUpO1xuICAgIG9wdGlvbihcImtleU1hcFwiLCBcImRlZmF1bHRcIiwgZnVuY3Rpb24gKGNtLCB2YWwsIG9sZCkge1xuICAgICAgdmFyIG5leHQgPSBnZXRLZXlNYXAodmFsKTtcbiAgICAgIHZhciBwcmV2ID0gb2xkICE9IEluaXQgJiYgZ2V0S2V5TWFwKG9sZCk7XG4gICAgICBpZiAocHJldiAmJiBwcmV2LmRldGFjaCkgeyBwcmV2LmRldGFjaChjbSwgbmV4dCk7IH1cbiAgICAgIGlmIChuZXh0LmF0dGFjaCkgeyBuZXh0LmF0dGFjaChjbSwgcHJldiB8fCBudWxsKTsgfVxuICAgIH0pO1xuICAgIG9wdGlvbihcImV4dHJhS2V5c1wiLCBudWxsKTtcbiAgICBvcHRpb24oXCJjb25maWd1cmVNb3VzZVwiLCBudWxsKTtcblxuICAgIG9wdGlvbihcImxpbmVXcmFwcGluZ1wiLCBmYWxzZSwgd3JhcHBpbmdDaGFuZ2VkLCB0cnVlKTtcbiAgICBvcHRpb24oXCJndXR0ZXJzXCIsIFtdLCBmdW5jdGlvbiAoY20sIHZhbCkge1xuICAgICAgY20uZGlzcGxheS5ndXR0ZXJTcGVjcyA9IGdldEd1dHRlcnModmFsLCBjbS5vcHRpb25zLmxpbmVOdW1iZXJzKTtcbiAgICAgIHVwZGF0ZUd1dHRlcnMoY20pO1xuICAgIH0sIHRydWUpO1xuICAgIG9wdGlvbihcImZpeGVkR3V0dGVyXCIsIHRydWUsIGZ1bmN0aW9uIChjbSwgdmFsKSB7XG4gICAgICBjbS5kaXNwbGF5Lmd1dHRlcnMuc3R5bGUubGVmdCA9IHZhbCA/IGNvbXBlbnNhdGVGb3JIU2Nyb2xsKGNtLmRpc3BsYXkpICsgXCJweFwiIDogXCIwXCI7XG4gICAgICBjbS5yZWZyZXNoKCk7XG4gICAgfSwgdHJ1ZSk7XG4gICAgb3B0aW9uKFwiY292ZXJHdXR0ZXJOZXh0VG9TY3JvbGxiYXJcIiwgZmFsc2UsIGZ1bmN0aW9uIChjbSkgeyByZXR1cm4gdXBkYXRlU2Nyb2xsYmFycyhjbSk7IH0sIHRydWUpO1xuICAgIG9wdGlvbihcInNjcm9sbGJhclN0eWxlXCIsIFwibmF0aXZlXCIsIGZ1bmN0aW9uIChjbSkge1xuICAgICAgaW5pdFNjcm9sbGJhcnMoY20pO1xuICAgICAgdXBkYXRlU2Nyb2xsYmFycyhjbSk7XG4gICAgICBjbS5kaXNwbGF5LnNjcm9sbGJhcnMuc2V0U2Nyb2xsVG9wKGNtLmRvYy5zY3JvbGxUb3ApO1xuICAgICAgY20uZGlzcGxheS5zY3JvbGxiYXJzLnNldFNjcm9sbExlZnQoY20uZG9jLnNjcm9sbExlZnQpO1xuICAgIH0sIHRydWUpO1xuICAgIG9wdGlvbihcImxpbmVOdW1iZXJzXCIsIGZhbHNlLCBmdW5jdGlvbiAoY20sIHZhbCkge1xuICAgICAgY20uZGlzcGxheS5ndXR0ZXJTcGVjcyA9IGdldEd1dHRlcnMoY20ub3B0aW9ucy5ndXR0ZXJzLCB2YWwpO1xuICAgICAgdXBkYXRlR3V0dGVycyhjbSk7XG4gICAgfSwgdHJ1ZSk7XG4gICAgb3B0aW9uKFwiZmlyc3RMaW5lTnVtYmVyXCIsIDEsIHVwZGF0ZUd1dHRlcnMsIHRydWUpO1xuICAgIG9wdGlvbihcImxpbmVOdW1iZXJGb3JtYXR0ZXJcIiwgZnVuY3Rpb24gKGludGVnZXIpIHsgcmV0dXJuIGludGVnZXI7IH0sIHVwZGF0ZUd1dHRlcnMsIHRydWUpO1xuICAgIG9wdGlvbihcInNob3dDdXJzb3JXaGVuU2VsZWN0aW5nXCIsIGZhbHNlLCB1cGRhdGVTZWxlY3Rpb24sIHRydWUpO1xuXG4gICAgb3B0aW9uKFwicmVzZXRTZWxlY3Rpb25PbkNvbnRleHRNZW51XCIsIHRydWUpO1xuICAgIG9wdGlvbihcImxpbmVXaXNlQ29weUN1dFwiLCB0cnVlKTtcbiAgICBvcHRpb24oXCJwYXN0ZUxpbmVzUGVyU2VsZWN0aW9uXCIsIHRydWUpO1xuICAgIG9wdGlvbihcInNlbGVjdGlvbnNNYXlUb3VjaFwiLCBmYWxzZSk7XG5cbiAgICBvcHRpb24oXCJyZWFkT25seVwiLCBmYWxzZSwgZnVuY3Rpb24gKGNtLCB2YWwpIHtcbiAgICAgIGlmICh2YWwgPT0gXCJub2N1cnNvclwiKSB7XG4gICAgICAgIG9uQmx1cihjbSk7XG4gICAgICAgIGNtLmRpc3BsYXkuaW5wdXQuYmx1cigpO1xuICAgICAgfVxuICAgICAgY20uZGlzcGxheS5pbnB1dC5yZWFkT25seUNoYW5nZWQodmFsKTtcbiAgICB9KTtcblxuICAgIG9wdGlvbihcInNjcmVlblJlYWRlckxhYmVsXCIsIG51bGwsIGZ1bmN0aW9uIChjbSwgdmFsKSB7XG4gICAgICB2YWwgPSAodmFsID09PSAnJykgPyBudWxsIDogdmFsO1xuICAgICAgY20uZGlzcGxheS5pbnB1dC5zY3JlZW5SZWFkZXJMYWJlbENoYW5nZWQodmFsKTtcbiAgICB9KTtcblxuICAgIG9wdGlvbihcImRpc2FibGVJbnB1dFwiLCBmYWxzZSwgZnVuY3Rpb24gKGNtLCB2YWwpIHtpZiAoIXZhbCkgeyBjbS5kaXNwbGF5LmlucHV0LnJlc2V0KCk7IH19LCB0cnVlKTtcbiAgICBvcHRpb24oXCJkcmFnRHJvcFwiLCB0cnVlLCBkcmFnRHJvcENoYW5nZWQpO1xuICAgIG9wdGlvbihcImFsbG93RHJvcEZpbGVUeXBlc1wiLCBudWxsKTtcblxuICAgIG9wdGlvbihcImN1cnNvckJsaW5rUmF0ZVwiLCA1MzApO1xuICAgIG9wdGlvbihcImN1cnNvclNjcm9sbE1hcmdpblwiLCAwKTtcbiAgICBvcHRpb24oXCJjdXJzb3JIZWlnaHRcIiwgMSwgdXBkYXRlU2VsZWN0aW9uLCB0cnVlKTtcbiAgICBvcHRpb24oXCJzaW5nbGVDdXJzb3JIZWlnaHRQZXJMaW5lXCIsIHRydWUsIHVwZGF0ZVNlbGVjdGlvbiwgdHJ1ZSk7XG4gICAgb3B0aW9uKFwid29ya1RpbWVcIiwgMTAwKTtcbiAgICBvcHRpb24oXCJ3b3JrRGVsYXlcIiwgMTAwKTtcbiAgICBvcHRpb24oXCJmbGF0dGVuU3BhbnNcIiwgdHJ1ZSwgcmVzZXRNb2RlU3RhdGUsIHRydWUpO1xuICAgIG9wdGlvbihcImFkZE1vZGVDbGFzc1wiLCBmYWxzZSwgcmVzZXRNb2RlU3RhdGUsIHRydWUpO1xuICAgIG9wdGlvbihcInBvbGxJbnRlcnZhbFwiLCAxMDApO1xuICAgIG9wdGlvbihcInVuZG9EZXB0aFwiLCAyMDAsIGZ1bmN0aW9uIChjbSwgdmFsKSB7IHJldHVybiBjbS5kb2MuaGlzdG9yeS51bmRvRGVwdGggPSB2YWw7IH0pO1xuICAgIG9wdGlvbihcImhpc3RvcnlFdmVudERlbGF5XCIsIDEyNTApO1xuICAgIG9wdGlvbihcInZpZXdwb3J0TWFyZ2luXCIsIDEwLCBmdW5jdGlvbiAoY20pIHsgcmV0dXJuIGNtLnJlZnJlc2goKTsgfSwgdHJ1ZSk7XG4gICAgb3B0aW9uKFwibWF4SGlnaGxpZ2h0TGVuZ3RoXCIsIDEwMDAwLCByZXNldE1vZGVTdGF0ZSwgdHJ1ZSk7XG4gICAgb3B0aW9uKFwibW92ZUlucHV0V2l0aEN1cnNvclwiLCB0cnVlLCBmdW5jdGlvbiAoY20sIHZhbCkge1xuICAgICAgaWYgKCF2YWwpIHsgY20uZGlzcGxheS5pbnB1dC5yZXNldFBvc2l0aW9uKCk7IH1cbiAgICB9KTtcblxuICAgIG9wdGlvbihcInRhYmluZGV4XCIsIG51bGwsIGZ1bmN0aW9uIChjbSwgdmFsKSB7IHJldHVybiBjbS5kaXNwbGF5LmlucHV0LmdldEZpZWxkKCkudGFiSW5kZXggPSB2YWwgfHwgXCJcIjsgfSk7XG4gICAgb3B0aW9uKFwiYXV0b2ZvY3VzXCIsIG51bGwpO1xuICAgIG9wdGlvbihcImRpcmVjdGlvblwiLCBcImx0clwiLCBmdW5jdGlvbiAoY20sIHZhbCkgeyByZXR1cm4gY20uZG9jLnNldERpcmVjdGlvbih2YWwpOyB9LCB0cnVlKTtcbiAgICBvcHRpb24oXCJwaHJhc2VzXCIsIG51bGwpO1xuICB9XG5cbiAgZnVuY3Rpb24gZHJhZ0Ryb3BDaGFuZ2VkKGNtLCB2YWx1ZSwgb2xkKSB7XG4gICAgdmFyIHdhc09uID0gb2xkICYmIG9sZCAhPSBJbml0O1xuICAgIGlmICghdmFsdWUgIT0gIXdhc09uKSB7XG4gICAgICB2YXIgZnVuY3MgPSBjbS5kaXNwbGF5LmRyYWdGdW5jdGlvbnM7XG4gICAgICB2YXIgdG9nZ2xlID0gdmFsdWUgPyBvbiA6IG9mZjtcbiAgICAgIHRvZ2dsZShjbS5kaXNwbGF5LnNjcm9sbGVyLCBcImRyYWdzdGFydFwiLCBmdW5jcy5zdGFydCk7XG4gICAgICB0b2dnbGUoY20uZGlzcGxheS5zY3JvbGxlciwgXCJkcmFnZW50ZXJcIiwgZnVuY3MuZW50ZXIpO1xuICAgICAgdG9nZ2xlKGNtLmRpc3BsYXkuc2Nyb2xsZXIsIFwiZHJhZ292ZXJcIiwgZnVuY3Mub3Zlcik7XG4gICAgICB0b2dnbGUoY20uZGlzcGxheS5zY3JvbGxlciwgXCJkcmFnbGVhdmVcIiwgZnVuY3MubGVhdmUpO1xuICAgICAgdG9nZ2xlKGNtLmRpc3BsYXkuc2Nyb2xsZXIsIFwiZHJvcFwiLCBmdW5jcy5kcm9wKTtcbiAgICB9XG4gIH1cblxuICBmdW5jdGlvbiB3cmFwcGluZ0NoYW5nZWQoY20pIHtcbiAgICBpZiAoY20ub3B0aW9ucy5saW5lV3JhcHBpbmcpIHtcbiAgICAgIGFkZENsYXNzKGNtLmRpc3BsYXkud3JhcHBlciwgXCJDb2RlTWlycm9yLXdyYXBcIik7XG4gICAgICBjbS5kaXNwbGF5LnNpemVyLnN0eWxlLm1pbldpZHRoID0gXCJcIjtcbiAgICAgIGNtLmRpc3BsYXkuc2l6ZXJXaWR0aCA9IG51bGw7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJtQ2xhc3MoY20uZGlzcGxheS53cmFwcGVyLCBcIkNvZGVNaXJyb3Itd3JhcFwiKTtcbiAgICAgIGZpbmRNYXhMaW5lKGNtKTtcbiAgICB9XG4gICAgZXN0aW1hdGVMaW5lSGVpZ2h0cyhjbSk7XG4gICAgcmVnQ2hhbmdlKGNtKTtcbiAgICBjbGVhckNhY2hlcyhjbSk7XG4gICAgc2V0VGltZW91dChmdW5jdGlvbiAoKSB7IHJldHVybiB1cGRhdGVTY3JvbGxiYXJzKGNtKTsgfSwgMTAwKTtcbiAgfVxuXG4gIC8vIEEgQ29kZU1pcnJvciBpbnN0YW5jZSByZXByZXNlbnRzIGFuIGVkaXRvci4gVGhpcyBpcyB0aGUgb2JqZWN0XG4gIC8vIHRoYXQgdXNlciBjb2RlIGlzIHVzdWFsbHkgZGVhbGluZyB3aXRoLlxuXG4gIGZ1bmN0aW9uIENvZGVNaXJyb3IocGxhY2UsIG9wdGlvbnMpIHtcbiAgICB2YXIgdGhpcyQxID0gdGhpcztcblxuICAgIGlmICghKHRoaXMgaW5zdGFuY2VvZiBDb2RlTWlycm9yKSkgeyByZXR1cm4gbmV3IENvZGVNaXJyb3IocGxhY2UsIG9wdGlvbnMpIH1cblxuICAgIHRoaXMub3B0aW9ucyA9IG9wdGlvbnMgPSBvcHRpb25zID8gY29weU9iaihvcHRpb25zKSA6IHt9O1xuICAgIC8vIERldGVybWluZSBlZmZlY3RpdmUgb3B0aW9ucyBiYXNlZCBvbiBnaXZlbiB2YWx1ZXMgYW5kIGRlZmF1bHRzLlxuICAgIGNvcHlPYmooZGVmYXVsdHMsIG9wdGlvbnMsIGZhbHNlKTtcblxuICAgIHZhciBkb2MgPSBvcHRpb25zLnZhbHVlO1xuICAgIGlmICh0eXBlb2YgZG9jID09IFwic3RyaW5nXCIpIHsgZG9jID0gbmV3IERvYyhkb2MsIG9wdGlvbnMubW9kZSwgbnVsbCwgb3B0aW9ucy5saW5lU2VwYXJhdG9yLCBvcHRpb25zLmRpcmVjdGlvbik7IH1cbiAgICBlbHNlIGlmIChvcHRpb25zLm1vZGUpIHsgZG9jLm1vZGVPcHRpb24gPSBvcHRpb25zLm1vZGU7IH1cbiAgICB0aGlzLmRvYyA9IGRvYztcblxuICAgIHZhciBpbnB1dCA9IG5ldyBDb2RlTWlycm9yLmlucHV0U3R5bGVzW29wdGlvbnMuaW5wdXRTdHlsZV0odGhpcyk7XG4gICAgdmFyIGRpc3BsYXkgPSB0aGlzLmRpc3BsYXkgPSBuZXcgRGlzcGxheShwbGFjZSwgZG9jLCBpbnB1dCwgb3B0aW9ucyk7XG4gICAgZGlzcGxheS53cmFwcGVyLkNvZGVNaXJyb3IgPSB0aGlzO1xuICAgIHRoZW1lQ2hhbmdlZCh0aGlzKTtcbiAgICBpZiAob3B0aW9ucy5saW5lV3JhcHBpbmcpXG4gICAgICB7IHRoaXMuZGlzcGxheS53cmFwcGVyLmNsYXNzTmFtZSArPSBcIiBDb2RlTWlycm9yLXdyYXBcIjsgfVxuICAgIGluaXRTY3JvbGxiYXJzKHRoaXMpO1xuXG4gICAgdGhpcy5zdGF0ZSA9IHtcbiAgICAgIGtleU1hcHM6IFtdLCAgLy8gc3RvcmVzIG1hcHMgYWRkZWQgYnkgYWRkS2V5TWFwXG4gICAgICBvdmVybGF5czogW10sIC8vIGhpZ2hsaWdodGluZyBvdmVybGF5cywgYXMgYWRkZWQgYnkgYWRkT3ZlcmxheVxuICAgICAgbW9kZUdlbjogMCwgICAvLyBidW1wZWQgd2hlbiBtb2RlL292ZXJsYXkgY2hhbmdlcywgdXNlZCB0byBpbnZhbGlkYXRlIGhpZ2hsaWdodGluZyBpbmZvXG4gICAgICBvdmVyd3JpdGU6IGZhbHNlLFxuICAgICAgZGVsYXlpbmdCbHVyRXZlbnQ6IGZhbHNlLFxuICAgICAgZm9jdXNlZDogZmFsc2UsXG4gICAgICBzdXBwcmVzc0VkaXRzOiBmYWxzZSwgLy8gdXNlZCB0byBkaXNhYmxlIGVkaXRpbmcgZHVyaW5nIGtleSBoYW5kbGVycyB3aGVuIGluIHJlYWRPbmx5IG1vZGVcbiAgICAgIHBhc3RlSW5jb21pbmc6IC0xLCBjdXRJbmNvbWluZzogLTEsIC8vIGhlbHAgcmVjb2duaXplIHBhc3RlL2N1dCBlZGl0cyBpbiBpbnB1dC5wb2xsXG4gICAgICBzZWxlY3RpbmdUZXh0OiBmYWxzZSxcbiAgICAgIGRyYWdnaW5nVGV4dDogZmFsc2UsXG4gICAgICBoaWdobGlnaHQ6IG5ldyBEZWxheWVkKCksIC8vIHN0b3JlcyBoaWdobGlnaHQgd29ya2VyIHRpbWVvdXRcbiAgICAgIGtleVNlcTogbnVsbCwgIC8vIFVuZmluaXNoZWQga2V5IHNlcXVlbmNlXG4gICAgICBzcGVjaWFsQ2hhcnM6IG51bGxcbiAgICB9O1xuXG4gICAgaWYgKG9wdGlvbnMuYXV0b2ZvY3VzICYmICFtb2JpbGUpIHsgZGlzcGxheS5pbnB1dC5mb2N1cygpOyB9XG5cbiAgICAvLyBPdmVycmlkZSBtYWdpYyB0ZXh0YXJlYSBjb250ZW50IHJlc3RvcmUgdGhhdCBJRSBzb21ldGltZXMgZG9lc1xuICAgIC8vIG9uIG91ciBoaWRkZW4gdGV4dGFyZWEgb24gcmVsb2FkXG4gICAgaWYgKGllICYmIGllX3ZlcnNpb24gPCAxMSkgeyBzZXRUaW1lb3V0KGZ1bmN0aW9uICgpIHsgcmV0dXJuIHRoaXMkMS5kaXNwbGF5LmlucHV0LnJlc2V0KHRydWUpOyB9LCAyMCk7IH1cblxuICAgIHJlZ2lzdGVyRXZlbnRIYW5kbGVycyh0aGlzKTtcbiAgICBlbnN1cmVHbG9iYWxIYW5kbGVycygpO1xuXG4gICAgc3RhcnRPcGVyYXRpb24odGhpcyk7XG4gICAgdGhpcy5jdXJPcC5mb3JjZVVwZGF0ZSA9IHRydWU7XG4gICAgYXR0YWNoRG9jKHRoaXMsIGRvYyk7XG5cbiAgICBpZiAoKG9wdGlvbnMuYXV0b2ZvY3VzICYmICFtb2JpbGUpIHx8IHRoaXMuaGFzRm9jdXMoKSlcbiAgICAgIHsgc2V0VGltZW91dChmdW5jdGlvbiAoKSB7XG4gICAgICAgIGlmICh0aGlzJDEuaGFzRm9jdXMoKSAmJiAhdGhpcyQxLnN0YXRlLmZvY3VzZWQpIHsgb25Gb2N1cyh0aGlzJDEpOyB9XG4gICAgICB9LCAyMCk7IH1cbiAgICBlbHNlXG4gICAgICB7IG9uQmx1cih0aGlzKTsgfVxuXG4gICAgZm9yICh2YXIgb3B0IGluIG9wdGlvbkhhbmRsZXJzKSB7IGlmIChvcHRpb25IYW5kbGVycy5oYXNPd25Qcm9wZXJ0eShvcHQpKVxuICAgICAgeyBvcHRpb25IYW5kbGVyc1tvcHRdKHRoaXMsIG9wdGlvbnNbb3B0XSwgSW5pdCk7IH0gfVxuICAgIG1heWJlVXBkYXRlTGluZU51bWJlcldpZHRoKHRoaXMpO1xuICAgIGlmIChvcHRpb25zLmZpbmlzaEluaXQpIHsgb3B0aW9ucy5maW5pc2hJbml0KHRoaXMpOyB9XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBpbml0SG9va3MubGVuZ3RoOyArK2kpIHsgaW5pdEhvb2tzW2ldKHRoaXMpOyB9XG4gICAgZW5kT3BlcmF0aW9uKHRoaXMpO1xuICAgIC8vIFN1cHByZXNzIG9wdGltaXplbGVnaWJpbGl0eSBpbiBXZWJraXQsIHNpbmNlIGl0IGJyZWFrcyB0ZXh0XG4gICAgLy8gbWVhc3VyaW5nIG9uIGxpbmUgd3JhcHBpbmcgYm91bmRhcmllcy5cbiAgICBpZiAod2Via2l0ICYmIG9wdGlvbnMubGluZVdyYXBwaW5nICYmXG4gICAgICAgIGdldENvbXB1dGVkU3R5bGUoZGlzcGxheS5saW5lRGl2KS50ZXh0UmVuZGVyaW5nID09IFwib3B0aW1pemVsZWdpYmlsaXR5XCIpXG4gICAgICB7IGRpc3BsYXkubGluZURpdi5zdHlsZS50ZXh0UmVuZGVyaW5nID0gXCJhdXRvXCI7IH1cbiAgfVxuXG4gIC8vIFRoZSBkZWZhdWx0IGNvbmZpZ3VyYXRpb24gb3B0aW9ucy5cbiAgQ29kZU1pcnJvci5kZWZhdWx0cyA9IGRlZmF1bHRzO1xuICAvLyBGdW5jdGlvbnMgdG8gcnVuIHdoZW4gb3B0aW9ucyBhcmUgY2hhbmdlZC5cbiAgQ29kZU1pcnJvci5vcHRpb25IYW5kbGVycyA9IG9wdGlvbkhhbmRsZXJzO1xuXG4gIC8vIEF0dGFjaCB0aGUgbmVjZXNzYXJ5IGV2ZW50IGhhbmRsZXJzIHdoZW4gaW5pdGlhbGl6aW5nIHRoZSBlZGl0b3JcbiAgZnVuY3Rpb24gcmVnaXN0ZXJFdmVudEhhbmRsZXJzKGNtKSB7XG4gICAgdmFyIGQgPSBjbS5kaXNwbGF5O1xuICAgIG9uKGQuc2Nyb2xsZXIsIFwibW91c2Vkb3duXCIsIG9wZXJhdGlvbihjbSwgb25Nb3VzZURvd24pKTtcbiAgICAvLyBPbGRlciBJRSdzIHdpbGwgbm90IGZpcmUgYSBzZWNvbmQgbW91c2Vkb3duIGZvciBhIGRvdWJsZSBjbGlja1xuICAgIGlmIChpZSAmJiBpZV92ZXJzaW9uIDwgMTEpXG4gICAgICB7IG9uKGQuc2Nyb2xsZXIsIFwiZGJsY2xpY2tcIiwgb3BlcmF0aW9uKGNtLCBmdW5jdGlvbiAoZSkge1xuICAgICAgICBpZiAoc2lnbmFsRE9NRXZlbnQoY20sIGUpKSB7IHJldHVybiB9XG4gICAgICAgIHZhciBwb3MgPSBwb3NGcm9tTW91c2UoY20sIGUpO1xuICAgICAgICBpZiAoIXBvcyB8fCBjbGlja0luR3V0dGVyKGNtLCBlKSB8fCBldmVudEluV2lkZ2V0KGNtLmRpc3BsYXksIGUpKSB7IHJldHVybiB9XG4gICAgICAgIGVfcHJldmVudERlZmF1bHQoZSk7XG4gICAgICAgIHZhciB3b3JkID0gY20uZmluZFdvcmRBdChwb3MpO1xuICAgICAgICBleHRlbmRTZWxlY3Rpb24oY20uZG9jLCB3b3JkLmFuY2hvciwgd29yZC5oZWFkKTtcbiAgICAgIH0pKTsgfVxuICAgIGVsc2VcbiAgICAgIHsgb24oZC5zY3JvbGxlciwgXCJkYmxjbGlja1wiLCBmdW5jdGlvbiAoZSkgeyByZXR1cm4gc2lnbmFsRE9NRXZlbnQoY20sIGUpIHx8IGVfcHJldmVudERlZmF1bHQoZSk7IH0pOyB9XG4gICAgLy8gU29tZSBicm93c2VycyBmaXJlIGNvbnRleHRtZW51ICphZnRlciogb3BlbmluZyB0aGUgbWVudSwgYXRcbiAgICAvLyB3aGljaCBwb2ludCB3ZSBjYW4ndCBtZXNzIHdpdGggaXQgYW55bW9yZS4gQ29udGV4dCBtZW51IGlzXG4gICAgLy8gaGFuZGxlZCBpbiBvbk1vdXNlRG93biBmb3IgdGhlc2UgYnJvd3NlcnMuXG4gICAgb24oZC5zY3JvbGxlciwgXCJjb250ZXh0bWVudVwiLCBmdW5jdGlvbiAoZSkgeyByZXR1cm4gb25Db250ZXh0TWVudShjbSwgZSk7IH0pO1xuICAgIG9uKGQuaW5wdXQuZ2V0RmllbGQoKSwgXCJjb250ZXh0bWVudVwiLCBmdW5jdGlvbiAoZSkge1xuICAgICAgaWYgKCFkLnNjcm9sbGVyLmNvbnRhaW5zKGUudGFyZ2V0KSkgeyBvbkNvbnRleHRNZW51KGNtLCBlKTsgfVxuICAgIH0pO1xuXG4gICAgLy8gVXNlZCB0byBzdXBwcmVzcyBtb3VzZSBldmVudCBoYW5kbGluZyB3aGVuIGEgdG91Y2ggaGFwcGVuc1xuICAgIHZhciB0b3VjaEZpbmlzaGVkLCBwcmV2VG91Y2ggPSB7ZW5kOiAwfTtcbiAgICBmdW5jdGlvbiBmaW5pc2hUb3VjaCgpIHtcbiAgICAgIGlmIChkLmFjdGl2ZVRvdWNoKSB7XG4gICAgICAgIHRvdWNoRmluaXNoZWQgPSBzZXRUaW1lb3V0KGZ1bmN0aW9uICgpIHsgcmV0dXJuIGQuYWN0aXZlVG91Y2ggPSBudWxsOyB9LCAxMDAwKTtcbiAgICAgICAgcHJldlRvdWNoID0gZC5hY3RpdmVUb3VjaDtcbiAgICAgICAgcHJldlRvdWNoLmVuZCA9ICtuZXcgRGF0ZTtcbiAgICAgIH1cbiAgICB9XG4gICAgZnVuY3Rpb24gaXNNb3VzZUxpa2VUb3VjaEV2ZW50KGUpIHtcbiAgICAgIGlmIChlLnRvdWNoZXMubGVuZ3RoICE9IDEpIHsgcmV0dXJuIGZhbHNlIH1cbiAgICAgIHZhciB0b3VjaCA9IGUudG91Y2hlc1swXTtcbiAgICAgIHJldHVybiB0b3VjaC5yYWRpdXNYIDw9IDEgJiYgdG91Y2gucmFkaXVzWSA8PSAxXG4gICAgfVxuICAgIGZ1bmN0aW9uIGZhckF3YXkodG91Y2gsIG90aGVyKSB7XG4gICAgICBpZiAob3RoZXIubGVmdCA9PSBudWxsKSB7IHJldHVybiB0cnVlIH1cbiAgICAgIHZhciBkeCA9IG90aGVyLmxlZnQgLSB0b3VjaC5sZWZ0LCBkeSA9IG90aGVyLnRvcCAtIHRvdWNoLnRvcDtcbiAgICAgIHJldHVybiBkeCAqIGR4ICsgZHkgKiBkeSA+IDIwICogMjBcbiAgICB9XG4gICAgb24oZC5zY3JvbGxlciwgXCJ0b3VjaHN0YXJ0XCIsIGZ1bmN0aW9uIChlKSB7XG4gICAgICBpZiAoIXNpZ25hbERPTUV2ZW50KGNtLCBlKSAmJiAhaXNNb3VzZUxpa2VUb3VjaEV2ZW50KGUpICYmICFjbGlja0luR3V0dGVyKGNtLCBlKSkge1xuICAgICAgICBkLmlucHV0LmVuc3VyZVBvbGxlZCgpO1xuICAgICAgICBjbGVhclRpbWVvdXQodG91Y2hGaW5pc2hlZCk7XG4gICAgICAgIHZhciBub3cgPSArbmV3IERhdGU7XG4gICAgICAgIGQuYWN0aXZlVG91Y2ggPSB7c3RhcnQ6IG5vdywgbW92ZWQ6IGZhbHNlLFxuICAgICAgICAgICAgICAgICAgICAgICAgIHByZXY6IG5vdyAtIHByZXZUb3VjaC5lbmQgPD0gMzAwID8gcHJldlRvdWNoIDogbnVsbH07XG4gICAgICAgIGlmIChlLnRvdWNoZXMubGVuZ3RoID09IDEpIHtcbiAgICAgICAgICBkLmFjdGl2ZVRvdWNoLmxlZnQgPSBlLnRvdWNoZXNbMF0ucGFnZVg7XG4gICAgICAgICAgZC5hY3RpdmVUb3VjaC50b3AgPSBlLnRvdWNoZXNbMF0ucGFnZVk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9KTtcbiAgICBvbihkLnNjcm9sbGVyLCBcInRvdWNobW92ZVwiLCBmdW5jdGlvbiAoKSB7XG4gICAgICBpZiAoZC5hY3RpdmVUb3VjaCkgeyBkLmFjdGl2ZVRvdWNoLm1vdmVkID0gdHJ1ZTsgfVxuICAgIH0pO1xuICAgIG9uKGQuc2Nyb2xsZXIsIFwidG91Y2hlbmRcIiwgZnVuY3Rpb24gKGUpIHtcbiAgICAgIHZhciB0b3VjaCA9IGQuYWN0aXZlVG91Y2g7XG4gICAgICBpZiAodG91Y2ggJiYgIWV2ZW50SW5XaWRnZXQoZCwgZSkgJiYgdG91Y2gubGVmdCAhPSBudWxsICYmXG4gICAgICAgICAgIXRvdWNoLm1vdmVkICYmIG5ldyBEYXRlIC0gdG91Y2guc3RhcnQgPCAzMDApIHtcbiAgICAgICAgdmFyIHBvcyA9IGNtLmNvb3Jkc0NoYXIoZC5hY3RpdmVUb3VjaCwgXCJwYWdlXCIpLCByYW5nZTtcbiAgICAgICAgaWYgKCF0b3VjaC5wcmV2IHx8IGZhckF3YXkodG91Y2gsIHRvdWNoLnByZXYpKSAvLyBTaW5nbGUgdGFwXG4gICAgICAgICAgeyByYW5nZSA9IG5ldyBSYW5nZShwb3MsIHBvcyk7IH1cbiAgICAgICAgZWxzZSBpZiAoIXRvdWNoLnByZXYucHJldiB8fCBmYXJBd2F5KHRvdWNoLCB0b3VjaC5wcmV2LnByZXYpKSAvLyBEb3VibGUgdGFwXG4gICAgICAgICAgeyByYW5nZSA9IGNtLmZpbmRXb3JkQXQocG9zKTsgfVxuICAgICAgICBlbHNlIC8vIFRyaXBsZSB0YXBcbiAgICAgICAgICB7IHJhbmdlID0gbmV3IFJhbmdlKFBvcyhwb3MubGluZSwgMCksIGNsaXBQb3MoY20uZG9jLCBQb3MocG9zLmxpbmUgKyAxLCAwKSkpOyB9XG4gICAgICAgIGNtLnNldFNlbGVjdGlvbihyYW5nZS5hbmNob3IsIHJhbmdlLmhlYWQpO1xuICAgICAgICBjbS5mb2N1cygpO1xuICAgICAgICBlX3ByZXZlbnREZWZhdWx0KGUpO1xuICAgICAgfVxuICAgICAgZmluaXNoVG91Y2goKTtcbiAgICB9KTtcbiAgICBvbihkLnNjcm9sbGVyLCBcInRvdWNoY2FuY2VsXCIsIGZpbmlzaFRvdWNoKTtcblxuICAgIC8vIFN5bmMgc2Nyb2xsaW5nIGJldHdlZW4gZmFrZSBzY3JvbGxiYXJzIGFuZCByZWFsIHNjcm9sbGFibGVcbiAgICAvLyBhcmVhLCBlbnN1cmUgdmlld3BvcnQgaXMgdXBkYXRlZCB3aGVuIHNjcm9sbGluZy5cbiAgICBvbihkLnNjcm9sbGVyLCBcInNjcm9sbFwiLCBmdW5jdGlvbiAoKSB7XG4gICAgICBpZiAoZC5zY3JvbGxlci5jbGllbnRIZWlnaHQpIHtcbiAgICAgICAgdXBkYXRlU2Nyb2xsVG9wKGNtLCBkLnNjcm9sbGVyLnNjcm9sbFRvcCk7XG4gICAgICAgIHNldFNjcm9sbExlZnQoY20sIGQuc2Nyb2xsZXIuc2Nyb2xsTGVmdCwgdHJ1ZSk7XG4gICAgICAgIHNpZ25hbChjbSwgXCJzY3JvbGxcIiwgY20pO1xuICAgICAgfVxuICAgIH0pO1xuXG4gICAgLy8gTGlzdGVuIHRvIHdoZWVsIGV2ZW50cyBpbiBvcmRlciB0byB0cnkgYW5kIHVwZGF0ZSB0aGUgdmlld3BvcnQgb24gdGltZS5cbiAgICBvbihkLnNjcm9sbGVyLCBcIm1vdXNld2hlZWxcIiwgZnVuY3Rpb24gKGUpIHsgcmV0dXJuIG9uU2Nyb2xsV2hlZWwoY20sIGUpOyB9KTtcbiAgICBvbihkLnNjcm9sbGVyLCBcIkRPTU1vdXNlU2Nyb2xsXCIsIGZ1bmN0aW9uIChlKSB7IHJldHVybiBvblNjcm9sbFdoZWVsKGNtLCBlKTsgfSk7XG5cbiAgICAvLyBQcmV2ZW50IHdyYXBwZXIgZnJvbSBldmVyIHNjcm9sbGluZ1xuICAgIG9uKGQud3JhcHBlciwgXCJzY3JvbGxcIiwgZnVuY3Rpb24gKCkgeyByZXR1cm4gZC53cmFwcGVyLnNjcm9sbFRvcCA9IGQud3JhcHBlci5zY3JvbGxMZWZ0ID0gMDsgfSk7XG5cbiAgICBkLmRyYWdGdW5jdGlvbnMgPSB7XG4gICAgICBlbnRlcjogZnVuY3Rpb24gKGUpIHtpZiAoIXNpZ25hbERPTUV2ZW50KGNtLCBlKSkgeyBlX3N0b3AoZSk7IH19LFxuICAgICAgb3ZlcjogZnVuY3Rpb24gKGUpIHtpZiAoIXNpZ25hbERPTUV2ZW50KGNtLCBlKSkgeyBvbkRyYWdPdmVyKGNtLCBlKTsgZV9zdG9wKGUpOyB9fSxcbiAgICAgIHN0YXJ0OiBmdW5jdGlvbiAoZSkgeyByZXR1cm4gb25EcmFnU3RhcnQoY20sIGUpOyB9LFxuICAgICAgZHJvcDogb3BlcmF0aW9uKGNtLCBvbkRyb3ApLFxuICAgICAgbGVhdmU6IGZ1bmN0aW9uIChlKSB7aWYgKCFzaWduYWxET01FdmVudChjbSwgZSkpIHsgY2xlYXJEcmFnQ3Vyc29yKGNtKTsgfX1cbiAgICB9O1xuXG4gICAgdmFyIGlucCA9IGQuaW5wdXQuZ2V0RmllbGQoKTtcbiAgICBvbihpbnAsIFwia2V5dXBcIiwgZnVuY3Rpb24gKGUpIHsgcmV0dXJuIG9uS2V5VXAuY2FsbChjbSwgZSk7IH0pO1xuICAgIG9uKGlucCwgXCJrZXlkb3duXCIsIG9wZXJhdGlvbihjbSwgb25LZXlEb3duKSk7XG4gICAgb24oaW5wLCBcImtleXByZXNzXCIsIG9wZXJhdGlvbihjbSwgb25LZXlQcmVzcykpO1xuICAgIG9uKGlucCwgXCJmb2N1c1wiLCBmdW5jdGlvbiAoZSkgeyByZXR1cm4gb25Gb2N1cyhjbSwgZSk7IH0pO1xuICAgIG9uKGlucCwgXCJibHVyXCIsIGZ1bmN0aW9uIChlKSB7IHJldHVybiBvbkJsdXIoY20sIGUpOyB9KTtcbiAgfVxuXG4gIHZhciBpbml0SG9va3MgPSBbXTtcbiAgQ29kZU1pcnJvci5kZWZpbmVJbml0SG9vayA9IGZ1bmN0aW9uIChmKSB7IHJldHVybiBpbml0SG9va3MucHVzaChmKTsgfTtcblxuICAvLyBJbmRlbnQgdGhlIGdpdmVuIGxpbmUuIFRoZSBob3cgcGFyYW1ldGVyIGNhbiBiZSBcInNtYXJ0XCIsXG4gIC8vIFwiYWRkXCIvbnVsbCwgXCJzdWJ0cmFjdFwiLCBvciBcInByZXZcIi4gV2hlbiBhZ2dyZXNzaXZlIGlzIGZhbHNlXG4gIC8vICh0eXBpY2FsbHkgc2V0IHRvIHRydWUgZm9yIGZvcmNlZCBzaW5nbGUtbGluZSBpbmRlbnRzKSwgZW1wdHlcbiAgLy8gbGluZXMgYXJlIG5vdCBpbmRlbnRlZCwgYW5kIHBsYWNlcyB3aGVyZSB0aGUgbW9kZSByZXR1cm5zIFBhc3NcbiAgLy8gYXJlIGxlZnQgYWxvbmUuXG4gIGZ1bmN0aW9uIGluZGVudExpbmUoY20sIG4sIGhvdywgYWdncmVzc2l2ZSkge1xuICAgIHZhciBkb2MgPSBjbS5kb2MsIHN0YXRlO1xuICAgIGlmIChob3cgPT0gbnVsbCkgeyBob3cgPSBcImFkZFwiOyB9XG4gICAgaWYgKGhvdyA9PSBcInNtYXJ0XCIpIHtcbiAgICAgIC8vIEZhbGwgYmFjayB0byBcInByZXZcIiB3aGVuIHRoZSBtb2RlIGRvZXNuJ3QgaGF2ZSBhbiBpbmRlbnRhdGlvblxuICAgICAgLy8gbWV0aG9kLlxuICAgICAgaWYgKCFkb2MubW9kZS5pbmRlbnQpIHsgaG93ID0gXCJwcmV2XCI7IH1cbiAgICAgIGVsc2UgeyBzdGF0ZSA9IGdldENvbnRleHRCZWZvcmUoY20sIG4pLnN0YXRlOyB9XG4gICAgfVxuXG4gICAgdmFyIHRhYlNpemUgPSBjbS5vcHRpb25zLnRhYlNpemU7XG4gICAgdmFyIGxpbmUgPSBnZXRMaW5lKGRvYywgbiksIGN1clNwYWNlID0gY291bnRDb2x1bW4obGluZS50ZXh0LCBudWxsLCB0YWJTaXplKTtcbiAgICBpZiAobGluZS5zdGF0ZUFmdGVyKSB7IGxpbmUuc3RhdGVBZnRlciA9IG51bGw7IH1cbiAgICB2YXIgY3VyU3BhY2VTdHJpbmcgPSBsaW5lLnRleHQubWF0Y2goL15cXHMqLylbMF0sIGluZGVudGF0aW9uO1xuICAgIGlmICghYWdncmVzc2l2ZSAmJiAhL1xcUy8udGVzdChsaW5lLnRleHQpKSB7XG4gICAgICBpbmRlbnRhdGlvbiA9IDA7XG4gICAgICBob3cgPSBcIm5vdFwiO1xuICAgIH0gZWxzZSBpZiAoaG93ID09IFwic21hcnRcIikge1xuICAgICAgaW5kZW50YXRpb24gPSBkb2MubW9kZS5pbmRlbnQoc3RhdGUsIGxpbmUudGV4dC5zbGljZShjdXJTcGFjZVN0cmluZy5sZW5ndGgpLCBsaW5lLnRleHQpO1xuICAgICAgaWYgKGluZGVudGF0aW9uID09IFBhc3MgfHwgaW5kZW50YXRpb24gPiAxNTApIHtcbiAgICAgICAgaWYgKCFhZ2dyZXNzaXZlKSB7IHJldHVybiB9XG4gICAgICAgIGhvdyA9IFwicHJldlwiO1xuICAgICAgfVxuICAgIH1cbiAgICBpZiAoaG93ID09IFwicHJldlwiKSB7XG4gICAgICBpZiAobiA+IGRvYy5maXJzdCkgeyBpbmRlbnRhdGlvbiA9IGNvdW50Q29sdW1uKGdldExpbmUoZG9jLCBuLTEpLnRleHQsIG51bGwsIHRhYlNpemUpOyB9XG4gICAgICBlbHNlIHsgaW5kZW50YXRpb24gPSAwOyB9XG4gICAgfSBlbHNlIGlmIChob3cgPT0gXCJhZGRcIikge1xuICAgICAgaW5kZW50YXRpb24gPSBjdXJTcGFjZSArIGNtLm9wdGlvbnMuaW5kZW50VW5pdDtcbiAgICB9IGVsc2UgaWYgKGhvdyA9PSBcInN1YnRyYWN0XCIpIHtcbiAgICAgIGluZGVudGF0aW9uID0gY3VyU3BhY2UgLSBjbS5vcHRpb25zLmluZGVudFVuaXQ7XG4gICAgfSBlbHNlIGlmICh0eXBlb2YgaG93ID09IFwibnVtYmVyXCIpIHtcbiAgICAgIGluZGVudGF0aW9uID0gY3VyU3BhY2UgKyBob3c7XG4gICAgfVxuICAgIGluZGVudGF0aW9uID0gTWF0aC5tYXgoMCwgaW5kZW50YXRpb24pO1xuXG4gICAgdmFyIGluZGVudFN0cmluZyA9IFwiXCIsIHBvcyA9IDA7XG4gICAgaWYgKGNtLm9wdGlvbnMuaW5kZW50V2l0aFRhYnMpXG4gICAgICB7IGZvciAodmFyIGkgPSBNYXRoLmZsb29yKGluZGVudGF0aW9uIC8gdGFiU2l6ZSk7IGk7IC0taSkge3BvcyArPSB0YWJTaXplOyBpbmRlbnRTdHJpbmcgKz0gXCJcXHRcIjt9IH1cbiAgICBpZiAocG9zIDwgaW5kZW50YXRpb24pIHsgaW5kZW50U3RyaW5nICs9IHNwYWNlU3RyKGluZGVudGF0aW9uIC0gcG9zKTsgfVxuXG4gICAgaWYgKGluZGVudFN0cmluZyAhPSBjdXJTcGFjZVN0cmluZykge1xuICAgICAgcmVwbGFjZVJhbmdlKGRvYywgaW5kZW50U3RyaW5nLCBQb3MobiwgMCksIFBvcyhuLCBjdXJTcGFjZVN0cmluZy5sZW5ndGgpLCBcIitpbnB1dFwiKTtcbiAgICAgIGxpbmUuc3RhdGVBZnRlciA9IG51bGw7XG4gICAgICByZXR1cm4gdHJ1ZVxuICAgIH0gZWxzZSB7XG4gICAgICAvLyBFbnN1cmUgdGhhdCwgaWYgdGhlIGN1cnNvciB3YXMgaW4gdGhlIHdoaXRlc3BhY2UgYXQgdGhlIHN0YXJ0XG4gICAgICAvLyBvZiB0aGUgbGluZSwgaXQgaXMgbW92ZWQgdG8gdGhlIGVuZCBvZiB0aGF0IHNwYWNlLlxuICAgICAgZm9yICh2YXIgaSQxID0gMDsgaSQxIDwgZG9jLnNlbC5yYW5nZXMubGVuZ3RoOyBpJDErKykge1xuICAgICAgICB2YXIgcmFuZ2UgPSBkb2Muc2VsLnJhbmdlc1tpJDFdO1xuICAgICAgICBpZiAocmFuZ2UuaGVhZC5saW5lID09IG4gJiYgcmFuZ2UuaGVhZC5jaCA8IGN1clNwYWNlU3RyaW5nLmxlbmd0aCkge1xuICAgICAgICAgIHZhciBwb3MkMSA9IFBvcyhuLCBjdXJTcGFjZVN0cmluZy5sZW5ndGgpO1xuICAgICAgICAgIHJlcGxhY2VPbmVTZWxlY3Rpb24oZG9jLCBpJDEsIG5ldyBSYW5nZShwb3MkMSwgcG9zJDEpKTtcbiAgICAgICAgICBicmVha1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgLy8gVGhpcyB3aWxsIGJlIHNldCB0byBhIHtsaW5lV2lzZTogYm9vbCwgdGV4dDogW3N0cmluZ119IG9iamVjdCwgc29cbiAgLy8gdGhhdCwgd2hlbiBwYXN0aW5nLCB3ZSBrbm93IHdoYXQga2luZCBvZiBzZWxlY3Rpb25zIHRoZSBjb3BpZWRcbiAgLy8gdGV4dCB3YXMgbWFkZSBvdXQgb2YuXG4gIHZhciBsYXN0Q29waWVkID0gbnVsbDtcblxuICBmdW5jdGlvbiBzZXRMYXN0Q29waWVkKG5ld0xhc3RDb3BpZWQpIHtcbiAgICBsYXN0Q29waWVkID0gbmV3TGFzdENvcGllZDtcbiAgfVxuXG4gIGZ1bmN0aW9uIGFwcGx5VGV4dElucHV0KGNtLCBpbnNlcnRlZCwgZGVsZXRlZCwgc2VsLCBvcmlnaW4pIHtcbiAgICB2YXIgZG9jID0gY20uZG9jO1xuICAgIGNtLmRpc3BsYXkuc2hpZnQgPSBmYWxzZTtcbiAgICBpZiAoIXNlbCkgeyBzZWwgPSBkb2Muc2VsOyB9XG5cbiAgICB2YXIgcmVjZW50ID0gK25ldyBEYXRlIC0gMjAwO1xuICAgIHZhciBwYXN0ZSA9IG9yaWdpbiA9PSBcInBhc3RlXCIgfHwgY20uc3RhdGUucGFzdGVJbmNvbWluZyA+IHJlY2VudDtcbiAgICB2YXIgdGV4dExpbmVzID0gc3BsaXRMaW5lc0F1dG8oaW5zZXJ0ZWQpLCBtdWx0aVBhc3RlID0gbnVsbDtcbiAgICAvLyBXaGVuIHBhc3RpbmcgTiBsaW5lcyBpbnRvIE4gc2VsZWN0aW9ucywgaW5zZXJ0IG9uZSBsaW5lIHBlciBzZWxlY3Rpb25cbiAgICBpZiAocGFzdGUgJiYgc2VsLnJhbmdlcy5sZW5ndGggPiAxKSB7XG4gICAgICBpZiAobGFzdENvcGllZCAmJiBsYXN0Q29waWVkLnRleHQuam9pbihcIlxcblwiKSA9PSBpbnNlcnRlZCkge1xuICAgICAgICBpZiAoc2VsLnJhbmdlcy5sZW5ndGggJSBsYXN0Q29waWVkLnRleHQubGVuZ3RoID09IDApIHtcbiAgICAgICAgICBtdWx0aVBhc3RlID0gW107XG4gICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBsYXN0Q29waWVkLnRleHQubGVuZ3RoOyBpKyspXG4gICAgICAgICAgICB7IG11bHRpUGFzdGUucHVzaChkb2Muc3BsaXRMaW5lcyhsYXN0Q29waWVkLnRleHRbaV0pKTsgfVxuICAgICAgICB9XG4gICAgICB9IGVsc2UgaWYgKHRleHRMaW5lcy5sZW5ndGggPT0gc2VsLnJhbmdlcy5sZW5ndGggJiYgY20ub3B0aW9ucy5wYXN0ZUxpbmVzUGVyU2VsZWN0aW9uKSB7XG4gICAgICAgIG11bHRpUGFzdGUgPSBtYXAodGV4dExpbmVzLCBmdW5jdGlvbiAobCkgeyByZXR1cm4gW2xdOyB9KTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICB2YXIgdXBkYXRlSW5wdXQgPSBjbS5jdXJPcC51cGRhdGVJbnB1dDtcbiAgICAvLyBOb3JtYWwgYmVoYXZpb3IgaXMgdG8gaW5zZXJ0IHRoZSBuZXcgdGV4dCBpbnRvIGV2ZXJ5IHNlbGVjdGlvblxuICAgIGZvciAodmFyIGkkMSA9IHNlbC5yYW5nZXMubGVuZ3RoIC0gMTsgaSQxID49IDA7IGkkMS0tKSB7XG4gICAgICB2YXIgcmFuZ2UgPSBzZWwucmFuZ2VzW2kkMV07XG4gICAgICB2YXIgZnJvbSA9IHJhbmdlLmZyb20oKSwgdG8gPSByYW5nZS50bygpO1xuICAgICAgaWYgKHJhbmdlLmVtcHR5KCkpIHtcbiAgICAgICAgaWYgKGRlbGV0ZWQgJiYgZGVsZXRlZCA+IDApIC8vIEhhbmRsZSBkZWxldGlvblxuICAgICAgICAgIHsgZnJvbSA9IFBvcyhmcm9tLmxpbmUsIGZyb20uY2ggLSBkZWxldGVkKTsgfVxuICAgICAgICBlbHNlIGlmIChjbS5zdGF0ZS5vdmVyd3JpdGUgJiYgIXBhc3RlKSAvLyBIYW5kbGUgb3ZlcndyaXRlXG4gICAgICAgICAgeyB0byA9IFBvcyh0by5saW5lLCBNYXRoLm1pbihnZXRMaW5lKGRvYywgdG8ubGluZSkudGV4dC5sZW5ndGgsIHRvLmNoICsgbHN0KHRleHRMaW5lcykubGVuZ3RoKSk7IH1cbiAgICAgICAgZWxzZSBpZiAocGFzdGUgJiYgbGFzdENvcGllZCAmJiBsYXN0Q29waWVkLmxpbmVXaXNlICYmIGxhc3RDb3BpZWQudGV4dC5qb2luKFwiXFxuXCIpID09IHRleHRMaW5lcy5qb2luKFwiXFxuXCIpKVxuICAgICAgICAgIHsgZnJvbSA9IHRvID0gUG9zKGZyb20ubGluZSwgMCk7IH1cbiAgICAgIH1cbiAgICAgIHZhciBjaGFuZ2VFdmVudCA9IHtmcm9tOiBmcm9tLCB0bzogdG8sIHRleHQ6IG11bHRpUGFzdGUgPyBtdWx0aVBhc3RlW2kkMSAlIG11bHRpUGFzdGUubGVuZ3RoXSA6IHRleHRMaW5lcyxcbiAgICAgICAgICAgICAgICAgICAgICAgICBvcmlnaW46IG9yaWdpbiB8fCAocGFzdGUgPyBcInBhc3RlXCIgOiBjbS5zdGF0ZS5jdXRJbmNvbWluZyA+IHJlY2VudCA/IFwiY3V0XCIgOiBcIitpbnB1dFwiKX07XG4gICAgICBtYWtlQ2hhbmdlKGNtLmRvYywgY2hhbmdlRXZlbnQpO1xuICAgICAgc2lnbmFsTGF0ZXIoY20sIFwiaW5wdXRSZWFkXCIsIGNtLCBjaGFuZ2VFdmVudCk7XG4gICAgfVxuICAgIGlmIChpbnNlcnRlZCAmJiAhcGFzdGUpXG4gICAgICB7IHRyaWdnZXJFbGVjdHJpYyhjbSwgaW5zZXJ0ZWQpOyB9XG5cbiAgICBlbnN1cmVDdXJzb3JWaXNpYmxlKGNtKTtcbiAgICBpZiAoY20uY3VyT3AudXBkYXRlSW5wdXQgPCAyKSB7IGNtLmN1ck9wLnVwZGF0ZUlucHV0ID0gdXBkYXRlSW5wdXQ7IH1cbiAgICBjbS5jdXJPcC50eXBpbmcgPSB0cnVlO1xuICAgIGNtLnN0YXRlLnBhc3RlSW5jb21pbmcgPSBjbS5zdGF0ZS5jdXRJbmNvbWluZyA9IC0xO1xuICB9XG5cbiAgZnVuY3Rpb24gaGFuZGxlUGFzdGUoZSwgY20pIHtcbiAgICB2YXIgcGFzdGVkID0gZS5jbGlwYm9hcmREYXRhICYmIGUuY2xpcGJvYXJkRGF0YS5nZXREYXRhKFwiVGV4dFwiKTtcbiAgICBpZiAocGFzdGVkKSB7XG4gICAgICBlLnByZXZlbnREZWZhdWx0KCk7XG4gICAgICBpZiAoIWNtLmlzUmVhZE9ubHkoKSAmJiAhY20ub3B0aW9ucy5kaXNhYmxlSW5wdXQgJiYgY20uaGFzRm9jdXMoKSlcbiAgICAgICAgeyBydW5Jbk9wKGNtLCBmdW5jdGlvbiAoKSB7IHJldHVybiBhcHBseVRleHRJbnB1dChjbSwgcGFzdGVkLCAwLCBudWxsLCBcInBhc3RlXCIpOyB9KTsgfVxuICAgICAgcmV0dXJuIHRydWVcbiAgICB9XG4gIH1cblxuICBmdW5jdGlvbiB0cmlnZ2VyRWxlY3RyaWMoY20sIGluc2VydGVkKSB7XG4gICAgLy8gV2hlbiBhbiAnZWxlY3RyaWMnIGNoYXJhY3RlciBpcyBpbnNlcnRlZCwgaW1tZWRpYXRlbHkgdHJpZ2dlciBhIHJlaW5kZW50XG4gICAgaWYgKCFjbS5vcHRpb25zLmVsZWN0cmljQ2hhcnMgfHwgIWNtLm9wdGlvbnMuc21hcnRJbmRlbnQpIHsgcmV0dXJuIH1cbiAgICB2YXIgc2VsID0gY20uZG9jLnNlbDtcblxuICAgIGZvciAodmFyIGkgPSBzZWwucmFuZ2VzLmxlbmd0aCAtIDE7IGkgPj0gMDsgaS0tKSB7XG4gICAgICB2YXIgcmFuZ2UgPSBzZWwucmFuZ2VzW2ldO1xuICAgICAgaWYgKHJhbmdlLmhlYWQuY2ggPiAxMDAgfHwgKGkgJiYgc2VsLnJhbmdlc1tpIC0gMV0uaGVhZC5saW5lID09IHJhbmdlLmhlYWQubGluZSkpIHsgY29udGludWUgfVxuICAgICAgdmFyIG1vZGUgPSBjbS5nZXRNb2RlQXQocmFuZ2UuaGVhZCk7XG4gICAgICB2YXIgaW5kZW50ZWQgPSBmYWxzZTtcbiAgICAgIGlmIChtb2RlLmVsZWN0cmljQ2hhcnMpIHtcbiAgICAgICAgZm9yICh2YXIgaiA9IDA7IGogPCBtb2RlLmVsZWN0cmljQ2hhcnMubGVuZ3RoOyBqKyspXG4gICAgICAgICAgeyBpZiAoaW5zZXJ0ZWQuaW5kZXhPZihtb2RlLmVsZWN0cmljQ2hhcnMuY2hhckF0KGopKSA+IC0xKSB7XG4gICAgICAgICAgICBpbmRlbnRlZCA9IGluZGVudExpbmUoY20sIHJhbmdlLmhlYWQubGluZSwgXCJzbWFydFwiKTtcbiAgICAgICAgICAgIGJyZWFrXG4gICAgICAgICAgfSB9XG4gICAgICB9IGVsc2UgaWYgKG1vZGUuZWxlY3RyaWNJbnB1dCkge1xuICAgICAgICBpZiAobW9kZS5lbGVjdHJpY0lucHV0LnRlc3QoZ2V0TGluZShjbS5kb2MsIHJhbmdlLmhlYWQubGluZSkudGV4dC5zbGljZSgwLCByYW5nZS5oZWFkLmNoKSkpXG4gICAgICAgICAgeyBpbmRlbnRlZCA9IGluZGVudExpbmUoY20sIHJhbmdlLmhlYWQubGluZSwgXCJzbWFydFwiKTsgfVxuICAgICAgfVxuICAgICAgaWYgKGluZGVudGVkKSB7IHNpZ25hbExhdGVyKGNtLCBcImVsZWN0cmljSW5wdXRcIiwgY20sIHJhbmdlLmhlYWQubGluZSk7IH1cbiAgICB9XG4gIH1cblxuICBmdW5jdGlvbiBjb3B5YWJsZVJhbmdlcyhjbSkge1xuICAgIHZhciB0ZXh0ID0gW10sIHJhbmdlcyA9IFtdO1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgY20uZG9jLnNlbC5yYW5nZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgIHZhciBsaW5lID0gY20uZG9jLnNlbC5yYW5nZXNbaV0uaGVhZC5saW5lO1xuICAgICAgdmFyIGxpbmVSYW5nZSA9IHthbmNob3I6IFBvcyhsaW5lLCAwKSwgaGVhZDogUG9zKGxpbmUgKyAxLCAwKX07XG4gICAgICByYW5nZXMucHVzaChsaW5lUmFuZ2UpO1xuICAgICAgdGV4dC5wdXNoKGNtLmdldFJhbmdlKGxpbmVSYW5nZS5hbmNob3IsIGxpbmVSYW5nZS5oZWFkKSk7XG4gICAgfVxuICAgIHJldHVybiB7dGV4dDogdGV4dCwgcmFuZ2VzOiByYW5nZXN9XG4gIH1cblxuICBmdW5jdGlvbiBkaXNhYmxlQnJvd3Nlck1hZ2ljKGZpZWxkLCBzcGVsbGNoZWNrLCBhdXRvY29ycmVjdCwgYXV0b2NhcGl0YWxpemUpIHtcbiAgICBmaWVsZC5zZXRBdHRyaWJ1dGUoXCJhdXRvY29ycmVjdFwiLCBhdXRvY29ycmVjdCA/IFwiXCIgOiBcIm9mZlwiKTtcbiAgICBmaWVsZC5zZXRBdHRyaWJ1dGUoXCJhdXRvY2FwaXRhbGl6ZVwiLCBhdXRvY2FwaXRhbGl6ZSA/IFwiXCIgOiBcIm9mZlwiKTtcbiAgICBmaWVsZC5zZXRBdHRyaWJ1dGUoXCJzcGVsbGNoZWNrXCIsICEhc3BlbGxjaGVjayk7XG4gIH1cblxuICBmdW5jdGlvbiBoaWRkZW5UZXh0YXJlYSgpIHtcbiAgICB2YXIgdGUgPSBlbHQoXCJ0ZXh0YXJlYVwiLCBudWxsLCBudWxsLCBcInBvc2l0aW9uOiBhYnNvbHV0ZTsgYm90dG9tOiAtMWVtOyBwYWRkaW5nOiAwOyB3aWR0aDogMXB4OyBoZWlnaHQ6IDFlbTsgbWluLWhlaWdodDogMWVtOyBvdXRsaW5lOiBub25lXCIpO1xuICAgIHZhciBkaXYgPSBlbHQoXCJkaXZcIiwgW3RlXSwgbnVsbCwgXCJvdmVyZmxvdzogaGlkZGVuOyBwb3NpdGlvbjogcmVsYXRpdmU7IHdpZHRoOiAzcHg7IGhlaWdodDogMHB4O1wiKTtcbiAgICAvLyBUaGUgdGV4dGFyZWEgaXMga2VwdCBwb3NpdGlvbmVkIG5lYXIgdGhlIGN1cnNvciB0byBwcmV2ZW50IHRoZVxuICAgIC8vIGZhY3QgdGhhdCBpdCdsbCBiZSBzY3JvbGxlZCBpbnRvIHZpZXcgb24gaW5wdXQgZnJvbSBzY3JvbGxpbmdcbiAgICAvLyBvdXIgZmFrZSBjdXJzb3Igb3V0IG9mIHZpZXcuIE9uIHdlYmtpdCwgd2hlbiB3cmFwPW9mZiwgcGFzdGUgaXNcbiAgICAvLyB2ZXJ5IHNsb3cuIFNvIG1ha2UgdGhlIGFyZWEgd2lkZSBpbnN0ZWFkLlxuICAgIGlmICh3ZWJraXQpIHsgdGUuc3R5bGUud2lkdGggPSBcIjEwMDBweFwiOyB9XG4gICAgZWxzZSB7IHRlLnNldEF0dHJpYnV0ZShcIndyYXBcIiwgXCJvZmZcIik7IH1cbiAgICAvLyBJZiBib3JkZXI6IDA7IC0tIGlPUyBmYWlscyB0byBvcGVuIGtleWJvYXJkIChpc3N1ZSAjMTI4NylcbiAgICBpZiAoaW9zKSB7IHRlLnN0eWxlLmJvcmRlciA9IFwiMXB4IHNvbGlkIGJsYWNrXCI7IH1cbiAgICBkaXNhYmxlQnJvd3Nlck1hZ2ljKHRlKTtcbiAgICByZXR1cm4gZGl2XG4gIH1cblxuICAvLyBUaGUgcHVibGljbHkgdmlzaWJsZSBBUEkuIE5vdGUgdGhhdCBtZXRob2RPcChmKSBtZWFuc1xuICAvLyAnd3JhcCBmIGluIGFuIG9wZXJhdGlvbiwgcGVyZm9ybWVkIG9uIGl0cyBgdGhpc2AgcGFyYW1ldGVyJy5cblxuICAvLyBUaGlzIGlzIG5vdCB0aGUgY29tcGxldGUgc2V0IG9mIGVkaXRvciBtZXRob2RzLiBNb3N0IG9mIHRoZVxuICAvLyBtZXRob2RzIGRlZmluZWQgb24gdGhlIERvYyB0eXBlIGFyZSBhbHNvIGluamVjdGVkIGludG9cbiAgLy8gQ29kZU1pcnJvci5wcm90b3R5cGUsIGZvciBiYWNrd2FyZHMgY29tcGF0aWJpbGl0eSBhbmRcbiAgLy8gY29udmVuaWVuY2UuXG5cbiAgZnVuY3Rpb24gYWRkRWRpdG9yTWV0aG9kcyhDb2RlTWlycm9yKSB7XG4gICAgdmFyIG9wdGlvbkhhbmRsZXJzID0gQ29kZU1pcnJvci5vcHRpb25IYW5kbGVycztcblxuICAgIHZhciBoZWxwZXJzID0gQ29kZU1pcnJvci5oZWxwZXJzID0ge307XG5cbiAgICBDb2RlTWlycm9yLnByb3RvdHlwZSA9IHtcbiAgICAgIGNvbnN0cnVjdG9yOiBDb2RlTWlycm9yLFxuICAgICAgZm9jdXM6IGZ1bmN0aW9uKCl7d2luZG93LmZvY3VzKCk7IHRoaXMuZGlzcGxheS5pbnB1dC5mb2N1cygpO30sXG5cbiAgICAgIHNldE9wdGlvbjogZnVuY3Rpb24ob3B0aW9uLCB2YWx1ZSkge1xuICAgICAgICB2YXIgb3B0aW9ucyA9IHRoaXMub3B0aW9ucywgb2xkID0gb3B0aW9uc1tvcHRpb25dO1xuICAgICAgICBpZiAob3B0aW9uc1tvcHRpb25dID09IHZhbHVlICYmIG9wdGlvbiAhPSBcIm1vZGVcIikgeyByZXR1cm4gfVxuICAgICAgICBvcHRpb25zW29wdGlvbl0gPSB2YWx1ZTtcbiAgICAgICAgaWYgKG9wdGlvbkhhbmRsZXJzLmhhc093blByb3BlcnR5KG9wdGlvbikpXG4gICAgICAgICAgeyBvcGVyYXRpb24odGhpcywgb3B0aW9uSGFuZGxlcnNbb3B0aW9uXSkodGhpcywgdmFsdWUsIG9sZCk7IH1cbiAgICAgICAgc2lnbmFsKHRoaXMsIFwib3B0aW9uQ2hhbmdlXCIsIHRoaXMsIG9wdGlvbik7XG4gICAgICB9LFxuXG4gICAgICBnZXRPcHRpb246IGZ1bmN0aW9uKG9wdGlvbikge3JldHVybiB0aGlzLm9wdGlvbnNbb3B0aW9uXX0sXG4gICAgICBnZXREb2M6IGZ1bmN0aW9uKCkge3JldHVybiB0aGlzLmRvY30sXG5cbiAgICAgIGFkZEtleU1hcDogZnVuY3Rpb24obWFwLCBib3R0b20pIHtcbiAgICAgICAgdGhpcy5zdGF0ZS5rZXlNYXBzW2JvdHRvbSA/IFwicHVzaFwiIDogXCJ1bnNoaWZ0XCJdKGdldEtleU1hcChtYXApKTtcbiAgICAgIH0sXG4gICAgICByZW1vdmVLZXlNYXA6IGZ1bmN0aW9uKG1hcCkge1xuICAgICAgICB2YXIgbWFwcyA9IHRoaXMuc3RhdGUua2V5TWFwcztcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBtYXBzLmxlbmd0aDsgKytpKVxuICAgICAgICAgIHsgaWYgKG1hcHNbaV0gPT0gbWFwIHx8IG1hcHNbaV0ubmFtZSA9PSBtYXApIHtcbiAgICAgICAgICAgIG1hcHMuc3BsaWNlKGksIDEpO1xuICAgICAgICAgICAgcmV0dXJuIHRydWVcbiAgICAgICAgICB9IH1cbiAgICAgIH0sXG5cbiAgICAgIGFkZE92ZXJsYXk6IG1ldGhvZE9wKGZ1bmN0aW9uKHNwZWMsIG9wdGlvbnMpIHtcbiAgICAgICAgdmFyIG1vZGUgPSBzcGVjLnRva2VuID8gc3BlYyA6IENvZGVNaXJyb3IuZ2V0TW9kZSh0aGlzLm9wdGlvbnMsIHNwZWMpO1xuICAgICAgICBpZiAobW9kZS5zdGFydFN0YXRlKSB7IHRocm93IG5ldyBFcnJvcihcIk92ZXJsYXlzIG1heSBub3QgYmUgc3RhdGVmdWwuXCIpIH1cbiAgICAgICAgaW5zZXJ0U29ydGVkKHRoaXMuc3RhdGUub3ZlcmxheXMsXG4gICAgICAgICAgICAgICAgICAgICB7bW9kZTogbW9kZSwgbW9kZVNwZWM6IHNwZWMsIG9wYXF1ZTogb3B0aW9ucyAmJiBvcHRpb25zLm9wYXF1ZSxcbiAgICAgICAgICAgICAgICAgICAgICBwcmlvcml0eTogKG9wdGlvbnMgJiYgb3B0aW9ucy5wcmlvcml0eSkgfHwgMH0sXG4gICAgICAgICAgICAgICAgICAgICBmdW5jdGlvbiAob3ZlcmxheSkgeyByZXR1cm4gb3ZlcmxheS5wcmlvcml0eTsgfSk7XG4gICAgICAgIHRoaXMuc3RhdGUubW9kZUdlbisrO1xuICAgICAgICByZWdDaGFuZ2UodGhpcyk7XG4gICAgICB9KSxcbiAgICAgIHJlbW92ZU92ZXJsYXk6IG1ldGhvZE9wKGZ1bmN0aW9uKHNwZWMpIHtcbiAgICAgICAgdmFyIG92ZXJsYXlzID0gdGhpcy5zdGF0ZS5vdmVybGF5cztcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBvdmVybGF5cy5sZW5ndGg7ICsraSkge1xuICAgICAgICAgIHZhciBjdXIgPSBvdmVybGF5c1tpXS5tb2RlU3BlYztcbiAgICAgICAgICBpZiAoY3VyID09IHNwZWMgfHwgdHlwZW9mIHNwZWMgPT0gXCJzdHJpbmdcIiAmJiBjdXIubmFtZSA9PSBzcGVjKSB7XG4gICAgICAgICAgICBvdmVybGF5cy5zcGxpY2UoaSwgMSk7XG4gICAgICAgICAgICB0aGlzLnN0YXRlLm1vZGVHZW4rKztcbiAgICAgICAgICAgIHJlZ0NoYW5nZSh0aGlzKTtcbiAgICAgICAgICAgIHJldHVyblxuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfSksXG5cbiAgICAgIGluZGVudExpbmU6IG1ldGhvZE9wKGZ1bmN0aW9uKG4sIGRpciwgYWdncmVzc2l2ZSkge1xuICAgICAgICBpZiAodHlwZW9mIGRpciAhPSBcInN0cmluZ1wiICYmIHR5cGVvZiBkaXIgIT0gXCJudW1iZXJcIikge1xuICAgICAgICAgIGlmIChkaXIgPT0gbnVsbCkgeyBkaXIgPSB0aGlzLm9wdGlvbnMuc21hcnRJbmRlbnQgPyBcInNtYXJ0XCIgOiBcInByZXZcIjsgfVxuICAgICAgICAgIGVsc2UgeyBkaXIgPSBkaXIgPyBcImFkZFwiIDogXCJzdWJ0cmFjdFwiOyB9XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGlzTGluZSh0aGlzLmRvYywgbikpIHsgaW5kZW50TGluZSh0aGlzLCBuLCBkaXIsIGFnZ3Jlc3NpdmUpOyB9XG4gICAgICB9KSxcbiAgICAgIGluZGVudFNlbGVjdGlvbjogbWV0aG9kT3AoZnVuY3Rpb24oaG93KSB7XG4gICAgICAgIHZhciByYW5nZXMgPSB0aGlzLmRvYy5zZWwucmFuZ2VzLCBlbmQgPSAtMTtcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCByYW5nZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICB2YXIgcmFuZ2UgPSByYW5nZXNbaV07XG4gICAgICAgICAgaWYgKCFyYW5nZS5lbXB0eSgpKSB7XG4gICAgICAgICAgICB2YXIgZnJvbSA9IHJhbmdlLmZyb20oKSwgdG8gPSByYW5nZS50bygpO1xuICAgICAgICAgICAgdmFyIHN0YXJ0ID0gTWF0aC5tYXgoZW5kLCBmcm9tLmxpbmUpO1xuICAgICAgICAgICAgZW5kID0gTWF0aC5taW4odGhpcy5sYXN0TGluZSgpLCB0by5saW5lIC0gKHRvLmNoID8gMCA6IDEpKSArIDE7XG4gICAgICAgICAgICBmb3IgKHZhciBqID0gc3RhcnQ7IGogPCBlbmQ7ICsrailcbiAgICAgICAgICAgICAgeyBpbmRlbnRMaW5lKHRoaXMsIGosIGhvdyk7IH1cbiAgICAgICAgICAgIHZhciBuZXdSYW5nZXMgPSB0aGlzLmRvYy5zZWwucmFuZ2VzO1xuICAgICAgICAgICAgaWYgKGZyb20uY2ggPT0gMCAmJiByYW5nZXMubGVuZ3RoID09IG5ld1Jhbmdlcy5sZW5ndGggJiYgbmV3UmFuZ2VzW2ldLmZyb20oKS5jaCA+IDApXG4gICAgICAgICAgICAgIHsgcmVwbGFjZU9uZVNlbGVjdGlvbih0aGlzLmRvYywgaSwgbmV3IFJhbmdlKGZyb20sIG5ld1Jhbmdlc1tpXS50bygpKSwgc2VsX2RvbnRTY3JvbGwpOyB9XG4gICAgICAgICAgfSBlbHNlIGlmIChyYW5nZS5oZWFkLmxpbmUgPiBlbmQpIHtcbiAgICAgICAgICAgIGluZGVudExpbmUodGhpcywgcmFuZ2UuaGVhZC5saW5lLCBob3csIHRydWUpO1xuICAgICAgICAgICAgZW5kID0gcmFuZ2UuaGVhZC5saW5lO1xuICAgICAgICAgICAgaWYgKGkgPT0gdGhpcy5kb2Muc2VsLnByaW1JbmRleCkgeyBlbnN1cmVDdXJzb3JWaXNpYmxlKHRoaXMpOyB9XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9KSxcblxuICAgICAgLy8gRmV0Y2ggdGhlIHBhcnNlciB0b2tlbiBmb3IgYSBnaXZlbiBjaGFyYWN0ZXIuIFVzZWZ1bCBmb3IgaGFja3NcbiAgICAgIC8vIHRoYXQgd2FudCB0byBpbnNwZWN0IHRoZSBtb2RlIHN0YXRlIChzYXksIGZvciBjb21wbGV0aW9uKS5cbiAgICAgIGdldFRva2VuQXQ6IGZ1bmN0aW9uKHBvcywgcHJlY2lzZSkge1xuICAgICAgICByZXR1cm4gdGFrZVRva2VuKHRoaXMsIHBvcywgcHJlY2lzZSlcbiAgICAgIH0sXG5cbiAgICAgIGdldExpbmVUb2tlbnM6IGZ1bmN0aW9uKGxpbmUsIHByZWNpc2UpIHtcbiAgICAgICAgcmV0dXJuIHRha2VUb2tlbih0aGlzLCBQb3MobGluZSksIHByZWNpc2UsIHRydWUpXG4gICAgICB9LFxuXG4gICAgICBnZXRUb2tlblR5cGVBdDogZnVuY3Rpb24ocG9zKSB7XG4gICAgICAgIHBvcyA9IGNsaXBQb3ModGhpcy5kb2MsIHBvcyk7XG4gICAgICAgIHZhciBzdHlsZXMgPSBnZXRMaW5lU3R5bGVzKHRoaXMsIGdldExpbmUodGhpcy5kb2MsIHBvcy5saW5lKSk7XG4gICAgICAgIHZhciBiZWZvcmUgPSAwLCBhZnRlciA9IChzdHlsZXMubGVuZ3RoIC0gMSkgLyAyLCBjaCA9IHBvcy5jaDtcbiAgICAgICAgdmFyIHR5cGU7XG4gICAgICAgIGlmIChjaCA9PSAwKSB7IHR5cGUgPSBzdHlsZXNbMl07IH1cbiAgICAgICAgZWxzZSB7IGZvciAoOzspIHtcbiAgICAgICAgICB2YXIgbWlkID0gKGJlZm9yZSArIGFmdGVyKSA+PiAxO1xuICAgICAgICAgIGlmICgobWlkID8gc3R5bGVzW21pZCAqIDIgLSAxXSA6IDApID49IGNoKSB7IGFmdGVyID0gbWlkOyB9XG4gICAgICAgICAgZWxzZSBpZiAoc3R5bGVzW21pZCAqIDIgKyAxXSA8IGNoKSB7IGJlZm9yZSA9IG1pZCArIDE7IH1cbiAgICAgICAgICBlbHNlIHsgdHlwZSA9IHN0eWxlc1ttaWQgKiAyICsgMl07IGJyZWFrIH1cbiAgICAgICAgfSB9XG4gICAgICAgIHZhciBjdXQgPSB0eXBlID8gdHlwZS5pbmRleE9mKFwib3ZlcmxheSBcIikgOiAtMTtcbiAgICAgICAgcmV0dXJuIGN1dCA8IDAgPyB0eXBlIDogY3V0ID09IDAgPyBudWxsIDogdHlwZS5zbGljZSgwLCBjdXQgLSAxKVxuICAgICAgfSxcblxuICAgICAgZ2V0TW9kZUF0OiBmdW5jdGlvbihwb3MpIHtcbiAgICAgICAgdmFyIG1vZGUgPSB0aGlzLmRvYy5tb2RlO1xuICAgICAgICBpZiAoIW1vZGUuaW5uZXJNb2RlKSB7IHJldHVybiBtb2RlIH1cbiAgICAgICAgcmV0dXJuIENvZGVNaXJyb3IuaW5uZXJNb2RlKG1vZGUsIHRoaXMuZ2V0VG9rZW5BdChwb3MpLnN0YXRlKS5tb2RlXG4gICAgICB9LFxuXG4gICAgICBnZXRIZWxwZXI6IGZ1bmN0aW9uKHBvcywgdHlwZSkge1xuICAgICAgICByZXR1cm4gdGhpcy5nZXRIZWxwZXJzKHBvcywgdHlwZSlbMF1cbiAgICAgIH0sXG5cbiAgICAgIGdldEhlbHBlcnM6IGZ1bmN0aW9uKHBvcywgdHlwZSkge1xuICAgICAgICB2YXIgZm91bmQgPSBbXTtcbiAgICAgICAgaWYgKCFoZWxwZXJzLmhhc093blByb3BlcnR5KHR5cGUpKSB7IHJldHVybiBmb3VuZCB9XG4gICAgICAgIHZhciBoZWxwID0gaGVscGVyc1t0eXBlXSwgbW9kZSA9IHRoaXMuZ2V0TW9kZUF0KHBvcyk7XG4gICAgICAgIGlmICh0eXBlb2YgbW9kZVt0eXBlXSA9PSBcInN0cmluZ1wiKSB7XG4gICAgICAgICAgaWYgKGhlbHBbbW9kZVt0eXBlXV0pIHsgZm91bmQucHVzaChoZWxwW21vZGVbdHlwZV1dKTsgfVxuICAgICAgICB9IGVsc2UgaWYgKG1vZGVbdHlwZV0pIHtcbiAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IG1vZGVbdHlwZV0ubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIHZhciB2YWwgPSBoZWxwW21vZGVbdHlwZV1baV1dO1xuICAgICAgICAgICAgaWYgKHZhbCkgeyBmb3VuZC5wdXNoKHZhbCk7IH1cbiAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSBpZiAobW9kZS5oZWxwZXJUeXBlICYmIGhlbHBbbW9kZS5oZWxwZXJUeXBlXSkge1xuICAgICAgICAgIGZvdW5kLnB1c2goaGVscFttb2RlLmhlbHBlclR5cGVdKTtcbiAgICAgICAgfSBlbHNlIGlmIChoZWxwW21vZGUubmFtZV0pIHtcbiAgICAgICAgICBmb3VuZC5wdXNoKGhlbHBbbW9kZS5uYW1lXSk7XG4gICAgICAgIH1cbiAgICAgICAgZm9yICh2YXIgaSQxID0gMDsgaSQxIDwgaGVscC5fZ2xvYmFsLmxlbmd0aDsgaSQxKyspIHtcbiAgICAgICAgICB2YXIgY3VyID0gaGVscC5fZ2xvYmFsW2kkMV07XG4gICAgICAgICAgaWYgKGN1ci5wcmVkKG1vZGUsIHRoaXMpICYmIGluZGV4T2YoZm91bmQsIGN1ci52YWwpID09IC0xKVxuICAgICAgICAgICAgeyBmb3VuZC5wdXNoKGN1ci52YWwpOyB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGZvdW5kXG4gICAgICB9LFxuXG4gICAgICBnZXRTdGF0ZUFmdGVyOiBmdW5jdGlvbihsaW5lLCBwcmVjaXNlKSB7XG4gICAgICAgIHZhciBkb2MgPSB0aGlzLmRvYztcbiAgICAgICAgbGluZSA9IGNsaXBMaW5lKGRvYywgbGluZSA9PSBudWxsID8gZG9jLmZpcnN0ICsgZG9jLnNpemUgLSAxOiBsaW5lKTtcbiAgICAgICAgcmV0dXJuIGdldENvbnRleHRCZWZvcmUodGhpcywgbGluZSArIDEsIHByZWNpc2UpLnN0YXRlXG4gICAgICB9LFxuXG4gICAgICBjdXJzb3JDb29yZHM6IGZ1bmN0aW9uKHN0YXJ0LCBtb2RlKSB7XG4gICAgICAgIHZhciBwb3MsIHJhbmdlID0gdGhpcy5kb2Muc2VsLnByaW1hcnkoKTtcbiAgICAgICAgaWYgKHN0YXJ0ID09IG51bGwpIHsgcG9zID0gcmFuZ2UuaGVhZDsgfVxuICAgICAgICBlbHNlIGlmICh0eXBlb2Ygc3RhcnQgPT0gXCJvYmplY3RcIikgeyBwb3MgPSBjbGlwUG9zKHRoaXMuZG9jLCBzdGFydCk7IH1cbiAgICAgICAgZWxzZSB7IHBvcyA9IHN0YXJ0ID8gcmFuZ2UuZnJvbSgpIDogcmFuZ2UudG8oKTsgfVxuICAgICAgICByZXR1cm4gY3Vyc29yQ29vcmRzKHRoaXMsIHBvcywgbW9kZSB8fCBcInBhZ2VcIilcbiAgICAgIH0sXG5cbiAgICAgIGNoYXJDb29yZHM6IGZ1bmN0aW9uKHBvcywgbW9kZSkge1xuICAgICAgICByZXR1cm4gY2hhckNvb3Jkcyh0aGlzLCBjbGlwUG9zKHRoaXMuZG9jLCBwb3MpLCBtb2RlIHx8IFwicGFnZVwiKVxuICAgICAgfSxcblxuICAgICAgY29vcmRzQ2hhcjogZnVuY3Rpb24oY29vcmRzLCBtb2RlKSB7XG4gICAgICAgIGNvb3JkcyA9IGZyb21Db29yZFN5c3RlbSh0aGlzLCBjb29yZHMsIG1vZGUgfHwgXCJwYWdlXCIpO1xuICAgICAgICByZXR1cm4gY29vcmRzQ2hhcih0aGlzLCBjb29yZHMubGVmdCwgY29vcmRzLnRvcClcbiAgICAgIH0sXG5cbiAgICAgIGxpbmVBdEhlaWdodDogZnVuY3Rpb24oaGVpZ2h0LCBtb2RlKSB7XG4gICAgICAgIGhlaWdodCA9IGZyb21Db29yZFN5c3RlbSh0aGlzLCB7dG9wOiBoZWlnaHQsIGxlZnQ6IDB9LCBtb2RlIHx8IFwicGFnZVwiKS50b3A7XG4gICAgICAgIHJldHVybiBsaW5lQXRIZWlnaHQodGhpcy5kb2MsIGhlaWdodCArIHRoaXMuZGlzcGxheS52aWV3T2Zmc2V0KVxuICAgICAgfSxcbiAgICAgIGhlaWdodEF0TGluZTogZnVuY3Rpb24obGluZSwgbW9kZSwgaW5jbHVkZVdpZGdldHMpIHtcbiAgICAgICAgdmFyIGVuZCA9IGZhbHNlLCBsaW5lT2JqO1xuICAgICAgICBpZiAodHlwZW9mIGxpbmUgPT0gXCJudW1iZXJcIikge1xuICAgICAgICAgIHZhciBsYXN0ID0gdGhpcy5kb2MuZmlyc3QgKyB0aGlzLmRvYy5zaXplIC0gMTtcbiAgICAgICAgICBpZiAobGluZSA8IHRoaXMuZG9jLmZpcnN0KSB7IGxpbmUgPSB0aGlzLmRvYy5maXJzdDsgfVxuICAgICAgICAgIGVsc2UgaWYgKGxpbmUgPiBsYXN0KSB7IGxpbmUgPSBsYXN0OyBlbmQgPSB0cnVlOyB9XG4gICAgICAgICAgbGluZU9iaiA9IGdldExpbmUodGhpcy5kb2MsIGxpbmUpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGxpbmVPYmogPSBsaW5lO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBpbnRvQ29vcmRTeXN0ZW0odGhpcywgbGluZU9iaiwge3RvcDogMCwgbGVmdDogMH0sIG1vZGUgfHwgXCJwYWdlXCIsIGluY2x1ZGVXaWRnZXRzIHx8IGVuZCkudG9wICtcbiAgICAgICAgICAoZW5kID8gdGhpcy5kb2MuaGVpZ2h0IC0gaGVpZ2h0QXRMaW5lKGxpbmVPYmopIDogMClcbiAgICAgIH0sXG5cbiAgICAgIGRlZmF1bHRUZXh0SGVpZ2h0OiBmdW5jdGlvbigpIHsgcmV0dXJuIHRleHRIZWlnaHQodGhpcy5kaXNwbGF5KSB9LFxuICAgICAgZGVmYXVsdENoYXJXaWR0aDogZnVuY3Rpb24oKSB7IHJldHVybiBjaGFyV2lkdGgodGhpcy5kaXNwbGF5KSB9LFxuXG4gICAgICBnZXRWaWV3cG9ydDogZnVuY3Rpb24oKSB7IHJldHVybiB7ZnJvbTogdGhpcy5kaXNwbGF5LnZpZXdGcm9tLCB0bzogdGhpcy5kaXNwbGF5LnZpZXdUb319LFxuXG4gICAgICBhZGRXaWRnZXQ6IGZ1bmN0aW9uKHBvcywgbm9kZSwgc2Nyb2xsLCB2ZXJ0LCBob3Jpeikge1xuICAgICAgICB2YXIgZGlzcGxheSA9IHRoaXMuZGlzcGxheTtcbiAgICAgICAgcG9zID0gY3Vyc29yQ29vcmRzKHRoaXMsIGNsaXBQb3ModGhpcy5kb2MsIHBvcykpO1xuICAgICAgICB2YXIgdG9wID0gcG9zLmJvdHRvbSwgbGVmdCA9IHBvcy5sZWZ0O1xuICAgICAgICBub2RlLnN0eWxlLnBvc2l0aW9uID0gXCJhYnNvbHV0ZVwiO1xuICAgICAgICBub2RlLnNldEF0dHJpYnV0ZShcImNtLWlnbm9yZS1ldmVudHNcIiwgXCJ0cnVlXCIpO1xuICAgICAgICB0aGlzLmRpc3BsYXkuaW5wdXQuc2V0VW5lZGl0YWJsZShub2RlKTtcbiAgICAgICAgZGlzcGxheS5zaXplci5hcHBlbmRDaGlsZChub2RlKTtcbiAgICAgICAgaWYgKHZlcnQgPT0gXCJvdmVyXCIpIHtcbiAgICAgICAgICB0b3AgPSBwb3MudG9wO1xuICAgICAgICB9IGVsc2UgaWYgKHZlcnQgPT0gXCJhYm92ZVwiIHx8IHZlcnQgPT0gXCJuZWFyXCIpIHtcbiAgICAgICAgICB2YXIgdnNwYWNlID0gTWF0aC5tYXgoZGlzcGxheS53cmFwcGVyLmNsaWVudEhlaWdodCwgdGhpcy5kb2MuaGVpZ2h0KSxcbiAgICAgICAgICBoc3BhY2UgPSBNYXRoLm1heChkaXNwbGF5LnNpemVyLmNsaWVudFdpZHRoLCBkaXNwbGF5LmxpbmVTcGFjZS5jbGllbnRXaWR0aCk7XG4gICAgICAgICAgLy8gRGVmYXVsdCB0byBwb3NpdGlvbmluZyBhYm92ZSAoaWYgc3BlY2lmaWVkIGFuZCBwb3NzaWJsZSk7IG90aGVyd2lzZSBkZWZhdWx0IHRvIHBvc2l0aW9uaW5nIGJlbG93XG4gICAgICAgICAgaWYgKCh2ZXJ0ID09ICdhYm92ZScgfHwgcG9zLmJvdHRvbSArIG5vZGUub2Zmc2V0SGVpZ2h0ID4gdnNwYWNlKSAmJiBwb3MudG9wID4gbm9kZS5vZmZzZXRIZWlnaHQpXG4gICAgICAgICAgICB7IHRvcCA9IHBvcy50b3AgLSBub2RlLm9mZnNldEhlaWdodDsgfVxuICAgICAgICAgIGVsc2UgaWYgKHBvcy5ib3R0b20gKyBub2RlLm9mZnNldEhlaWdodCA8PSB2c3BhY2UpXG4gICAgICAgICAgICB7IHRvcCA9IHBvcy5ib3R0b207IH1cbiAgICAgICAgICBpZiAobGVmdCArIG5vZGUub2Zmc2V0V2lkdGggPiBoc3BhY2UpXG4gICAgICAgICAgICB7IGxlZnQgPSBoc3BhY2UgLSBub2RlLm9mZnNldFdpZHRoOyB9XG4gICAgICAgIH1cbiAgICAgICAgbm9kZS5zdHlsZS50b3AgPSB0b3AgKyBcInB4XCI7XG4gICAgICAgIG5vZGUuc3R5bGUubGVmdCA9IG5vZGUuc3R5bGUucmlnaHQgPSBcIlwiO1xuICAgICAgICBpZiAoaG9yaXogPT0gXCJyaWdodFwiKSB7XG4gICAgICAgICAgbGVmdCA9IGRpc3BsYXkuc2l6ZXIuY2xpZW50V2lkdGggLSBub2RlLm9mZnNldFdpZHRoO1xuICAgICAgICAgIG5vZGUuc3R5bGUucmlnaHQgPSBcIjBweFwiO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGlmIChob3JpeiA9PSBcImxlZnRcIikgeyBsZWZ0ID0gMDsgfVxuICAgICAgICAgIGVsc2UgaWYgKGhvcml6ID09IFwibWlkZGxlXCIpIHsgbGVmdCA9IChkaXNwbGF5LnNpemVyLmNsaWVudFdpZHRoIC0gbm9kZS5vZmZzZXRXaWR0aCkgLyAyOyB9XG4gICAgICAgICAgbm9kZS5zdHlsZS5sZWZ0ID0gbGVmdCArIFwicHhcIjtcbiAgICAgICAgfVxuICAgICAgICBpZiAoc2Nyb2xsKVxuICAgICAgICAgIHsgc2Nyb2xsSW50b1ZpZXcodGhpcywge2xlZnQ6IGxlZnQsIHRvcDogdG9wLCByaWdodDogbGVmdCArIG5vZGUub2Zmc2V0V2lkdGgsIGJvdHRvbTogdG9wICsgbm9kZS5vZmZzZXRIZWlnaHR9KTsgfVxuICAgICAgfSxcblxuICAgICAgdHJpZ2dlck9uS2V5RG93bjogbWV0aG9kT3Aob25LZXlEb3duKSxcbiAgICAgIHRyaWdnZXJPbktleVByZXNzOiBtZXRob2RPcChvbktleVByZXNzKSxcbiAgICAgIHRyaWdnZXJPbktleVVwOiBvbktleVVwLFxuICAgICAgdHJpZ2dlck9uTW91c2VEb3duOiBtZXRob2RPcChvbk1vdXNlRG93biksXG5cbiAgICAgIGV4ZWNDb21tYW5kOiBmdW5jdGlvbihjbWQpIHtcbiAgICAgICAgaWYgKGNvbW1hbmRzLmhhc093blByb3BlcnR5KGNtZCkpXG4gICAgICAgICAgeyByZXR1cm4gY29tbWFuZHNbY21kXS5jYWxsKG51bGwsIHRoaXMpIH1cbiAgICAgIH0sXG5cbiAgICAgIHRyaWdnZXJFbGVjdHJpYzogbWV0aG9kT3AoZnVuY3Rpb24odGV4dCkgeyB0cmlnZ2VyRWxlY3RyaWModGhpcywgdGV4dCk7IH0pLFxuXG4gICAgICBmaW5kUG9zSDogZnVuY3Rpb24oZnJvbSwgYW1vdW50LCB1bml0LCB2aXN1YWxseSkge1xuICAgICAgICB2YXIgZGlyID0gMTtcbiAgICAgICAgaWYgKGFtb3VudCA8IDApIHsgZGlyID0gLTE7IGFtb3VudCA9IC1hbW91bnQ7IH1cbiAgICAgICAgdmFyIGN1ciA9IGNsaXBQb3ModGhpcy5kb2MsIGZyb20pO1xuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGFtb3VudDsgKytpKSB7XG4gICAgICAgICAgY3VyID0gZmluZFBvc0godGhpcy5kb2MsIGN1ciwgZGlyLCB1bml0LCB2aXN1YWxseSk7XG4gICAgICAgICAgaWYgKGN1ci5oaXRTaWRlKSB7IGJyZWFrIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gY3VyXG4gICAgICB9LFxuXG4gICAgICBtb3ZlSDogbWV0aG9kT3AoZnVuY3Rpb24oZGlyLCB1bml0KSB7XG4gICAgICAgIHZhciB0aGlzJDEgPSB0aGlzO1xuXG4gICAgICAgIHRoaXMuZXh0ZW5kU2VsZWN0aW9uc0J5KGZ1bmN0aW9uIChyYW5nZSkge1xuICAgICAgICAgIGlmICh0aGlzJDEuZGlzcGxheS5zaGlmdCB8fCB0aGlzJDEuZG9jLmV4dGVuZCB8fCByYW5nZS5lbXB0eSgpKVxuICAgICAgICAgICAgeyByZXR1cm4gZmluZFBvc0godGhpcyQxLmRvYywgcmFuZ2UuaGVhZCwgZGlyLCB1bml0LCB0aGlzJDEub3B0aW9ucy5ydGxNb3ZlVmlzdWFsbHkpIH1cbiAgICAgICAgICBlbHNlXG4gICAgICAgICAgICB7IHJldHVybiBkaXIgPCAwID8gcmFuZ2UuZnJvbSgpIDogcmFuZ2UudG8oKSB9XG4gICAgICAgIH0sIHNlbF9tb3ZlKTtcbiAgICAgIH0pLFxuXG4gICAgICBkZWxldGVIOiBtZXRob2RPcChmdW5jdGlvbihkaXIsIHVuaXQpIHtcbiAgICAgICAgdmFyIHNlbCA9IHRoaXMuZG9jLnNlbCwgZG9jID0gdGhpcy5kb2M7XG4gICAgICAgIGlmIChzZWwuc29tZXRoaW5nU2VsZWN0ZWQoKSlcbiAgICAgICAgICB7IGRvYy5yZXBsYWNlU2VsZWN0aW9uKFwiXCIsIG51bGwsIFwiK2RlbGV0ZVwiKTsgfVxuICAgICAgICBlbHNlXG4gICAgICAgICAgeyBkZWxldGVOZWFyU2VsZWN0aW9uKHRoaXMsIGZ1bmN0aW9uIChyYW5nZSkge1xuICAgICAgICAgICAgdmFyIG90aGVyID0gZmluZFBvc0goZG9jLCByYW5nZS5oZWFkLCBkaXIsIHVuaXQsIGZhbHNlKTtcbiAgICAgICAgICAgIHJldHVybiBkaXIgPCAwID8ge2Zyb206IG90aGVyLCB0bzogcmFuZ2UuaGVhZH0gOiB7ZnJvbTogcmFuZ2UuaGVhZCwgdG86IG90aGVyfVxuICAgICAgICAgIH0pOyB9XG4gICAgICB9KSxcblxuICAgICAgZmluZFBvc1Y6IGZ1bmN0aW9uKGZyb20sIGFtb3VudCwgdW5pdCwgZ29hbENvbHVtbikge1xuICAgICAgICB2YXIgZGlyID0gMSwgeCA9IGdvYWxDb2x1bW47XG4gICAgICAgIGlmIChhbW91bnQgPCAwKSB7IGRpciA9IC0xOyBhbW91bnQgPSAtYW1vdW50OyB9XG4gICAgICAgIHZhciBjdXIgPSBjbGlwUG9zKHRoaXMuZG9jLCBmcm9tKTtcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBhbW91bnQ7ICsraSkge1xuICAgICAgICAgIHZhciBjb29yZHMgPSBjdXJzb3JDb29yZHModGhpcywgY3VyLCBcImRpdlwiKTtcbiAgICAgICAgICBpZiAoeCA9PSBudWxsKSB7IHggPSBjb29yZHMubGVmdDsgfVxuICAgICAgICAgIGVsc2UgeyBjb29yZHMubGVmdCA9IHg7IH1cbiAgICAgICAgICBjdXIgPSBmaW5kUG9zVih0aGlzLCBjb29yZHMsIGRpciwgdW5pdCk7XG4gICAgICAgICAgaWYgKGN1ci5oaXRTaWRlKSB7IGJyZWFrIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gY3VyXG4gICAgICB9LFxuXG4gICAgICBtb3ZlVjogbWV0aG9kT3AoZnVuY3Rpb24oZGlyLCB1bml0KSB7XG4gICAgICAgIHZhciB0aGlzJDEgPSB0aGlzO1xuXG4gICAgICAgIHZhciBkb2MgPSB0aGlzLmRvYywgZ29hbHMgPSBbXTtcbiAgICAgICAgdmFyIGNvbGxhcHNlID0gIXRoaXMuZGlzcGxheS5zaGlmdCAmJiAhZG9jLmV4dGVuZCAmJiBkb2Muc2VsLnNvbWV0aGluZ1NlbGVjdGVkKCk7XG4gICAgICAgIGRvYy5leHRlbmRTZWxlY3Rpb25zQnkoZnVuY3Rpb24gKHJhbmdlKSB7XG4gICAgICAgICAgaWYgKGNvbGxhcHNlKVxuICAgICAgICAgICAgeyByZXR1cm4gZGlyIDwgMCA/IHJhbmdlLmZyb20oKSA6IHJhbmdlLnRvKCkgfVxuICAgICAgICAgIHZhciBoZWFkUG9zID0gY3Vyc29yQ29vcmRzKHRoaXMkMSwgcmFuZ2UuaGVhZCwgXCJkaXZcIik7XG4gICAgICAgICAgaWYgKHJhbmdlLmdvYWxDb2x1bW4gIT0gbnVsbCkgeyBoZWFkUG9zLmxlZnQgPSByYW5nZS5nb2FsQ29sdW1uOyB9XG4gICAgICAgICAgZ29hbHMucHVzaChoZWFkUG9zLmxlZnQpO1xuICAgICAgICAgIHZhciBwb3MgPSBmaW5kUG9zVih0aGlzJDEsIGhlYWRQb3MsIGRpciwgdW5pdCk7XG4gICAgICAgICAgaWYgKHVuaXQgPT0gXCJwYWdlXCIgJiYgcmFuZ2UgPT0gZG9jLnNlbC5wcmltYXJ5KCkpXG4gICAgICAgICAgICB7IGFkZFRvU2Nyb2xsVG9wKHRoaXMkMSwgY2hhckNvb3Jkcyh0aGlzJDEsIHBvcywgXCJkaXZcIikudG9wIC0gaGVhZFBvcy50b3ApOyB9XG4gICAgICAgICAgcmV0dXJuIHBvc1xuICAgICAgICB9LCBzZWxfbW92ZSk7XG4gICAgICAgIGlmIChnb2Fscy5sZW5ndGgpIHsgZm9yICh2YXIgaSA9IDA7IGkgPCBkb2Muc2VsLnJhbmdlcy5sZW5ndGg7IGkrKylcbiAgICAgICAgICB7IGRvYy5zZWwucmFuZ2VzW2ldLmdvYWxDb2x1bW4gPSBnb2Fsc1tpXTsgfSB9XG4gICAgICB9KSxcblxuICAgICAgLy8gRmluZCB0aGUgd29yZCBhdCB0aGUgZ2l2ZW4gcG9zaXRpb24gKGFzIHJldHVybmVkIGJ5IGNvb3Jkc0NoYXIpLlxuICAgICAgZmluZFdvcmRBdDogZnVuY3Rpb24ocG9zKSB7XG4gICAgICAgIHZhciBkb2MgPSB0aGlzLmRvYywgbGluZSA9IGdldExpbmUoZG9jLCBwb3MubGluZSkudGV4dDtcbiAgICAgICAgdmFyIHN0YXJ0ID0gcG9zLmNoLCBlbmQgPSBwb3MuY2g7XG4gICAgICAgIGlmIChsaW5lKSB7XG4gICAgICAgICAgdmFyIGhlbHBlciA9IHRoaXMuZ2V0SGVscGVyKHBvcywgXCJ3b3JkQ2hhcnNcIik7XG4gICAgICAgICAgaWYgKChwb3Muc3RpY2t5ID09IFwiYmVmb3JlXCIgfHwgZW5kID09IGxpbmUubGVuZ3RoKSAmJiBzdGFydCkgeyAtLXN0YXJ0OyB9IGVsc2UgeyArK2VuZDsgfVxuICAgICAgICAgIHZhciBzdGFydENoYXIgPSBsaW5lLmNoYXJBdChzdGFydCk7XG4gICAgICAgICAgdmFyIGNoZWNrID0gaXNXb3JkQ2hhcihzdGFydENoYXIsIGhlbHBlcilcbiAgICAgICAgICAgID8gZnVuY3Rpb24gKGNoKSB7IHJldHVybiBpc1dvcmRDaGFyKGNoLCBoZWxwZXIpOyB9XG4gICAgICAgICAgICA6IC9cXHMvLnRlc3Qoc3RhcnRDaGFyKSA/IGZ1bmN0aW9uIChjaCkgeyByZXR1cm4gL1xccy8udGVzdChjaCk7IH1cbiAgICAgICAgICAgIDogZnVuY3Rpb24gKGNoKSB7IHJldHVybiAoIS9cXHMvLnRlc3QoY2gpICYmICFpc1dvcmRDaGFyKGNoKSk7IH07XG4gICAgICAgICAgd2hpbGUgKHN0YXJ0ID4gMCAmJiBjaGVjayhsaW5lLmNoYXJBdChzdGFydCAtIDEpKSkgeyAtLXN0YXJ0OyB9XG4gICAgICAgICAgd2hpbGUgKGVuZCA8IGxpbmUubGVuZ3RoICYmIGNoZWNrKGxpbmUuY2hhckF0KGVuZCkpKSB7ICsrZW5kOyB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG5ldyBSYW5nZShQb3MocG9zLmxpbmUsIHN0YXJ0KSwgUG9zKHBvcy5saW5lLCBlbmQpKVxuICAgICAgfSxcblxuICAgICAgdG9nZ2xlT3ZlcndyaXRlOiBmdW5jdGlvbih2YWx1ZSkge1xuICAgICAgICBpZiAodmFsdWUgIT0gbnVsbCAmJiB2YWx1ZSA9PSB0aGlzLnN0YXRlLm92ZXJ3cml0ZSkgeyByZXR1cm4gfVxuICAgICAgICBpZiAodGhpcy5zdGF0ZS5vdmVyd3JpdGUgPSAhdGhpcy5zdGF0ZS5vdmVyd3JpdGUpXG4gICAgICAgICAgeyBhZGRDbGFzcyh0aGlzLmRpc3BsYXkuY3Vyc29yRGl2LCBcIkNvZGVNaXJyb3Itb3ZlcndyaXRlXCIpOyB9XG4gICAgICAgIGVsc2VcbiAgICAgICAgICB7IHJtQ2xhc3ModGhpcy5kaXNwbGF5LmN1cnNvckRpdiwgXCJDb2RlTWlycm9yLW92ZXJ3cml0ZVwiKTsgfVxuXG4gICAgICAgIHNpZ25hbCh0aGlzLCBcIm92ZXJ3cml0ZVRvZ2dsZVwiLCB0aGlzLCB0aGlzLnN0YXRlLm92ZXJ3cml0ZSk7XG4gICAgICB9LFxuICAgICAgaGFzRm9jdXM6IGZ1bmN0aW9uKCkgeyByZXR1cm4gdGhpcy5kaXNwbGF5LmlucHV0LmdldEZpZWxkKCkgPT0gYWN0aXZlRWx0KCkgfSxcbiAgICAgIGlzUmVhZE9ubHk6IGZ1bmN0aW9uKCkgeyByZXR1cm4gISEodGhpcy5vcHRpb25zLnJlYWRPbmx5IHx8IHRoaXMuZG9jLmNhbnRFZGl0KSB9LFxuXG4gICAgICBzY3JvbGxUbzogbWV0aG9kT3AoZnVuY3Rpb24gKHgsIHkpIHsgc2Nyb2xsVG9Db29yZHModGhpcywgeCwgeSk7IH0pLFxuICAgICAgZ2V0U2Nyb2xsSW5mbzogZnVuY3Rpb24oKSB7XG4gICAgICAgIHZhciBzY3JvbGxlciA9IHRoaXMuZGlzcGxheS5zY3JvbGxlcjtcbiAgICAgICAgcmV0dXJuIHtsZWZ0OiBzY3JvbGxlci5zY3JvbGxMZWZ0LCB0b3A6IHNjcm9sbGVyLnNjcm9sbFRvcCxcbiAgICAgICAgICAgICAgICBoZWlnaHQ6IHNjcm9sbGVyLnNjcm9sbEhlaWdodCAtIHNjcm9sbEdhcCh0aGlzKSAtIHRoaXMuZGlzcGxheS5iYXJIZWlnaHQsXG4gICAgICAgICAgICAgICAgd2lkdGg6IHNjcm9sbGVyLnNjcm9sbFdpZHRoIC0gc2Nyb2xsR2FwKHRoaXMpIC0gdGhpcy5kaXNwbGF5LmJhcldpZHRoLFxuICAgICAgICAgICAgICAgIGNsaWVudEhlaWdodDogZGlzcGxheUhlaWdodCh0aGlzKSwgY2xpZW50V2lkdGg6IGRpc3BsYXlXaWR0aCh0aGlzKX1cbiAgICAgIH0sXG5cbiAgICAgIHNjcm9sbEludG9WaWV3OiBtZXRob2RPcChmdW5jdGlvbihyYW5nZSwgbWFyZ2luKSB7XG4gICAgICAgIGlmIChyYW5nZSA9PSBudWxsKSB7XG4gICAgICAgICAgcmFuZ2UgPSB7ZnJvbTogdGhpcy5kb2Muc2VsLnByaW1hcnkoKS5oZWFkLCB0bzogbnVsbH07XG4gICAgICAgICAgaWYgKG1hcmdpbiA9PSBudWxsKSB7IG1hcmdpbiA9IHRoaXMub3B0aW9ucy5jdXJzb3JTY3JvbGxNYXJnaW47IH1cbiAgICAgICAgfSBlbHNlIGlmICh0eXBlb2YgcmFuZ2UgPT0gXCJudW1iZXJcIikge1xuICAgICAgICAgIHJhbmdlID0ge2Zyb206IFBvcyhyYW5nZSwgMCksIHRvOiBudWxsfTtcbiAgICAgICAgfSBlbHNlIGlmIChyYW5nZS5mcm9tID09IG51bGwpIHtcbiAgICAgICAgICByYW5nZSA9IHtmcm9tOiByYW5nZSwgdG86IG51bGx9O1xuICAgICAgICB9XG4gICAgICAgIGlmICghcmFuZ2UudG8pIHsgcmFuZ2UudG8gPSByYW5nZS5mcm9tOyB9XG4gICAgICAgIHJhbmdlLm1hcmdpbiA9IG1hcmdpbiB8fCAwO1xuXG4gICAgICAgIGlmIChyYW5nZS5mcm9tLmxpbmUgIT0gbnVsbCkge1xuICAgICAgICAgIHNjcm9sbFRvUmFuZ2UodGhpcywgcmFuZ2UpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHNjcm9sbFRvQ29vcmRzUmFuZ2UodGhpcywgcmFuZ2UuZnJvbSwgcmFuZ2UudG8sIHJhbmdlLm1hcmdpbik7XG4gICAgICAgIH1cbiAgICAgIH0pLFxuXG4gICAgICBzZXRTaXplOiBtZXRob2RPcChmdW5jdGlvbih3aWR0aCwgaGVpZ2h0KSB7XG4gICAgICAgIHZhciB0aGlzJDEgPSB0aGlzO1xuXG4gICAgICAgIHZhciBpbnRlcnByZXQgPSBmdW5jdGlvbiAodmFsKSB7IHJldHVybiB0eXBlb2YgdmFsID09IFwibnVtYmVyXCIgfHwgL15cXGQrJC8udGVzdChTdHJpbmcodmFsKSkgPyB2YWwgKyBcInB4XCIgOiB2YWw7IH07XG4gICAgICAgIGlmICh3aWR0aCAhPSBudWxsKSB7IHRoaXMuZGlzcGxheS53cmFwcGVyLnN0eWxlLndpZHRoID0gaW50ZXJwcmV0KHdpZHRoKTsgfVxuICAgICAgICBpZiAoaGVpZ2h0ICE9IG51bGwpIHsgdGhpcy5kaXNwbGF5LndyYXBwZXIuc3R5bGUuaGVpZ2h0ID0gaW50ZXJwcmV0KGhlaWdodCk7IH1cbiAgICAgICAgaWYgKHRoaXMub3B0aW9ucy5saW5lV3JhcHBpbmcpIHsgY2xlYXJMaW5lTWVhc3VyZW1lbnRDYWNoZSh0aGlzKTsgfVxuICAgICAgICB2YXIgbGluZU5vID0gdGhpcy5kaXNwbGF5LnZpZXdGcm9tO1xuICAgICAgICB0aGlzLmRvYy5pdGVyKGxpbmVObywgdGhpcy5kaXNwbGF5LnZpZXdUbywgZnVuY3Rpb24gKGxpbmUpIHtcbiAgICAgICAgICBpZiAobGluZS53aWRnZXRzKSB7IGZvciAodmFyIGkgPSAwOyBpIDwgbGluZS53aWRnZXRzLmxlbmd0aDsgaSsrKVxuICAgICAgICAgICAgeyBpZiAobGluZS53aWRnZXRzW2ldLm5vSFNjcm9sbCkgeyByZWdMaW5lQ2hhbmdlKHRoaXMkMSwgbGluZU5vLCBcIndpZGdldFwiKTsgYnJlYWsgfSB9IH1cbiAgICAgICAgICArK2xpbmVObztcbiAgICAgICAgfSk7XG4gICAgICAgIHRoaXMuY3VyT3AuZm9yY2VVcGRhdGUgPSB0cnVlO1xuICAgICAgICBzaWduYWwodGhpcywgXCJyZWZyZXNoXCIsIHRoaXMpO1xuICAgICAgfSksXG5cbiAgICAgIG9wZXJhdGlvbjogZnVuY3Rpb24oZil7cmV0dXJuIHJ1bkluT3AodGhpcywgZil9LFxuICAgICAgc3RhcnRPcGVyYXRpb246IGZ1bmN0aW9uKCl7cmV0dXJuIHN0YXJ0T3BlcmF0aW9uKHRoaXMpfSxcbiAgICAgIGVuZE9wZXJhdGlvbjogZnVuY3Rpb24oKXtyZXR1cm4gZW5kT3BlcmF0aW9uKHRoaXMpfSxcblxuICAgICAgcmVmcmVzaDogbWV0aG9kT3AoZnVuY3Rpb24oKSB7XG4gICAgICAgIHZhciBvbGRIZWlnaHQgPSB0aGlzLmRpc3BsYXkuY2FjaGVkVGV4dEhlaWdodDtcbiAgICAgICAgcmVnQ2hhbmdlKHRoaXMpO1xuICAgICAgICB0aGlzLmN1ck9wLmZvcmNlVXBkYXRlID0gdHJ1ZTtcbiAgICAgICAgY2xlYXJDYWNoZXModGhpcyk7XG4gICAgICAgIHNjcm9sbFRvQ29vcmRzKHRoaXMsIHRoaXMuZG9jLnNjcm9sbExlZnQsIHRoaXMuZG9jLnNjcm9sbFRvcCk7XG4gICAgICAgIHVwZGF0ZUd1dHRlclNwYWNlKHRoaXMuZGlzcGxheSk7XG4gICAgICAgIGlmIChvbGRIZWlnaHQgPT0gbnVsbCB8fCBNYXRoLmFicyhvbGRIZWlnaHQgLSB0ZXh0SGVpZ2h0KHRoaXMuZGlzcGxheSkpID4gLjUgfHwgdGhpcy5vcHRpb25zLmxpbmVXcmFwcGluZylcbiAgICAgICAgICB7IGVzdGltYXRlTGluZUhlaWdodHModGhpcyk7IH1cbiAgICAgICAgc2lnbmFsKHRoaXMsIFwicmVmcmVzaFwiLCB0aGlzKTtcbiAgICAgIH0pLFxuXG4gICAgICBzd2FwRG9jOiBtZXRob2RPcChmdW5jdGlvbihkb2MpIHtcbiAgICAgICAgdmFyIG9sZCA9IHRoaXMuZG9jO1xuICAgICAgICBvbGQuY20gPSBudWxsO1xuICAgICAgICAvLyBDYW5jZWwgdGhlIGN1cnJlbnQgdGV4dCBzZWxlY3Rpb24gaWYgYW55ICgjNTgyMSlcbiAgICAgICAgaWYgKHRoaXMuc3RhdGUuc2VsZWN0aW5nVGV4dCkgeyB0aGlzLnN0YXRlLnNlbGVjdGluZ1RleHQoKTsgfVxuICAgICAgICBhdHRhY2hEb2ModGhpcywgZG9jKTtcbiAgICAgICAgY2xlYXJDYWNoZXModGhpcyk7XG4gICAgICAgIHRoaXMuZGlzcGxheS5pbnB1dC5yZXNldCgpO1xuICAgICAgICBzY3JvbGxUb0Nvb3Jkcyh0aGlzLCBkb2Muc2Nyb2xsTGVmdCwgZG9jLnNjcm9sbFRvcCk7XG4gICAgICAgIHRoaXMuY3VyT3AuZm9yY2VTY3JvbGwgPSB0cnVlO1xuICAgICAgICBzaWduYWxMYXRlcih0aGlzLCBcInN3YXBEb2NcIiwgdGhpcywgb2xkKTtcbiAgICAgICAgcmV0dXJuIG9sZFxuICAgICAgfSksXG5cbiAgICAgIHBocmFzZTogZnVuY3Rpb24ocGhyYXNlVGV4dCkge1xuICAgICAgICB2YXIgcGhyYXNlcyA9IHRoaXMub3B0aW9ucy5waHJhc2VzO1xuICAgICAgICByZXR1cm4gcGhyYXNlcyAmJiBPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwocGhyYXNlcywgcGhyYXNlVGV4dCkgPyBwaHJhc2VzW3BocmFzZVRleHRdIDogcGhyYXNlVGV4dFxuICAgICAgfSxcblxuICAgICAgZ2V0SW5wdXRGaWVsZDogZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy5kaXNwbGF5LmlucHV0LmdldEZpZWxkKCl9LFxuICAgICAgZ2V0V3JhcHBlckVsZW1lbnQ6IGZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMuZGlzcGxheS53cmFwcGVyfSxcbiAgICAgIGdldFNjcm9sbGVyRWxlbWVudDogZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy5kaXNwbGF5LnNjcm9sbGVyfSxcbiAgICAgIGdldEd1dHRlckVsZW1lbnQ6IGZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMuZGlzcGxheS5ndXR0ZXJzfVxuICAgIH07XG4gICAgZXZlbnRNaXhpbihDb2RlTWlycm9yKTtcblxuICAgIENvZGVNaXJyb3IucmVnaXN0ZXJIZWxwZXIgPSBmdW5jdGlvbih0eXBlLCBuYW1lLCB2YWx1ZSkge1xuICAgICAgaWYgKCFoZWxwZXJzLmhhc093blByb3BlcnR5KHR5cGUpKSB7IGhlbHBlcnNbdHlwZV0gPSBDb2RlTWlycm9yW3R5cGVdID0ge19nbG9iYWw6IFtdfTsgfVxuICAgICAgaGVscGVyc1t0eXBlXVtuYW1lXSA9IHZhbHVlO1xuICAgIH07XG4gICAgQ29kZU1pcnJvci5yZWdpc3Rlckdsb2JhbEhlbHBlciA9IGZ1bmN0aW9uKHR5cGUsIG5hbWUsIHByZWRpY2F0ZSwgdmFsdWUpIHtcbiAgICAgIENvZGVNaXJyb3IucmVnaXN0ZXJIZWxwZXIodHlwZSwgbmFtZSwgdmFsdWUpO1xuICAgICAgaGVscGVyc1t0eXBlXS5fZ2xvYmFsLnB1c2goe3ByZWQ6IHByZWRpY2F0ZSwgdmFsOiB2YWx1ZX0pO1xuICAgIH07XG4gIH1cblxuICAvLyBVc2VkIGZvciBob3Jpem9udGFsIHJlbGF0aXZlIG1vdGlvbi4gRGlyIGlzIC0xIG9yIDEgKGxlZnQgb3JcbiAgLy8gcmlnaHQpLCB1bml0IGNhbiBiZSBcImNvZGVwb2ludFwiLCBcImNoYXJcIiwgXCJjb2x1bW5cIiAobGlrZSBjaGFyLCBidXRcbiAgLy8gZG9lc24ndCBjcm9zcyBsaW5lIGJvdW5kYXJpZXMpLCBcIndvcmRcIiAoYWNyb3NzIG5leHQgd29yZCksIG9yXG4gIC8vIFwiZ3JvdXBcIiAodG8gdGhlIHN0YXJ0IG9mIG5leHQgZ3JvdXAgb2Ygd29yZCBvclxuICAvLyBub24td29yZC1ub24td2hpdGVzcGFjZSBjaGFycykuIFRoZSB2aXN1YWxseSBwYXJhbSBjb250cm9sc1xuICAvLyB3aGV0aGVyLCBpbiByaWdodC10by1sZWZ0IHRleHQsIGRpcmVjdGlvbiAxIG1lYW5zIHRvIG1vdmUgdG93YXJkc1xuICAvLyB0aGUgbmV4dCBpbmRleCBpbiB0aGUgc3RyaW5nLCBvciB0b3dhcmRzIHRoZSBjaGFyYWN0ZXIgdG8gdGhlIHJpZ2h0XG4gIC8vIG9mIHRoZSBjdXJyZW50IHBvc2l0aW9uLiBUaGUgcmVzdWx0aW5nIHBvc2l0aW9uIHdpbGwgaGF2ZSBhXG4gIC8vIGhpdFNpZGU9dHJ1ZSBwcm9wZXJ0eSBpZiBpdCByZWFjaGVkIHRoZSBlbmQgb2YgdGhlIGRvY3VtZW50LlxuICBmdW5jdGlvbiBmaW5kUG9zSChkb2MsIHBvcywgZGlyLCB1bml0LCB2aXN1YWxseSkge1xuICAgIHZhciBvbGRQb3MgPSBwb3M7XG4gICAgdmFyIG9yaWdEaXIgPSBkaXI7XG4gICAgdmFyIGxpbmVPYmogPSBnZXRMaW5lKGRvYywgcG9zLmxpbmUpO1xuICAgIHZhciBsaW5lRGlyID0gdmlzdWFsbHkgJiYgZG9jLmRpcmVjdGlvbiA9PSBcInJ0bFwiID8gLWRpciA6IGRpcjtcbiAgICBmdW5jdGlvbiBmaW5kTmV4dExpbmUoKSB7XG4gICAgICB2YXIgbCA9IHBvcy5saW5lICsgbGluZURpcjtcbiAgICAgIGlmIChsIDwgZG9jLmZpcnN0IHx8IGwgPj0gZG9jLmZpcnN0ICsgZG9jLnNpemUpIHsgcmV0dXJuIGZhbHNlIH1cbiAgICAgIHBvcyA9IG5ldyBQb3MobCwgcG9zLmNoLCBwb3Muc3RpY2t5KTtcbiAgICAgIHJldHVybiBsaW5lT2JqID0gZ2V0TGluZShkb2MsIGwpXG4gICAgfVxuICAgIGZ1bmN0aW9uIG1vdmVPbmNlKGJvdW5kVG9MaW5lKSB7XG4gICAgICB2YXIgbmV4dDtcbiAgICAgIGlmICh1bml0ID09IFwiY29kZXBvaW50XCIpIHtcbiAgICAgICAgdmFyIGNoID0gbGluZU9iai50ZXh0LmNoYXJDb2RlQXQocG9zLmNoICsgKGRpciA+IDAgPyAwIDogLTEpKTtcbiAgICAgICAgaWYgKGlzTmFOKGNoKSkge1xuICAgICAgICAgIG5leHQgPSBudWxsO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHZhciBhc3RyYWwgPSBkaXIgPiAwID8gY2ggPj0gMHhEODAwICYmIGNoIDwgMHhEQzAwIDogY2ggPj0gMHhEQzAwICYmIGNoIDwgMHhERkZGO1xuICAgICAgICAgIG5leHQgPSBuZXcgUG9zKHBvcy5saW5lLCBNYXRoLm1heCgwLCBNYXRoLm1pbihsaW5lT2JqLnRleHQubGVuZ3RoLCBwb3MuY2ggKyBkaXIgKiAoYXN0cmFsID8gMiA6IDEpKSksIC1kaXIpO1xuICAgICAgICB9XG4gICAgICB9IGVsc2UgaWYgKHZpc3VhbGx5KSB7XG4gICAgICAgIG5leHQgPSBtb3ZlVmlzdWFsbHkoZG9jLmNtLCBsaW5lT2JqLCBwb3MsIGRpcik7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBuZXh0ID0gbW92ZUxvZ2ljYWxseShsaW5lT2JqLCBwb3MsIGRpcik7XG4gICAgICB9XG4gICAgICBpZiAobmV4dCA9PSBudWxsKSB7XG4gICAgICAgIGlmICghYm91bmRUb0xpbmUgJiYgZmluZE5leHRMaW5lKCkpXG4gICAgICAgICAgeyBwb3MgPSBlbmRPZkxpbmUodmlzdWFsbHksIGRvYy5jbSwgbGluZU9iaiwgcG9zLmxpbmUsIGxpbmVEaXIpOyB9XG4gICAgICAgIGVsc2VcbiAgICAgICAgICB7IHJldHVybiBmYWxzZSB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBwb3MgPSBuZXh0O1xuICAgICAgfVxuICAgICAgcmV0dXJuIHRydWVcbiAgICB9XG5cbiAgICBpZiAodW5pdCA9PSBcImNoYXJcIiB8fCB1bml0ID09IFwiY29kZXBvaW50XCIpIHtcbiAgICAgIG1vdmVPbmNlKCk7XG4gICAgfSBlbHNlIGlmICh1bml0ID09IFwiY29sdW1uXCIpIHtcbiAgICAgIG1vdmVPbmNlKHRydWUpO1xuICAgIH0gZWxzZSBpZiAodW5pdCA9PSBcIndvcmRcIiB8fCB1bml0ID09IFwiZ3JvdXBcIikge1xuICAgICAgdmFyIHNhd1R5cGUgPSBudWxsLCBncm91cCA9IHVuaXQgPT0gXCJncm91cFwiO1xuICAgICAgdmFyIGhlbHBlciA9IGRvYy5jbSAmJiBkb2MuY20uZ2V0SGVscGVyKHBvcywgXCJ3b3JkQ2hhcnNcIik7XG4gICAgICBmb3IgKHZhciBmaXJzdCA9IHRydWU7OyBmaXJzdCA9IGZhbHNlKSB7XG4gICAgICAgIGlmIChkaXIgPCAwICYmICFtb3ZlT25jZSghZmlyc3QpKSB7IGJyZWFrIH1cbiAgICAgICAgdmFyIGN1ciA9IGxpbmVPYmoudGV4dC5jaGFyQXQocG9zLmNoKSB8fCBcIlxcblwiO1xuICAgICAgICB2YXIgdHlwZSA9IGlzV29yZENoYXIoY3VyLCBoZWxwZXIpID8gXCJ3XCJcbiAgICAgICAgICA6IGdyb3VwICYmIGN1ciA9PSBcIlxcblwiID8gXCJuXCJcbiAgICAgICAgICA6ICFncm91cCB8fCAvXFxzLy50ZXN0KGN1cikgPyBudWxsXG4gICAgICAgICAgOiBcInBcIjtcbiAgICAgICAgaWYgKGdyb3VwICYmICFmaXJzdCAmJiAhdHlwZSkgeyB0eXBlID0gXCJzXCI7IH1cbiAgICAgICAgaWYgKHNhd1R5cGUgJiYgc2F3VHlwZSAhPSB0eXBlKSB7XG4gICAgICAgICAgaWYgKGRpciA8IDApIHtkaXIgPSAxOyBtb3ZlT25jZSgpOyBwb3Muc3RpY2t5ID0gXCJhZnRlclwiO31cbiAgICAgICAgICBicmVha1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHR5cGUpIHsgc2F3VHlwZSA9IHR5cGU7IH1cbiAgICAgICAgaWYgKGRpciA+IDAgJiYgIW1vdmVPbmNlKCFmaXJzdCkpIHsgYnJlYWsgfVxuICAgICAgfVxuICAgIH1cbiAgICB2YXIgcmVzdWx0ID0gc2tpcEF0b21pYyhkb2MsIHBvcywgb2xkUG9zLCBvcmlnRGlyLCB0cnVlKTtcbiAgICBpZiAoZXF1YWxDdXJzb3JQb3Mob2xkUG9zLCByZXN1bHQpKSB7IHJlc3VsdC5oaXRTaWRlID0gdHJ1ZTsgfVxuICAgIHJldHVybiByZXN1bHRcbiAgfVxuXG4gIC8vIEZvciByZWxhdGl2ZSB2ZXJ0aWNhbCBtb3ZlbWVudC4gRGlyIG1heSBiZSAtMSBvciAxLiBVbml0IGNhbiBiZVxuICAvLyBcInBhZ2VcIiBvciBcImxpbmVcIi4gVGhlIHJlc3VsdGluZyBwb3NpdGlvbiB3aWxsIGhhdmUgYSBoaXRTaWRlPXRydWVcbiAgLy8gcHJvcGVydHkgaWYgaXQgcmVhY2hlZCB0aGUgZW5kIG9mIHRoZSBkb2N1bWVudC5cbiAgZnVuY3Rpb24gZmluZFBvc1YoY20sIHBvcywgZGlyLCB1bml0KSB7XG4gICAgdmFyIGRvYyA9IGNtLmRvYywgeCA9IHBvcy5sZWZ0LCB5O1xuICAgIGlmICh1bml0ID09IFwicGFnZVwiKSB7XG4gICAgICB2YXIgcGFnZVNpemUgPSBNYXRoLm1pbihjbS5kaXNwbGF5LndyYXBwZXIuY2xpZW50SGVpZ2h0LCB3aW5kb3cuaW5uZXJIZWlnaHQgfHwgZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50LmNsaWVudEhlaWdodCk7XG4gICAgICB2YXIgbW92ZUFtb3VudCA9IE1hdGgubWF4KHBhZ2VTaXplIC0gLjUgKiB0ZXh0SGVpZ2h0KGNtLmRpc3BsYXkpLCAzKTtcbiAgICAgIHkgPSAoZGlyID4gMCA/IHBvcy5ib3R0b20gOiBwb3MudG9wKSArIGRpciAqIG1vdmVBbW91bnQ7XG5cbiAgICB9IGVsc2UgaWYgKHVuaXQgPT0gXCJsaW5lXCIpIHtcbiAgICAgIHkgPSBkaXIgPiAwID8gcG9zLmJvdHRvbSArIDMgOiBwb3MudG9wIC0gMztcbiAgICB9XG4gICAgdmFyIHRhcmdldDtcbiAgICBmb3IgKDs7KSB7XG4gICAgICB0YXJnZXQgPSBjb29yZHNDaGFyKGNtLCB4LCB5KTtcbiAgICAgIGlmICghdGFyZ2V0Lm91dHNpZGUpIHsgYnJlYWsgfVxuICAgICAgaWYgKGRpciA8IDAgPyB5IDw9IDAgOiB5ID49IGRvYy5oZWlnaHQpIHsgdGFyZ2V0LmhpdFNpZGUgPSB0cnVlOyBicmVhayB9XG4gICAgICB5ICs9IGRpciAqIDU7XG4gICAgfVxuICAgIHJldHVybiB0YXJnZXRcbiAgfVxuXG4gIC8vIENPTlRFTlRFRElUQUJMRSBJTlBVVCBTVFlMRVxuXG4gIHZhciBDb250ZW50RWRpdGFibGVJbnB1dCA9IGZ1bmN0aW9uKGNtKSB7XG4gICAgdGhpcy5jbSA9IGNtO1xuICAgIHRoaXMubGFzdEFuY2hvck5vZGUgPSB0aGlzLmxhc3RBbmNob3JPZmZzZXQgPSB0aGlzLmxhc3RGb2N1c05vZGUgPSB0aGlzLmxhc3RGb2N1c09mZnNldCA9IG51bGw7XG4gICAgdGhpcy5wb2xsaW5nID0gbmV3IERlbGF5ZWQoKTtcbiAgICB0aGlzLmNvbXBvc2luZyA9IG51bGw7XG4gICAgdGhpcy5ncmFjZVBlcmlvZCA9IGZhbHNlO1xuICAgIHRoaXMucmVhZERPTVRpbWVvdXQgPSBudWxsO1xuICB9O1xuXG4gIENvbnRlbnRFZGl0YWJsZUlucHV0LnByb3RvdHlwZS5pbml0ID0gZnVuY3Rpb24gKGRpc3BsYXkpIHtcbiAgICAgIHZhciB0aGlzJDEgPSB0aGlzO1xuXG4gICAgdmFyIGlucHV0ID0gdGhpcywgY20gPSBpbnB1dC5jbTtcbiAgICB2YXIgZGl2ID0gaW5wdXQuZGl2ID0gZGlzcGxheS5saW5lRGl2O1xuICAgIGRpdi5jb250ZW50RWRpdGFibGUgPSB0cnVlO1xuICAgIGRpc2FibGVCcm93c2VyTWFnaWMoZGl2LCBjbS5vcHRpb25zLnNwZWxsY2hlY2ssIGNtLm9wdGlvbnMuYXV0b2NvcnJlY3QsIGNtLm9wdGlvbnMuYXV0b2NhcGl0YWxpemUpO1xuXG4gICAgZnVuY3Rpb24gYmVsb25nc1RvSW5wdXQoZSkge1xuICAgICAgZm9yICh2YXIgdCA9IGUudGFyZ2V0OyB0OyB0ID0gdC5wYXJlbnROb2RlKSB7XG4gICAgICAgIGlmICh0ID09IGRpdikgeyByZXR1cm4gdHJ1ZSB9XG4gICAgICAgIGlmICgvXFxiQ29kZU1pcnJvci0oPzpsaW5lKT93aWRnZXRcXGIvLnRlc3QodC5jbGFzc05hbWUpKSB7IGJyZWFrIH1cbiAgICAgIH1cbiAgICAgIHJldHVybiBmYWxzZVxuICAgIH1cblxuICAgIG9uKGRpdiwgXCJwYXN0ZVwiLCBmdW5jdGlvbiAoZSkge1xuICAgICAgaWYgKCFiZWxvbmdzVG9JbnB1dChlKSB8fCBzaWduYWxET01FdmVudChjbSwgZSkgfHwgaGFuZGxlUGFzdGUoZSwgY20pKSB7IHJldHVybiB9XG4gICAgICAvLyBJRSBkb2Vzbid0IGZpcmUgaW5wdXQgZXZlbnRzLCBzbyB3ZSBzY2hlZHVsZSBhIHJlYWQgZm9yIHRoZSBwYXN0ZWQgY29udGVudCBpbiB0aGlzIHdheVxuICAgICAgaWYgKGllX3ZlcnNpb24gPD0gMTEpIHsgc2V0VGltZW91dChvcGVyYXRpb24oY20sIGZ1bmN0aW9uICgpIHsgcmV0dXJuIHRoaXMkMS51cGRhdGVGcm9tRE9NKCk7IH0pLCAyMCk7IH1cbiAgICB9KTtcblxuICAgIG9uKGRpdiwgXCJjb21wb3NpdGlvbnN0YXJ0XCIsIGZ1bmN0aW9uIChlKSB7XG4gICAgICB0aGlzJDEuY29tcG9zaW5nID0ge2RhdGE6IGUuZGF0YSwgZG9uZTogZmFsc2V9O1xuICAgIH0pO1xuICAgIG9uKGRpdiwgXCJjb21wb3NpdGlvbnVwZGF0ZVwiLCBmdW5jdGlvbiAoZSkge1xuICAgICAgaWYgKCF0aGlzJDEuY29tcG9zaW5nKSB7IHRoaXMkMS5jb21wb3NpbmcgPSB7ZGF0YTogZS5kYXRhLCBkb25lOiBmYWxzZX07IH1cbiAgICB9KTtcbiAgICBvbihkaXYsIFwiY29tcG9zaXRpb25lbmRcIiwgZnVuY3Rpb24gKGUpIHtcbiAgICAgIGlmICh0aGlzJDEuY29tcG9zaW5nKSB7XG4gICAgICAgIGlmIChlLmRhdGEgIT0gdGhpcyQxLmNvbXBvc2luZy5kYXRhKSB7IHRoaXMkMS5yZWFkRnJvbURPTVNvb24oKTsgfVxuICAgICAgICB0aGlzJDEuY29tcG9zaW5nLmRvbmUgPSB0cnVlO1xuICAgICAgfVxuICAgIH0pO1xuXG4gICAgb24oZGl2LCBcInRvdWNoc3RhcnRcIiwgZnVuY3Rpb24gKCkgeyByZXR1cm4gaW5wdXQuZm9yY2VDb21wb3NpdGlvbkVuZCgpOyB9KTtcblxuICAgIG9uKGRpdiwgXCJpbnB1dFwiLCBmdW5jdGlvbiAoKSB7XG4gICAgICBpZiAoIXRoaXMkMS5jb21wb3NpbmcpIHsgdGhpcyQxLnJlYWRGcm9tRE9NU29vbigpOyB9XG4gICAgfSk7XG5cbiAgICBmdW5jdGlvbiBvbkNvcHlDdXQoZSkge1xuICAgICAgaWYgKCFiZWxvbmdzVG9JbnB1dChlKSB8fCBzaWduYWxET01FdmVudChjbSwgZSkpIHsgcmV0dXJuIH1cbiAgICAgIGlmIChjbS5zb21ldGhpbmdTZWxlY3RlZCgpKSB7XG4gICAgICAgIHNldExhc3RDb3BpZWQoe2xpbmVXaXNlOiBmYWxzZSwgdGV4dDogY20uZ2V0U2VsZWN0aW9ucygpfSk7XG4gICAgICAgIGlmIChlLnR5cGUgPT0gXCJjdXRcIikgeyBjbS5yZXBsYWNlU2VsZWN0aW9uKFwiXCIsIG51bGwsIFwiY3V0XCIpOyB9XG4gICAgICB9IGVsc2UgaWYgKCFjbS5vcHRpb25zLmxpbmVXaXNlQ29weUN1dCkge1xuICAgICAgICByZXR1cm5cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHZhciByYW5nZXMgPSBjb3B5YWJsZVJhbmdlcyhjbSk7XG4gICAgICAgIHNldExhc3RDb3BpZWQoe2xpbmVXaXNlOiB0cnVlLCB0ZXh0OiByYW5nZXMudGV4dH0pO1xuICAgICAgICBpZiAoZS50eXBlID09IFwiY3V0XCIpIHtcbiAgICAgICAgICBjbS5vcGVyYXRpb24oZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgY20uc2V0U2VsZWN0aW9ucyhyYW5nZXMucmFuZ2VzLCAwLCBzZWxfZG9udFNjcm9sbCk7XG4gICAgICAgICAgICBjbS5yZXBsYWNlU2VsZWN0aW9uKFwiXCIsIG51bGwsIFwiY3V0XCIpO1xuICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBpZiAoZS5jbGlwYm9hcmREYXRhKSB7XG4gICAgICAgIGUuY2xpcGJvYXJkRGF0YS5jbGVhckRhdGEoKTtcbiAgICAgICAgdmFyIGNvbnRlbnQgPSBsYXN0Q29waWVkLnRleHQuam9pbihcIlxcblwiKTtcbiAgICAgICAgLy8gaU9TIGV4cG9zZXMgdGhlIGNsaXBib2FyZCBBUEksIGJ1dCBzZWVtcyB0byBkaXNjYXJkIGNvbnRlbnQgaW5zZXJ0ZWQgaW50byBpdFxuICAgICAgICBlLmNsaXBib2FyZERhdGEuc2V0RGF0YShcIlRleHRcIiwgY29udGVudCk7XG4gICAgICAgIGlmIChlLmNsaXBib2FyZERhdGEuZ2V0RGF0YShcIlRleHRcIikgPT0gY29udGVudCkge1xuICAgICAgICAgIGUucHJldmVudERlZmF1bHQoKTtcbiAgICAgICAgICByZXR1cm5cbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgLy8gT2xkLWZhc2hpb25lZCBicmllZmx5LWZvY3VzLWEtdGV4dGFyZWEgaGFja1xuICAgICAgdmFyIGtsdWRnZSA9IGhpZGRlblRleHRhcmVhKCksIHRlID0ga2x1ZGdlLmZpcnN0Q2hpbGQ7XG4gICAgICBjbS5kaXNwbGF5LmxpbmVTcGFjZS5pbnNlcnRCZWZvcmUoa2x1ZGdlLCBjbS5kaXNwbGF5LmxpbmVTcGFjZS5maXJzdENoaWxkKTtcbiAgICAgIHRlLnZhbHVlID0gbGFzdENvcGllZC50ZXh0LmpvaW4oXCJcXG5cIik7XG4gICAgICB2YXIgaGFkRm9jdXMgPSBhY3RpdmVFbHQoKTtcbiAgICAgIHNlbGVjdElucHV0KHRlKTtcbiAgICAgIHNldFRpbWVvdXQoZnVuY3Rpb24gKCkge1xuICAgICAgICBjbS5kaXNwbGF5LmxpbmVTcGFjZS5yZW1vdmVDaGlsZChrbHVkZ2UpO1xuICAgICAgICBoYWRGb2N1cy5mb2N1cygpO1xuICAgICAgICBpZiAoaGFkRm9jdXMgPT0gZGl2KSB7IGlucHV0LnNob3dQcmltYXJ5U2VsZWN0aW9uKCk7IH1cbiAgICAgIH0sIDUwKTtcbiAgICB9XG4gICAgb24oZGl2LCBcImNvcHlcIiwgb25Db3B5Q3V0KTtcbiAgICBvbihkaXYsIFwiY3V0XCIsIG9uQ29weUN1dCk7XG4gIH07XG5cbiAgQ29udGVudEVkaXRhYmxlSW5wdXQucHJvdG90eXBlLnNjcmVlblJlYWRlckxhYmVsQ2hhbmdlZCA9IGZ1bmN0aW9uIChsYWJlbCkge1xuICAgIC8vIExhYmVsIGZvciBzY3JlZW5yZWFkZXJzLCBhY2Nlc3NpYmlsaXR5XG4gICAgaWYobGFiZWwpIHtcbiAgICAgIHRoaXMuZGl2LnNldEF0dHJpYnV0ZSgnYXJpYS1sYWJlbCcsIGxhYmVsKTtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy5kaXYucmVtb3ZlQXR0cmlidXRlKCdhcmlhLWxhYmVsJyk7XG4gICAgfVxuICB9O1xuXG4gIENvbnRlbnRFZGl0YWJsZUlucHV0LnByb3RvdHlwZS5wcmVwYXJlU2VsZWN0aW9uID0gZnVuY3Rpb24gKCkge1xuICAgIHZhciByZXN1bHQgPSBwcmVwYXJlU2VsZWN0aW9uKHRoaXMuY20sIGZhbHNlKTtcbiAgICByZXN1bHQuZm9jdXMgPSBhY3RpdmVFbHQoKSA9PSB0aGlzLmRpdjtcbiAgICByZXR1cm4gcmVzdWx0XG4gIH07XG5cbiAgQ29udGVudEVkaXRhYmxlSW5wdXQucHJvdG90eXBlLnNob3dTZWxlY3Rpb24gPSBmdW5jdGlvbiAoaW5mbywgdGFrZUZvY3VzKSB7XG4gICAgaWYgKCFpbmZvIHx8ICF0aGlzLmNtLmRpc3BsYXkudmlldy5sZW5ndGgpIHsgcmV0dXJuIH1cbiAgICBpZiAoaW5mby5mb2N1cyB8fCB0YWtlRm9jdXMpIHsgdGhpcy5zaG93UHJpbWFyeVNlbGVjdGlvbigpOyB9XG4gICAgdGhpcy5zaG93TXVsdGlwbGVTZWxlY3Rpb25zKGluZm8pO1xuICB9O1xuXG4gIENvbnRlbnRFZGl0YWJsZUlucHV0LnByb3RvdHlwZS5nZXRTZWxlY3Rpb24gPSBmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIHRoaXMuY20uZGlzcGxheS53cmFwcGVyLm93bmVyRG9jdW1lbnQuZ2V0U2VsZWN0aW9uKClcbiAgfTtcblxuICBDb250ZW50RWRpdGFibGVJbnB1dC5wcm90b3R5cGUuc2hvd1ByaW1hcnlTZWxlY3Rpb24gPSBmdW5jdGlvbiAoKSB7XG4gICAgdmFyIHNlbCA9IHRoaXMuZ2V0U2VsZWN0aW9uKCksIGNtID0gdGhpcy5jbSwgcHJpbSA9IGNtLmRvYy5zZWwucHJpbWFyeSgpO1xuICAgIHZhciBmcm9tID0gcHJpbS5mcm9tKCksIHRvID0gcHJpbS50bygpO1xuXG4gICAgaWYgKGNtLmRpc3BsYXkudmlld1RvID09IGNtLmRpc3BsYXkudmlld0Zyb20gfHwgZnJvbS5saW5lID49IGNtLmRpc3BsYXkudmlld1RvIHx8IHRvLmxpbmUgPCBjbS5kaXNwbGF5LnZpZXdGcm9tKSB7XG4gICAgICBzZWwucmVtb3ZlQWxsUmFuZ2VzKCk7XG4gICAgICByZXR1cm5cbiAgICB9XG5cbiAgICB2YXIgY3VyQW5jaG9yID0gZG9tVG9Qb3MoY20sIHNlbC5hbmNob3JOb2RlLCBzZWwuYW5jaG9yT2Zmc2V0KTtcbiAgICB2YXIgY3VyRm9jdXMgPSBkb21Ub1BvcyhjbSwgc2VsLmZvY3VzTm9kZSwgc2VsLmZvY3VzT2Zmc2V0KTtcbiAgICBpZiAoY3VyQW5jaG9yICYmICFjdXJBbmNob3IuYmFkICYmIGN1ckZvY3VzICYmICFjdXJGb2N1cy5iYWQgJiZcbiAgICAgICAgY21wKG1pblBvcyhjdXJBbmNob3IsIGN1ckZvY3VzKSwgZnJvbSkgPT0gMCAmJlxuICAgICAgICBjbXAobWF4UG9zKGN1ckFuY2hvciwgY3VyRm9jdXMpLCB0bykgPT0gMClcbiAgICAgIHsgcmV0dXJuIH1cblxuICAgIHZhciB2aWV3ID0gY20uZGlzcGxheS52aWV3O1xuICAgIHZhciBzdGFydCA9IChmcm9tLmxpbmUgPj0gY20uZGlzcGxheS52aWV3RnJvbSAmJiBwb3NUb0RPTShjbSwgZnJvbSkpIHx8XG4gICAgICAgIHtub2RlOiB2aWV3WzBdLm1lYXN1cmUubWFwWzJdLCBvZmZzZXQ6IDB9O1xuICAgIHZhciBlbmQgPSB0by5saW5lIDwgY20uZGlzcGxheS52aWV3VG8gJiYgcG9zVG9ET00oY20sIHRvKTtcbiAgICBpZiAoIWVuZCkge1xuICAgICAgdmFyIG1lYXN1cmUgPSB2aWV3W3ZpZXcubGVuZ3RoIC0gMV0ubWVhc3VyZTtcbiAgICAgIHZhciBtYXAgPSBtZWFzdXJlLm1hcHMgPyBtZWFzdXJlLm1hcHNbbWVhc3VyZS5tYXBzLmxlbmd0aCAtIDFdIDogbWVhc3VyZS5tYXA7XG4gICAgICBlbmQgPSB7bm9kZTogbWFwW21hcC5sZW5ndGggLSAxXSwgb2Zmc2V0OiBtYXBbbWFwLmxlbmd0aCAtIDJdIC0gbWFwW21hcC5sZW5ndGggLSAzXX07XG4gICAgfVxuXG4gICAgaWYgKCFzdGFydCB8fCAhZW5kKSB7XG4gICAgICBzZWwucmVtb3ZlQWxsUmFuZ2VzKCk7XG4gICAgICByZXR1cm5cbiAgICB9XG5cbiAgICB2YXIgb2xkID0gc2VsLnJhbmdlQ291bnQgJiYgc2VsLmdldFJhbmdlQXQoMCksIHJuZztcbiAgICB0cnkgeyBybmcgPSByYW5nZShzdGFydC5ub2RlLCBzdGFydC5vZmZzZXQsIGVuZC5vZmZzZXQsIGVuZC5ub2RlKTsgfVxuICAgIGNhdGNoKGUpIHt9IC8vIE91ciBtb2RlbCBvZiB0aGUgRE9NIG1pZ2h0IGJlIG91dGRhdGVkLCBpbiB3aGljaCBjYXNlIHRoZSByYW5nZSB3ZSB0cnkgdG8gc2V0IGNhbiBiZSBpbXBvc3NpYmxlXG4gICAgaWYgKHJuZykge1xuICAgICAgaWYgKCFnZWNrbyAmJiBjbS5zdGF0ZS5mb2N1c2VkKSB7XG4gICAgICAgIHNlbC5jb2xsYXBzZShzdGFydC5ub2RlLCBzdGFydC5vZmZzZXQpO1xuICAgICAgICBpZiAoIXJuZy5jb2xsYXBzZWQpIHtcbiAgICAgICAgICBzZWwucmVtb3ZlQWxsUmFuZ2VzKCk7XG4gICAgICAgICAgc2VsLmFkZFJhbmdlKHJuZyk7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHNlbC5yZW1vdmVBbGxSYW5nZXMoKTtcbiAgICAgICAgc2VsLmFkZFJhbmdlKHJuZyk7XG4gICAgICB9XG4gICAgICBpZiAob2xkICYmIHNlbC5hbmNob3JOb2RlID09IG51bGwpIHsgc2VsLmFkZFJhbmdlKG9sZCk7IH1cbiAgICAgIGVsc2UgaWYgKGdlY2tvKSB7IHRoaXMuc3RhcnRHcmFjZVBlcmlvZCgpOyB9XG4gICAgfVxuICAgIHRoaXMucmVtZW1iZXJTZWxlY3Rpb24oKTtcbiAgfTtcblxuICBDb250ZW50RWRpdGFibGVJbnB1dC5wcm90b3R5cGUuc3RhcnRHcmFjZVBlcmlvZCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgIHZhciB0aGlzJDEgPSB0aGlzO1xuXG4gICAgY2xlYXJUaW1lb3V0KHRoaXMuZ3JhY2VQZXJpb2QpO1xuICAgIHRoaXMuZ3JhY2VQZXJpb2QgPSBzZXRUaW1lb3V0KGZ1bmN0aW9uICgpIHtcbiAgICAgIHRoaXMkMS5ncmFjZVBlcmlvZCA9IGZhbHNlO1xuICAgICAgaWYgKHRoaXMkMS5zZWxlY3Rpb25DaGFuZ2VkKCkpXG4gICAgICAgIHsgdGhpcyQxLmNtLm9wZXJhdGlvbihmdW5jdGlvbiAoKSB7IHJldHVybiB0aGlzJDEuY20uY3VyT3Auc2VsZWN0aW9uQ2hhbmdlZCA9IHRydWU7IH0pOyB9XG4gICAgfSwgMjApO1xuICB9O1xuXG4gIENvbnRlbnRFZGl0YWJsZUlucHV0LnByb3RvdHlwZS5zaG93TXVsdGlwbGVTZWxlY3Rpb25zID0gZnVuY3Rpb24gKGluZm8pIHtcbiAgICByZW1vdmVDaGlsZHJlbkFuZEFkZCh0aGlzLmNtLmRpc3BsYXkuY3Vyc29yRGl2LCBpbmZvLmN1cnNvcnMpO1xuICAgIHJlbW92ZUNoaWxkcmVuQW5kQWRkKHRoaXMuY20uZGlzcGxheS5zZWxlY3Rpb25EaXYsIGluZm8uc2VsZWN0aW9uKTtcbiAgfTtcblxuICBDb250ZW50RWRpdGFibGVJbnB1dC5wcm90b3R5cGUucmVtZW1iZXJTZWxlY3Rpb24gPSBmdW5jdGlvbiAoKSB7XG4gICAgdmFyIHNlbCA9IHRoaXMuZ2V0U2VsZWN0aW9uKCk7XG4gICAgdGhpcy5sYXN0QW5jaG9yTm9kZSA9IHNlbC5hbmNob3JOb2RlOyB0aGlzLmxhc3RBbmNob3JPZmZzZXQgPSBzZWwuYW5jaG9yT2Zmc2V0O1xuICAgIHRoaXMubGFzdEZvY3VzTm9kZSA9IHNlbC5mb2N1c05vZGU7IHRoaXMubGFzdEZvY3VzT2Zmc2V0ID0gc2VsLmZvY3VzT2Zmc2V0O1xuICB9O1xuXG4gIENvbnRlbnRFZGl0YWJsZUlucHV0LnByb3RvdHlwZS5zZWxlY3Rpb25JbkVkaXRvciA9IGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgc2VsID0gdGhpcy5nZXRTZWxlY3Rpb24oKTtcbiAgICBpZiAoIXNlbC5yYW5nZUNvdW50KSB7IHJldHVybiBmYWxzZSB9XG4gICAgdmFyIG5vZGUgPSBzZWwuZ2V0UmFuZ2VBdCgwKS5jb21tb25BbmNlc3RvckNvbnRhaW5lcjtcbiAgICByZXR1cm4gY29udGFpbnModGhpcy5kaXYsIG5vZGUpXG4gIH07XG5cbiAgQ29udGVudEVkaXRhYmxlSW5wdXQucHJvdG90eXBlLmZvY3VzID0gZnVuY3Rpb24gKCkge1xuICAgIGlmICh0aGlzLmNtLm9wdGlvbnMucmVhZE9ubHkgIT0gXCJub2N1cnNvclwiKSB7XG4gICAgICBpZiAoIXRoaXMuc2VsZWN0aW9uSW5FZGl0b3IoKSB8fCBhY3RpdmVFbHQoKSAhPSB0aGlzLmRpdilcbiAgICAgICAgeyB0aGlzLnNob3dTZWxlY3Rpb24odGhpcy5wcmVwYXJlU2VsZWN0aW9uKCksIHRydWUpOyB9XG4gICAgICB0aGlzLmRpdi5mb2N1cygpO1xuICAgIH1cbiAgfTtcbiAgQ29udGVudEVkaXRhYmxlSW5wdXQucHJvdG90eXBlLmJsdXIgPSBmdW5jdGlvbiAoKSB7IHRoaXMuZGl2LmJsdXIoKTsgfTtcbiAgQ29udGVudEVkaXRhYmxlSW5wdXQucHJvdG90eXBlLmdldEZpZWxkID0gZnVuY3Rpb24gKCkgeyByZXR1cm4gdGhpcy5kaXYgfTtcblxuICBDb250ZW50RWRpdGFibGVJbnB1dC5wcm90b3R5cGUuc3VwcG9ydHNUb3VjaCA9IGZ1bmN0aW9uICgpIHsgcmV0dXJuIHRydWUgfTtcblxuICBDb250ZW50RWRpdGFibGVJbnB1dC5wcm90b3R5cGUucmVjZWl2ZWRGb2N1cyA9IGZ1bmN0aW9uICgpIHtcbiAgICAgIHZhciB0aGlzJDEgPSB0aGlzO1xuXG4gICAgdmFyIGlucHV0ID0gdGhpcztcbiAgICBpZiAodGhpcy5zZWxlY3Rpb25JbkVkaXRvcigpKVxuICAgICAgeyBzZXRUaW1lb3V0KGZ1bmN0aW9uICgpIHsgcmV0dXJuIHRoaXMkMS5wb2xsU2VsZWN0aW9uKCk7IH0sIDIwKTsgfVxuICAgIGVsc2VcbiAgICAgIHsgcnVuSW5PcCh0aGlzLmNtLCBmdW5jdGlvbiAoKSB7IHJldHVybiBpbnB1dC5jbS5jdXJPcC5zZWxlY3Rpb25DaGFuZ2VkID0gdHJ1ZTsgfSk7IH1cblxuICAgIGZ1bmN0aW9uIHBvbGwoKSB7XG4gICAgICBpZiAoaW5wdXQuY20uc3RhdGUuZm9jdXNlZCkge1xuICAgICAgICBpbnB1dC5wb2xsU2VsZWN0aW9uKCk7XG4gICAgICAgIGlucHV0LnBvbGxpbmcuc2V0KGlucHV0LmNtLm9wdGlvbnMucG9sbEludGVydmFsLCBwb2xsKTtcbiAgICAgIH1cbiAgICB9XG4gICAgdGhpcy5wb2xsaW5nLnNldCh0aGlzLmNtLm9wdGlvbnMucG9sbEludGVydmFsLCBwb2xsKTtcbiAgfTtcblxuICBDb250ZW50RWRpdGFibGVJbnB1dC5wcm90b3R5cGUuc2VsZWN0aW9uQ2hhbmdlZCA9IGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgc2VsID0gdGhpcy5nZXRTZWxlY3Rpb24oKTtcbiAgICByZXR1cm4gc2VsLmFuY2hvck5vZGUgIT0gdGhpcy5sYXN0QW5jaG9yTm9kZSB8fCBzZWwuYW5jaG9yT2Zmc2V0ICE9IHRoaXMubGFzdEFuY2hvck9mZnNldCB8fFxuICAgICAgc2VsLmZvY3VzTm9kZSAhPSB0aGlzLmxhc3RGb2N1c05vZGUgfHwgc2VsLmZvY3VzT2Zmc2V0ICE9IHRoaXMubGFzdEZvY3VzT2Zmc2V0XG4gIH07XG5cbiAgQ29udGVudEVkaXRhYmxlSW5wdXQucHJvdG90eXBlLnBvbGxTZWxlY3Rpb24gPSBmdW5jdGlvbiAoKSB7XG4gICAgaWYgKHRoaXMucmVhZERPTVRpbWVvdXQgIT0gbnVsbCB8fCB0aGlzLmdyYWNlUGVyaW9kIHx8ICF0aGlzLnNlbGVjdGlvbkNoYW5nZWQoKSkgeyByZXR1cm4gfVxuICAgIHZhciBzZWwgPSB0aGlzLmdldFNlbGVjdGlvbigpLCBjbSA9IHRoaXMuY207XG4gICAgLy8gT24gQW5kcm9pZCBDaHJvbWUgKHZlcnNpb24gNTYsIGF0IGxlYXN0KSwgYmFja3NwYWNpbmcgaW50byBhblxuICAgIC8vIHVuZWRpdGFibGUgYmxvY2sgZWxlbWVudCB3aWxsIHB1dCB0aGUgY3Vyc29yIGluIHRoYXQgZWxlbWVudCxcbiAgICAvLyBhbmQgdGhlbiwgYmVjYXVzZSBpdCdzIG5vdCBlZGl0YWJsZSwgaGlkZSB0aGUgdmlydHVhbCBrZXlib2FyZC5cbiAgICAvLyBCZWNhdXNlIEFuZHJvaWQgZG9lc24ndCBhbGxvdyB1cyB0byBhY3R1YWxseSBkZXRlY3QgYmFja3NwYWNlXG4gICAgLy8gcHJlc3NlcyBpbiBhIHNhbmUgd2F5LCB0aGlzIGNvZGUgY2hlY2tzIGZvciB3aGVuIHRoYXQgaGFwcGVuc1xuICAgIC8vIGFuZCBzaW11bGF0ZXMgYSBiYWNrc3BhY2UgcHJlc3MgaW4gdGhpcyBjYXNlLlxuICAgIGlmIChhbmRyb2lkICYmIGNocm9tZSAmJiB0aGlzLmNtLmRpc3BsYXkuZ3V0dGVyU3BlY3MubGVuZ3RoICYmIGlzSW5HdXR0ZXIoc2VsLmFuY2hvck5vZGUpKSB7XG4gICAgICB0aGlzLmNtLnRyaWdnZXJPbktleURvd24oe3R5cGU6IFwia2V5ZG93blwiLCBrZXlDb2RlOiA4LCBwcmV2ZW50RGVmYXVsdDogTWF0aC5hYnN9KTtcbiAgICAgIHRoaXMuYmx1cigpO1xuICAgICAgdGhpcy5mb2N1cygpO1xuICAgICAgcmV0dXJuXG4gICAgfVxuICAgIGlmICh0aGlzLmNvbXBvc2luZykgeyByZXR1cm4gfVxuICAgIHRoaXMucmVtZW1iZXJTZWxlY3Rpb24oKTtcbiAgICB2YXIgYW5jaG9yID0gZG9tVG9Qb3MoY20sIHNlbC5hbmNob3JOb2RlLCBzZWwuYW5jaG9yT2Zmc2V0KTtcbiAgICB2YXIgaGVhZCA9IGRvbVRvUG9zKGNtLCBzZWwuZm9jdXNOb2RlLCBzZWwuZm9jdXNPZmZzZXQpO1xuICAgIGlmIChhbmNob3IgJiYgaGVhZCkgeyBydW5Jbk9wKGNtLCBmdW5jdGlvbiAoKSB7XG4gICAgICBzZXRTZWxlY3Rpb24oY20uZG9jLCBzaW1wbGVTZWxlY3Rpb24oYW5jaG9yLCBoZWFkKSwgc2VsX2RvbnRTY3JvbGwpO1xuICAgICAgaWYgKGFuY2hvci5iYWQgfHwgaGVhZC5iYWQpIHsgY20uY3VyT3Auc2VsZWN0aW9uQ2hhbmdlZCA9IHRydWU7IH1cbiAgICB9KTsgfVxuICB9O1xuXG4gIENvbnRlbnRFZGl0YWJsZUlucHV0LnByb3RvdHlwZS5wb2xsQ29udGVudCA9IGZ1bmN0aW9uICgpIHtcbiAgICBpZiAodGhpcy5yZWFkRE9NVGltZW91dCAhPSBudWxsKSB7XG4gICAgICBjbGVhclRpbWVvdXQodGhpcy5yZWFkRE9NVGltZW91dCk7XG4gICAgICB0aGlzLnJlYWRET01UaW1lb3V0ID0gbnVsbDtcbiAgICB9XG5cbiAgICB2YXIgY20gPSB0aGlzLmNtLCBkaXNwbGF5ID0gY20uZGlzcGxheSwgc2VsID0gY20uZG9jLnNlbC5wcmltYXJ5KCk7XG4gICAgdmFyIGZyb20gPSBzZWwuZnJvbSgpLCB0byA9IHNlbC50bygpO1xuICAgIGlmIChmcm9tLmNoID09IDAgJiYgZnJvbS5saW5lID4gY20uZmlyc3RMaW5lKCkpXG4gICAgICB7IGZyb20gPSBQb3MoZnJvbS5saW5lIC0gMSwgZ2V0TGluZShjbS5kb2MsIGZyb20ubGluZSAtIDEpLmxlbmd0aCk7IH1cbiAgICBpZiAodG8uY2ggPT0gZ2V0TGluZShjbS5kb2MsIHRvLmxpbmUpLnRleHQubGVuZ3RoICYmIHRvLmxpbmUgPCBjbS5sYXN0TGluZSgpKVxuICAgICAgeyB0byA9IFBvcyh0by5saW5lICsgMSwgMCk7IH1cbiAgICBpZiAoZnJvbS5saW5lIDwgZGlzcGxheS52aWV3RnJvbSB8fCB0by5saW5lID4gZGlzcGxheS52aWV3VG8gLSAxKSB7IHJldHVybiBmYWxzZSB9XG5cbiAgICB2YXIgZnJvbUluZGV4LCBmcm9tTGluZSwgZnJvbU5vZGU7XG4gICAgaWYgKGZyb20ubGluZSA9PSBkaXNwbGF5LnZpZXdGcm9tIHx8IChmcm9tSW5kZXggPSBmaW5kVmlld0luZGV4KGNtLCBmcm9tLmxpbmUpKSA9PSAwKSB7XG4gICAgICBmcm9tTGluZSA9IGxpbmVObyhkaXNwbGF5LnZpZXdbMF0ubGluZSk7XG4gICAgICBmcm9tTm9kZSA9IGRpc3BsYXkudmlld1swXS5ub2RlO1xuICAgIH0gZWxzZSB7XG4gICAgICBmcm9tTGluZSA9IGxpbmVObyhkaXNwbGF5LnZpZXdbZnJvbUluZGV4XS5saW5lKTtcbiAgICAgIGZyb21Ob2RlID0gZGlzcGxheS52aWV3W2Zyb21JbmRleCAtIDFdLm5vZGUubmV4dFNpYmxpbmc7XG4gICAgfVxuICAgIHZhciB0b0luZGV4ID0gZmluZFZpZXdJbmRleChjbSwgdG8ubGluZSk7XG4gICAgdmFyIHRvTGluZSwgdG9Ob2RlO1xuICAgIGlmICh0b0luZGV4ID09IGRpc3BsYXkudmlldy5sZW5ndGggLSAxKSB7XG4gICAgICB0b0xpbmUgPSBkaXNwbGF5LnZpZXdUbyAtIDE7XG4gICAgICB0b05vZGUgPSBkaXNwbGF5LmxpbmVEaXYubGFzdENoaWxkO1xuICAgIH0gZWxzZSB7XG4gICAgICB0b0xpbmUgPSBsaW5lTm8oZGlzcGxheS52aWV3W3RvSW5kZXggKyAxXS5saW5lKSAtIDE7XG4gICAgICB0b05vZGUgPSBkaXNwbGF5LnZpZXdbdG9JbmRleCArIDFdLm5vZGUucHJldmlvdXNTaWJsaW5nO1xuICAgIH1cblxuICAgIGlmICghZnJvbU5vZGUpIHsgcmV0dXJuIGZhbHNlIH1cbiAgICB2YXIgbmV3VGV4dCA9IGNtLmRvYy5zcGxpdExpbmVzKGRvbVRleHRCZXR3ZWVuKGNtLCBmcm9tTm9kZSwgdG9Ob2RlLCBmcm9tTGluZSwgdG9MaW5lKSk7XG4gICAgdmFyIG9sZFRleHQgPSBnZXRCZXR3ZWVuKGNtLmRvYywgUG9zKGZyb21MaW5lLCAwKSwgUG9zKHRvTGluZSwgZ2V0TGluZShjbS5kb2MsIHRvTGluZSkudGV4dC5sZW5ndGgpKTtcbiAgICB3aGlsZSAobmV3VGV4dC5sZW5ndGggPiAxICYmIG9sZFRleHQubGVuZ3RoID4gMSkge1xuICAgICAgaWYgKGxzdChuZXdUZXh0KSA9PSBsc3Qob2xkVGV4dCkpIHsgbmV3VGV4dC5wb3AoKTsgb2xkVGV4dC5wb3AoKTsgdG9MaW5lLS07IH1cbiAgICAgIGVsc2UgaWYgKG5ld1RleHRbMF0gPT0gb2xkVGV4dFswXSkgeyBuZXdUZXh0LnNoaWZ0KCk7IG9sZFRleHQuc2hpZnQoKTsgZnJvbUxpbmUrKzsgfVxuICAgICAgZWxzZSB7IGJyZWFrIH1cbiAgICB9XG5cbiAgICB2YXIgY3V0RnJvbnQgPSAwLCBjdXRFbmQgPSAwO1xuICAgIHZhciBuZXdUb3AgPSBuZXdUZXh0WzBdLCBvbGRUb3AgPSBvbGRUZXh0WzBdLCBtYXhDdXRGcm9udCA9IE1hdGgubWluKG5ld1RvcC5sZW5ndGgsIG9sZFRvcC5sZW5ndGgpO1xuICAgIHdoaWxlIChjdXRGcm9udCA8IG1heEN1dEZyb250ICYmIG5ld1RvcC5jaGFyQ29kZUF0KGN1dEZyb250KSA9PSBvbGRUb3AuY2hhckNvZGVBdChjdXRGcm9udCkpXG4gICAgICB7ICsrY3V0RnJvbnQ7IH1cbiAgICB2YXIgbmV3Qm90ID0gbHN0KG5ld1RleHQpLCBvbGRCb3QgPSBsc3Qob2xkVGV4dCk7XG4gICAgdmFyIG1heEN1dEVuZCA9IE1hdGgubWluKG5ld0JvdC5sZW5ndGggLSAobmV3VGV4dC5sZW5ndGggPT0gMSA/IGN1dEZyb250IDogMCksXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgIG9sZEJvdC5sZW5ndGggLSAob2xkVGV4dC5sZW5ndGggPT0gMSA/IGN1dEZyb250IDogMCkpO1xuICAgIHdoaWxlIChjdXRFbmQgPCBtYXhDdXRFbmQgJiZcbiAgICAgICAgICAgbmV3Qm90LmNoYXJDb2RlQXQobmV3Qm90Lmxlbmd0aCAtIGN1dEVuZCAtIDEpID09IG9sZEJvdC5jaGFyQ29kZUF0KG9sZEJvdC5sZW5ndGggLSBjdXRFbmQgLSAxKSlcbiAgICAgIHsgKytjdXRFbmQ7IH1cbiAgICAvLyBUcnkgdG8gbW92ZSBzdGFydCBvZiBjaGFuZ2UgdG8gc3RhcnQgb2Ygc2VsZWN0aW9uIGlmIGFtYmlndW91c1xuICAgIGlmIChuZXdUZXh0Lmxlbmd0aCA9PSAxICYmIG9sZFRleHQubGVuZ3RoID09IDEgJiYgZnJvbUxpbmUgPT0gZnJvbS5saW5lKSB7XG4gICAgICB3aGlsZSAoY3V0RnJvbnQgJiYgY3V0RnJvbnQgPiBmcm9tLmNoICYmXG4gICAgICAgICAgICAgbmV3Qm90LmNoYXJDb2RlQXQobmV3Qm90Lmxlbmd0aCAtIGN1dEVuZCAtIDEpID09IG9sZEJvdC5jaGFyQ29kZUF0KG9sZEJvdC5sZW5ndGggLSBjdXRFbmQgLSAxKSkge1xuICAgICAgICBjdXRGcm9udC0tO1xuICAgICAgICBjdXRFbmQrKztcbiAgICAgIH1cbiAgICB9XG5cbiAgICBuZXdUZXh0W25ld1RleHQubGVuZ3RoIC0gMV0gPSBuZXdCb3Quc2xpY2UoMCwgbmV3Qm90Lmxlbmd0aCAtIGN1dEVuZCkucmVwbGFjZSgvXlxcdTIwMGIrLywgXCJcIik7XG4gICAgbmV3VGV4dFswXSA9IG5ld1RleHRbMF0uc2xpY2UoY3V0RnJvbnQpLnJlcGxhY2UoL1xcdTIwMGIrJC8sIFwiXCIpO1xuXG4gICAgdmFyIGNoRnJvbSA9IFBvcyhmcm9tTGluZSwgY3V0RnJvbnQpO1xuICAgIHZhciBjaFRvID0gUG9zKHRvTGluZSwgb2xkVGV4dC5sZW5ndGggPyBsc3Qob2xkVGV4dCkubGVuZ3RoIC0gY3V0RW5kIDogMCk7XG4gICAgaWYgKG5ld1RleHQubGVuZ3RoID4gMSB8fCBuZXdUZXh0WzBdIHx8IGNtcChjaEZyb20sIGNoVG8pKSB7XG4gICAgICByZXBsYWNlUmFuZ2UoY20uZG9jLCBuZXdUZXh0LCBjaEZyb20sIGNoVG8sIFwiK2lucHV0XCIpO1xuICAgICAgcmV0dXJuIHRydWVcbiAgICB9XG4gIH07XG5cbiAgQ29udGVudEVkaXRhYmxlSW5wdXQucHJvdG90eXBlLmVuc3VyZVBvbGxlZCA9IGZ1bmN0aW9uICgpIHtcbiAgICB0aGlzLmZvcmNlQ29tcG9zaXRpb25FbmQoKTtcbiAgfTtcbiAgQ29udGVudEVkaXRhYmxlSW5wdXQucHJvdG90eXBlLnJlc2V0ID0gZnVuY3Rpb24gKCkge1xuICAgIHRoaXMuZm9yY2VDb21wb3NpdGlvbkVuZCgpO1xuICB9O1xuICBDb250ZW50RWRpdGFibGVJbnB1dC5wcm90b3R5cGUuZm9yY2VDb21wb3NpdGlvbkVuZCA9IGZ1bmN0aW9uICgpIHtcbiAgICBpZiAoIXRoaXMuY29tcG9zaW5nKSB7IHJldHVybiB9XG4gICAgY2xlYXJUaW1lb3V0KHRoaXMucmVhZERPTVRpbWVvdXQpO1xuICAgIHRoaXMuY29tcG9zaW5nID0gbnVsbDtcbiAgICB0aGlzLnVwZGF0ZUZyb21ET00oKTtcbiAgICB0aGlzLmRpdi5ibHVyKCk7XG4gICAgdGhpcy5kaXYuZm9jdXMoKTtcbiAgfTtcbiAgQ29udGVudEVkaXRhYmxlSW5wdXQucHJvdG90eXBlLnJlYWRGcm9tRE9NU29vbiA9IGZ1bmN0aW9uICgpIHtcbiAgICAgIHZhciB0aGlzJDEgPSB0aGlzO1xuXG4gICAgaWYgKHRoaXMucmVhZERPTVRpbWVvdXQgIT0gbnVsbCkgeyByZXR1cm4gfVxuICAgIHRoaXMucmVhZERPTVRpbWVvdXQgPSBzZXRUaW1lb3V0KGZ1bmN0aW9uICgpIHtcbiAgICAgIHRoaXMkMS5yZWFkRE9NVGltZW91dCA9IG51bGw7XG4gICAgICBpZiAodGhpcyQxLmNvbXBvc2luZykge1xuICAgICAgICBpZiAodGhpcyQxLmNvbXBvc2luZy5kb25lKSB7IHRoaXMkMS5jb21wb3NpbmcgPSBudWxsOyB9XG4gICAgICAgIGVsc2UgeyByZXR1cm4gfVxuICAgICAgfVxuICAgICAgdGhpcyQxLnVwZGF0ZUZyb21ET00oKTtcbiAgICB9LCA4MCk7XG4gIH07XG5cbiAgQ29udGVudEVkaXRhYmxlSW5wdXQucHJvdG90eXBlLnVwZGF0ZUZyb21ET00gPSBmdW5jdGlvbiAoKSB7XG4gICAgICB2YXIgdGhpcyQxID0gdGhpcztcblxuICAgIGlmICh0aGlzLmNtLmlzUmVhZE9ubHkoKSB8fCAhdGhpcy5wb2xsQ29udGVudCgpKVxuICAgICAgeyBydW5Jbk9wKHRoaXMuY20sIGZ1bmN0aW9uICgpIHsgcmV0dXJuIHJlZ0NoYW5nZSh0aGlzJDEuY20pOyB9KTsgfVxuICB9O1xuXG4gIENvbnRlbnRFZGl0YWJsZUlucHV0LnByb3RvdHlwZS5zZXRVbmVkaXRhYmxlID0gZnVuY3Rpb24gKG5vZGUpIHtcbiAgICBub2RlLmNvbnRlbnRFZGl0YWJsZSA9IFwiZmFsc2VcIjtcbiAgfTtcblxuICBDb250ZW50RWRpdGFibGVJbnB1dC5wcm90b3R5cGUub25LZXlQcmVzcyA9IGZ1bmN0aW9uIChlKSB7XG4gICAgaWYgKGUuY2hhckNvZGUgPT0gMCB8fCB0aGlzLmNvbXBvc2luZykgeyByZXR1cm4gfVxuICAgIGUucHJldmVudERlZmF1bHQoKTtcbiAgICBpZiAoIXRoaXMuY20uaXNSZWFkT25seSgpKVxuICAgICAgeyBvcGVyYXRpb24odGhpcy5jbSwgYXBwbHlUZXh0SW5wdXQpKHRoaXMuY20sIFN0cmluZy5mcm9tQ2hhckNvZGUoZS5jaGFyQ29kZSA9PSBudWxsID8gZS5rZXlDb2RlIDogZS5jaGFyQ29kZSksIDApOyB9XG4gIH07XG5cbiAgQ29udGVudEVkaXRhYmxlSW5wdXQucHJvdG90eXBlLnJlYWRPbmx5Q2hhbmdlZCA9IGZ1bmN0aW9uICh2YWwpIHtcbiAgICB0aGlzLmRpdi5jb250ZW50RWRpdGFibGUgPSBTdHJpbmcodmFsICE9IFwibm9jdXJzb3JcIik7XG4gIH07XG5cbiAgQ29udGVudEVkaXRhYmxlSW5wdXQucHJvdG90eXBlLm9uQ29udGV4dE1lbnUgPSBmdW5jdGlvbiAoKSB7fTtcbiAgQ29udGVudEVkaXRhYmxlSW5wdXQucHJvdG90eXBlLnJlc2V0UG9zaXRpb24gPSBmdW5jdGlvbiAoKSB7fTtcblxuICBDb250ZW50RWRpdGFibGVJbnB1dC5wcm90b3R5cGUubmVlZHNDb250ZW50QXR0cmlidXRlID0gdHJ1ZTtcblxuICBmdW5jdGlvbiBwb3NUb0RPTShjbSwgcG9zKSB7XG4gICAgdmFyIHZpZXcgPSBmaW5kVmlld0ZvckxpbmUoY20sIHBvcy5saW5lKTtcbiAgICBpZiAoIXZpZXcgfHwgdmlldy5oaWRkZW4pIHsgcmV0dXJuIG51bGwgfVxuICAgIHZhciBsaW5lID0gZ2V0TGluZShjbS5kb2MsIHBvcy5saW5lKTtcbiAgICB2YXIgaW5mbyA9IG1hcEZyb21MaW5lVmlldyh2aWV3LCBsaW5lLCBwb3MubGluZSk7XG5cbiAgICB2YXIgb3JkZXIgPSBnZXRPcmRlcihsaW5lLCBjbS5kb2MuZGlyZWN0aW9uKSwgc2lkZSA9IFwibGVmdFwiO1xuICAgIGlmIChvcmRlcikge1xuICAgICAgdmFyIHBhcnRQb3MgPSBnZXRCaWRpUGFydEF0KG9yZGVyLCBwb3MuY2gpO1xuICAgICAgc2lkZSA9IHBhcnRQb3MgJSAyID8gXCJyaWdodFwiIDogXCJsZWZ0XCI7XG4gICAgfVxuICAgIHZhciByZXN1bHQgPSBub2RlQW5kT2Zmc2V0SW5MaW5lTWFwKGluZm8ubWFwLCBwb3MuY2gsIHNpZGUpO1xuICAgIHJlc3VsdC5vZmZzZXQgPSByZXN1bHQuY29sbGFwc2UgPT0gXCJyaWdodFwiID8gcmVzdWx0LmVuZCA6IHJlc3VsdC5zdGFydDtcbiAgICByZXR1cm4gcmVzdWx0XG4gIH1cblxuICBmdW5jdGlvbiBpc0luR3V0dGVyKG5vZGUpIHtcbiAgICBmb3IgKHZhciBzY2FuID0gbm9kZTsgc2Nhbjsgc2NhbiA9IHNjYW4ucGFyZW50Tm9kZSlcbiAgICAgIHsgaWYgKC9Db2RlTWlycm9yLWd1dHRlci13cmFwcGVyLy50ZXN0KHNjYW4uY2xhc3NOYW1lKSkgeyByZXR1cm4gdHJ1ZSB9IH1cbiAgICByZXR1cm4gZmFsc2VcbiAgfVxuXG4gIGZ1bmN0aW9uIGJhZFBvcyhwb3MsIGJhZCkgeyBpZiAoYmFkKSB7IHBvcy5iYWQgPSB0cnVlOyB9IHJldHVybiBwb3MgfVxuXG4gIGZ1bmN0aW9uIGRvbVRleHRCZXR3ZWVuKGNtLCBmcm9tLCB0bywgZnJvbUxpbmUsIHRvTGluZSkge1xuICAgIHZhciB0ZXh0ID0gXCJcIiwgY2xvc2luZyA9IGZhbHNlLCBsaW5lU2VwID0gY20uZG9jLmxpbmVTZXBhcmF0b3IoKSwgZXh0cmFMaW5lYnJlYWsgPSBmYWxzZTtcbiAgICBmdW5jdGlvbiByZWNvZ25pemVNYXJrZXIoaWQpIHsgcmV0dXJuIGZ1bmN0aW9uIChtYXJrZXIpIHsgcmV0dXJuIG1hcmtlci5pZCA9PSBpZDsgfSB9XG4gICAgZnVuY3Rpb24gY2xvc2UoKSB7XG4gICAgICBpZiAoY2xvc2luZykge1xuICAgICAgICB0ZXh0ICs9IGxpbmVTZXA7XG4gICAgICAgIGlmIChleHRyYUxpbmVicmVhaykgeyB0ZXh0ICs9IGxpbmVTZXA7IH1cbiAgICAgICAgY2xvc2luZyA9IGV4dHJhTGluZWJyZWFrID0gZmFsc2U7XG4gICAgICB9XG4gICAgfVxuICAgIGZ1bmN0aW9uIGFkZFRleHQoc3RyKSB7XG4gICAgICBpZiAoc3RyKSB7XG4gICAgICAgIGNsb3NlKCk7XG4gICAgICAgIHRleHQgKz0gc3RyO1xuICAgICAgfVxuICAgIH1cbiAgICBmdW5jdGlvbiB3YWxrKG5vZGUpIHtcbiAgICAgIGlmIChub2RlLm5vZGVUeXBlID09IDEpIHtcbiAgICAgICAgdmFyIGNtVGV4dCA9IG5vZGUuZ2V0QXR0cmlidXRlKFwiY20tdGV4dFwiKTtcbiAgICAgICAgaWYgKGNtVGV4dCkge1xuICAgICAgICAgIGFkZFRleHQoY21UZXh0KTtcbiAgICAgICAgICByZXR1cm5cbiAgICAgICAgfVxuICAgICAgICB2YXIgbWFya2VySUQgPSBub2RlLmdldEF0dHJpYnV0ZShcImNtLW1hcmtlclwiKSwgcmFuZ2U7XG4gICAgICAgIGlmIChtYXJrZXJJRCkge1xuICAgICAgICAgIHZhciBmb3VuZCA9IGNtLmZpbmRNYXJrcyhQb3MoZnJvbUxpbmUsIDApLCBQb3ModG9MaW5lICsgMSwgMCksIHJlY29nbml6ZU1hcmtlcigrbWFya2VySUQpKTtcbiAgICAgICAgICBpZiAoZm91bmQubGVuZ3RoICYmIChyYW5nZSA9IGZvdW5kWzBdLmZpbmQoMCkpKVxuICAgICAgICAgICAgeyBhZGRUZXh0KGdldEJldHdlZW4oY20uZG9jLCByYW5nZS5mcm9tLCByYW5nZS50bykuam9pbihsaW5lU2VwKSk7IH1cbiAgICAgICAgICByZXR1cm5cbiAgICAgICAgfVxuICAgICAgICBpZiAobm9kZS5nZXRBdHRyaWJ1dGUoXCJjb250ZW50ZWRpdGFibGVcIikgPT0gXCJmYWxzZVwiKSB7IHJldHVybiB9XG4gICAgICAgIHZhciBpc0Jsb2NrID0gL14ocHJlfGRpdnxwfGxpfHRhYmxlfGJyKSQvaS50ZXN0KG5vZGUubm9kZU5hbWUpO1xuICAgICAgICBpZiAoIS9eYnIkL2kudGVzdChub2RlLm5vZGVOYW1lKSAmJiBub2RlLnRleHRDb250ZW50Lmxlbmd0aCA9PSAwKSB7IHJldHVybiB9XG5cbiAgICAgICAgaWYgKGlzQmxvY2spIHsgY2xvc2UoKTsgfVxuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IG5vZGUuY2hpbGROb2Rlcy5sZW5ndGg7IGkrKylcbiAgICAgICAgICB7IHdhbGsobm9kZS5jaGlsZE5vZGVzW2ldKTsgfVxuXG4gICAgICAgIGlmICgvXihwcmV8cCkkL2kudGVzdChub2RlLm5vZGVOYW1lKSkgeyBleHRyYUxpbmVicmVhayA9IHRydWU7IH1cbiAgICAgICAgaWYgKGlzQmxvY2spIHsgY2xvc2luZyA9IHRydWU7IH1cbiAgICAgIH0gZWxzZSBpZiAobm9kZS5ub2RlVHlwZSA9PSAzKSB7XG4gICAgICAgIGFkZFRleHQobm9kZS5ub2RlVmFsdWUucmVwbGFjZSgvXFx1MjAwYi9nLCBcIlwiKS5yZXBsYWNlKC9cXHUwMGEwL2csIFwiIFwiKSk7XG4gICAgICB9XG4gICAgfVxuICAgIGZvciAoOzspIHtcbiAgICAgIHdhbGsoZnJvbSk7XG4gICAgICBpZiAoZnJvbSA9PSB0bykgeyBicmVhayB9XG4gICAgICBmcm9tID0gZnJvbS5uZXh0U2libGluZztcbiAgICAgIGV4dHJhTGluZWJyZWFrID0gZmFsc2U7XG4gICAgfVxuICAgIHJldHVybiB0ZXh0XG4gIH1cblxuICBmdW5jdGlvbiBkb21Ub1BvcyhjbSwgbm9kZSwgb2Zmc2V0KSB7XG4gICAgdmFyIGxpbmVOb2RlO1xuICAgIGlmIChub2RlID09IGNtLmRpc3BsYXkubGluZURpdikge1xuICAgICAgbGluZU5vZGUgPSBjbS5kaXNwbGF5LmxpbmVEaXYuY2hpbGROb2Rlc1tvZmZzZXRdO1xuICAgICAgaWYgKCFsaW5lTm9kZSkgeyByZXR1cm4gYmFkUG9zKGNtLmNsaXBQb3MoUG9zKGNtLmRpc3BsYXkudmlld1RvIC0gMSkpLCB0cnVlKSB9XG4gICAgICBub2RlID0gbnVsbDsgb2Zmc2V0ID0gMDtcbiAgICB9IGVsc2Uge1xuICAgICAgZm9yIChsaW5lTm9kZSA9IG5vZGU7OyBsaW5lTm9kZSA9IGxpbmVOb2RlLnBhcmVudE5vZGUpIHtcbiAgICAgICAgaWYgKCFsaW5lTm9kZSB8fCBsaW5lTm9kZSA9PSBjbS5kaXNwbGF5LmxpbmVEaXYpIHsgcmV0dXJuIG51bGwgfVxuICAgICAgICBpZiAobGluZU5vZGUucGFyZW50Tm9kZSAmJiBsaW5lTm9kZS5wYXJlbnROb2RlID09IGNtLmRpc3BsYXkubGluZURpdikgeyBicmVhayB9XG4gICAgICB9XG4gICAgfVxuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgY20uZGlzcGxheS52aWV3Lmxlbmd0aDsgaSsrKSB7XG4gICAgICB2YXIgbGluZVZpZXcgPSBjbS5kaXNwbGF5LnZpZXdbaV07XG4gICAgICBpZiAobGluZVZpZXcubm9kZSA9PSBsaW5lTm9kZSlcbiAgICAgICAgeyByZXR1cm4gbG9jYXRlTm9kZUluTGluZVZpZXcobGluZVZpZXcsIG5vZGUsIG9mZnNldCkgfVxuICAgIH1cbiAgfVxuXG4gIGZ1bmN0aW9uIGxvY2F0ZU5vZGVJbkxpbmVWaWV3KGxpbmVWaWV3LCBub2RlLCBvZmZzZXQpIHtcbiAgICB2YXIgd3JhcHBlciA9IGxpbmVWaWV3LnRleHQuZmlyc3RDaGlsZCwgYmFkID0gZmFsc2U7XG4gICAgaWYgKCFub2RlIHx8ICFjb250YWlucyh3cmFwcGVyLCBub2RlKSkgeyByZXR1cm4gYmFkUG9zKFBvcyhsaW5lTm8obGluZVZpZXcubGluZSksIDApLCB0cnVlKSB9XG4gICAgaWYgKG5vZGUgPT0gd3JhcHBlcikge1xuICAgICAgYmFkID0gdHJ1ZTtcbiAgICAgIG5vZGUgPSB3cmFwcGVyLmNoaWxkTm9kZXNbb2Zmc2V0XTtcbiAgICAgIG9mZnNldCA9IDA7XG4gICAgICBpZiAoIW5vZGUpIHtcbiAgICAgICAgdmFyIGxpbmUgPSBsaW5lVmlldy5yZXN0ID8gbHN0KGxpbmVWaWV3LnJlc3QpIDogbGluZVZpZXcubGluZTtcbiAgICAgICAgcmV0dXJuIGJhZFBvcyhQb3MobGluZU5vKGxpbmUpLCBsaW5lLnRleHQubGVuZ3RoKSwgYmFkKVxuICAgICAgfVxuICAgIH1cblxuICAgIHZhciB0ZXh0Tm9kZSA9IG5vZGUubm9kZVR5cGUgPT0gMyA/IG5vZGUgOiBudWxsLCB0b3BOb2RlID0gbm9kZTtcbiAgICBpZiAoIXRleHROb2RlICYmIG5vZGUuY2hpbGROb2Rlcy5sZW5ndGggPT0gMSAmJiBub2RlLmZpcnN0Q2hpbGQubm9kZVR5cGUgPT0gMykge1xuICAgICAgdGV4dE5vZGUgPSBub2RlLmZpcnN0Q2hpbGQ7XG4gICAgICBpZiAob2Zmc2V0KSB7IG9mZnNldCA9IHRleHROb2RlLm5vZGVWYWx1ZS5sZW5ndGg7IH1cbiAgICB9XG4gICAgd2hpbGUgKHRvcE5vZGUucGFyZW50Tm9kZSAhPSB3cmFwcGVyKSB7IHRvcE5vZGUgPSB0b3BOb2RlLnBhcmVudE5vZGU7IH1cbiAgICB2YXIgbWVhc3VyZSA9IGxpbmVWaWV3Lm1lYXN1cmUsIG1hcHMgPSBtZWFzdXJlLm1hcHM7XG5cbiAgICBmdW5jdGlvbiBmaW5kKHRleHROb2RlLCB0b3BOb2RlLCBvZmZzZXQpIHtcbiAgICAgIGZvciAodmFyIGkgPSAtMTsgaSA8IChtYXBzID8gbWFwcy5sZW5ndGggOiAwKTsgaSsrKSB7XG4gICAgICAgIHZhciBtYXAgPSBpIDwgMCA/IG1lYXN1cmUubWFwIDogbWFwc1tpXTtcbiAgICAgICAgZm9yICh2YXIgaiA9IDA7IGogPCBtYXAubGVuZ3RoOyBqICs9IDMpIHtcbiAgICAgICAgICB2YXIgY3VyTm9kZSA9IG1hcFtqICsgMl07XG4gICAgICAgICAgaWYgKGN1ck5vZGUgPT0gdGV4dE5vZGUgfHwgY3VyTm9kZSA9PSB0b3BOb2RlKSB7XG4gICAgICAgICAgICB2YXIgbGluZSA9IGxpbmVObyhpIDwgMCA/IGxpbmVWaWV3LmxpbmUgOiBsaW5lVmlldy5yZXN0W2ldKTtcbiAgICAgICAgICAgIHZhciBjaCA9IG1hcFtqXSArIG9mZnNldDtcbiAgICAgICAgICAgIGlmIChvZmZzZXQgPCAwIHx8IGN1ck5vZGUgIT0gdGV4dE5vZGUpIHsgY2ggPSBtYXBbaiArIChvZmZzZXQgPyAxIDogMCldOyB9XG4gICAgICAgICAgICByZXR1cm4gUG9zKGxpbmUsIGNoKVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgICB2YXIgZm91bmQgPSBmaW5kKHRleHROb2RlLCB0b3BOb2RlLCBvZmZzZXQpO1xuICAgIGlmIChmb3VuZCkgeyByZXR1cm4gYmFkUG9zKGZvdW5kLCBiYWQpIH1cblxuICAgIC8vIEZJWE1FIHRoaXMgaXMgYWxsIHJlYWxseSBzaGFreS4gbWlnaHQgaGFuZGxlIHRoZSBmZXcgY2FzZXMgaXQgbmVlZHMgdG8gaGFuZGxlLCBidXQgbGlrZWx5IHRvIGNhdXNlIHByb2JsZW1zXG4gICAgZm9yICh2YXIgYWZ0ZXIgPSB0b3BOb2RlLm5leHRTaWJsaW5nLCBkaXN0ID0gdGV4dE5vZGUgPyB0ZXh0Tm9kZS5ub2RlVmFsdWUubGVuZ3RoIC0gb2Zmc2V0IDogMDsgYWZ0ZXI7IGFmdGVyID0gYWZ0ZXIubmV4dFNpYmxpbmcpIHtcbiAgICAgIGZvdW5kID0gZmluZChhZnRlciwgYWZ0ZXIuZmlyc3RDaGlsZCwgMCk7XG4gICAgICBpZiAoZm91bmQpXG4gICAgICAgIHsgcmV0dXJuIGJhZFBvcyhQb3MoZm91bmQubGluZSwgZm91bmQuY2ggLSBkaXN0KSwgYmFkKSB9XG4gICAgICBlbHNlXG4gICAgICAgIHsgZGlzdCArPSBhZnRlci50ZXh0Q29udGVudC5sZW5ndGg7IH1cbiAgICB9XG4gICAgZm9yICh2YXIgYmVmb3JlID0gdG9wTm9kZS5wcmV2aW91c1NpYmxpbmcsIGRpc3QkMSA9IG9mZnNldDsgYmVmb3JlOyBiZWZvcmUgPSBiZWZvcmUucHJldmlvdXNTaWJsaW5nKSB7XG4gICAgICBmb3VuZCA9IGZpbmQoYmVmb3JlLCBiZWZvcmUuZmlyc3RDaGlsZCwgLTEpO1xuICAgICAgaWYgKGZvdW5kKVxuICAgICAgICB7IHJldHVybiBiYWRQb3MoUG9zKGZvdW5kLmxpbmUsIGZvdW5kLmNoICsgZGlzdCQxKSwgYmFkKSB9XG4gICAgICBlbHNlXG4gICAgICAgIHsgZGlzdCQxICs9IGJlZm9yZS50ZXh0Q29udGVudC5sZW5ndGg7IH1cbiAgICB9XG4gIH1cblxuICAvLyBURVhUQVJFQSBJTlBVVCBTVFlMRVxuXG4gIHZhciBUZXh0YXJlYUlucHV0ID0gZnVuY3Rpb24oY20pIHtcbiAgICB0aGlzLmNtID0gY207XG4gICAgLy8gU2VlIGlucHV0LnBvbGwgYW5kIGlucHV0LnJlc2V0XG4gICAgdGhpcy5wcmV2SW5wdXQgPSBcIlwiO1xuXG4gICAgLy8gRmxhZyB0aGF0IGluZGljYXRlcyB3aGV0aGVyIHdlIGV4cGVjdCBpbnB1dCB0byBhcHBlYXIgcmVhbCBzb29uXG4gICAgLy8gbm93IChhZnRlciBzb21lIGV2ZW50IGxpa2UgJ2tleXByZXNzJyBvciAnaW5wdXQnKSBhbmQgYXJlXG4gICAgLy8gcG9sbGluZyBpbnRlbnNpdmVseS5cbiAgICB0aGlzLnBvbGxpbmdGYXN0ID0gZmFsc2U7XG4gICAgLy8gU2VsZi1yZXNldHRpbmcgdGltZW91dCBmb3IgdGhlIHBvbGxlclxuICAgIHRoaXMucG9sbGluZyA9IG5ldyBEZWxheWVkKCk7XG4gICAgLy8gVXNlZCB0byB3b3JrIGFyb3VuZCBJRSBpc3N1ZSB3aXRoIHNlbGVjdGlvbiBiZWluZyBmb3Jnb3R0ZW4gd2hlbiBmb2N1cyBtb3ZlcyBhd2F5IGZyb20gdGV4dGFyZWFcbiAgICB0aGlzLmhhc1NlbGVjdGlvbiA9IGZhbHNlO1xuICAgIHRoaXMuY29tcG9zaW5nID0gbnVsbDtcbiAgfTtcblxuICBUZXh0YXJlYUlucHV0LnByb3RvdHlwZS5pbml0ID0gZnVuY3Rpb24gKGRpc3BsYXkpIHtcbiAgICAgIHZhciB0aGlzJDEgPSB0aGlzO1xuXG4gICAgdmFyIGlucHV0ID0gdGhpcywgY20gPSB0aGlzLmNtO1xuICAgIHRoaXMuY3JlYXRlRmllbGQoZGlzcGxheSk7XG4gICAgdmFyIHRlID0gdGhpcy50ZXh0YXJlYTtcblxuICAgIGRpc3BsYXkud3JhcHBlci5pbnNlcnRCZWZvcmUodGhpcy53cmFwcGVyLCBkaXNwbGF5LndyYXBwZXIuZmlyc3RDaGlsZCk7XG5cbiAgICAvLyBOZWVkZWQgdG8gaGlkZSBiaWcgYmx1ZSBibGlua2luZyBjdXJzb3Igb24gTW9iaWxlIFNhZmFyaSAoZG9lc24ndCBzZWVtIHRvIHdvcmsgaW4gaU9TIDggYW55bW9yZSlcbiAgICBpZiAoaW9zKSB7IHRlLnN0eWxlLndpZHRoID0gXCIwcHhcIjsgfVxuXG4gICAgb24odGUsIFwiaW5wdXRcIiwgZnVuY3Rpb24gKCkge1xuICAgICAgaWYgKGllICYmIGllX3ZlcnNpb24gPj0gOSAmJiB0aGlzJDEuaGFzU2VsZWN0aW9uKSB7IHRoaXMkMS5oYXNTZWxlY3Rpb24gPSBudWxsOyB9XG4gICAgICBpbnB1dC5wb2xsKCk7XG4gICAgfSk7XG5cbiAgICBvbih0ZSwgXCJwYXN0ZVwiLCBmdW5jdGlvbiAoZSkge1xuICAgICAgaWYgKHNpZ25hbERPTUV2ZW50KGNtLCBlKSB8fCBoYW5kbGVQYXN0ZShlLCBjbSkpIHsgcmV0dXJuIH1cblxuICAgICAgY20uc3RhdGUucGFzdGVJbmNvbWluZyA9ICtuZXcgRGF0ZTtcbiAgICAgIGlucHV0LmZhc3RQb2xsKCk7XG4gICAgfSk7XG5cbiAgICBmdW5jdGlvbiBwcmVwYXJlQ29weUN1dChlKSB7XG4gICAgICBpZiAoc2lnbmFsRE9NRXZlbnQoY20sIGUpKSB7IHJldHVybiB9XG4gICAgICBpZiAoY20uc29tZXRoaW5nU2VsZWN0ZWQoKSkge1xuICAgICAgICBzZXRMYXN0Q29waWVkKHtsaW5lV2lzZTogZmFsc2UsIHRleHQ6IGNtLmdldFNlbGVjdGlvbnMoKX0pO1xuICAgICAgfSBlbHNlIGlmICghY20ub3B0aW9ucy5saW5lV2lzZUNvcHlDdXQpIHtcbiAgICAgICAgcmV0dXJuXG4gICAgICB9IGVsc2Uge1xuICAgICAgICB2YXIgcmFuZ2VzID0gY29weWFibGVSYW5nZXMoY20pO1xuICAgICAgICBzZXRMYXN0Q29waWVkKHtsaW5lV2lzZTogdHJ1ZSwgdGV4dDogcmFuZ2VzLnRleHR9KTtcbiAgICAgICAgaWYgKGUudHlwZSA9PSBcImN1dFwiKSB7XG4gICAgICAgICAgY20uc2V0U2VsZWN0aW9ucyhyYW5nZXMucmFuZ2VzLCBudWxsLCBzZWxfZG9udFNjcm9sbCk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgaW5wdXQucHJldklucHV0ID0gXCJcIjtcbiAgICAgICAgICB0ZS52YWx1ZSA9IHJhbmdlcy50ZXh0LmpvaW4oXCJcXG5cIik7XG4gICAgICAgICAgc2VsZWN0SW5wdXQodGUpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBpZiAoZS50eXBlID09IFwiY3V0XCIpIHsgY20uc3RhdGUuY3V0SW5jb21pbmcgPSArbmV3IERhdGU7IH1cbiAgICB9XG4gICAgb24odGUsIFwiY3V0XCIsIHByZXBhcmVDb3B5Q3V0KTtcbiAgICBvbih0ZSwgXCJjb3B5XCIsIHByZXBhcmVDb3B5Q3V0KTtcblxuICAgIG9uKGRpc3BsYXkuc2Nyb2xsZXIsIFwicGFzdGVcIiwgZnVuY3Rpb24gKGUpIHtcbiAgICAgIGlmIChldmVudEluV2lkZ2V0KGRpc3BsYXksIGUpIHx8IHNpZ25hbERPTUV2ZW50KGNtLCBlKSkgeyByZXR1cm4gfVxuICAgICAgaWYgKCF0ZS5kaXNwYXRjaEV2ZW50KSB7XG4gICAgICAgIGNtLnN0YXRlLnBhc3RlSW5jb21pbmcgPSArbmV3IERhdGU7XG4gICAgICAgIGlucHV0LmZvY3VzKCk7XG4gICAgICAgIHJldHVyblxuICAgICAgfVxuXG4gICAgICAvLyBQYXNzIHRoZSBgcGFzdGVgIGV2ZW50IHRvIHRoZSB0ZXh0YXJlYSBzbyBpdCdzIGhhbmRsZWQgYnkgaXRzIGV2ZW50IGxpc3RlbmVyLlxuICAgICAgdmFyIGV2ZW50ID0gbmV3IEV2ZW50KFwicGFzdGVcIik7XG4gICAgICBldmVudC5jbGlwYm9hcmREYXRhID0gZS5jbGlwYm9hcmREYXRhO1xuICAgICAgdGUuZGlzcGF0Y2hFdmVudChldmVudCk7XG4gICAgfSk7XG5cbiAgICAvLyBQcmV2ZW50IG5vcm1hbCBzZWxlY3Rpb24gaW4gdGhlIGVkaXRvciAod2UgaGFuZGxlIG91ciBvd24pXG4gICAgb24oZGlzcGxheS5saW5lU3BhY2UsIFwic2VsZWN0c3RhcnRcIiwgZnVuY3Rpb24gKGUpIHtcbiAgICAgIGlmICghZXZlbnRJbldpZGdldChkaXNwbGF5LCBlKSkgeyBlX3ByZXZlbnREZWZhdWx0KGUpOyB9XG4gICAgfSk7XG5cbiAgICBvbih0ZSwgXCJjb21wb3NpdGlvbnN0YXJ0XCIsIGZ1bmN0aW9uICgpIHtcbiAgICAgIHZhciBzdGFydCA9IGNtLmdldEN1cnNvcihcImZyb21cIik7XG4gICAgICBpZiAoaW5wdXQuY29tcG9zaW5nKSB7IGlucHV0LmNvbXBvc2luZy5yYW5nZS5jbGVhcigpOyB9XG4gICAgICBpbnB1dC5jb21wb3NpbmcgPSB7XG4gICAgICAgIHN0YXJ0OiBzdGFydCxcbiAgICAgICAgcmFuZ2U6IGNtLm1hcmtUZXh0KHN0YXJ0LCBjbS5nZXRDdXJzb3IoXCJ0b1wiKSwge2NsYXNzTmFtZTogXCJDb2RlTWlycm9yLWNvbXBvc2luZ1wifSlcbiAgICAgIH07XG4gICAgfSk7XG4gICAgb24odGUsIFwiY29tcG9zaXRpb25lbmRcIiwgZnVuY3Rpb24gKCkge1xuICAgICAgaWYgKGlucHV0LmNvbXBvc2luZykge1xuICAgICAgICBpbnB1dC5wb2xsKCk7XG4gICAgICAgIGlucHV0LmNvbXBvc2luZy5yYW5nZS5jbGVhcigpO1xuICAgICAgICBpbnB1dC5jb21wb3NpbmcgPSBudWxsO1xuICAgICAgfVxuICAgIH0pO1xuICB9O1xuXG4gIFRleHRhcmVhSW5wdXQucHJvdG90eXBlLmNyZWF0ZUZpZWxkID0gZnVuY3Rpb24gKF9kaXNwbGF5KSB7XG4gICAgLy8gV3JhcHMgYW5kIGhpZGVzIGlucHV0IHRleHRhcmVhXG4gICAgdGhpcy53cmFwcGVyID0gaGlkZGVuVGV4dGFyZWEoKTtcbiAgICAvLyBUaGUgc2VtaWhpZGRlbiB0ZXh0YXJlYSB0aGF0IGlzIGZvY3VzZWQgd2hlbiB0aGUgZWRpdG9yIGlzXG4gICAgLy8gZm9jdXNlZCwgYW5kIHJlY2VpdmVzIGlucHV0LlxuICAgIHRoaXMudGV4dGFyZWEgPSB0aGlzLndyYXBwZXIuZmlyc3RDaGlsZDtcbiAgfTtcblxuICBUZXh0YXJlYUlucHV0LnByb3RvdHlwZS5zY3JlZW5SZWFkZXJMYWJlbENoYW5nZWQgPSBmdW5jdGlvbiAobGFiZWwpIHtcbiAgICAvLyBMYWJlbCBmb3Igc2NyZWVucmVhZGVycywgYWNjZXNzaWJpbGl0eVxuICAgIGlmKGxhYmVsKSB7XG4gICAgICB0aGlzLnRleHRhcmVhLnNldEF0dHJpYnV0ZSgnYXJpYS1sYWJlbCcsIGxhYmVsKTtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy50ZXh0YXJlYS5yZW1vdmVBdHRyaWJ1dGUoJ2FyaWEtbGFiZWwnKTtcbiAgICB9XG4gIH07XG5cbiAgVGV4dGFyZWFJbnB1dC5wcm90b3R5cGUucHJlcGFyZVNlbGVjdGlvbiA9IGZ1bmN0aW9uICgpIHtcbiAgICAvLyBSZWRyYXcgdGhlIHNlbGVjdGlvbiBhbmQvb3IgY3Vyc29yXG4gICAgdmFyIGNtID0gdGhpcy5jbSwgZGlzcGxheSA9IGNtLmRpc3BsYXksIGRvYyA9IGNtLmRvYztcbiAgICB2YXIgcmVzdWx0ID0gcHJlcGFyZVNlbGVjdGlvbihjbSk7XG5cbiAgICAvLyBNb3ZlIHRoZSBoaWRkZW4gdGV4dGFyZWEgbmVhciB0aGUgY3Vyc29yIHRvIHByZXZlbnQgc2Nyb2xsaW5nIGFydGlmYWN0c1xuICAgIGlmIChjbS5vcHRpb25zLm1vdmVJbnB1dFdpdGhDdXJzb3IpIHtcbiAgICAgIHZhciBoZWFkUG9zID0gY3Vyc29yQ29vcmRzKGNtLCBkb2Muc2VsLnByaW1hcnkoKS5oZWFkLCBcImRpdlwiKTtcbiAgICAgIHZhciB3cmFwT2ZmID0gZGlzcGxheS53cmFwcGVyLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpLCBsaW5lT2ZmID0gZGlzcGxheS5saW5lRGl2LmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpO1xuICAgICAgcmVzdWx0LnRlVG9wID0gTWF0aC5tYXgoMCwgTWF0aC5taW4oZGlzcGxheS53cmFwcGVyLmNsaWVudEhlaWdodCAtIDEwLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaGVhZFBvcy50b3AgKyBsaW5lT2ZmLnRvcCAtIHdyYXBPZmYudG9wKSk7XG4gICAgICByZXN1bHQudGVMZWZ0ID0gTWF0aC5tYXgoMCwgTWF0aC5taW4oZGlzcGxheS53cmFwcGVyLmNsaWVudFdpZHRoIC0gMTAsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaGVhZFBvcy5sZWZ0ICsgbGluZU9mZi5sZWZ0IC0gd3JhcE9mZi5sZWZ0KSk7XG4gICAgfVxuXG4gICAgcmV0dXJuIHJlc3VsdFxuICB9O1xuXG4gIFRleHRhcmVhSW5wdXQucHJvdG90eXBlLnNob3dTZWxlY3Rpb24gPSBmdW5jdGlvbiAoZHJhd24pIHtcbiAgICB2YXIgY20gPSB0aGlzLmNtLCBkaXNwbGF5ID0gY20uZGlzcGxheTtcbiAgICByZW1vdmVDaGlsZHJlbkFuZEFkZChkaXNwbGF5LmN1cnNvckRpdiwgZHJhd24uY3Vyc29ycyk7XG4gICAgcmVtb3ZlQ2hpbGRyZW5BbmRBZGQoZGlzcGxheS5zZWxlY3Rpb25EaXYsIGRyYXduLnNlbGVjdGlvbik7XG4gICAgaWYgKGRyYXduLnRlVG9wICE9IG51bGwpIHtcbiAgICAgIHRoaXMud3JhcHBlci5zdHlsZS50b3AgPSBkcmF3bi50ZVRvcCArIFwicHhcIjtcbiAgICAgIHRoaXMud3JhcHBlci5zdHlsZS5sZWZ0ID0gZHJhd24udGVMZWZ0ICsgXCJweFwiO1xuICAgIH1cbiAgfTtcblxuICAvLyBSZXNldCB0aGUgaW5wdXQgdG8gY29ycmVzcG9uZCB0byB0aGUgc2VsZWN0aW9uIChvciB0byBiZSBlbXB0eSxcbiAgLy8gd2hlbiBub3QgdHlwaW5nIGFuZCBub3RoaW5nIGlzIHNlbGVjdGVkKVxuICBUZXh0YXJlYUlucHV0LnByb3RvdHlwZS5yZXNldCA9IGZ1bmN0aW9uICh0eXBpbmcpIHtcbiAgICBpZiAodGhpcy5jb250ZXh0TWVudVBlbmRpbmcgfHwgdGhpcy5jb21wb3NpbmcpIHsgcmV0dXJuIH1cbiAgICB2YXIgY20gPSB0aGlzLmNtO1xuICAgIGlmIChjbS5zb21ldGhpbmdTZWxlY3RlZCgpKSB7XG4gICAgICB0aGlzLnByZXZJbnB1dCA9IFwiXCI7XG4gICAgICB2YXIgY29udGVudCA9IGNtLmdldFNlbGVjdGlvbigpO1xuICAgICAgdGhpcy50ZXh0YXJlYS52YWx1ZSA9IGNvbnRlbnQ7XG4gICAgICBpZiAoY20uc3RhdGUuZm9jdXNlZCkgeyBzZWxlY3RJbnB1dCh0aGlzLnRleHRhcmVhKTsgfVxuICAgICAgaWYgKGllICYmIGllX3ZlcnNpb24gPj0gOSkgeyB0aGlzLmhhc1NlbGVjdGlvbiA9IGNvbnRlbnQ7IH1cbiAgICB9IGVsc2UgaWYgKCF0eXBpbmcpIHtcbiAgICAgIHRoaXMucHJldklucHV0ID0gdGhpcy50ZXh0YXJlYS52YWx1ZSA9IFwiXCI7XG4gICAgICBpZiAoaWUgJiYgaWVfdmVyc2lvbiA+PSA5KSB7IHRoaXMuaGFzU2VsZWN0aW9uID0gbnVsbDsgfVxuICAgIH1cbiAgfTtcblxuICBUZXh0YXJlYUlucHV0LnByb3RvdHlwZS5nZXRGaWVsZCA9IGZ1bmN0aW9uICgpIHsgcmV0dXJuIHRoaXMudGV4dGFyZWEgfTtcblxuICBUZXh0YXJlYUlucHV0LnByb3RvdHlwZS5zdXBwb3J0c1RvdWNoID0gZnVuY3Rpb24gKCkgeyByZXR1cm4gZmFsc2UgfTtcblxuICBUZXh0YXJlYUlucHV0LnByb3RvdHlwZS5mb2N1cyA9IGZ1bmN0aW9uICgpIHtcbiAgICBpZiAodGhpcy5jbS5vcHRpb25zLnJlYWRPbmx5ICE9IFwibm9jdXJzb3JcIiAmJiAoIW1vYmlsZSB8fCBhY3RpdmVFbHQoKSAhPSB0aGlzLnRleHRhcmVhKSkge1xuICAgICAgdHJ5IHsgdGhpcy50ZXh0YXJlYS5mb2N1cygpOyB9XG4gICAgICBjYXRjaCAoZSkge30gLy8gSUU4IHdpbGwgdGhyb3cgaWYgdGhlIHRleHRhcmVhIGlzIGRpc3BsYXk6IG5vbmUgb3Igbm90IGluIERPTVxuICAgIH1cbiAgfTtcblxuICBUZXh0YXJlYUlucHV0LnByb3RvdHlwZS5ibHVyID0gZnVuY3Rpb24gKCkgeyB0aGlzLnRleHRhcmVhLmJsdXIoKTsgfTtcblxuICBUZXh0YXJlYUlucHV0LnByb3RvdHlwZS5yZXNldFBvc2l0aW9uID0gZnVuY3Rpb24gKCkge1xuICAgIHRoaXMud3JhcHBlci5zdHlsZS50b3AgPSB0aGlzLndyYXBwZXIuc3R5bGUubGVmdCA9IDA7XG4gIH07XG5cbiAgVGV4dGFyZWFJbnB1dC5wcm90b3R5cGUucmVjZWl2ZWRGb2N1cyA9IGZ1bmN0aW9uICgpIHsgdGhpcy5zbG93UG9sbCgpOyB9O1xuXG4gIC8vIFBvbGwgZm9yIGlucHV0IGNoYW5nZXMsIHVzaW5nIHRoZSBub3JtYWwgcmF0ZSBvZiBwb2xsaW5nLiBUaGlzXG4gIC8vIHJ1bnMgYXMgbG9uZyBhcyB0aGUgZWRpdG9yIGlzIGZvY3VzZWQuXG4gIFRleHRhcmVhSW5wdXQucHJvdG90eXBlLnNsb3dQb2xsID0gZnVuY3Rpb24gKCkge1xuICAgICAgdmFyIHRoaXMkMSA9IHRoaXM7XG5cbiAgICBpZiAodGhpcy5wb2xsaW5nRmFzdCkgeyByZXR1cm4gfVxuICAgIHRoaXMucG9sbGluZy5zZXQodGhpcy5jbS5vcHRpb25zLnBvbGxJbnRlcnZhbCwgZnVuY3Rpb24gKCkge1xuICAgICAgdGhpcyQxLnBvbGwoKTtcbiAgICAgIGlmICh0aGlzJDEuY20uc3RhdGUuZm9jdXNlZCkgeyB0aGlzJDEuc2xvd1BvbGwoKTsgfVxuICAgIH0pO1xuICB9O1xuXG4gIC8vIFdoZW4gYW4gZXZlbnQgaGFzIGp1c3QgY29tZSBpbiB0aGF0IGlzIGxpa2VseSB0byBhZGQgb3IgY2hhbmdlXG4gIC8vIHNvbWV0aGluZyBpbiB0aGUgaW5wdXQgdGV4dGFyZWEsIHdlIHBvbGwgZmFzdGVyLCB0byBlbnN1cmUgdGhhdFxuICAvLyB0aGUgY2hhbmdlIGFwcGVhcnMgb24gdGhlIHNjcmVlbiBxdWlja2x5LlxuICBUZXh0YXJlYUlucHV0LnByb3RvdHlwZS5mYXN0UG9sbCA9IGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgbWlzc2VkID0gZmFsc2UsIGlucHV0ID0gdGhpcztcbiAgICBpbnB1dC5wb2xsaW5nRmFzdCA9IHRydWU7XG4gICAgZnVuY3Rpb24gcCgpIHtcbiAgICAgIHZhciBjaGFuZ2VkID0gaW5wdXQucG9sbCgpO1xuICAgICAgaWYgKCFjaGFuZ2VkICYmICFtaXNzZWQpIHttaXNzZWQgPSB0cnVlOyBpbnB1dC5wb2xsaW5nLnNldCg2MCwgcCk7fVxuICAgICAgZWxzZSB7aW5wdXQucG9sbGluZ0Zhc3QgPSBmYWxzZTsgaW5wdXQuc2xvd1BvbGwoKTt9XG4gICAgfVxuICAgIGlucHV0LnBvbGxpbmcuc2V0KDIwLCBwKTtcbiAgfTtcblxuICAvLyBSZWFkIGlucHV0IGZyb20gdGhlIHRleHRhcmVhLCBhbmQgdXBkYXRlIHRoZSBkb2N1bWVudCB0byBtYXRjaC5cbiAgLy8gV2hlbiBzb21ldGhpbmcgaXMgc2VsZWN0ZWQsIGl0IGlzIHByZXNlbnQgaW4gdGhlIHRleHRhcmVhLCBhbmRcbiAgLy8gc2VsZWN0ZWQgKHVubGVzcyBpdCBpcyBodWdlLCBpbiB3aGljaCBjYXNlIGEgcGxhY2Vob2xkZXIgaXNcbiAgLy8gdXNlZCkuIFdoZW4gbm90aGluZyBpcyBzZWxlY3RlZCwgdGhlIGN1cnNvciBzaXRzIGFmdGVyIHByZXZpb3VzbHlcbiAgLy8gc2VlbiB0ZXh0IChjYW4gYmUgZW1wdHkpLCB3aGljaCBpcyBzdG9yZWQgaW4gcHJldklucHV0ICh3ZSBtdXN0XG4gIC8vIG5vdCByZXNldCB0aGUgdGV4dGFyZWEgd2hlbiB0eXBpbmcsIGJlY2F1c2UgdGhhdCBicmVha3MgSU1FKS5cbiAgVGV4dGFyZWFJbnB1dC5wcm90b3R5cGUucG9sbCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgIHZhciB0aGlzJDEgPSB0aGlzO1xuXG4gICAgdmFyIGNtID0gdGhpcy5jbSwgaW5wdXQgPSB0aGlzLnRleHRhcmVhLCBwcmV2SW5wdXQgPSB0aGlzLnByZXZJbnB1dDtcbiAgICAvLyBTaW5jZSB0aGlzIGlzIGNhbGxlZCBhICpsb3QqLCB0cnkgdG8gYmFpbCBvdXQgYXMgY2hlYXBseSBhc1xuICAgIC8vIHBvc3NpYmxlIHdoZW4gaXQgaXMgY2xlYXIgdGhhdCBub3RoaW5nIGhhcHBlbmVkLiBoYXNTZWxlY3Rpb25cbiAgICAvLyB3aWxsIGJlIHRoZSBjYXNlIHdoZW4gdGhlcmUgaXMgYSBsb3Qgb2YgdGV4dCBpbiB0aGUgdGV4dGFyZWEsXG4gICAgLy8gaW4gd2hpY2ggY2FzZSByZWFkaW5nIGl0cyB2YWx1ZSB3b3VsZCBiZSBleHBlbnNpdmUuXG4gICAgaWYgKHRoaXMuY29udGV4dE1lbnVQZW5kaW5nIHx8ICFjbS5zdGF0ZS5mb2N1c2VkIHx8XG4gICAgICAgIChoYXNTZWxlY3Rpb24oaW5wdXQpICYmICFwcmV2SW5wdXQgJiYgIXRoaXMuY29tcG9zaW5nKSB8fFxuICAgICAgICBjbS5pc1JlYWRPbmx5KCkgfHwgY20ub3B0aW9ucy5kaXNhYmxlSW5wdXQgfHwgY20uc3RhdGUua2V5U2VxKVxuICAgICAgeyByZXR1cm4gZmFsc2UgfVxuXG4gICAgdmFyIHRleHQgPSBpbnB1dC52YWx1ZTtcbiAgICAvLyBJZiBub3RoaW5nIGNoYW5nZWQsIGJhaWwuXG4gICAgaWYgKHRleHQgPT0gcHJldklucHV0ICYmICFjbS5zb21ldGhpbmdTZWxlY3RlZCgpKSB7IHJldHVybiBmYWxzZSB9XG4gICAgLy8gV29yayBhcm91bmQgbm9uc2Vuc2ljYWwgc2VsZWN0aW9uIHJlc2V0dGluZyBpbiBJRTkvMTAsIGFuZFxuICAgIC8vIGluZXhwbGljYWJsZSBhcHBlYXJhbmNlIG9mIHByaXZhdGUgYXJlYSB1bmljb2RlIGNoYXJhY3RlcnMgb25cbiAgICAvLyBzb21lIGtleSBjb21ib3MgaW4gTWFjICgjMjY4OSkuXG4gICAgaWYgKGllICYmIGllX3ZlcnNpb24gPj0gOSAmJiB0aGlzLmhhc1NlbGVjdGlvbiA9PT0gdGV4dCB8fFxuICAgICAgICBtYWMgJiYgL1tcXHVmNzAwLVxcdWY3ZmZdLy50ZXN0KHRleHQpKSB7XG4gICAgICBjbS5kaXNwbGF5LmlucHV0LnJlc2V0KCk7XG4gICAgICByZXR1cm4gZmFsc2VcbiAgICB9XG5cbiAgICBpZiAoY20uZG9jLnNlbCA9PSBjbS5kaXNwbGF5LnNlbEZvckNvbnRleHRNZW51KSB7XG4gICAgICB2YXIgZmlyc3QgPSB0ZXh0LmNoYXJDb2RlQXQoMCk7XG4gICAgICBpZiAoZmlyc3QgPT0gMHgyMDBiICYmICFwcmV2SW5wdXQpIHsgcHJldklucHV0ID0gXCJcXHUyMDBiXCI7IH1cbiAgICAgIGlmIChmaXJzdCA9PSAweDIxZGEpIHsgdGhpcy5yZXNldCgpOyByZXR1cm4gdGhpcy5jbS5leGVjQ29tbWFuZChcInVuZG9cIikgfVxuICAgIH1cbiAgICAvLyBGaW5kIHRoZSBwYXJ0IG9mIHRoZSBpbnB1dCB0aGF0IGlzIGFjdHVhbGx5IG5ld1xuICAgIHZhciBzYW1lID0gMCwgbCA9IE1hdGgubWluKHByZXZJbnB1dC5sZW5ndGgsIHRleHQubGVuZ3RoKTtcbiAgICB3aGlsZSAoc2FtZSA8IGwgJiYgcHJldklucHV0LmNoYXJDb2RlQXQoc2FtZSkgPT0gdGV4dC5jaGFyQ29kZUF0KHNhbWUpKSB7ICsrc2FtZTsgfVxuXG4gICAgcnVuSW5PcChjbSwgZnVuY3Rpb24gKCkge1xuICAgICAgYXBwbHlUZXh0SW5wdXQoY20sIHRleHQuc2xpY2Uoc2FtZSksIHByZXZJbnB1dC5sZW5ndGggLSBzYW1lLFxuICAgICAgICAgICAgICAgICAgICAgbnVsbCwgdGhpcyQxLmNvbXBvc2luZyA/IFwiKmNvbXBvc2VcIiA6IG51bGwpO1xuXG4gICAgICAvLyBEb24ndCBsZWF2ZSBsb25nIHRleHQgaW4gdGhlIHRleHRhcmVhLCBzaW5jZSBpdCBtYWtlcyBmdXJ0aGVyIHBvbGxpbmcgc2xvd1xuICAgICAgaWYgKHRleHQubGVuZ3RoID4gMTAwMCB8fCB0ZXh0LmluZGV4T2YoXCJcXG5cIikgPiAtMSkgeyBpbnB1dC52YWx1ZSA9IHRoaXMkMS5wcmV2SW5wdXQgPSBcIlwiOyB9XG4gICAgICBlbHNlIHsgdGhpcyQxLnByZXZJbnB1dCA9IHRleHQ7IH1cblxuICAgICAgaWYgKHRoaXMkMS5jb21wb3NpbmcpIHtcbiAgICAgICAgdGhpcyQxLmNvbXBvc2luZy5yYW5nZS5jbGVhcigpO1xuICAgICAgICB0aGlzJDEuY29tcG9zaW5nLnJhbmdlID0gY20ubWFya1RleHQodGhpcyQxLmNvbXBvc2luZy5zdGFydCwgY20uZ2V0Q3Vyc29yKFwidG9cIiksXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAge2NsYXNzTmFtZTogXCJDb2RlTWlycm9yLWNvbXBvc2luZ1wifSk7XG4gICAgICB9XG4gICAgfSk7XG4gICAgcmV0dXJuIHRydWVcbiAgfTtcblxuICBUZXh0YXJlYUlucHV0LnByb3RvdHlwZS5lbnN1cmVQb2xsZWQgPSBmdW5jdGlvbiAoKSB7XG4gICAgaWYgKHRoaXMucG9sbGluZ0Zhc3QgJiYgdGhpcy5wb2xsKCkpIHsgdGhpcy5wb2xsaW5nRmFzdCA9IGZhbHNlOyB9XG4gIH07XG5cbiAgVGV4dGFyZWFJbnB1dC5wcm90b3R5cGUub25LZXlQcmVzcyA9IGZ1bmN0aW9uICgpIHtcbiAgICBpZiAoaWUgJiYgaWVfdmVyc2lvbiA+PSA5KSB7IHRoaXMuaGFzU2VsZWN0aW9uID0gbnVsbDsgfVxuICAgIHRoaXMuZmFzdFBvbGwoKTtcbiAgfTtcblxuICBUZXh0YXJlYUlucHV0LnByb3RvdHlwZS5vbkNvbnRleHRNZW51ID0gZnVuY3Rpb24gKGUpIHtcbiAgICB2YXIgaW5wdXQgPSB0aGlzLCBjbSA9IGlucHV0LmNtLCBkaXNwbGF5ID0gY20uZGlzcGxheSwgdGUgPSBpbnB1dC50ZXh0YXJlYTtcbiAgICBpZiAoaW5wdXQuY29udGV4dE1lbnVQZW5kaW5nKSB7IGlucHV0LmNvbnRleHRNZW51UGVuZGluZygpOyB9XG4gICAgdmFyIHBvcyA9IHBvc0Zyb21Nb3VzZShjbSwgZSksIHNjcm9sbFBvcyA9IGRpc3BsYXkuc2Nyb2xsZXIuc2Nyb2xsVG9wO1xuICAgIGlmICghcG9zIHx8IHByZXN0bykgeyByZXR1cm4gfSAvLyBPcGVyYSBpcyBkaWZmaWN1bHQuXG5cbiAgICAvLyBSZXNldCB0aGUgY3VycmVudCB0ZXh0IHNlbGVjdGlvbiBvbmx5IGlmIHRoZSBjbGljayBpcyBkb25lIG91dHNpZGUgb2YgdGhlIHNlbGVjdGlvblxuICAgIC8vIGFuZCAncmVzZXRTZWxlY3Rpb25PbkNvbnRleHRNZW51JyBvcHRpb24gaXMgdHJ1ZS5cbiAgICB2YXIgcmVzZXQgPSBjbS5vcHRpb25zLnJlc2V0U2VsZWN0aW9uT25Db250ZXh0TWVudTtcbiAgICBpZiAocmVzZXQgJiYgY20uZG9jLnNlbC5jb250YWlucyhwb3MpID09IC0xKVxuICAgICAgeyBvcGVyYXRpb24oY20sIHNldFNlbGVjdGlvbikoY20uZG9jLCBzaW1wbGVTZWxlY3Rpb24ocG9zKSwgc2VsX2RvbnRTY3JvbGwpOyB9XG5cbiAgICB2YXIgb2xkQ1NTID0gdGUuc3R5bGUuY3NzVGV4dCwgb2xkV3JhcHBlckNTUyA9IGlucHV0LndyYXBwZXIuc3R5bGUuY3NzVGV4dDtcbiAgICB2YXIgd3JhcHBlckJveCA9IGlucHV0LndyYXBwZXIub2Zmc2V0UGFyZW50LmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpO1xuICAgIGlucHV0LndyYXBwZXIuc3R5bGUuY3NzVGV4dCA9IFwicG9zaXRpb246IHN0YXRpY1wiO1xuICAgIHRlLnN0eWxlLmNzc1RleHQgPSBcInBvc2l0aW9uOiBhYnNvbHV0ZTsgd2lkdGg6IDMwcHg7IGhlaWdodDogMzBweDtcXG4gICAgICB0b3A6IFwiICsgKGUuY2xpZW50WSAtIHdyYXBwZXJCb3gudG9wIC0gNSkgKyBcInB4OyBsZWZ0OiBcIiArIChlLmNsaWVudFggLSB3cmFwcGVyQm94LmxlZnQgLSA1KSArIFwicHg7XFxuICAgICAgei1pbmRleDogMTAwMDsgYmFja2dyb3VuZDogXCIgKyAoaWUgPyBcInJnYmEoMjU1LCAyNTUsIDI1NSwgLjA1KVwiIDogXCJ0cmFuc3BhcmVudFwiKSArIFwiO1xcbiAgICAgIG91dGxpbmU6IG5vbmU7IGJvcmRlci13aWR0aDogMDsgb3V0bGluZTogbm9uZTsgb3ZlcmZsb3c6IGhpZGRlbjsgb3BhY2l0eTogLjA1OyBmaWx0ZXI6IGFscGhhKG9wYWNpdHk9NSk7XCI7XG4gICAgdmFyIG9sZFNjcm9sbFk7XG4gICAgaWYgKHdlYmtpdCkgeyBvbGRTY3JvbGxZID0gd2luZG93LnNjcm9sbFk7IH0gLy8gV29yayBhcm91bmQgQ2hyb21lIGlzc3VlICgjMjcxMilcbiAgICBkaXNwbGF5LmlucHV0LmZvY3VzKCk7XG4gICAgaWYgKHdlYmtpdCkgeyB3aW5kb3cuc2Nyb2xsVG8obnVsbCwgb2xkU2Nyb2xsWSk7IH1cbiAgICBkaXNwbGF5LmlucHV0LnJlc2V0KCk7XG4gICAgLy8gQWRkcyBcIlNlbGVjdCBhbGxcIiB0byBjb250ZXh0IG1lbnUgaW4gRkZcbiAgICBpZiAoIWNtLnNvbWV0aGluZ1NlbGVjdGVkKCkpIHsgdGUudmFsdWUgPSBpbnB1dC5wcmV2SW5wdXQgPSBcIiBcIjsgfVxuICAgIGlucHV0LmNvbnRleHRNZW51UGVuZGluZyA9IHJlaGlkZTtcbiAgICBkaXNwbGF5LnNlbEZvckNvbnRleHRNZW51ID0gY20uZG9jLnNlbDtcbiAgICBjbGVhclRpbWVvdXQoZGlzcGxheS5kZXRlY3RpbmdTZWxlY3RBbGwpO1xuXG4gICAgLy8gU2VsZWN0LWFsbCB3aWxsIGJlIGdyZXllZCBvdXQgaWYgdGhlcmUncyBub3RoaW5nIHRvIHNlbGVjdCwgc29cbiAgICAvLyB0aGlzIGFkZHMgYSB6ZXJvLXdpZHRoIHNwYWNlIHNvIHRoYXQgd2UgY2FuIGxhdGVyIGNoZWNrIHdoZXRoZXJcbiAgICAvLyBpdCBnb3Qgc2VsZWN0ZWQuXG4gICAgZnVuY3Rpb24gcHJlcGFyZVNlbGVjdEFsbEhhY2soKSB7XG4gICAgICBpZiAodGUuc2VsZWN0aW9uU3RhcnQgIT0gbnVsbCkge1xuICAgICAgICB2YXIgc2VsZWN0ZWQgPSBjbS5zb21ldGhpbmdTZWxlY3RlZCgpO1xuICAgICAgICB2YXIgZXh0dmFsID0gXCJcXHUyMDBiXCIgKyAoc2VsZWN0ZWQgPyB0ZS52YWx1ZSA6IFwiXCIpO1xuICAgICAgICB0ZS52YWx1ZSA9IFwiXFx1MjFkYVwiOyAvLyBVc2VkIHRvIGNhdGNoIGNvbnRleHQtbWVudSB1bmRvXG4gICAgICAgIHRlLnZhbHVlID0gZXh0dmFsO1xuICAgICAgICBpbnB1dC5wcmV2SW5wdXQgPSBzZWxlY3RlZCA/IFwiXCIgOiBcIlxcdTIwMGJcIjtcbiAgICAgICAgdGUuc2VsZWN0aW9uU3RhcnQgPSAxOyB0ZS5zZWxlY3Rpb25FbmQgPSBleHR2YWwubGVuZ3RoO1xuICAgICAgICAvLyBSZS1zZXQgdGhpcywgaW4gY2FzZSBzb21lIG90aGVyIGhhbmRsZXIgdG91Y2hlZCB0aGVcbiAgICAgICAgLy8gc2VsZWN0aW9uIGluIHRoZSBtZWFudGltZS5cbiAgICAgICAgZGlzcGxheS5zZWxGb3JDb250ZXh0TWVudSA9IGNtLmRvYy5zZWw7XG4gICAgICB9XG4gICAgfVxuICAgIGZ1bmN0aW9uIHJlaGlkZSgpIHtcbiAgICAgIGlmIChpbnB1dC5jb250ZXh0TWVudVBlbmRpbmcgIT0gcmVoaWRlKSB7IHJldHVybiB9XG4gICAgICBpbnB1dC5jb250ZXh0TWVudVBlbmRpbmcgPSBmYWxzZTtcbiAgICAgIGlucHV0LndyYXBwZXIuc3R5bGUuY3NzVGV4dCA9IG9sZFdyYXBwZXJDU1M7XG4gICAgICB0ZS5zdHlsZS5jc3NUZXh0ID0gb2xkQ1NTO1xuICAgICAgaWYgKGllICYmIGllX3ZlcnNpb24gPCA5KSB7IGRpc3BsYXkuc2Nyb2xsYmFycy5zZXRTY3JvbGxUb3AoZGlzcGxheS5zY3JvbGxlci5zY3JvbGxUb3AgPSBzY3JvbGxQb3MpOyB9XG5cbiAgICAgIC8vIFRyeSB0byBkZXRlY3QgdGhlIHVzZXIgY2hvb3Npbmcgc2VsZWN0LWFsbFxuICAgICAgaWYgKHRlLnNlbGVjdGlvblN0YXJ0ICE9IG51bGwpIHtcbiAgICAgICAgaWYgKCFpZSB8fCAoaWUgJiYgaWVfdmVyc2lvbiA8IDkpKSB7IHByZXBhcmVTZWxlY3RBbGxIYWNrKCk7IH1cbiAgICAgICAgdmFyIGkgPSAwLCBwb2xsID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgIGlmIChkaXNwbGF5LnNlbEZvckNvbnRleHRNZW51ID09IGNtLmRvYy5zZWwgJiYgdGUuc2VsZWN0aW9uU3RhcnQgPT0gMCAmJlxuICAgICAgICAgICAgICB0ZS5zZWxlY3Rpb25FbmQgPiAwICYmIGlucHV0LnByZXZJbnB1dCA9PSBcIlxcdTIwMGJcIikge1xuICAgICAgICAgICAgb3BlcmF0aW9uKGNtLCBzZWxlY3RBbGwpKGNtKTtcbiAgICAgICAgICB9IGVsc2UgaWYgKGkrKyA8IDEwKSB7XG4gICAgICAgICAgICBkaXNwbGF5LmRldGVjdGluZ1NlbGVjdEFsbCA9IHNldFRpbWVvdXQocG9sbCwgNTAwKTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgZGlzcGxheS5zZWxGb3JDb250ZXh0TWVudSA9IG51bGw7XG4gICAgICAgICAgICBkaXNwbGF5LmlucHV0LnJlc2V0KCk7XG4gICAgICAgICAgfVxuICAgICAgICB9O1xuICAgICAgICBkaXNwbGF5LmRldGVjdGluZ1NlbGVjdEFsbCA9IHNldFRpbWVvdXQocG9sbCwgMjAwKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAoaWUgJiYgaWVfdmVyc2lvbiA+PSA5KSB7IHByZXBhcmVTZWxlY3RBbGxIYWNrKCk7IH1cbiAgICBpZiAoY2FwdHVyZVJpZ2h0Q2xpY2spIHtcbiAgICAgIGVfc3RvcChlKTtcbiAgICAgIHZhciBtb3VzZXVwID0gZnVuY3Rpb24gKCkge1xuICAgICAgICBvZmYod2luZG93LCBcIm1vdXNldXBcIiwgbW91c2V1cCk7XG4gICAgICAgIHNldFRpbWVvdXQocmVoaWRlLCAyMCk7XG4gICAgICB9O1xuICAgICAgb24od2luZG93LCBcIm1vdXNldXBcIiwgbW91c2V1cCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHNldFRpbWVvdXQocmVoaWRlLCA1MCk7XG4gICAgfVxuICB9O1xuXG4gIFRleHRhcmVhSW5wdXQucHJvdG90eXBlLnJlYWRPbmx5Q2hhbmdlZCA9IGZ1bmN0aW9uICh2YWwpIHtcbiAgICBpZiAoIXZhbCkgeyB0aGlzLnJlc2V0KCk7IH1cbiAgICB0aGlzLnRleHRhcmVhLmRpc2FibGVkID0gdmFsID09IFwibm9jdXJzb3JcIjtcbiAgICB0aGlzLnRleHRhcmVhLnJlYWRPbmx5ID0gISF2YWw7XG4gIH07XG5cbiAgVGV4dGFyZWFJbnB1dC5wcm90b3R5cGUuc2V0VW5lZGl0YWJsZSA9IGZ1bmN0aW9uICgpIHt9O1xuXG4gIFRleHRhcmVhSW5wdXQucHJvdG90eXBlLm5lZWRzQ29udGVudEF0dHJpYnV0ZSA9IGZhbHNlO1xuXG4gIGZ1bmN0aW9uIGZyb21UZXh0QXJlYSh0ZXh0YXJlYSwgb3B0aW9ucykge1xuICAgIG9wdGlvbnMgPSBvcHRpb25zID8gY29weU9iaihvcHRpb25zKSA6IHt9O1xuICAgIG9wdGlvbnMudmFsdWUgPSB0ZXh0YXJlYS52YWx1ZTtcbiAgICBpZiAoIW9wdGlvbnMudGFiaW5kZXggJiYgdGV4dGFyZWEudGFiSW5kZXgpXG4gICAgICB7IG9wdGlvbnMudGFiaW5kZXggPSB0ZXh0YXJlYS50YWJJbmRleDsgfVxuICAgIGlmICghb3B0aW9ucy5wbGFjZWhvbGRlciAmJiB0ZXh0YXJlYS5wbGFjZWhvbGRlcilcbiAgICAgIHsgb3B0aW9ucy5wbGFjZWhvbGRlciA9IHRleHRhcmVhLnBsYWNlaG9sZGVyOyB9XG4gICAgLy8gU2V0IGF1dG9mb2N1cyB0byB0cnVlIGlmIHRoaXMgdGV4dGFyZWEgaXMgZm9jdXNlZCwgb3IgaWYgaXQgaGFzXG4gICAgLy8gYXV0b2ZvY3VzIGFuZCBubyBvdGhlciBlbGVtZW50IGlzIGZvY3VzZWQuXG4gICAgaWYgKG9wdGlvbnMuYXV0b2ZvY3VzID09IG51bGwpIHtcbiAgICAgIHZhciBoYXNGb2N1cyA9IGFjdGl2ZUVsdCgpO1xuICAgICAgb3B0aW9ucy5hdXRvZm9jdXMgPSBoYXNGb2N1cyA9PSB0ZXh0YXJlYSB8fFxuICAgICAgICB0ZXh0YXJlYS5nZXRBdHRyaWJ1dGUoXCJhdXRvZm9jdXNcIikgIT0gbnVsbCAmJiBoYXNGb2N1cyA9PSBkb2N1bWVudC5ib2R5O1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIHNhdmUoKSB7dGV4dGFyZWEudmFsdWUgPSBjbS5nZXRWYWx1ZSgpO31cblxuICAgIHZhciByZWFsU3VibWl0O1xuICAgIGlmICh0ZXh0YXJlYS5mb3JtKSB7XG4gICAgICBvbih0ZXh0YXJlYS5mb3JtLCBcInN1Ym1pdFwiLCBzYXZlKTtcbiAgICAgIC8vIERlcGxvcmFibGUgaGFjayB0byBtYWtlIHRoZSBzdWJtaXQgbWV0aG9kIGRvIHRoZSByaWdodCB0aGluZy5cbiAgICAgIGlmICghb3B0aW9ucy5sZWF2ZVN1Ym1pdE1ldGhvZEFsb25lKSB7XG4gICAgICAgIHZhciBmb3JtID0gdGV4dGFyZWEuZm9ybTtcbiAgICAgICAgcmVhbFN1Ym1pdCA9IGZvcm0uc3VibWl0O1xuICAgICAgICB0cnkge1xuICAgICAgICAgIHZhciB3cmFwcGVkU3VibWl0ID0gZm9ybS5zdWJtaXQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICBzYXZlKCk7XG4gICAgICAgICAgICBmb3JtLnN1Ym1pdCA9IHJlYWxTdWJtaXQ7XG4gICAgICAgICAgICBmb3JtLnN1Ym1pdCgpO1xuICAgICAgICAgICAgZm9ybS5zdWJtaXQgPSB3cmFwcGVkU3VibWl0O1xuICAgICAgICAgIH07XG4gICAgICAgIH0gY2F0Y2goZSkge31cbiAgICAgIH1cbiAgICB9XG5cbiAgICBvcHRpb25zLmZpbmlzaEluaXQgPSBmdW5jdGlvbiAoY20pIHtcbiAgICAgIGNtLnNhdmUgPSBzYXZlO1xuICAgICAgY20uZ2V0VGV4dEFyZWEgPSBmdW5jdGlvbiAoKSB7IHJldHVybiB0ZXh0YXJlYTsgfTtcbiAgICAgIGNtLnRvVGV4dEFyZWEgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIGNtLnRvVGV4dEFyZWEgPSBpc05hTjsgLy8gUHJldmVudCB0aGlzIGZyb20gYmVpbmcgcmFuIHR3aWNlXG4gICAgICAgIHNhdmUoKTtcbiAgICAgICAgdGV4dGFyZWEucGFyZW50Tm9kZS5yZW1vdmVDaGlsZChjbS5nZXRXcmFwcGVyRWxlbWVudCgpKTtcbiAgICAgICAgdGV4dGFyZWEuc3R5bGUuZGlzcGxheSA9IFwiXCI7XG4gICAgICAgIGlmICh0ZXh0YXJlYS5mb3JtKSB7XG4gICAgICAgICAgb2ZmKHRleHRhcmVhLmZvcm0sIFwic3VibWl0XCIsIHNhdmUpO1xuICAgICAgICAgIGlmICghb3B0aW9ucy5sZWF2ZVN1Ym1pdE1ldGhvZEFsb25lICYmIHR5cGVvZiB0ZXh0YXJlYS5mb3JtLnN1Ym1pdCA9PSBcImZ1bmN0aW9uXCIpXG4gICAgICAgICAgICB7IHRleHRhcmVhLmZvcm0uc3VibWl0ID0gcmVhbFN1Ym1pdDsgfVxuICAgICAgICB9XG4gICAgICB9O1xuICAgIH07XG5cbiAgICB0ZXh0YXJlYS5zdHlsZS5kaXNwbGF5ID0gXCJub25lXCI7XG4gICAgdmFyIGNtID0gQ29kZU1pcnJvcihmdW5jdGlvbiAobm9kZSkgeyByZXR1cm4gdGV4dGFyZWEucGFyZW50Tm9kZS5pbnNlcnRCZWZvcmUobm9kZSwgdGV4dGFyZWEubmV4dFNpYmxpbmcpOyB9LFxuICAgICAgb3B0aW9ucyk7XG4gICAgcmV0dXJuIGNtXG4gIH1cblxuICBmdW5jdGlvbiBhZGRMZWdhY3lQcm9wcyhDb2RlTWlycm9yKSB7XG4gICAgQ29kZU1pcnJvci5vZmYgPSBvZmY7XG4gICAgQ29kZU1pcnJvci5vbiA9IG9uO1xuICAgIENvZGVNaXJyb3Iud2hlZWxFdmVudFBpeGVscyA9IHdoZWVsRXZlbnRQaXhlbHM7XG4gICAgQ29kZU1pcnJvci5Eb2MgPSBEb2M7XG4gICAgQ29kZU1pcnJvci5zcGxpdExpbmVzID0gc3BsaXRMaW5lc0F1dG87XG4gICAgQ29kZU1pcnJvci5jb3VudENvbHVtbiA9IGNvdW50Q29sdW1uO1xuICAgIENvZGVNaXJyb3IuZmluZENvbHVtbiA9IGZpbmRDb2x1bW47XG4gICAgQ29kZU1pcnJvci5pc1dvcmRDaGFyID0gaXNXb3JkQ2hhckJhc2ljO1xuICAgIENvZGVNaXJyb3IuUGFzcyA9IFBhc3M7XG4gICAgQ29kZU1pcnJvci5zaWduYWwgPSBzaWduYWw7XG4gICAgQ29kZU1pcnJvci5MaW5lID0gTGluZTtcbiAgICBDb2RlTWlycm9yLmNoYW5nZUVuZCA9IGNoYW5nZUVuZDtcbiAgICBDb2RlTWlycm9yLnNjcm9sbGJhck1vZGVsID0gc2Nyb2xsYmFyTW9kZWw7XG4gICAgQ29kZU1pcnJvci5Qb3MgPSBQb3M7XG4gICAgQ29kZU1pcnJvci5jbXBQb3MgPSBjbXA7XG4gICAgQ29kZU1pcnJvci5tb2RlcyA9IG1vZGVzO1xuICAgIENvZGVNaXJyb3IubWltZU1vZGVzID0gbWltZU1vZGVzO1xuICAgIENvZGVNaXJyb3IucmVzb2x2ZU1vZGUgPSByZXNvbHZlTW9kZTtcbiAgICBDb2RlTWlycm9yLmdldE1vZGUgPSBnZXRNb2RlO1xuICAgIENvZGVNaXJyb3IubW9kZUV4dGVuc2lvbnMgPSBtb2RlRXh0ZW5zaW9ucztcbiAgICBDb2RlTWlycm9yLmV4dGVuZE1vZGUgPSBleHRlbmRNb2RlO1xuICAgIENvZGVNaXJyb3IuY29weVN0YXRlID0gY29weVN0YXRlO1xuICAgIENvZGVNaXJyb3Iuc3RhcnRTdGF0ZSA9IHN0YXJ0U3RhdGU7XG4gICAgQ29kZU1pcnJvci5pbm5lck1vZGUgPSBpbm5lck1vZGU7XG4gICAgQ29kZU1pcnJvci5jb21tYW5kcyA9IGNvbW1hbmRzO1xuICAgIENvZGVNaXJyb3Iua2V5TWFwID0ga2V5TWFwO1xuICAgIENvZGVNaXJyb3Iua2V5TmFtZSA9IGtleU5hbWU7XG4gICAgQ29kZU1pcnJvci5pc01vZGlmaWVyS2V5ID0gaXNNb2RpZmllcktleTtcbiAgICBDb2RlTWlycm9yLmxvb2t1cEtleSA9IGxvb2t1cEtleTtcbiAgICBDb2RlTWlycm9yLm5vcm1hbGl6ZUtleU1hcCA9IG5vcm1hbGl6ZUtleU1hcDtcbiAgICBDb2RlTWlycm9yLlN0cmluZ1N0cmVhbSA9IFN0cmluZ1N0cmVhbTtcbiAgICBDb2RlTWlycm9yLlNoYXJlZFRleHRNYXJrZXIgPSBTaGFyZWRUZXh0TWFya2VyO1xuICAgIENvZGVNaXJyb3IuVGV4dE1hcmtlciA9IFRleHRNYXJrZXI7XG4gICAgQ29kZU1pcnJvci5MaW5lV2lkZ2V0ID0gTGluZVdpZGdldDtcbiAgICBDb2RlTWlycm9yLmVfcHJldmVudERlZmF1bHQgPSBlX3ByZXZlbnREZWZhdWx0O1xuICAgIENvZGVNaXJyb3IuZV9zdG9wUHJvcGFnYXRpb24gPSBlX3N0b3BQcm9wYWdhdGlvbjtcbiAgICBDb2RlTWlycm9yLmVfc3RvcCA9IGVfc3RvcDtcbiAgICBDb2RlTWlycm9yLmFkZENsYXNzID0gYWRkQ2xhc3M7XG4gICAgQ29kZU1pcnJvci5jb250YWlucyA9IGNvbnRhaW5zO1xuICAgIENvZGVNaXJyb3Iucm1DbGFzcyA9IHJtQ2xhc3M7XG4gICAgQ29kZU1pcnJvci5rZXlOYW1lcyA9IGtleU5hbWVzO1xuICB9XG5cbiAgLy8gRURJVE9SIENPTlNUUlVDVE9SXG5cbiAgZGVmaW5lT3B0aW9ucyhDb2RlTWlycm9yKTtcblxuICBhZGRFZGl0b3JNZXRob2RzKENvZGVNaXJyb3IpO1xuXG4gIC8vIFNldCB1cCBtZXRob2RzIG9uIENvZGVNaXJyb3IncyBwcm90b3R5cGUgdG8gcmVkaXJlY3QgdG8gdGhlIGVkaXRvcidzIGRvY3VtZW50LlxuICB2YXIgZG9udERlbGVnYXRlID0gXCJpdGVyIGluc2VydCByZW1vdmUgY29weSBnZXRFZGl0b3IgY29uc3RydWN0b3JcIi5zcGxpdChcIiBcIik7XG4gIGZvciAodmFyIHByb3AgaW4gRG9jLnByb3RvdHlwZSkgeyBpZiAoRG9jLnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eShwcm9wKSAmJiBpbmRleE9mKGRvbnREZWxlZ2F0ZSwgcHJvcCkgPCAwKVxuICAgIHsgQ29kZU1pcnJvci5wcm90b3R5cGVbcHJvcF0gPSAoZnVuY3Rpb24obWV0aG9kKSB7XG4gICAgICByZXR1cm4gZnVuY3Rpb24oKSB7cmV0dXJuIG1ldGhvZC5hcHBseSh0aGlzLmRvYywgYXJndW1lbnRzKX1cbiAgICB9KShEb2MucHJvdG90eXBlW3Byb3BdKTsgfSB9XG5cbiAgZXZlbnRNaXhpbihEb2MpO1xuICBDb2RlTWlycm9yLmlucHV0U3R5bGVzID0ge1widGV4dGFyZWFcIjogVGV4dGFyZWFJbnB1dCwgXCJjb250ZW50ZWRpdGFibGVcIjogQ29udGVudEVkaXRhYmxlSW5wdXR9O1xuXG4gIC8vIEV4dHJhIGFyZ3VtZW50cyBhcmUgc3RvcmVkIGFzIHRoZSBtb2RlJ3MgZGVwZW5kZW5jaWVzLCB3aGljaCBpc1xuICAvLyB1c2VkIGJ5IChsZWdhY3kpIG1lY2hhbmlzbXMgbGlrZSBsb2FkbW9kZS5qcyB0byBhdXRvbWF0aWNhbGx5XG4gIC8vIGxvYWQgYSBtb2RlLiAoUHJlZmVycmVkIG1lY2hhbmlzbSBpcyB0aGUgcmVxdWlyZS9kZWZpbmUgY2FsbHMuKVxuICBDb2RlTWlycm9yLmRlZmluZU1vZGUgPSBmdW5jdGlvbihuYW1lLyosIG1vZGUsIOKApiovKSB7XG4gICAgaWYgKCFDb2RlTWlycm9yLmRlZmF1bHRzLm1vZGUgJiYgbmFtZSAhPSBcIm51bGxcIikgeyBDb2RlTWlycm9yLmRlZmF1bHRzLm1vZGUgPSBuYW1lOyB9XG4gICAgZGVmaW5lTW9kZS5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICB9O1xuXG4gIENvZGVNaXJyb3IuZGVmaW5lTUlNRSA9IGRlZmluZU1JTUU7XG5cbiAgLy8gTWluaW1hbCBkZWZhdWx0IG1vZGUuXG4gIENvZGVNaXJyb3IuZGVmaW5lTW9kZShcIm51bGxcIiwgZnVuY3Rpb24gKCkgeyByZXR1cm4gKHt0b2tlbjogZnVuY3Rpb24gKHN0cmVhbSkgeyByZXR1cm4gc3RyZWFtLnNraXBUb0VuZCgpOyB9fSk7IH0pO1xuICBDb2RlTWlycm9yLmRlZmluZU1JTUUoXCJ0ZXh0L3BsYWluXCIsIFwibnVsbFwiKTtcblxuICAvLyBFWFRFTlNJT05TXG5cbiAgQ29kZU1pcnJvci5kZWZpbmVFeHRlbnNpb24gPSBmdW5jdGlvbiAobmFtZSwgZnVuYykge1xuICAgIENvZGVNaXJyb3IucHJvdG90eXBlW25hbWVdID0gZnVuYztcbiAgfTtcbiAgQ29kZU1pcnJvci5kZWZpbmVEb2NFeHRlbnNpb24gPSBmdW5jdGlvbiAobmFtZSwgZnVuYykge1xuICAgIERvYy5wcm90b3R5cGVbbmFtZV0gPSBmdW5jO1xuICB9O1xuXG4gIENvZGVNaXJyb3IuZnJvbVRleHRBcmVhID0gZnJvbVRleHRBcmVhO1xuXG4gIGFkZExlZ2FjeVByb3BzKENvZGVNaXJyb3IpO1xuXG4gIENvZGVNaXJyb3IudmVyc2lvbiA9IFwiNS42NS40XCI7XG5cbiAgcmV0dXJuIENvZGVNaXJyb3I7XG5cbn0pKSk7XG4iLCIvLyBDb2RlTWlycm9yLCBjb3B5cmlnaHQgKGMpIGJ5IE1hcmlqbiBIYXZlcmJla2UgYW5kIG90aGVyc1xuLy8gRGlzdHJpYnV0ZWQgdW5kZXIgYW4gTUlUIGxpY2Vuc2U6IGh0dHBzOi8vY29kZW1pcnJvci5uZXQvTElDRU5TRVxuXG4oZnVuY3Rpb24obW9kKSB7XG4gIGlmICh0eXBlb2YgZXhwb3J0cyA9PSBcIm9iamVjdFwiICYmIHR5cGVvZiBtb2R1bGUgPT0gXCJvYmplY3RcIikgLy8gQ29tbW9uSlNcbiAgICBtb2QocmVxdWlyZShcIi4uLy4uL2xpYi9jb2RlbWlycm9yXCIpKTtcbiAgZWxzZSBpZiAodHlwZW9mIGRlZmluZSA9PSBcImZ1bmN0aW9uXCIgJiYgZGVmaW5lLmFtZCkgLy8gQU1EXG4gICAgZGVmaW5lKFtcIi4uLy4uL2xpYi9jb2RlbWlycm9yXCJdLCBtb2QpO1xuICBlbHNlIC8vIFBsYWluIGJyb3dzZXIgZW52XG4gICAgbW9kKENvZGVNaXJyb3IpO1xufSkoZnVuY3Rpb24oQ29kZU1pcnJvcikge1xuICBcInVzZSBzdHJpY3RcIjtcblxuICBmdW5jdGlvbiB3b3JkUmVnZXhwKHdvcmRzKSB7XG4gICAgcmV0dXJuIG5ldyBSZWdFeHAoXCJeKChcIiArIHdvcmRzLmpvaW4oXCIpfChcIikgKyBcIikpXFxcXGJcIik7XG4gIH1cblxuICB2YXIgd29yZE9wZXJhdG9ycyA9IHdvcmRSZWdleHAoW1wiYW5kXCIsIFwib3JcIiwgXCJub3RcIiwgXCJpc1wiXSk7XG4gIHZhciBjb21tb25LZXl3b3JkcyA9IFtcImFzXCIsIFwiYXNzZXJ0XCIsIFwiYnJlYWtcIiwgXCJjbGFzc1wiLCBcImNvbnRpbnVlXCIsXG4gICAgICAgICAgICAgICAgICAgICAgICBcImRlZlwiLCBcImRlbFwiLCBcImVsaWZcIiwgXCJlbHNlXCIsIFwiZXhjZXB0XCIsIFwiZmluYWxseVwiLFxuICAgICAgICAgICAgICAgICAgICAgICAgXCJmb3JcIiwgXCJmcm9tXCIsIFwiZ2xvYmFsXCIsIFwiaWZcIiwgXCJpbXBvcnRcIixcbiAgICAgICAgICAgICAgICAgICAgICAgIFwibGFtYmRhXCIsIFwicGFzc1wiLCBcInJhaXNlXCIsIFwicmV0dXJuXCIsXG4gICAgICAgICAgICAgICAgICAgICAgICBcInRyeVwiLCBcIndoaWxlXCIsIFwid2l0aFwiLCBcInlpZWxkXCIsIFwiaW5cIl07XG4gIHZhciBjb21tb25CdWlsdGlucyA9IFtcImFic1wiLCBcImFsbFwiLCBcImFueVwiLCBcImJpblwiLCBcImJvb2xcIiwgXCJieXRlYXJyYXlcIiwgXCJjYWxsYWJsZVwiLCBcImNoclwiLFxuICAgICAgICAgICAgICAgICAgICAgICAgXCJjbGFzc21ldGhvZFwiLCBcImNvbXBpbGVcIiwgXCJjb21wbGV4XCIsIFwiZGVsYXR0clwiLCBcImRpY3RcIiwgXCJkaXJcIiwgXCJkaXZtb2RcIixcbiAgICAgICAgICAgICAgICAgICAgICAgIFwiZW51bWVyYXRlXCIsIFwiZXZhbFwiLCBcImZpbHRlclwiLCBcImZsb2F0XCIsIFwiZm9ybWF0XCIsIFwiZnJvemVuc2V0XCIsXG4gICAgICAgICAgICAgICAgICAgICAgICBcImdldGF0dHJcIiwgXCJnbG9iYWxzXCIsIFwiaGFzYXR0clwiLCBcImhhc2hcIiwgXCJoZWxwXCIsIFwiaGV4XCIsIFwiaWRcIixcbiAgICAgICAgICAgICAgICAgICAgICAgIFwiaW5wdXRcIiwgXCJpbnRcIiwgXCJpc2luc3RhbmNlXCIsIFwiaXNzdWJjbGFzc1wiLCBcIml0ZXJcIiwgXCJsZW5cIixcbiAgICAgICAgICAgICAgICAgICAgICAgIFwibGlzdFwiLCBcImxvY2Fsc1wiLCBcIm1hcFwiLCBcIm1heFwiLCBcIm1lbW9yeXZpZXdcIiwgXCJtaW5cIiwgXCJuZXh0XCIsXG4gICAgICAgICAgICAgICAgICAgICAgICBcIm9iamVjdFwiLCBcIm9jdFwiLCBcIm9wZW5cIiwgXCJvcmRcIiwgXCJwb3dcIiwgXCJwcm9wZXJ0eVwiLCBcInJhbmdlXCIsXG4gICAgICAgICAgICAgICAgICAgICAgICBcInJlcHJcIiwgXCJyZXZlcnNlZFwiLCBcInJvdW5kXCIsIFwic2V0XCIsIFwic2V0YXR0clwiLCBcInNsaWNlXCIsXG4gICAgICAgICAgICAgICAgICAgICAgICBcInNvcnRlZFwiLCBcInN0YXRpY21ldGhvZFwiLCBcInN0clwiLCBcInN1bVwiLCBcInN1cGVyXCIsIFwidHVwbGVcIixcbiAgICAgICAgICAgICAgICAgICAgICAgIFwidHlwZVwiLCBcInZhcnNcIiwgXCJ6aXBcIiwgXCJfX2ltcG9ydF9fXCIsIFwiTm90SW1wbGVtZW50ZWRcIixcbiAgICAgICAgICAgICAgICAgICAgICAgIFwiRWxsaXBzaXNcIiwgXCJfX2RlYnVnX19cIl07XG4gIENvZGVNaXJyb3IucmVnaXN0ZXJIZWxwZXIoXCJoaW50V29yZHNcIiwgXCJweXRob25cIiwgY29tbW9uS2V5d29yZHMuY29uY2F0KGNvbW1vbkJ1aWx0aW5zKSk7XG5cbiAgZnVuY3Rpb24gdG9wKHN0YXRlKSB7XG4gICAgcmV0dXJuIHN0YXRlLnNjb3Blc1tzdGF0ZS5zY29wZXMubGVuZ3RoIC0gMV07XG4gIH1cblxuICBDb2RlTWlycm9yLmRlZmluZU1vZGUoXCJweXRob25cIiwgZnVuY3Rpb24oY29uZiwgcGFyc2VyQ29uZikge1xuICAgIHZhciBFUlJPUkNMQVNTID0gXCJlcnJvclwiO1xuXG4gICAgdmFyIGRlbGltaXRlcnMgPSBwYXJzZXJDb25mLmRlbGltaXRlcnMgfHwgcGFyc2VyQ29uZi5zaW5nbGVEZWxpbWl0ZXJzIHx8IC9eW1xcKFxcKVxcW1xcXVxce1xcfUAsOmA9O1xcLlxcXFxdLztcbiAgICAvLyAgICAgICAgICAgICAgIChCYWNrd2FyZHMtY29tcGF0aWJpbGl0eSB3aXRoIG9sZCwgY3VtYmVyc29tZSBjb25maWcgc3lzdGVtKVxuICAgIHZhciBvcGVyYXRvcnMgPSBbcGFyc2VyQ29uZi5zaW5nbGVPcGVyYXRvcnMsIHBhcnNlckNvbmYuZG91YmxlT3BlcmF0b3JzLCBwYXJzZXJDb25mLmRvdWJsZURlbGltaXRlcnMsIHBhcnNlckNvbmYudHJpcGxlRGVsaW1pdGVycyxcbiAgICAgICAgICAgICAgICAgICAgIHBhcnNlckNvbmYub3BlcmF0b3JzIHx8IC9eKFstKyovJVxcLyZ8Xl09P3xbPD49XSt8XFwvXFwvPT98XFwqXFwqPT98IT18W34hQF18XFwuXFwuXFwuKS9dXG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBvcGVyYXRvcnMubGVuZ3RoOyBpKyspIGlmICghb3BlcmF0b3JzW2ldKSBvcGVyYXRvcnMuc3BsaWNlKGktLSwgMSlcblxuICAgIHZhciBoYW5naW5nSW5kZW50ID0gcGFyc2VyQ29uZi5oYW5naW5nSW5kZW50IHx8IGNvbmYuaW5kZW50VW5pdDtcblxuICAgIHZhciBteUtleXdvcmRzID0gY29tbW9uS2V5d29yZHMsIG15QnVpbHRpbnMgPSBjb21tb25CdWlsdGlucztcbiAgICBpZiAocGFyc2VyQ29uZi5leHRyYV9rZXl3b3JkcyAhPSB1bmRlZmluZWQpXG4gICAgICBteUtleXdvcmRzID0gbXlLZXl3b3Jkcy5jb25jYXQocGFyc2VyQ29uZi5leHRyYV9rZXl3b3Jkcyk7XG5cbiAgICBpZiAocGFyc2VyQ29uZi5leHRyYV9idWlsdGlucyAhPSB1bmRlZmluZWQpXG4gICAgICBteUJ1aWx0aW5zID0gbXlCdWlsdGlucy5jb25jYXQocGFyc2VyQ29uZi5leHRyYV9idWlsdGlucyk7XG5cbiAgICB2YXIgcHkzID0gIShwYXJzZXJDb25mLnZlcnNpb24gJiYgTnVtYmVyKHBhcnNlckNvbmYudmVyc2lvbikgPCAzKVxuICAgIGlmIChweTMpIHtcbiAgICAgIC8vIHNpbmNlIGh0dHA6Ly9sZWdhY3kucHl0aG9uLm9yZy9kZXYvcGVwcy9wZXAtMDQ2NS8gQCBpcyBhbHNvIGFuIG9wZXJhdG9yXG4gICAgICB2YXIgaWRlbnRpZmllcnMgPSBwYXJzZXJDb25mLmlkZW50aWZpZXJzfHwgL15bX0EtWmEtelxcdTAwQTEtXFx1RkZGRl1bX0EtWmEtejAtOVxcdTAwQTEtXFx1RkZGRl0qLztcbiAgICAgIG15S2V5d29yZHMgPSBteUtleXdvcmRzLmNvbmNhdChbXCJub25sb2NhbFwiLCBcIkZhbHNlXCIsIFwiVHJ1ZVwiLCBcIk5vbmVcIiwgXCJhc3luY1wiLCBcImF3YWl0XCJdKTtcbiAgICAgIG15QnVpbHRpbnMgPSBteUJ1aWx0aW5zLmNvbmNhdChbXCJhc2NpaVwiLCBcImJ5dGVzXCIsIFwiZXhlY1wiLCBcInByaW50XCJdKTtcbiAgICAgIHZhciBzdHJpbmdQcmVmaXhlcyA9IG5ldyBSZWdFeHAoXCJeKChbcmJ1Zl18KGJyKXwocmIpfChmcil8KHJmKSk/KCd7M318XFxcInszfXxbJ1xcXCJdKSlcIiwgXCJpXCIpO1xuICAgIH0gZWxzZSB7XG4gICAgICB2YXIgaWRlbnRpZmllcnMgPSBwYXJzZXJDb25mLmlkZW50aWZpZXJzfHwgL15bX0EtWmEtel1bX0EtWmEtejAtOV0qLztcbiAgICAgIG15S2V5d29yZHMgPSBteUtleXdvcmRzLmNvbmNhdChbXCJleGVjXCIsIFwicHJpbnRcIl0pO1xuICAgICAgbXlCdWlsdGlucyA9IG15QnVpbHRpbnMuY29uY2F0KFtcImFwcGx5XCIsIFwiYmFzZXN0cmluZ1wiLCBcImJ1ZmZlclwiLCBcImNtcFwiLCBcImNvZXJjZVwiLCBcImV4ZWNmaWxlXCIsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIFwiZmlsZVwiLCBcImludGVyblwiLCBcImxvbmdcIiwgXCJyYXdfaW5wdXRcIiwgXCJyZWR1Y2VcIiwgXCJyZWxvYWRcIixcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgXCJ1bmljaHJcIiwgXCJ1bmljb2RlXCIsIFwieHJhbmdlXCIsIFwiRmFsc2VcIiwgXCJUcnVlXCIsIFwiTm9uZVwiXSk7XG4gICAgICB2YXIgc3RyaW5nUHJlZml4ZXMgPSBuZXcgUmVnRXhwKFwiXigoW3J1YmZdfCh1cil8KGJyKSk/KCd7M318XFxcInszfXxbJ1xcXCJdKSlcIiwgXCJpXCIpO1xuICAgIH1cbiAgICB2YXIga2V5d29yZHMgPSB3b3JkUmVnZXhwKG15S2V5d29yZHMpO1xuICAgIHZhciBidWlsdGlucyA9IHdvcmRSZWdleHAobXlCdWlsdGlucyk7XG5cbiAgICAvLyB0b2tlbml6ZXJzXG4gICAgZnVuY3Rpb24gdG9rZW5CYXNlKHN0cmVhbSwgc3RhdGUpIHtcbiAgICAgIHZhciBzb2wgPSBzdHJlYW0uc29sKCkgJiYgc3RhdGUubGFzdFRva2VuICE9IFwiXFxcXFwiXG4gICAgICBpZiAoc29sKSBzdGF0ZS5pbmRlbnQgPSBzdHJlYW0uaW5kZW50YXRpb24oKVxuICAgICAgLy8gSGFuZGxlIHNjb3BlIGNoYW5nZXNcbiAgICAgIGlmIChzb2wgJiYgdG9wKHN0YXRlKS50eXBlID09IFwicHlcIikge1xuICAgICAgICB2YXIgc2NvcGVPZmZzZXQgPSB0b3Aoc3RhdGUpLm9mZnNldDtcbiAgICAgICAgaWYgKHN0cmVhbS5lYXRTcGFjZSgpKSB7XG4gICAgICAgICAgdmFyIGxpbmVPZmZzZXQgPSBzdHJlYW0uaW5kZW50YXRpb24oKTtcbiAgICAgICAgICBpZiAobGluZU9mZnNldCA+IHNjb3BlT2Zmc2V0KVxuICAgICAgICAgICAgcHVzaFB5U2NvcGUoc3RhdGUpO1xuICAgICAgICAgIGVsc2UgaWYgKGxpbmVPZmZzZXQgPCBzY29wZU9mZnNldCAmJiBkZWRlbnQoc3RyZWFtLCBzdGF0ZSkgJiYgc3RyZWFtLnBlZWsoKSAhPSBcIiNcIilcbiAgICAgICAgICAgIHN0YXRlLmVycm9yVG9rZW4gPSB0cnVlO1xuICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHZhciBzdHlsZSA9IHRva2VuQmFzZUlubmVyKHN0cmVhbSwgc3RhdGUpO1xuICAgICAgICAgIGlmIChzY29wZU9mZnNldCA+IDAgJiYgZGVkZW50KHN0cmVhbSwgc3RhdGUpKVxuICAgICAgICAgICAgc3R5bGUgKz0gXCIgXCIgKyBFUlJPUkNMQVNTO1xuICAgICAgICAgIHJldHVybiBzdHlsZTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgcmV0dXJuIHRva2VuQmFzZUlubmVyKHN0cmVhbSwgc3RhdGUpO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIHRva2VuQmFzZUlubmVyKHN0cmVhbSwgc3RhdGUsIGluRm9ybWF0KSB7XG4gICAgICBpZiAoc3RyZWFtLmVhdFNwYWNlKCkpIHJldHVybiBudWxsO1xuXG4gICAgICAvLyBIYW5kbGUgQ29tbWVudHNcbiAgICAgIGlmICghaW5Gb3JtYXQgJiYgc3RyZWFtLm1hdGNoKC9eIy4qLykpIHJldHVybiBcImNvbW1lbnRcIjtcblxuICAgICAgLy8gSGFuZGxlIE51bWJlciBMaXRlcmFsc1xuICAgICAgaWYgKHN0cmVhbS5tYXRjaCgvXlswLTlcXC5dLywgZmFsc2UpKSB7XG4gICAgICAgIHZhciBmbG9hdExpdGVyYWwgPSBmYWxzZTtcbiAgICAgICAgLy8gRmxvYXRzXG4gICAgICAgIGlmIChzdHJlYW0ubWF0Y2goL15bXFxkX10qXFwuXFxkKyhlW1xcK1xcLV0/XFxkKyk/L2kpKSB7IGZsb2F0TGl0ZXJhbCA9IHRydWU7IH1cbiAgICAgICAgaWYgKHN0cmVhbS5tYXRjaCgvXltcXGRfXStcXC5cXGQqLykpIHsgZmxvYXRMaXRlcmFsID0gdHJ1ZTsgfVxuICAgICAgICBpZiAoc3RyZWFtLm1hdGNoKC9eXFwuXFxkKy8pKSB7IGZsb2F0TGl0ZXJhbCA9IHRydWU7IH1cbiAgICAgICAgaWYgKGZsb2F0TGl0ZXJhbCkge1xuICAgICAgICAgIC8vIEZsb2F0IGxpdGVyYWxzIG1heSBiZSBcImltYWdpbmFyeVwiXG4gICAgICAgICAgc3RyZWFtLmVhdCgvSi9pKTtcbiAgICAgICAgICByZXR1cm4gXCJudW1iZXJcIjtcbiAgICAgICAgfVxuICAgICAgICAvLyBJbnRlZ2Vyc1xuICAgICAgICB2YXIgaW50TGl0ZXJhbCA9IGZhbHNlO1xuICAgICAgICAvLyBIZXhcbiAgICAgICAgaWYgKHN0cmVhbS5tYXRjaCgvXjB4WzAtOWEtZl9dKy9pKSkgaW50TGl0ZXJhbCA9IHRydWU7XG4gICAgICAgIC8vIEJpbmFyeVxuICAgICAgICBpZiAoc3RyZWFtLm1hdGNoKC9eMGJbMDFfXSsvaSkpIGludExpdGVyYWwgPSB0cnVlO1xuICAgICAgICAvLyBPY3RhbFxuICAgICAgICBpZiAoc3RyZWFtLm1hdGNoKC9eMG9bMC03X10rL2kpKSBpbnRMaXRlcmFsID0gdHJ1ZTtcbiAgICAgICAgLy8gRGVjaW1hbFxuICAgICAgICBpZiAoc3RyZWFtLm1hdGNoKC9eWzEtOV1bXFxkX10qKGVbXFwrXFwtXT9bXFxkX10rKT8vKSkge1xuICAgICAgICAgIC8vIERlY2ltYWwgbGl0ZXJhbHMgbWF5IGJlIFwiaW1hZ2luYXJ5XCJcbiAgICAgICAgICBzdHJlYW0uZWF0KC9KL2kpO1xuICAgICAgICAgIC8vIFRPRE8gLSBDYW4geW91IGhhdmUgaW1hZ2luYXJ5IGxvbmdzP1xuICAgICAgICAgIGludExpdGVyYWwgPSB0cnVlO1xuICAgICAgICB9XG4gICAgICAgIC8vIFplcm8gYnkgaXRzZWxmIHdpdGggbm8gb3RoZXIgcGllY2Ugb2YgbnVtYmVyLlxuICAgICAgICBpZiAoc3RyZWFtLm1hdGNoKC9eMCg/IVtcXGR4XSkvaSkpIGludExpdGVyYWwgPSB0cnVlO1xuICAgICAgICBpZiAoaW50TGl0ZXJhbCkge1xuICAgICAgICAgIC8vIEludGVnZXIgbGl0ZXJhbHMgbWF5IGJlIFwibG9uZ1wiXG4gICAgICAgICAgc3RyZWFtLmVhdCgvTC9pKTtcbiAgICAgICAgICByZXR1cm4gXCJudW1iZXJcIjtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICAvLyBIYW5kbGUgU3RyaW5nc1xuICAgICAgaWYgKHN0cmVhbS5tYXRjaChzdHJpbmdQcmVmaXhlcykpIHtcbiAgICAgICAgdmFyIGlzRm10U3RyaW5nID0gc3RyZWFtLmN1cnJlbnQoKS50b0xvd2VyQ2FzZSgpLmluZGV4T2YoJ2YnKSAhPT0gLTE7XG4gICAgICAgIGlmICghaXNGbXRTdHJpbmcpIHtcbiAgICAgICAgICBzdGF0ZS50b2tlbml6ZSA9IHRva2VuU3RyaW5nRmFjdG9yeShzdHJlYW0uY3VycmVudCgpLCBzdGF0ZS50b2tlbml6ZSk7XG4gICAgICAgICAgcmV0dXJuIHN0YXRlLnRva2VuaXplKHN0cmVhbSwgc3RhdGUpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHN0YXRlLnRva2VuaXplID0gZm9ybWF0U3RyaW5nRmFjdG9yeShzdHJlYW0uY3VycmVudCgpLCBzdGF0ZS50b2tlbml6ZSk7XG4gICAgICAgICAgcmV0dXJuIHN0YXRlLnRva2VuaXplKHN0cmVhbSwgc3RhdGUpO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgb3BlcmF0b3JzLmxlbmd0aDsgaSsrKVxuICAgICAgICBpZiAoc3RyZWFtLm1hdGNoKG9wZXJhdG9yc1tpXSkpIHJldHVybiBcIm9wZXJhdG9yXCJcblxuICAgICAgaWYgKHN0cmVhbS5tYXRjaChkZWxpbWl0ZXJzKSkgcmV0dXJuIFwicHVuY3R1YXRpb25cIjtcblxuICAgICAgaWYgKHN0YXRlLmxhc3RUb2tlbiA9PSBcIi5cIiAmJiBzdHJlYW0ubWF0Y2goaWRlbnRpZmllcnMpKVxuICAgICAgICByZXR1cm4gXCJwcm9wZXJ0eVwiO1xuXG4gICAgICBpZiAoc3RyZWFtLm1hdGNoKGtleXdvcmRzKSB8fCBzdHJlYW0ubWF0Y2god29yZE9wZXJhdG9ycykpXG4gICAgICAgIHJldHVybiBcImtleXdvcmRcIjtcblxuICAgICAgaWYgKHN0cmVhbS5tYXRjaChidWlsdGlucykpXG4gICAgICAgIHJldHVybiBcImJ1aWx0aW5cIjtcblxuICAgICAgaWYgKHN0cmVhbS5tYXRjaCgvXihzZWxmfGNscylcXGIvKSlcbiAgICAgICAgcmV0dXJuIFwidmFyaWFibGUtMlwiO1xuXG4gICAgICBpZiAoc3RyZWFtLm1hdGNoKGlkZW50aWZpZXJzKSkge1xuICAgICAgICBpZiAoc3RhdGUubGFzdFRva2VuID09IFwiZGVmXCIgfHwgc3RhdGUubGFzdFRva2VuID09IFwiY2xhc3NcIilcbiAgICAgICAgICByZXR1cm4gXCJkZWZcIjtcbiAgICAgICAgcmV0dXJuIFwidmFyaWFibGVcIjtcbiAgICAgIH1cblxuICAgICAgLy8gSGFuZGxlIG5vbi1kZXRlY3RlZCBpdGVtc1xuICAgICAgc3RyZWFtLm5leHQoKTtcbiAgICAgIHJldHVybiBpbkZvcm1hdCA/IG51bGwgOkVSUk9SQ0xBU1M7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gZm9ybWF0U3RyaW5nRmFjdG9yeShkZWxpbWl0ZXIsIHRva2VuT3V0ZXIpIHtcbiAgICAgIHdoaWxlIChcInJ1YmZcIi5pbmRleE9mKGRlbGltaXRlci5jaGFyQXQoMCkudG9Mb3dlckNhc2UoKSkgPj0gMClcbiAgICAgICAgZGVsaW1pdGVyID0gZGVsaW1pdGVyLnN1YnN0cigxKTtcblxuICAgICAgdmFyIHNpbmdsZWxpbmUgPSBkZWxpbWl0ZXIubGVuZ3RoID09IDE7XG4gICAgICB2YXIgT1VUQ0xBU1MgPSBcInN0cmluZ1wiO1xuXG4gICAgICBmdW5jdGlvbiB0b2tlbk5lc3RlZEV4cHIoZGVwdGgpIHtcbiAgICAgICAgcmV0dXJuIGZ1bmN0aW9uKHN0cmVhbSwgc3RhdGUpIHtcbiAgICAgICAgICB2YXIgaW5uZXIgPSB0b2tlbkJhc2VJbm5lcihzdHJlYW0sIHN0YXRlLCB0cnVlKVxuICAgICAgICAgIGlmIChpbm5lciA9PSBcInB1bmN0dWF0aW9uXCIpIHtcbiAgICAgICAgICAgIGlmIChzdHJlYW0uY3VycmVudCgpID09IFwie1wiKSB7XG4gICAgICAgICAgICAgIHN0YXRlLnRva2VuaXplID0gdG9rZW5OZXN0ZWRFeHByKGRlcHRoICsgMSlcbiAgICAgICAgICAgIH0gZWxzZSBpZiAoc3RyZWFtLmN1cnJlbnQoKSA9PSBcIn1cIikge1xuICAgICAgICAgICAgICBpZiAoZGVwdGggPiAxKSBzdGF0ZS50b2tlbml6ZSA9IHRva2VuTmVzdGVkRXhwcihkZXB0aCAtIDEpXG4gICAgICAgICAgICAgIGVsc2Ugc3RhdGUudG9rZW5pemUgPSB0b2tlblN0cmluZ1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgICByZXR1cm4gaW5uZXJcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBmdW5jdGlvbiB0b2tlblN0cmluZyhzdHJlYW0sIHN0YXRlKSB7XG4gICAgICAgIHdoaWxlICghc3RyZWFtLmVvbCgpKSB7XG4gICAgICAgICAgc3RyZWFtLmVhdFdoaWxlKC9bXidcIlxce1xcfVxcXFxdLyk7XG4gICAgICAgICAgaWYgKHN0cmVhbS5lYXQoXCJcXFxcXCIpKSB7XG4gICAgICAgICAgICBzdHJlYW0ubmV4dCgpO1xuICAgICAgICAgICAgaWYgKHNpbmdsZWxpbmUgJiYgc3RyZWFtLmVvbCgpKVxuICAgICAgICAgICAgICByZXR1cm4gT1VUQ0xBU1M7XG4gICAgICAgICAgfSBlbHNlIGlmIChzdHJlYW0ubWF0Y2goZGVsaW1pdGVyKSkge1xuICAgICAgICAgICAgc3RhdGUudG9rZW5pemUgPSB0b2tlbk91dGVyO1xuICAgICAgICAgICAgcmV0dXJuIE9VVENMQVNTO1xuICAgICAgICAgIH0gZWxzZSBpZiAoc3RyZWFtLm1hdGNoKCd7eycpKSB7XG4gICAgICAgICAgICAvLyBpZ25vcmUge3sgaW4gZi1zdHJcbiAgICAgICAgICAgIHJldHVybiBPVVRDTEFTUztcbiAgICAgICAgICB9IGVsc2UgaWYgKHN0cmVhbS5tYXRjaCgneycsIGZhbHNlKSkge1xuICAgICAgICAgICAgLy8gc3dpdGNoIHRvIG5lc3RlZCBtb2RlXG4gICAgICAgICAgICBzdGF0ZS50b2tlbml6ZSA9IHRva2VuTmVzdGVkRXhwcigwKVxuICAgICAgICAgICAgaWYgKHN0cmVhbS5jdXJyZW50KCkpIHJldHVybiBPVVRDTEFTUztcbiAgICAgICAgICAgIGVsc2UgcmV0dXJuIHN0YXRlLnRva2VuaXplKHN0cmVhbSwgc3RhdGUpXG4gICAgICAgICAgfSBlbHNlIGlmIChzdHJlYW0ubWF0Y2goJ319JykpIHtcbiAgICAgICAgICAgIHJldHVybiBPVVRDTEFTUztcbiAgICAgICAgICB9IGVsc2UgaWYgKHN0cmVhbS5tYXRjaCgnfScpKSB7XG4gICAgICAgICAgICAvLyBzaW5nbGUgfSBpbiBmLXN0cmluZyBpcyBhbiBlcnJvclxuICAgICAgICAgICAgcmV0dXJuIEVSUk9SQ0xBU1M7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHN0cmVhbS5lYXQoL1snXCJdLyk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGlmIChzaW5nbGVsaW5lKSB7XG4gICAgICAgICAgaWYgKHBhcnNlckNvbmYuc2luZ2xlTGluZVN0cmluZ0Vycm9ycylcbiAgICAgICAgICAgIHJldHVybiBFUlJPUkNMQVNTO1xuICAgICAgICAgIGVsc2VcbiAgICAgICAgICAgIHN0YXRlLnRva2VuaXplID0gdG9rZW5PdXRlcjtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gT1VUQ0xBU1M7XG4gICAgICB9XG4gICAgICB0b2tlblN0cmluZy5pc1N0cmluZyA9IHRydWU7XG4gICAgICByZXR1cm4gdG9rZW5TdHJpbmc7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gdG9rZW5TdHJpbmdGYWN0b3J5KGRlbGltaXRlciwgdG9rZW5PdXRlcikge1xuICAgICAgd2hpbGUgKFwicnViZlwiLmluZGV4T2YoZGVsaW1pdGVyLmNoYXJBdCgwKS50b0xvd2VyQ2FzZSgpKSA+PSAwKVxuICAgICAgICBkZWxpbWl0ZXIgPSBkZWxpbWl0ZXIuc3Vic3RyKDEpO1xuXG4gICAgICB2YXIgc2luZ2xlbGluZSA9IGRlbGltaXRlci5sZW5ndGggPT0gMTtcbiAgICAgIHZhciBPVVRDTEFTUyA9IFwic3RyaW5nXCI7XG5cbiAgICAgIGZ1bmN0aW9uIHRva2VuU3RyaW5nKHN0cmVhbSwgc3RhdGUpIHtcbiAgICAgICAgd2hpbGUgKCFzdHJlYW0uZW9sKCkpIHtcbiAgICAgICAgICBzdHJlYW0uZWF0V2hpbGUoL1teJ1wiXFxcXF0vKTtcbiAgICAgICAgICBpZiAoc3RyZWFtLmVhdChcIlxcXFxcIikpIHtcbiAgICAgICAgICAgIHN0cmVhbS5uZXh0KCk7XG4gICAgICAgICAgICBpZiAoc2luZ2xlbGluZSAmJiBzdHJlYW0uZW9sKCkpXG4gICAgICAgICAgICAgIHJldHVybiBPVVRDTEFTUztcbiAgICAgICAgICB9IGVsc2UgaWYgKHN0cmVhbS5tYXRjaChkZWxpbWl0ZXIpKSB7XG4gICAgICAgICAgICBzdGF0ZS50b2tlbml6ZSA9IHRva2VuT3V0ZXI7XG4gICAgICAgICAgICByZXR1cm4gT1VUQ0xBU1M7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHN0cmVhbS5lYXQoL1snXCJdLyk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGlmIChzaW5nbGVsaW5lKSB7XG4gICAgICAgICAgaWYgKHBhcnNlckNvbmYuc2luZ2xlTGluZVN0cmluZ0Vycm9ycylcbiAgICAgICAgICAgIHJldHVybiBFUlJPUkNMQVNTO1xuICAgICAgICAgIGVsc2VcbiAgICAgICAgICAgIHN0YXRlLnRva2VuaXplID0gdG9rZW5PdXRlcjtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gT1VUQ0xBU1M7XG4gICAgICB9XG4gICAgICB0b2tlblN0cmluZy5pc1N0cmluZyA9IHRydWU7XG4gICAgICByZXR1cm4gdG9rZW5TdHJpbmc7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gcHVzaFB5U2NvcGUoc3RhdGUpIHtcbiAgICAgIHdoaWxlICh0b3Aoc3RhdGUpLnR5cGUgIT0gXCJweVwiKSBzdGF0ZS5zY29wZXMucG9wKClcbiAgICAgIHN0YXRlLnNjb3Blcy5wdXNoKHtvZmZzZXQ6IHRvcChzdGF0ZSkub2Zmc2V0ICsgY29uZi5pbmRlbnRVbml0LFxuICAgICAgICAgICAgICAgICAgICAgICAgIHR5cGU6IFwicHlcIixcbiAgICAgICAgICAgICAgICAgICAgICAgICBhbGlnbjogbnVsbH0pXG4gICAgfVxuXG4gICAgZnVuY3Rpb24gcHVzaEJyYWNrZXRTY29wZShzdHJlYW0sIHN0YXRlLCB0eXBlKSB7XG4gICAgICB2YXIgYWxpZ24gPSBzdHJlYW0ubWF0Y2goL15bXFxzXFxbXFx7XFwoXSooPzojfCQpLywgZmFsc2UpID8gbnVsbCA6IHN0cmVhbS5jb2x1bW4oKSArIDFcbiAgICAgIHN0YXRlLnNjb3Blcy5wdXNoKHtvZmZzZXQ6IHN0YXRlLmluZGVudCArIGhhbmdpbmdJbmRlbnQsXG4gICAgICAgICAgICAgICAgICAgICAgICAgdHlwZTogdHlwZSxcbiAgICAgICAgICAgICAgICAgICAgICAgICBhbGlnbjogYWxpZ259KVxuICAgIH1cblxuICAgIGZ1bmN0aW9uIGRlZGVudChzdHJlYW0sIHN0YXRlKSB7XG4gICAgICB2YXIgaW5kZW50ZWQgPSBzdHJlYW0uaW5kZW50YXRpb24oKTtcbiAgICAgIHdoaWxlIChzdGF0ZS5zY29wZXMubGVuZ3RoID4gMSAmJiB0b3Aoc3RhdGUpLm9mZnNldCA+IGluZGVudGVkKSB7XG4gICAgICAgIGlmICh0b3Aoc3RhdGUpLnR5cGUgIT0gXCJweVwiKSByZXR1cm4gdHJ1ZTtcbiAgICAgICAgc3RhdGUuc2NvcGVzLnBvcCgpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHRvcChzdGF0ZSkub2Zmc2V0ICE9IGluZGVudGVkO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIHRva2VuTGV4ZXIoc3RyZWFtLCBzdGF0ZSkge1xuICAgICAgaWYgKHN0cmVhbS5zb2woKSkge1xuICAgICAgICBzdGF0ZS5iZWdpbm5pbmdPZkxpbmUgPSB0cnVlO1xuICAgICAgICBzdGF0ZS5kZWRlbnQgPSBmYWxzZTtcbiAgICAgIH1cblxuICAgICAgdmFyIHN0eWxlID0gc3RhdGUudG9rZW5pemUoc3RyZWFtLCBzdGF0ZSk7XG4gICAgICB2YXIgY3VycmVudCA9IHN0cmVhbS5jdXJyZW50KCk7XG5cbiAgICAgIC8vIEhhbmRsZSBkZWNvcmF0b3JzXG4gICAgICBpZiAoc3RhdGUuYmVnaW5uaW5nT2ZMaW5lICYmIGN1cnJlbnQgPT0gXCJAXCIpXG4gICAgICAgIHJldHVybiBzdHJlYW0ubWF0Y2goaWRlbnRpZmllcnMsIGZhbHNlKSA/IFwibWV0YVwiIDogcHkzID8gXCJvcGVyYXRvclwiIDogRVJST1JDTEFTUztcblxuICAgICAgaWYgKC9cXFMvLnRlc3QoY3VycmVudCkpIHN0YXRlLmJlZ2lubmluZ09mTGluZSA9IGZhbHNlO1xuXG4gICAgICBpZiAoKHN0eWxlID09IFwidmFyaWFibGVcIiB8fCBzdHlsZSA9PSBcImJ1aWx0aW5cIilcbiAgICAgICAgICAmJiBzdGF0ZS5sYXN0VG9rZW4gPT0gXCJtZXRhXCIpXG4gICAgICAgIHN0eWxlID0gXCJtZXRhXCI7XG5cbiAgICAgIC8vIEhhbmRsZSBzY29wZSBjaGFuZ2VzLlxuICAgICAgaWYgKGN1cnJlbnQgPT0gXCJwYXNzXCIgfHwgY3VycmVudCA9PSBcInJldHVyblwiKVxuICAgICAgICBzdGF0ZS5kZWRlbnQgPSB0cnVlO1xuXG4gICAgICBpZiAoY3VycmVudCA9PSBcImxhbWJkYVwiKSBzdGF0ZS5sYW1iZGEgPSB0cnVlO1xuICAgICAgaWYgKGN1cnJlbnQgPT0gXCI6XCIgJiYgIXN0YXRlLmxhbWJkYSAmJiB0b3Aoc3RhdGUpLnR5cGUgPT0gXCJweVwiICYmIHN0cmVhbS5tYXRjaCgvXlxccyooPzojfCQpLywgZmFsc2UpKVxuICAgICAgICBwdXNoUHlTY29wZShzdGF0ZSk7XG5cbiAgICAgIGlmIChjdXJyZW50Lmxlbmd0aCA9PSAxICYmICEvc3RyaW5nfGNvbW1lbnQvLnRlc3Qoc3R5bGUpKSB7XG4gICAgICAgIHZhciBkZWxpbWl0ZXJfaW5kZXggPSBcIlsoe1wiLmluZGV4T2YoY3VycmVudCk7XG4gICAgICAgIGlmIChkZWxpbWl0ZXJfaW5kZXggIT0gLTEpXG4gICAgICAgICAgcHVzaEJyYWNrZXRTY29wZShzdHJlYW0sIHN0YXRlLCBcIl0pfVwiLnNsaWNlKGRlbGltaXRlcl9pbmRleCwgZGVsaW1pdGVyX2luZGV4KzEpKTtcblxuICAgICAgICBkZWxpbWl0ZXJfaW5kZXggPSBcIl0pfVwiLmluZGV4T2YoY3VycmVudCk7XG4gICAgICAgIGlmIChkZWxpbWl0ZXJfaW5kZXggIT0gLTEpIHtcbiAgICAgICAgICBpZiAodG9wKHN0YXRlKS50eXBlID09IGN1cnJlbnQpIHN0YXRlLmluZGVudCA9IHN0YXRlLnNjb3Blcy5wb3AoKS5vZmZzZXQgLSBoYW5naW5nSW5kZW50XG4gICAgICAgICAgZWxzZSByZXR1cm4gRVJST1JDTEFTUztcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgaWYgKHN0YXRlLmRlZGVudCAmJiBzdHJlYW0uZW9sKCkgJiYgdG9wKHN0YXRlKS50eXBlID09IFwicHlcIiAmJiBzdGF0ZS5zY29wZXMubGVuZ3RoID4gMSlcbiAgICAgICAgc3RhdGUuc2NvcGVzLnBvcCgpO1xuXG4gICAgICByZXR1cm4gc3R5bGU7XG4gICAgfVxuXG4gICAgdmFyIGV4dGVybmFsID0ge1xuICAgICAgc3RhcnRTdGF0ZTogZnVuY3Rpb24oYmFzZWNvbHVtbikge1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgIHRva2VuaXplOiB0b2tlbkJhc2UsXG4gICAgICAgICAgc2NvcGVzOiBbe29mZnNldDogYmFzZWNvbHVtbiB8fCAwLCB0eXBlOiBcInB5XCIsIGFsaWduOiBudWxsfV0sXG4gICAgICAgICAgaW5kZW50OiBiYXNlY29sdW1uIHx8IDAsXG4gICAgICAgICAgbGFzdFRva2VuOiBudWxsLFxuICAgICAgICAgIGxhbWJkYTogZmFsc2UsXG4gICAgICAgICAgZGVkZW50OiAwXG4gICAgICAgIH07XG4gICAgICB9LFxuXG4gICAgICB0b2tlbjogZnVuY3Rpb24oc3RyZWFtLCBzdGF0ZSkge1xuICAgICAgICB2YXIgYWRkRXJyID0gc3RhdGUuZXJyb3JUb2tlbjtcbiAgICAgICAgaWYgKGFkZEVycikgc3RhdGUuZXJyb3JUb2tlbiA9IGZhbHNlO1xuICAgICAgICB2YXIgc3R5bGUgPSB0b2tlbkxleGVyKHN0cmVhbSwgc3RhdGUpO1xuXG4gICAgICAgIGlmIChzdHlsZSAmJiBzdHlsZSAhPSBcImNvbW1lbnRcIilcbiAgICAgICAgICBzdGF0ZS5sYXN0VG9rZW4gPSAoc3R5bGUgPT0gXCJrZXl3b3JkXCIgfHwgc3R5bGUgPT0gXCJwdW5jdHVhdGlvblwiKSA/IHN0cmVhbS5jdXJyZW50KCkgOiBzdHlsZTtcbiAgICAgICAgaWYgKHN0eWxlID09IFwicHVuY3R1YXRpb25cIikgc3R5bGUgPSBudWxsO1xuXG4gICAgICAgIGlmIChzdHJlYW0uZW9sKCkgJiYgc3RhdGUubGFtYmRhKVxuICAgICAgICAgIHN0YXRlLmxhbWJkYSA9IGZhbHNlO1xuICAgICAgICByZXR1cm4gYWRkRXJyID8gc3R5bGUgKyBcIiBcIiArIEVSUk9SQ0xBU1MgOiBzdHlsZTtcbiAgICAgIH0sXG5cbiAgICAgIGluZGVudDogZnVuY3Rpb24oc3RhdGUsIHRleHRBZnRlcikge1xuICAgICAgICBpZiAoc3RhdGUudG9rZW5pemUgIT0gdG9rZW5CYXNlKVxuICAgICAgICAgIHJldHVybiBzdGF0ZS50b2tlbml6ZS5pc1N0cmluZyA/IENvZGVNaXJyb3IuUGFzcyA6IDA7XG5cbiAgICAgICAgdmFyIHNjb3BlID0gdG9wKHN0YXRlKVxuICAgICAgICB2YXIgY2xvc2luZyA9IHNjb3BlLnR5cGUgPT0gdGV4dEFmdGVyLmNoYXJBdCgwKSB8fFxuICAgICAgICAgICAgc2NvcGUudHlwZSA9PSBcInB5XCIgJiYgIXN0YXRlLmRlZGVudCAmJiAvXihlbHNlOnxlbGlmIHxleGNlcHQgfGZpbmFsbHk6KS8udGVzdCh0ZXh0QWZ0ZXIpXG4gICAgICAgIGlmIChzY29wZS5hbGlnbiAhPSBudWxsKVxuICAgICAgICAgIHJldHVybiBzY29wZS5hbGlnbiAtIChjbG9zaW5nID8gMSA6IDApXG4gICAgICAgIGVsc2VcbiAgICAgICAgICByZXR1cm4gc2NvcGUub2Zmc2V0IC0gKGNsb3NpbmcgPyBoYW5naW5nSW5kZW50IDogMClcbiAgICAgIH0sXG5cbiAgICAgIGVsZWN0cmljSW5wdXQ6IC9eXFxzKihbXFx9XFxdXFwpXXxlbHNlOnxlbGlmIHxleGNlcHQgfGZpbmFsbHk6KSQvLFxuICAgICAgY2xvc2VCcmFja2V0czoge3RyaXBsZXM6IFwiJ1xcXCJcIn0sXG4gICAgICBsaW5lQ29tbWVudDogXCIjXCIsXG4gICAgICBmb2xkOiBcImluZGVudFwiXG4gICAgfTtcbiAgICByZXR1cm4gZXh0ZXJuYWw7XG4gIH0pO1xuXG4gIENvZGVNaXJyb3IuZGVmaW5lTUlNRShcInRleHQveC1weXRob25cIiwgXCJweXRob25cIik7XG5cbiAgdmFyIHdvcmRzID0gZnVuY3Rpb24oc3RyKSB7IHJldHVybiBzdHIuc3BsaXQoXCIgXCIpOyB9O1xuXG4gIENvZGVNaXJyb3IuZGVmaW5lTUlNRShcInRleHQveC1jeXRob25cIiwge1xuICAgIG5hbWU6IFwicHl0aG9uXCIsXG4gICAgZXh0cmFfa2V5d29yZHM6IHdvcmRzKFwiYnkgY2RlZiBjaW1wb3J0IGNwZGVmIGN0eXBlZGVmIGVudW0gZXhjZXB0IFwiK1xuICAgICAgICAgICAgICAgICAgICAgICAgICBcImV4dGVybiBnaWwgaW5jbHVkZSBub2dpbCBwcm9wZXJ0eSBwdWJsaWMgXCIrXG4gICAgICAgICAgICAgICAgICAgICAgICAgIFwicmVhZG9ubHkgc3RydWN0IHVuaW9uIERFRiBJRiBFTElGIEVMU0VcIilcbiAgfSk7XG5cbn0pO1xuIiwiLy8gSW1wb3J0c1xuaW1wb3J0IF9fX0NTU19MT0FERVJfQVBJX1NPVVJDRU1BUF9JTVBPUlRfX18gZnJvbSBcIi4uLy4uLy4uL2Nzcy1sb2FkZXIvZGlzdC9ydW50aW1lL3NvdXJjZU1hcHMuanNcIjtcbmltcG9ydCBfX19DU1NfTE9BREVSX0FQSV9JTVBPUlRfX18gZnJvbSBcIi4uLy4uLy4uL2Nzcy1sb2FkZXIvZGlzdC9ydW50aW1lL2FwaS5qc1wiO1xudmFyIF9fX0NTU19MT0FERVJfRVhQT1JUX19fID0gX19fQ1NTX0xPQURFUl9BUElfSU1QT1JUX19fKF9fX0NTU19MT0FERVJfQVBJX1NPVVJDRU1BUF9JTVBPUlRfX18pO1xuLy8gTW9kdWxlXG5fX19DU1NfTE9BREVSX0VYUE9SVF9fXy5wdXNoKFttb2R1bGUuaWQsIFwiLkNvZGVNaXJyb3ItaGludHMge1xcbiAgcG9zaXRpb246IGFic29sdXRlO1xcbiAgei1pbmRleDogMTA7XFxuICBvdmVyZmxvdzogaGlkZGVuO1xcbiAgbGlzdC1zdHlsZTogbm9uZTtcXG5cXG4gIG1hcmdpbjogMDtcXG4gIHBhZGRpbmc6IDJweDtcXG5cXG4gIC13ZWJraXQtYm94LXNoYWRvdzogMnB4IDNweCA1cHggcmdiYSgwLDAsMCwuMik7XFxuICAtbW96LWJveC1zaGFkb3c6IDJweCAzcHggNXB4IHJnYmEoMCwwLDAsLjIpO1xcbiAgYm94LXNoYWRvdzogMnB4IDNweCA1cHggcmdiYSgwLDAsMCwuMik7XFxuICBib3JkZXItcmFkaXVzOiAzcHg7XFxuICBib3JkZXI6IDFweCBzb2xpZCBzaWx2ZXI7XFxuXFxuICBiYWNrZ3JvdW5kOiB3aGl0ZTtcXG4gIGZvbnQtc2l6ZTogOTAlO1xcbiAgZm9udC1mYW1pbHk6IG1vbm9zcGFjZTtcXG5cXG4gIG1heC1oZWlnaHQ6IDIwZW07XFxuICBvdmVyZmxvdy15OiBhdXRvO1xcbn1cXG5cXG4uQ29kZU1pcnJvci1oaW50IHtcXG4gIG1hcmdpbjogMDtcXG4gIHBhZGRpbmc6IDAgNHB4O1xcbiAgYm9yZGVyLXJhZGl1czogMnB4O1xcbiAgd2hpdGUtc3BhY2U6IHByZTtcXG4gIGNvbG9yOiBibGFjaztcXG4gIGN1cnNvcjogcG9pbnRlcjtcXG59XFxuXFxubGkuQ29kZU1pcnJvci1oaW50LWFjdGl2ZSB7XFxuICBiYWNrZ3JvdW5kOiAjMDhmO1xcbiAgY29sb3I6IHdoaXRlO1xcbn1cXG5cIiwgXCJcIix7XCJ2ZXJzaW9uXCI6MyxcInNvdXJjZXNcIjpbXCJ3ZWJwYWNrOi8vLi9ub2RlX21vZHVsZXMvY29kZW1pcnJvci9hZGRvbi9oaW50L3Nob3ctaGludC5jc3NcIl0sXCJuYW1lc1wiOltdLFwibWFwcGluZ3NcIjpcIkFBQUE7RUFDRSxrQkFBa0I7RUFDbEIsV0FBVztFQUNYLGdCQUFnQjtFQUNoQixnQkFBZ0I7O0VBRWhCLFNBQVM7RUFDVCxZQUFZOztFQUVaLDhDQUE4QztFQUM5QywyQ0FBMkM7RUFDM0Msc0NBQXNDO0VBQ3RDLGtCQUFrQjtFQUNsQix3QkFBd0I7O0VBRXhCLGlCQUFpQjtFQUNqQixjQUFjO0VBQ2Qsc0JBQXNCOztFQUV0QixnQkFBZ0I7RUFDaEIsZ0JBQWdCO0FBQ2xCOztBQUVBO0VBQ0UsU0FBUztFQUNULGNBQWM7RUFDZCxrQkFBa0I7RUFDbEIsZ0JBQWdCO0VBQ2hCLFlBQVk7RUFDWixlQUFlO0FBQ2pCOztBQUVBO0VBQ0UsZ0JBQWdCO0VBQ2hCLFlBQVk7QUFDZFwiLFwic291cmNlc0NvbnRlbnRcIjpbXCIuQ29kZU1pcnJvci1oaW50cyB7XFxuICBwb3NpdGlvbjogYWJzb2x1dGU7XFxuICB6LWluZGV4OiAxMDtcXG4gIG92ZXJmbG93OiBoaWRkZW47XFxuICBsaXN0LXN0eWxlOiBub25lO1xcblxcbiAgbWFyZ2luOiAwO1xcbiAgcGFkZGluZzogMnB4O1xcblxcbiAgLXdlYmtpdC1ib3gtc2hhZG93OiAycHggM3B4IDVweCByZ2JhKDAsMCwwLC4yKTtcXG4gIC1tb3otYm94LXNoYWRvdzogMnB4IDNweCA1cHggcmdiYSgwLDAsMCwuMik7XFxuICBib3gtc2hhZG93OiAycHggM3B4IDVweCByZ2JhKDAsMCwwLC4yKTtcXG4gIGJvcmRlci1yYWRpdXM6IDNweDtcXG4gIGJvcmRlcjogMXB4IHNvbGlkIHNpbHZlcjtcXG5cXG4gIGJhY2tncm91bmQ6IHdoaXRlO1xcbiAgZm9udC1zaXplOiA5MCU7XFxuICBmb250LWZhbWlseTogbW9ub3NwYWNlO1xcblxcbiAgbWF4LWhlaWdodDogMjBlbTtcXG4gIG92ZXJmbG93LXk6IGF1dG87XFxufVxcblxcbi5Db2RlTWlycm9yLWhpbnQge1xcbiAgbWFyZ2luOiAwO1xcbiAgcGFkZGluZzogMCA0cHg7XFxuICBib3JkZXItcmFkaXVzOiAycHg7XFxuICB3aGl0ZS1zcGFjZTogcHJlO1xcbiAgY29sb3I6IGJsYWNrO1xcbiAgY3Vyc29yOiBwb2ludGVyO1xcbn1cXG5cXG5saS5Db2RlTWlycm9yLWhpbnQtYWN0aXZlIHtcXG4gIGJhY2tncm91bmQ6ICMwOGY7XFxuICBjb2xvcjogd2hpdGU7XFxufVxcblwiXSxcInNvdXJjZVJvb3RcIjpcIlwifV0pO1xuLy8gRXhwb3J0c1xuZXhwb3J0IGRlZmF1bHQgX19fQ1NTX0xPQURFUl9FWFBPUlRfX187XG4iLCIvLyBJbXBvcnRzXG5pbXBvcnQgX19fQ1NTX0xPQURFUl9BUElfU09VUkNFTUFQX0lNUE9SVF9fXyBmcm9tIFwiLi4vLi4vLi4vY3NzLWxvYWRlci9kaXN0L3J1bnRpbWUvc291cmNlTWFwcy5qc1wiO1xuaW1wb3J0IF9fX0NTU19MT0FERVJfQVBJX0lNUE9SVF9fXyBmcm9tIFwiLi4vLi4vLi4vY3NzLWxvYWRlci9kaXN0L3J1bnRpbWUvYXBpLmpzXCI7XG5pbXBvcnQgX19fQ1NTX0xPQURFUl9HRVRfVVJMX0lNUE9SVF9fXyBmcm9tIFwiLi4vLi4vLi4vY3NzLWxvYWRlci9kaXN0L3J1bnRpbWUvZ2V0VXJsLmpzXCI7XG52YXIgX19fQ1NTX0xPQURFUl9VUkxfSU1QT1JUXzBfX18gPSBuZXcgVVJMKFwiZGF0YTppbWFnZS9wbmc7YmFzZTY0LGlWQk9SdzBLR2dvQUFBQU5TVWhFVWdBQUFBUUFBQUFEQ0FZQUFBQzA5SzdHQUFBQUFYTlNSMElBcnM0YzZRQUFBQVppUzBkRUFQOEEvd0Qvb0wybmt3QUFBQWx3U0ZsekFBQUxFd0FBQ3hNQkFKcWNHQUFBQUFkMFNVMUZCOXNKRmhRWEViaFRnN1lBQUFBWmRFVllkRU52YlcxbGJuUUFRM0psWVhSbFpDQjNhWFJvSUVkSlRWQlhnUTRYQUFBQU1rbEVRVlFJMTJOa2dJSXZKM1FYTWpBd2RETitPYUVieXNEQTRNUEF3TkROd01Dd2lPSExDZDF6WDA3bzZrQlZHUUVBS0JBTnRvYnNrTk1BQUFBQVNVVk9SSzVDWUlJPVwiLCBpbXBvcnQubWV0YS51cmwpO1xudmFyIF9fX0NTU19MT0FERVJfVVJMX0lNUE9SVF8xX19fID0gbmV3IFVSTChcImRhdGE6aW1hZ2UvcG5nO2Jhc2U2NCxpVkJPUncwS0dnb0FBQUFOU1VoRVVnQUFBQVFBQUFBRENBWUFBQUMwOUs3R0FBQUFBWE5TUjBJQXJzNGM2UUFBQUFaaVMwZEVBUDhBL3dEL29MMm5rd0FBQUFsd1NGbHpBQUFMRXdBQUN4TUJBSnFjR0FBQUFBZDBTVTFGQjlzSkR3NGNPQ1cxL0tJQUFBQVpkRVZZZEVOdmJXMWxiblFBUTNKbFlYUmxaQ0IzYVhSb0lFZEpUVkJYZ1E0WEFBQUFIRWxFUVZRSTEyTmdnSUwvREF6L0dkQTUveGtZL3FQS01EQXdBQURMWndmNXJ2bStMUUFBQUFCSlJVNUVya0pnZ2c9PVwiLCBpbXBvcnQubWV0YS51cmwpO1xudmFyIF9fX0NTU19MT0FERVJfVVJMX0lNUE9SVF8yX19fID0gbmV3IFVSTChcImRhdGE6aW1hZ2UvcG5nO2Jhc2U2NCxpVkJPUncwS0dnb0FBQUFOU1VoRVVnQUFBQkFBQUFBUUNBTUFBQUFvTFE5VEFBQUFObEJNVkVYL3V3RHZyd0QvdXdEL3V3RC91d0QvdXdEL3V3RC91d0QvdXdENnR3RC91d0FBQUFEdXJ3RDJ0UUQ3dUFEK3VnQUFBQUQvdXdEaG1lVFJBQUFBREhSU1RsTUo4bU4xRVljYm1paXhnQUNtN1didUFBQUFWa2xFUVZSNDJuM1BVUXFBSUJCRlVVMUxMYzN1L2pkYk9Kb1cxUDA4REE5R2JhOCtZV0o2Z05Kb05ZSUJ6QUEyY2hCdGg1a0xtRzlZVW9HME5IQVV3Rlh3TzlMdUJRTDFnaUNRYjhnQzlPcm8ydnA1cm5jQ0lZOEw4dUV4NVprQUFBQUFTVVZPUks1Q1lJST1cIiwgaW1wb3J0Lm1ldGEudXJsKTtcbnZhciBfX19DU1NfTE9BREVSX1VSTF9JTVBPUlRfM19fXyA9IG5ldyBVUkwoXCJkYXRhOmltYWdlL3BuZztiYXNlNjQsaVZCT1J3MEtHZ29BQUFBTlNVaEVVZ0FBQUJBQUFBQVFDQU1BQUFBb0xROVRBQUFBSGxCTVZFVzdBQUM3QUFDeEFBQzdBQUM3QUFBQUFBQzRBQUM1QUFELy8vKzdBQUFVZGNscEFBQUFCblJTVGxNWG5PUlNpd0NLMFpLU0FBQUFUVWxFUVZSNDJtV1BPUTdBUUFnRHVRTHgvejhjc1lSbVBSSUZJd1JHbm9zUnJwYW12a0tpMEZUSWlNQVNSM2hoS1craEFONi90SVdodTlQRFdpVEdORWtUdElPdWNBNU95cjlja1BnQVdtMEdQQm9nNnY0QUFBQUFTVVZPUks1Q1lJST1cIiwgaW1wb3J0Lm1ldGEudXJsKTtcbnZhciBfX19DU1NfTE9BREVSX1VSTF9JTVBPUlRfNF9fXyA9IG5ldyBVUkwoXCJkYXRhOmltYWdlL3BuZztiYXNlNjQsaVZCT1J3MEtHZ29BQUFBTlNVaEVVZ0FBQUFjQUFBQUhDQU1BQUFEempLZmhBQUFBQ1ZCTVZFVUFBQUFBQUFDL3Y3OTE0a3lIQUFBQUFYUlNUbE1BUU9iWVpnQUFBQ05KUkVGVWVObzFpb0VKQUFBSXdtei9IOTBpRkZTR0pnRk1lM2dhTFowb2QrOS9BUVowQURvc2JZcmFBQUFBQUVsRlRrU3VRbUNDXCIsIGltcG9ydC5tZXRhLnVybCk7XG52YXIgX19fQ1NTX0xPQURFUl9FWFBPUlRfX18gPSBfX19DU1NfTE9BREVSX0FQSV9JTVBPUlRfX18oX19fQ1NTX0xPQURFUl9BUElfU09VUkNFTUFQX0lNUE9SVF9fXyk7XG52YXIgX19fQ1NTX0xPQURFUl9VUkxfUkVQTEFDRU1FTlRfMF9fXyA9IF9fX0NTU19MT0FERVJfR0VUX1VSTF9JTVBPUlRfX18oX19fQ1NTX0xPQURFUl9VUkxfSU1QT1JUXzBfX18pO1xudmFyIF9fX0NTU19MT0FERVJfVVJMX1JFUExBQ0VNRU5UXzFfX18gPSBfX19DU1NfTE9BREVSX0dFVF9VUkxfSU1QT1JUX19fKF9fX0NTU19MT0FERVJfVVJMX0lNUE9SVF8xX19fKTtcbnZhciBfX19DU1NfTE9BREVSX1VSTF9SRVBMQUNFTUVOVF8yX19fID0gX19fQ1NTX0xPQURFUl9HRVRfVVJMX0lNUE9SVF9fXyhfX19DU1NfTE9BREVSX1VSTF9JTVBPUlRfMl9fXyk7XG52YXIgX19fQ1NTX0xPQURFUl9VUkxfUkVQTEFDRU1FTlRfM19fXyA9IF9fX0NTU19MT0FERVJfR0VUX1VSTF9JTVBPUlRfX18oX19fQ1NTX0xPQURFUl9VUkxfSU1QT1JUXzNfX18pO1xudmFyIF9fX0NTU19MT0FERVJfVVJMX1JFUExBQ0VNRU5UXzRfX18gPSBfX19DU1NfTE9BREVSX0dFVF9VUkxfSU1QT1JUX19fKF9fX0NTU19MT0FERVJfVVJMX0lNUE9SVF80X19fKTtcbi8vIE1vZHVsZVxuX19fQ1NTX0xPQURFUl9FWFBPUlRfX18ucHVzaChbbW9kdWxlLmlkLCBcIi8qIFRoZSBsaW50IG1hcmtlciBndXR0ZXIgKi9cXG4uQ29kZU1pcnJvci1saW50LW1hcmtlcnMge1xcbiAgd2lkdGg6IDE2cHg7XFxufVxcblxcbi5Db2RlTWlycm9yLWxpbnQtdG9vbHRpcCB7XFxuICBiYWNrZ3JvdW5kLWNvbG9yOiAjZmZkO1xcbiAgYm9yZGVyOiAxcHggc29saWQgYmxhY2s7XFxuICBib3JkZXItcmFkaXVzOiA0cHggNHB4IDRweCA0cHg7XFxuICBjb2xvcjogYmxhY2s7XFxuICBmb250LWZhbWlseTogbW9ub3NwYWNlO1xcbiAgZm9udC1zaXplOiAxMHB0O1xcbiAgb3ZlcmZsb3c6IGhpZGRlbjtcXG4gIHBhZGRpbmc6IDJweCA1cHg7XFxuICBwb3NpdGlvbjogZml4ZWQ7XFxuICB3aGl0ZS1zcGFjZTogcHJlO1xcbiAgd2hpdGUtc3BhY2U6IHByZS13cmFwO1xcbiAgei1pbmRleDogMTAwO1xcbiAgbWF4LXdpZHRoOiA2MDBweDtcXG4gIG9wYWNpdHk6IDA7XFxuICB0cmFuc2l0aW9uOiBvcGFjaXR5IC40cztcXG4gIC1tb3otdHJhbnNpdGlvbjogb3BhY2l0eSAuNHM7XFxuICAtd2Via2l0LXRyYW5zaXRpb246IG9wYWNpdHkgLjRzO1xcbiAgLW8tdHJhbnNpdGlvbjogb3BhY2l0eSAuNHM7XFxuICAtbXMtdHJhbnNpdGlvbjogb3BhY2l0eSAuNHM7XFxufVxcblxcbi5Db2RlTWlycm9yLWxpbnQtbWFyayB7XFxuICBiYWNrZ3JvdW5kLXBvc2l0aW9uOiBsZWZ0IGJvdHRvbTtcXG4gIGJhY2tncm91bmQtcmVwZWF0OiByZXBlYXQteDtcXG59XFxuXFxuLkNvZGVNaXJyb3ItbGludC1tYXJrLXdhcm5pbmcge1xcbiAgYmFja2dyb3VuZC1pbWFnZTogdXJsKFwiICsgX19fQ1NTX0xPQURFUl9VUkxfUkVQTEFDRU1FTlRfMF9fXyArIFwiKTtcXG59XFxuXFxuLkNvZGVNaXJyb3ItbGludC1tYXJrLWVycm9yIHtcXG4gIGJhY2tncm91bmQtaW1hZ2U6IHVybChcIiArIF9fX0NTU19MT0FERVJfVVJMX1JFUExBQ0VNRU5UXzFfX18gKyBcIik7XFxufVxcblxcbi5Db2RlTWlycm9yLWxpbnQtbWFya2VyIHtcXG4gIGJhY2tncm91bmQtcG9zaXRpb246IGNlbnRlciBjZW50ZXI7XFxuICBiYWNrZ3JvdW5kLXJlcGVhdDogbm8tcmVwZWF0O1xcbiAgY3Vyc29yOiBwb2ludGVyO1xcbiAgZGlzcGxheTogaW5saW5lLWJsb2NrO1xcbiAgaGVpZ2h0OiAxNnB4O1xcbiAgd2lkdGg6IDE2cHg7XFxuICB2ZXJ0aWNhbC1hbGlnbjogbWlkZGxlO1xcbiAgcG9zaXRpb246IHJlbGF0aXZlO1xcbn1cXG5cXG4uQ29kZU1pcnJvci1saW50LW1lc3NhZ2Uge1xcbiAgcGFkZGluZy1sZWZ0OiAxOHB4O1xcbiAgYmFja2dyb3VuZC1wb3NpdGlvbjogdG9wIGxlZnQ7XFxuICBiYWNrZ3JvdW5kLXJlcGVhdDogbm8tcmVwZWF0O1xcbn1cXG5cXG4uQ29kZU1pcnJvci1saW50LW1hcmtlci13YXJuaW5nLCAuQ29kZU1pcnJvci1saW50LW1lc3NhZ2Utd2FybmluZyB7XFxuICBiYWNrZ3JvdW5kLWltYWdlOiB1cmwoXCIgKyBfX19DU1NfTE9BREVSX1VSTF9SRVBMQUNFTUVOVF8yX19fICsgXCIpO1xcbn1cXG5cXG4uQ29kZU1pcnJvci1saW50LW1hcmtlci1lcnJvciwgLkNvZGVNaXJyb3ItbGludC1tZXNzYWdlLWVycm9yIHtcXG4gIGJhY2tncm91bmQtaW1hZ2U6IHVybChcIiArIF9fX0NTU19MT0FERVJfVVJMX1JFUExBQ0VNRU5UXzNfX18gKyBcIik7XFxufVxcblxcbi5Db2RlTWlycm9yLWxpbnQtbWFya2VyLW11bHRpcGxlIHtcXG4gIGJhY2tncm91bmQtaW1hZ2U6IHVybChcIiArIF9fX0NTU19MT0FERVJfVVJMX1JFUExBQ0VNRU5UXzRfX18gKyBcIik7XFxuICBiYWNrZ3JvdW5kLXJlcGVhdDogbm8tcmVwZWF0O1xcbiAgYmFja2dyb3VuZC1wb3NpdGlvbjogcmlnaHQgYm90dG9tO1xcbiAgd2lkdGg6IDEwMCU7IGhlaWdodDogMTAwJTtcXG59XFxuXFxuLkNvZGVNaXJyb3ItbGludC1saW5lLWVycm9yIHtcXG4gIGJhY2tncm91bmQtY29sb3I6IHJnYmEoMTgzLCA3NiwgODEsIDAuMDgpO1xcbn1cXG5cXG4uQ29kZU1pcnJvci1saW50LWxpbmUtd2FybmluZyB7XFxuICBiYWNrZ3JvdW5kLWNvbG9yOiByZ2JhKDI1NSwgMjExLCAwLCAwLjEpO1xcbn1cXG5cIiwgXCJcIix7XCJ2ZXJzaW9uXCI6MyxcInNvdXJjZXNcIjpbXCJ3ZWJwYWNrOi8vLi9ub2RlX21vZHVsZXMvY29kZW1pcnJvci9hZGRvbi9saW50L2xpbnQuY3NzXCJdLFwibmFtZXNcIjpbXSxcIm1hcHBpbmdzXCI6XCJBQUFBLDJCQUEyQjtBQUMzQjtFQUNFLFdBQVc7QUFDYjs7QUFFQTtFQUNFLHNCQUFzQjtFQUN0Qix1QkFBdUI7RUFDdkIsOEJBQThCO0VBQzlCLFlBQVk7RUFDWixzQkFBc0I7RUFDdEIsZUFBZTtFQUNmLGdCQUFnQjtFQUNoQixnQkFBZ0I7RUFDaEIsZUFBZTtFQUNmLGdCQUFnQjtFQUNoQixxQkFBcUI7RUFDckIsWUFBWTtFQUNaLGdCQUFnQjtFQUNoQixVQUFVO0VBQ1YsdUJBQXVCO0VBQ3ZCLDRCQUE0QjtFQUM1QiwrQkFBK0I7RUFDL0IsMEJBQTBCO0VBQzFCLDJCQUEyQjtBQUM3Qjs7QUFFQTtFQUNFLGdDQUFnQztFQUNoQywyQkFBMkI7QUFDN0I7O0FBRUE7RUFDRSx5REFBK1U7QUFDalY7O0FBRUE7RUFDRSx5REFBbVQ7QUFDclQ7O0FBRUE7RUFDRSxrQ0FBa0M7RUFDbEMsNEJBQTRCO0VBQzVCLGVBQWU7RUFDZixxQkFBcUI7RUFDckIsWUFBWTtFQUNaLFdBQVc7RUFDWCxzQkFBc0I7RUFDdEIsa0JBQWtCO0FBQ3BCOztBQUVBO0VBQ0Usa0JBQWtCO0VBQ2xCLDZCQUE2QjtFQUM3Qiw0QkFBNEI7QUFDOUI7O0FBRUE7RUFDRSx5REFBdVc7QUFDelc7O0FBRUE7RUFDRSx5REFBbVQ7QUFDclQ7O0FBRUE7RUFDRSx5REFBdU47RUFDdk4sNEJBQTRCO0VBQzVCLGlDQUFpQztFQUNqQyxXQUFXLEVBQUUsWUFBWTtBQUMzQjs7QUFFQTtFQUNFLHlDQUF5QztBQUMzQzs7QUFFQTtFQUNFLHdDQUF3QztBQUMxQ1wiLFwic291cmNlc0NvbnRlbnRcIjpbXCIvKiBUaGUgbGludCBtYXJrZXIgZ3V0dGVyICovXFxuLkNvZGVNaXJyb3ItbGludC1tYXJrZXJzIHtcXG4gIHdpZHRoOiAxNnB4O1xcbn1cXG5cXG4uQ29kZU1pcnJvci1saW50LXRvb2x0aXAge1xcbiAgYmFja2dyb3VuZC1jb2xvcjogI2ZmZDtcXG4gIGJvcmRlcjogMXB4IHNvbGlkIGJsYWNrO1xcbiAgYm9yZGVyLXJhZGl1czogNHB4IDRweCA0cHggNHB4O1xcbiAgY29sb3I6IGJsYWNrO1xcbiAgZm9udC1mYW1pbHk6IG1vbm9zcGFjZTtcXG4gIGZvbnQtc2l6ZTogMTBwdDtcXG4gIG92ZXJmbG93OiBoaWRkZW47XFxuICBwYWRkaW5nOiAycHggNXB4O1xcbiAgcG9zaXRpb246IGZpeGVkO1xcbiAgd2hpdGUtc3BhY2U6IHByZTtcXG4gIHdoaXRlLXNwYWNlOiBwcmUtd3JhcDtcXG4gIHotaW5kZXg6IDEwMDtcXG4gIG1heC13aWR0aDogNjAwcHg7XFxuICBvcGFjaXR5OiAwO1xcbiAgdHJhbnNpdGlvbjogb3BhY2l0eSAuNHM7XFxuICAtbW96LXRyYW5zaXRpb246IG9wYWNpdHkgLjRzO1xcbiAgLXdlYmtpdC10cmFuc2l0aW9uOiBvcGFjaXR5IC40cztcXG4gIC1vLXRyYW5zaXRpb246IG9wYWNpdHkgLjRzO1xcbiAgLW1zLXRyYW5zaXRpb246IG9wYWNpdHkgLjRzO1xcbn1cXG5cXG4uQ29kZU1pcnJvci1saW50LW1hcmsge1xcbiAgYmFja2dyb3VuZC1wb3NpdGlvbjogbGVmdCBib3R0b207XFxuICBiYWNrZ3JvdW5kLXJlcGVhdDogcmVwZWF0LXg7XFxufVxcblxcbi5Db2RlTWlycm9yLWxpbnQtbWFyay13YXJuaW5nIHtcXG4gIGJhY2tncm91bmQtaW1hZ2U6IHVybChcXFwiZGF0YTppbWFnZS9wbmc7YmFzZTY0LGlWQk9SdzBLR2dvQUFBQU5TVWhFVWdBQUFBUUFBQUFEQ0FZQUFBQzA5SzdHQUFBQUFYTlNSMElBcnM0YzZRQUFBQVppUzBkRUFQOEEvd0Qvb0wybmt3QUFBQWx3U0ZsekFBQUxFd0FBQ3hNQkFKcWNHQUFBQUFkMFNVMUZCOXNKRmhRWEViaFRnN1lBQUFBWmRFVllkRU52YlcxbGJuUUFRM0psWVhSbFpDQjNhWFJvSUVkSlRWQlhnUTRYQUFBQU1rbEVRVlFJMTJOa2dJSXZKM1FYTWpBd2RETitPYUVieXNEQTRNUEF3TkROd01Dd2lPSExDZDF6WDA3bzZrQlZHUUVBS0JBTnRvYnNrTk1BQUFBQVNVVk9SSzVDWUlJPVxcXCIpO1xcbn1cXG5cXG4uQ29kZU1pcnJvci1saW50LW1hcmstZXJyb3Ige1xcbiAgYmFja2dyb3VuZC1pbWFnZTogdXJsKFxcXCJkYXRhOmltYWdlL3BuZztiYXNlNjQsaVZCT1J3MEtHZ29BQUFBTlNVaEVVZ0FBQUFRQUFBQURDQVlBQUFDMDlLN0dBQUFBQVhOU1IwSUFyczRjNlFBQUFBWmlTMGRFQVA4QS93RC9vTDJua3dBQUFBbHdTRmx6QUFBTEV3QUFDeE1CQUpxY0dBQUFBQWQwU1UxRkI5c0pEdzRjT0NXMS9LSUFBQUFaZEVWWWRFTnZiVzFsYm5RQVEzSmxZWFJsWkNCM2FYUm9JRWRKVFZCWGdRNFhBQUFBSEVsRVFWUUkxMk5nZ0lML0RBei9HZEE1L3hrWS9xUEtNREF3QUFETFp3ZjVydm0rTFFBQUFBQkpSVTVFcmtKZ2dnPT1cXFwiKTtcXG59XFxuXFxuLkNvZGVNaXJyb3ItbGludC1tYXJrZXIge1xcbiAgYmFja2dyb3VuZC1wb3NpdGlvbjogY2VudGVyIGNlbnRlcjtcXG4gIGJhY2tncm91bmQtcmVwZWF0OiBuby1yZXBlYXQ7XFxuICBjdXJzb3I6IHBvaW50ZXI7XFxuICBkaXNwbGF5OiBpbmxpbmUtYmxvY2s7XFxuICBoZWlnaHQ6IDE2cHg7XFxuICB3aWR0aDogMTZweDtcXG4gIHZlcnRpY2FsLWFsaWduOiBtaWRkbGU7XFxuICBwb3NpdGlvbjogcmVsYXRpdmU7XFxufVxcblxcbi5Db2RlTWlycm9yLWxpbnQtbWVzc2FnZSB7XFxuICBwYWRkaW5nLWxlZnQ6IDE4cHg7XFxuICBiYWNrZ3JvdW5kLXBvc2l0aW9uOiB0b3AgbGVmdDtcXG4gIGJhY2tncm91bmQtcmVwZWF0OiBuby1yZXBlYXQ7XFxufVxcblxcbi5Db2RlTWlycm9yLWxpbnQtbWFya2VyLXdhcm5pbmcsIC5Db2RlTWlycm9yLWxpbnQtbWVzc2FnZS13YXJuaW5nIHtcXG4gIGJhY2tncm91bmQtaW1hZ2U6IHVybChcXFwiZGF0YTppbWFnZS9wbmc7YmFzZTY0LGlWQk9SdzBLR2dvQUFBQU5TVWhFVWdBQUFCQUFBQUFRQ0FNQUFBQW9MUTlUQUFBQU5sQk1WRVgvdXdEdnJ3RC91d0QvdXdEL3V3RC91d0QvdXdEL3V3RC91d0Q2dHdEL3V3QUFBQUR1cndEMnRRRDd1QUQrdWdBQUFBRC91d0RobWVUUkFBQUFESFJTVGxNSjhtTjFFWWNibWlpeGdBQ203V2J1QUFBQVZrbEVRVlI0Mm4zUFVRcUFJQkJGVVUxTExjM3UvamRiT0pvVzFQMDhEQTlHYmE4K1lXSjZnTkpvTllJQnpBQTJjaEJ0aDVrTG1HOVlVb0cwTkhBVXdGWHdPOUx1QlFMMWdpQ1FiOGdDOU9ybzJ2cDVybmNDSVk4TDh1RXg1WmtBQUFBQVNVVk9SSzVDWUlJPVxcXCIpO1xcbn1cXG5cXG4uQ29kZU1pcnJvci1saW50LW1hcmtlci1lcnJvciwgLkNvZGVNaXJyb3ItbGludC1tZXNzYWdlLWVycm9yIHtcXG4gIGJhY2tncm91bmQtaW1hZ2U6IHVybChcXFwiZGF0YTppbWFnZS9wbmc7YmFzZTY0LGlWQk9SdzBLR2dvQUFBQU5TVWhFVWdBQUFCQUFBQUFRQ0FNQUFBQW9MUTlUQUFBQUhsQk1WRVc3QUFDN0FBQ3hBQUM3QUFDN0FBQUFBQUM0QUFDNUFBRC8vLys3QUFBVWRjbHBBQUFBQm5SU1RsTVhuT1JTaXdDSzBaS1NBQUFBVFVsRVFWUjQybVdQT1E3QVFBZ0R1UUx4L3o4Y3NZUm1QUklGSXdSR25vc1JycGFtdmtLaTBGVElpTUFTUjNoaEtXK2hBTjYvdElXaHU5UERXaVRHTkVrVHRJT3VjQTVPeXI5Y2tQZ0FXbTBHUEJvZzZ2NEFBQUFBU1VWT1JLNUNZSUk9XFxcIik7XFxufVxcblxcbi5Db2RlTWlycm9yLWxpbnQtbWFya2VyLW11bHRpcGxlIHtcXG4gIGJhY2tncm91bmQtaW1hZ2U6IHVybChcXFwiZGF0YTppbWFnZS9wbmc7YmFzZTY0LGlWQk9SdzBLR2dvQUFBQU5TVWhFVWdBQUFBY0FBQUFIQ0FNQUFBRHpqS2ZoQUFBQUNWQk1WRVVBQUFBQUFBQy92NzkxNGt5SEFBQUFBWFJTVGxNQVFPYllaZ0FBQUNOSlJFRlVlTm8xaW9FSkFBQUl3bXovSDkwaUZGU0dKZ0ZNZTNnYUxaMG9kKzkvQVFaMEFEb3NiWXJhQUFBQUFFbEZUa1N1UW1DQ1xcXCIpO1xcbiAgYmFja2dyb3VuZC1yZXBlYXQ6IG5vLXJlcGVhdDtcXG4gIGJhY2tncm91bmQtcG9zaXRpb246IHJpZ2h0IGJvdHRvbTtcXG4gIHdpZHRoOiAxMDAlOyBoZWlnaHQ6IDEwMCU7XFxufVxcblxcbi5Db2RlTWlycm9yLWxpbnQtbGluZS1lcnJvciB7XFxuICBiYWNrZ3JvdW5kLWNvbG9yOiByZ2JhKDE4MywgNzYsIDgxLCAwLjA4KTtcXG59XFxuXFxuLkNvZGVNaXJyb3ItbGludC1saW5lLXdhcm5pbmcge1xcbiAgYmFja2dyb3VuZC1jb2xvcjogcmdiYSgyNTUsIDIxMSwgMCwgMC4xKTtcXG59XFxuXCJdLFwic291cmNlUm9vdFwiOlwiXCJ9XSk7XG4vLyBFeHBvcnRzXG5leHBvcnQgZGVmYXVsdCBfX19DU1NfTE9BREVSX0VYUE9SVF9fXztcbiIsIi8vIEltcG9ydHNcbmltcG9ydCBfX19DU1NfTE9BREVSX0FQSV9TT1VSQ0VNQVBfSU1QT1JUX19fIGZyb20gXCIuLi8uLi8uLi9jc3MtbG9hZGVyL2Rpc3QvcnVudGltZS9zb3VyY2VNYXBzLmpzXCI7XG5pbXBvcnQgX19fQ1NTX0xPQURFUl9BUElfSU1QT1JUX19fIGZyb20gXCIuLi8uLi8uLi9jc3MtbG9hZGVyL2Rpc3QvcnVudGltZS9hcGkuanNcIjtcbnZhciBfX19DU1NfTE9BREVSX0VYUE9SVF9fXyA9IF9fX0NTU19MT0FERVJfQVBJX0lNUE9SVF9fXyhfX19DU1NfTE9BREVSX0FQSV9TT1VSQ0VNQVBfSU1QT1JUX19fKTtcbi8vIE1vZHVsZVxuX19fQ1NTX0xPQURFUl9FWFBPUlRfX18ucHVzaChbbW9kdWxlLmlkLCBcIi5Db2RlTWlycm9yLXNpbXBsZXNjcm9sbC1ob3Jpem9udGFsIGRpdiwgLkNvZGVNaXJyb3Itc2ltcGxlc2Nyb2xsLXZlcnRpY2FsIGRpdiB7XFxuICBwb3NpdGlvbjogYWJzb2x1dGU7XFxuICBiYWNrZ3JvdW5kOiAjY2NjO1xcbiAgLW1vei1ib3gtc2l6aW5nOiBib3JkZXItYm94O1xcbiAgYm94LXNpemluZzogYm9yZGVyLWJveDtcXG4gIGJvcmRlcjogMXB4IHNvbGlkICNiYmI7XFxuICBib3JkZXItcmFkaXVzOiAycHg7XFxufVxcblxcbi5Db2RlTWlycm9yLXNpbXBsZXNjcm9sbC1ob3Jpem9udGFsLCAuQ29kZU1pcnJvci1zaW1wbGVzY3JvbGwtdmVydGljYWwge1xcbiAgcG9zaXRpb246IGFic29sdXRlO1xcbiAgei1pbmRleDogNjtcXG4gIGJhY2tncm91bmQ6ICNlZWU7XFxufVxcblxcbi5Db2RlTWlycm9yLXNpbXBsZXNjcm9sbC1ob3Jpem9udGFsIHtcXG4gIGJvdHRvbTogMDsgbGVmdDogMDtcXG4gIGhlaWdodDogOHB4O1xcbn1cXG4uQ29kZU1pcnJvci1zaW1wbGVzY3JvbGwtaG9yaXpvbnRhbCBkaXYge1xcbiAgYm90dG9tOiAwO1xcbiAgaGVpZ2h0OiAxMDAlO1xcbn1cXG5cXG4uQ29kZU1pcnJvci1zaW1wbGVzY3JvbGwtdmVydGljYWwge1xcbiAgcmlnaHQ6IDA7IHRvcDogMDtcXG4gIHdpZHRoOiA4cHg7XFxufVxcbi5Db2RlTWlycm9yLXNpbXBsZXNjcm9sbC12ZXJ0aWNhbCBkaXYge1xcbiAgcmlnaHQ6IDA7XFxuICB3aWR0aDogMTAwJTtcXG59XFxuXFxuXFxuLkNvZGVNaXJyb3Itb3ZlcmxheXNjcm9sbCAuQ29kZU1pcnJvci1zY3JvbGxiYXItZmlsbGVyLCAuQ29kZU1pcnJvci1vdmVybGF5c2Nyb2xsIC5Db2RlTWlycm9yLWd1dHRlci1maWxsZXIge1xcbiAgZGlzcGxheTogbm9uZTtcXG59XFxuXFxuLkNvZGVNaXJyb3Itb3ZlcmxheXNjcm9sbC1ob3Jpem9udGFsIGRpdiwgLkNvZGVNaXJyb3Itb3ZlcmxheXNjcm9sbC12ZXJ0aWNhbCBkaXYge1xcbiAgcG9zaXRpb246IGFic29sdXRlO1xcbiAgYmFja2dyb3VuZDogI2JjZDtcXG4gIGJvcmRlci1yYWRpdXM6IDNweDtcXG59XFxuXFxuLkNvZGVNaXJyb3Itb3ZlcmxheXNjcm9sbC1ob3Jpem9udGFsLCAuQ29kZU1pcnJvci1vdmVybGF5c2Nyb2xsLXZlcnRpY2FsIHtcXG4gIHBvc2l0aW9uOiBhYnNvbHV0ZTtcXG4gIHotaW5kZXg6IDY7XFxufVxcblxcbi5Db2RlTWlycm9yLW92ZXJsYXlzY3JvbGwtaG9yaXpvbnRhbCB7XFxuICBib3R0b206IDA7IGxlZnQ6IDA7XFxuICBoZWlnaHQ6IDZweDtcXG59XFxuLkNvZGVNaXJyb3Itb3ZlcmxheXNjcm9sbC1ob3Jpem9udGFsIGRpdiB7XFxuICBib3R0b206IDA7XFxuICBoZWlnaHQ6IDEwMCU7XFxufVxcblxcbi5Db2RlTWlycm9yLW92ZXJsYXlzY3JvbGwtdmVydGljYWwge1xcbiAgcmlnaHQ6IDA7IHRvcDogMDtcXG4gIHdpZHRoOiA2cHg7XFxufVxcbi5Db2RlTWlycm9yLW92ZXJsYXlzY3JvbGwtdmVydGljYWwgZGl2IHtcXG4gIHJpZ2h0OiAwO1xcbiAgd2lkdGg6IDEwMCU7XFxufVxcblwiLCBcIlwiLHtcInZlcnNpb25cIjozLFwic291cmNlc1wiOltcIndlYnBhY2s6Ly8uL25vZGVfbW9kdWxlcy9jb2RlbWlycm9yL2FkZG9uL3Njcm9sbC9zaW1wbGVzY3JvbGxiYXJzLmNzc1wiXSxcIm5hbWVzXCI6W10sXCJtYXBwaW5nc1wiOlwiQUFBQTtFQUNFLGtCQUFrQjtFQUNsQixnQkFBZ0I7RUFDaEIsMkJBQTJCO0VBQzNCLHNCQUFzQjtFQUN0QixzQkFBc0I7RUFDdEIsa0JBQWtCO0FBQ3BCOztBQUVBO0VBQ0Usa0JBQWtCO0VBQ2xCLFVBQVU7RUFDVixnQkFBZ0I7QUFDbEI7O0FBRUE7RUFDRSxTQUFTLEVBQUUsT0FBTztFQUNsQixXQUFXO0FBQ2I7QUFDQTtFQUNFLFNBQVM7RUFDVCxZQUFZO0FBQ2Q7O0FBRUE7RUFDRSxRQUFRLEVBQUUsTUFBTTtFQUNoQixVQUFVO0FBQ1o7QUFDQTtFQUNFLFFBQVE7RUFDUixXQUFXO0FBQ2I7OztBQUdBO0VBQ0UsYUFBYTtBQUNmOztBQUVBO0VBQ0Usa0JBQWtCO0VBQ2xCLGdCQUFnQjtFQUNoQixrQkFBa0I7QUFDcEI7O0FBRUE7RUFDRSxrQkFBa0I7RUFDbEIsVUFBVTtBQUNaOztBQUVBO0VBQ0UsU0FBUyxFQUFFLE9BQU87RUFDbEIsV0FBVztBQUNiO0FBQ0E7RUFDRSxTQUFTO0VBQ1QsWUFBWTtBQUNkOztBQUVBO0VBQ0UsUUFBUSxFQUFFLE1BQU07RUFDaEIsVUFBVTtBQUNaO0FBQ0E7RUFDRSxRQUFRO0VBQ1IsV0FBVztBQUNiXCIsXCJzb3VyY2VzQ29udGVudFwiOltcIi5Db2RlTWlycm9yLXNpbXBsZXNjcm9sbC1ob3Jpem9udGFsIGRpdiwgLkNvZGVNaXJyb3Itc2ltcGxlc2Nyb2xsLXZlcnRpY2FsIGRpdiB7XFxuICBwb3NpdGlvbjogYWJzb2x1dGU7XFxuICBiYWNrZ3JvdW5kOiAjY2NjO1xcbiAgLW1vei1ib3gtc2l6aW5nOiBib3JkZXItYm94O1xcbiAgYm94LXNpemluZzogYm9yZGVyLWJveDtcXG4gIGJvcmRlcjogMXB4IHNvbGlkICNiYmI7XFxuICBib3JkZXItcmFkaXVzOiAycHg7XFxufVxcblxcbi5Db2RlTWlycm9yLXNpbXBsZXNjcm9sbC1ob3Jpem9udGFsLCAuQ29kZU1pcnJvci1zaW1wbGVzY3JvbGwtdmVydGljYWwge1xcbiAgcG9zaXRpb246IGFic29sdXRlO1xcbiAgei1pbmRleDogNjtcXG4gIGJhY2tncm91bmQ6ICNlZWU7XFxufVxcblxcbi5Db2RlTWlycm9yLXNpbXBsZXNjcm9sbC1ob3Jpem9udGFsIHtcXG4gIGJvdHRvbTogMDsgbGVmdDogMDtcXG4gIGhlaWdodDogOHB4O1xcbn1cXG4uQ29kZU1pcnJvci1zaW1wbGVzY3JvbGwtaG9yaXpvbnRhbCBkaXYge1xcbiAgYm90dG9tOiAwO1xcbiAgaGVpZ2h0OiAxMDAlO1xcbn1cXG5cXG4uQ29kZU1pcnJvci1zaW1wbGVzY3JvbGwtdmVydGljYWwge1xcbiAgcmlnaHQ6IDA7IHRvcDogMDtcXG4gIHdpZHRoOiA4cHg7XFxufVxcbi5Db2RlTWlycm9yLXNpbXBsZXNjcm9sbC12ZXJ0aWNhbCBkaXYge1xcbiAgcmlnaHQ6IDA7XFxuICB3aWR0aDogMTAwJTtcXG59XFxuXFxuXFxuLkNvZGVNaXJyb3Itb3ZlcmxheXNjcm9sbCAuQ29kZU1pcnJvci1zY3JvbGxiYXItZmlsbGVyLCAuQ29kZU1pcnJvci1vdmVybGF5c2Nyb2xsIC5Db2RlTWlycm9yLWd1dHRlci1maWxsZXIge1xcbiAgZGlzcGxheTogbm9uZTtcXG59XFxuXFxuLkNvZGVNaXJyb3Itb3ZlcmxheXNjcm9sbC1ob3Jpem9udGFsIGRpdiwgLkNvZGVNaXJyb3Itb3ZlcmxheXNjcm9sbC12ZXJ0aWNhbCBkaXYge1xcbiAgcG9zaXRpb246IGFic29sdXRlO1xcbiAgYmFja2dyb3VuZDogI2JjZDtcXG4gIGJvcmRlci1yYWRpdXM6IDNweDtcXG59XFxuXFxuLkNvZGVNaXJyb3Itb3ZlcmxheXNjcm9sbC1ob3Jpem9udGFsLCAuQ29kZU1pcnJvci1vdmVybGF5c2Nyb2xsLXZlcnRpY2FsIHtcXG4gIHBvc2l0aW9uOiBhYnNvbHV0ZTtcXG4gIHotaW5kZXg6IDY7XFxufVxcblxcbi5Db2RlTWlycm9yLW92ZXJsYXlzY3JvbGwtaG9yaXpvbnRhbCB7XFxuICBib3R0b206IDA7IGxlZnQ6IDA7XFxuICBoZWlnaHQ6IDZweDtcXG59XFxuLkNvZGVNaXJyb3Itb3ZlcmxheXNjcm9sbC1ob3Jpem9udGFsIGRpdiB7XFxuICBib3R0b206IDA7XFxuICBoZWlnaHQ6IDEwMCU7XFxufVxcblxcbi5Db2RlTWlycm9yLW92ZXJsYXlzY3JvbGwtdmVydGljYWwge1xcbiAgcmlnaHQ6IDA7IHRvcDogMDtcXG4gIHdpZHRoOiA2cHg7XFxufVxcbi5Db2RlTWlycm9yLW92ZXJsYXlzY3JvbGwtdmVydGljYWwgZGl2IHtcXG4gIHJpZ2h0OiAwO1xcbiAgd2lkdGg6IDEwMCU7XFxufVxcblwiXSxcInNvdXJjZVJvb3RcIjpcIlwifV0pO1xuLy8gRXhwb3J0c1xuZXhwb3J0IGRlZmF1bHQgX19fQ1NTX0xPQURFUl9FWFBPUlRfX187XG4iLCIvLyBJbXBvcnRzXG5pbXBvcnQgX19fQ1NTX0xPQURFUl9BUElfU09VUkNFTUFQX0lNUE9SVF9fXyBmcm9tIFwiLi4vLi4vY3NzLWxvYWRlci9kaXN0L3J1bnRpbWUvc291cmNlTWFwcy5qc1wiO1xuaW1wb3J0IF9fX0NTU19MT0FERVJfQVBJX0lNUE9SVF9fXyBmcm9tIFwiLi4vLi4vY3NzLWxvYWRlci9kaXN0L3J1bnRpbWUvYXBpLmpzXCI7XG52YXIgX19fQ1NTX0xPQURFUl9FWFBPUlRfX18gPSBfX19DU1NfTE9BREVSX0FQSV9JTVBPUlRfX18oX19fQ1NTX0xPQURFUl9BUElfU09VUkNFTUFQX0lNUE9SVF9fXyk7XG4vLyBNb2R1bGVcbl9fX0NTU19MT0FERVJfRVhQT1JUX19fLnB1c2goW21vZHVsZS5pZCwgXCIvKiBCQVNJQ1MgKi9cXG5cXG4uQ29kZU1pcnJvciB7XFxuICAvKiBTZXQgaGVpZ2h0LCB3aWR0aCwgYm9yZGVycywgYW5kIGdsb2JhbCBmb250IHByb3BlcnRpZXMgaGVyZSAqL1xcbiAgZm9udC1mYW1pbHk6IG1vbm9zcGFjZTtcXG4gIGhlaWdodDogMzAwcHg7XFxuICBjb2xvcjogYmxhY2s7XFxuICBkaXJlY3Rpb246IGx0cjtcXG59XFxuXFxuLyogUEFERElORyAqL1xcblxcbi5Db2RlTWlycm9yLWxpbmVzIHtcXG4gIHBhZGRpbmc6IDRweCAwOyAvKiBWZXJ0aWNhbCBwYWRkaW5nIGFyb3VuZCBjb250ZW50ICovXFxufVxcbi5Db2RlTWlycm9yIHByZS5Db2RlTWlycm9yLWxpbmUsXFxuLkNvZGVNaXJyb3IgcHJlLkNvZGVNaXJyb3ItbGluZS1saWtlIHtcXG4gIHBhZGRpbmc6IDAgNHB4OyAvKiBIb3Jpem9udGFsIHBhZGRpbmcgb2YgY29udGVudCAqL1xcbn1cXG5cXG4uQ29kZU1pcnJvci1zY3JvbGxiYXItZmlsbGVyLCAuQ29kZU1pcnJvci1ndXR0ZXItZmlsbGVyIHtcXG4gIGJhY2tncm91bmQtY29sb3I6IHdoaXRlOyAvKiBUaGUgbGl0dGxlIHNxdWFyZSBiZXR3ZWVuIEggYW5kIFYgc2Nyb2xsYmFycyAqL1xcbn1cXG5cXG4vKiBHVVRURVIgKi9cXG5cXG4uQ29kZU1pcnJvci1ndXR0ZXJzIHtcXG4gIGJvcmRlci1yaWdodDogMXB4IHNvbGlkICNkZGQ7XFxuICBiYWNrZ3JvdW5kLWNvbG9yOiAjZjdmN2Y3O1xcbiAgd2hpdGUtc3BhY2U6IG5vd3JhcDtcXG59XFxuLkNvZGVNaXJyb3ItbGluZW51bWJlcnMge31cXG4uQ29kZU1pcnJvci1saW5lbnVtYmVyIHtcXG4gIHBhZGRpbmc6IDAgM3B4IDAgNXB4O1xcbiAgbWluLXdpZHRoOiAyMHB4O1xcbiAgdGV4dC1hbGlnbjogcmlnaHQ7XFxuICBjb2xvcjogIzk5OTtcXG4gIHdoaXRlLXNwYWNlOiBub3dyYXA7XFxufVxcblxcbi5Db2RlTWlycm9yLWd1dHRlcm1hcmtlciB7IGNvbG9yOiBibGFjazsgfVxcbi5Db2RlTWlycm9yLWd1dHRlcm1hcmtlci1zdWJ0bGUgeyBjb2xvcjogIzk5OTsgfVxcblxcbi8qIENVUlNPUiAqL1xcblxcbi5Db2RlTWlycm9yLWN1cnNvciB7XFxuICBib3JkZXItbGVmdDogMXB4IHNvbGlkIGJsYWNrO1xcbiAgYm9yZGVyLXJpZ2h0OiBub25lO1xcbiAgd2lkdGg6IDA7XFxufVxcbi8qIFNob3duIHdoZW4gbW92aW5nIGluIGJpLWRpcmVjdGlvbmFsIHRleHQgKi9cXG4uQ29kZU1pcnJvciBkaXYuQ29kZU1pcnJvci1zZWNvbmRhcnljdXJzb3Ige1xcbiAgYm9yZGVyLWxlZnQ6IDFweCBzb2xpZCBzaWx2ZXI7XFxufVxcbi5jbS1mYXQtY3Vyc29yIC5Db2RlTWlycm9yLWN1cnNvciB7XFxuICB3aWR0aDogYXV0bztcXG4gIGJvcmRlcjogMCAhaW1wb3J0YW50O1xcbiAgYmFja2dyb3VuZDogIzdlNztcXG59XFxuLmNtLWZhdC1jdXJzb3IgZGl2LkNvZGVNaXJyb3ItY3Vyc29ycyB7XFxuICB6LWluZGV4OiAxO1xcbn1cXG4uY20tZmF0LWN1cnNvciAuQ29kZU1pcnJvci1saW5lOjpzZWxlY3Rpb24sXFxuLmNtLWZhdC1jdXJzb3IgLkNvZGVNaXJyb3ItbGluZSA+IHNwYW46OnNlbGVjdGlvbiwgXFxuLmNtLWZhdC1jdXJzb3IgLkNvZGVNaXJyb3ItbGluZSA+IHNwYW4gPiBzcGFuOjpzZWxlY3Rpb24geyBiYWNrZ3JvdW5kOiB0cmFuc3BhcmVudDsgfVxcbi5jbS1mYXQtY3Vyc29yIC5Db2RlTWlycm9yLWxpbmU6Oi1tb3otc2VsZWN0aW9uLFxcbi5jbS1mYXQtY3Vyc29yIC5Db2RlTWlycm9yLWxpbmUgPiBzcGFuOjotbW96LXNlbGVjdGlvbixcXG4uY20tZmF0LWN1cnNvciAuQ29kZU1pcnJvci1saW5lID4gc3BhbiA+IHNwYW46Oi1tb3otc2VsZWN0aW9uIHsgYmFja2dyb3VuZDogdHJhbnNwYXJlbnQ7IH1cXG4uY20tZmF0LWN1cnNvciB7IGNhcmV0LWNvbG9yOiB0cmFuc3BhcmVudDsgfVxcbkAtbW96LWtleWZyYW1lcyBibGluayB7XFxuICAwJSB7fVxcbiAgNTAlIHsgYmFja2dyb3VuZC1jb2xvcjogdHJhbnNwYXJlbnQ7IH1cXG4gIDEwMCUge31cXG59XFxuQC13ZWJraXQta2V5ZnJhbWVzIGJsaW5rIHtcXG4gIDAlIHt9XFxuICA1MCUgeyBiYWNrZ3JvdW5kLWNvbG9yOiB0cmFuc3BhcmVudDsgfVxcbiAgMTAwJSB7fVxcbn1cXG5Aa2V5ZnJhbWVzIGJsaW5rIHtcXG4gIDAlIHt9XFxuICA1MCUgeyBiYWNrZ3JvdW5kLWNvbG9yOiB0cmFuc3BhcmVudDsgfVxcbiAgMTAwJSB7fVxcbn1cXG5cXG4vKiBDYW4gc3R5bGUgY3Vyc29yIGRpZmZlcmVudCBpbiBvdmVyd3JpdGUgKG5vbi1pbnNlcnQpIG1vZGUgKi9cXG4uQ29kZU1pcnJvci1vdmVyd3JpdGUgLkNvZGVNaXJyb3ItY3Vyc29yIHt9XFxuXFxuLmNtLXRhYiB7IGRpc3BsYXk6IGlubGluZS1ibG9jazsgdGV4dC1kZWNvcmF0aW9uOiBpbmhlcml0OyB9XFxuXFxuLkNvZGVNaXJyb3ItcnVsZXJzIHtcXG4gIHBvc2l0aW9uOiBhYnNvbHV0ZTtcXG4gIGxlZnQ6IDA7IHJpZ2h0OiAwOyB0b3A6IC01MHB4OyBib3R0b206IDA7XFxuICBvdmVyZmxvdzogaGlkZGVuO1xcbn1cXG4uQ29kZU1pcnJvci1ydWxlciB7XFxuICBib3JkZXItbGVmdDogMXB4IHNvbGlkICNjY2M7XFxuICB0b3A6IDA7IGJvdHRvbTogMDtcXG4gIHBvc2l0aW9uOiBhYnNvbHV0ZTtcXG59XFxuXFxuLyogREVGQVVMVCBUSEVNRSAqL1xcblxcbi5jbS1zLWRlZmF1bHQgLmNtLWhlYWRlciB7Y29sb3I6IGJsdWU7fVxcbi5jbS1zLWRlZmF1bHQgLmNtLXF1b3RlIHtjb2xvcjogIzA5MDt9XFxuLmNtLW5lZ2F0aXZlIHtjb2xvcjogI2Q0NDt9XFxuLmNtLXBvc2l0aXZlIHtjb2xvcjogIzI5Mjt9XFxuLmNtLWhlYWRlciwgLmNtLXN0cm9uZyB7Zm9udC13ZWlnaHQ6IGJvbGQ7fVxcbi5jbS1lbSB7Zm9udC1zdHlsZTogaXRhbGljO31cXG4uY20tbGluayB7dGV4dC1kZWNvcmF0aW9uOiB1bmRlcmxpbmU7fVxcbi5jbS1zdHJpa2V0aHJvdWdoIHt0ZXh0LWRlY29yYXRpb246IGxpbmUtdGhyb3VnaDt9XFxuXFxuLmNtLXMtZGVmYXVsdCAuY20ta2V5d29yZCB7Y29sb3I6ICM3MDg7fVxcbi5jbS1zLWRlZmF1bHQgLmNtLWF0b20ge2NvbG9yOiAjMjE5O31cXG4uY20tcy1kZWZhdWx0IC5jbS1udW1iZXIge2NvbG9yOiAjMTY0O31cXG4uY20tcy1kZWZhdWx0IC5jbS1kZWYge2NvbG9yOiAjMDBmO31cXG4uY20tcy1kZWZhdWx0IC5jbS12YXJpYWJsZSxcXG4uY20tcy1kZWZhdWx0IC5jbS1wdW5jdHVhdGlvbixcXG4uY20tcy1kZWZhdWx0IC5jbS1wcm9wZXJ0eSxcXG4uY20tcy1kZWZhdWx0IC5jbS1vcGVyYXRvciB7fVxcbi5jbS1zLWRlZmF1bHQgLmNtLXZhcmlhYmxlLTIge2NvbG9yOiAjMDVhO31cXG4uY20tcy1kZWZhdWx0IC5jbS12YXJpYWJsZS0zLCAuY20tcy1kZWZhdWx0IC5jbS10eXBlIHtjb2xvcjogIzA4NTt9XFxuLmNtLXMtZGVmYXVsdCAuY20tY29tbWVudCB7Y29sb3I6ICNhNTA7fVxcbi5jbS1zLWRlZmF1bHQgLmNtLXN0cmluZyB7Y29sb3I6ICNhMTE7fVxcbi5jbS1zLWRlZmF1bHQgLmNtLXN0cmluZy0yIHtjb2xvcjogI2Y1MDt9XFxuLmNtLXMtZGVmYXVsdCAuY20tbWV0YSB7Y29sb3I6ICM1NTU7fVxcbi5jbS1zLWRlZmF1bHQgLmNtLXF1YWxpZmllciB7Y29sb3I6ICM1NTU7fVxcbi5jbS1zLWRlZmF1bHQgLmNtLWJ1aWx0aW4ge2NvbG9yOiAjMzBhO31cXG4uY20tcy1kZWZhdWx0IC5jbS1icmFja2V0IHtjb2xvcjogIzk5Nzt9XFxuLmNtLXMtZGVmYXVsdCAuY20tdGFnIHtjb2xvcjogIzE3MDt9XFxuLmNtLXMtZGVmYXVsdCAuY20tYXR0cmlidXRlIHtjb2xvcjogIzAwYzt9XFxuLmNtLXMtZGVmYXVsdCAuY20taHIge2NvbG9yOiAjOTk5O31cXG4uY20tcy1kZWZhdWx0IC5jbS1saW5rIHtjb2xvcjogIzAwYzt9XFxuXFxuLmNtLXMtZGVmYXVsdCAuY20tZXJyb3Ige2NvbG9yOiAjZjAwO31cXG4uY20taW52YWxpZGNoYXIge2NvbG9yOiAjZjAwO31cXG5cXG4uQ29kZU1pcnJvci1jb21wb3NpbmcgeyBib3JkZXItYm90dG9tOiAycHggc29saWQ7IH1cXG5cXG4vKiBEZWZhdWx0IHN0eWxlcyBmb3IgY29tbW9uIGFkZG9ucyAqL1xcblxcbmRpdi5Db2RlTWlycm9yIHNwYW4uQ29kZU1pcnJvci1tYXRjaGluZ2JyYWNrZXQge2NvbG9yOiAjMGIwO31cXG5kaXYuQ29kZU1pcnJvciBzcGFuLkNvZGVNaXJyb3Itbm9ubWF0Y2hpbmdicmFja2V0IHtjb2xvcjogI2EyMjt9XFxuLkNvZGVNaXJyb3ItbWF0Y2hpbmd0YWcgeyBiYWNrZ3JvdW5kOiByZ2JhKDI1NSwgMTUwLCAwLCAuMyk7IH1cXG4uQ29kZU1pcnJvci1hY3RpdmVsaW5lLWJhY2tncm91bmQge2JhY2tncm91bmQ6ICNlOGYyZmY7fVxcblxcbi8qIFNUT1AgKi9cXG5cXG4vKiBUaGUgcmVzdCBvZiB0aGlzIGZpbGUgY29udGFpbnMgc3R5bGVzIHJlbGF0ZWQgdG8gdGhlIG1lY2hhbmljcyBvZlxcbiAgIHRoZSBlZGl0b3IuIFlvdSBwcm9iYWJseSBzaG91bGRuJ3QgdG91Y2ggdGhlbS4gKi9cXG5cXG4uQ29kZU1pcnJvciB7XFxuICBwb3NpdGlvbjogcmVsYXRpdmU7XFxuICBvdmVyZmxvdzogaGlkZGVuO1xcbiAgYmFja2dyb3VuZDogd2hpdGU7XFxufVxcblxcbi5Db2RlTWlycm9yLXNjcm9sbCB7XFxuICBvdmVyZmxvdzogc2Nyb2xsICFpbXBvcnRhbnQ7IC8qIFRoaW5ncyB3aWxsIGJyZWFrIGlmIHRoaXMgaXMgb3ZlcnJpZGRlbiAqL1xcbiAgLyogNTBweCBpcyB0aGUgbWFnaWMgbWFyZ2luIHVzZWQgdG8gaGlkZSB0aGUgZWxlbWVudCdzIHJlYWwgc2Nyb2xsYmFycyAqL1xcbiAgLyogU2VlIG92ZXJmbG93OiBoaWRkZW4gaW4gLkNvZGVNaXJyb3IgKi9cXG4gIG1hcmdpbi1ib3R0b206IC01MHB4OyBtYXJnaW4tcmlnaHQ6IC01MHB4O1xcbiAgcGFkZGluZy1ib3R0b206IDUwcHg7XFxuICBoZWlnaHQ6IDEwMCU7XFxuICBvdXRsaW5lOiBub25lOyAvKiBQcmV2ZW50IGRyYWdnaW5nIGZyb20gaGlnaGxpZ2h0aW5nIHRoZSBlbGVtZW50ICovXFxuICBwb3NpdGlvbjogcmVsYXRpdmU7XFxuICB6LWluZGV4OiAwO1xcbn1cXG4uQ29kZU1pcnJvci1zaXplciB7XFxuICBwb3NpdGlvbjogcmVsYXRpdmU7XFxuICBib3JkZXItcmlnaHQ6IDUwcHggc29saWQgdHJhbnNwYXJlbnQ7XFxufVxcblxcbi8qIFRoZSBmYWtlLCB2aXNpYmxlIHNjcm9sbGJhcnMuIFVzZWQgdG8gZm9yY2UgcmVkcmF3IGR1cmluZyBzY3JvbGxpbmdcXG4gICBiZWZvcmUgYWN0dWFsIHNjcm9sbGluZyBoYXBwZW5zLCB0aHVzIHByZXZlbnRpbmcgc2hha2luZyBhbmRcXG4gICBmbGlja2VyaW5nIGFydGlmYWN0cy4gKi9cXG4uQ29kZU1pcnJvci12c2Nyb2xsYmFyLCAuQ29kZU1pcnJvci1oc2Nyb2xsYmFyLCAuQ29kZU1pcnJvci1zY3JvbGxiYXItZmlsbGVyLCAuQ29kZU1pcnJvci1ndXR0ZXItZmlsbGVyIHtcXG4gIHBvc2l0aW9uOiBhYnNvbHV0ZTtcXG4gIHotaW5kZXg6IDY7XFxuICBkaXNwbGF5OiBub25lO1xcbiAgb3V0bGluZTogbm9uZTtcXG59XFxuLkNvZGVNaXJyb3ItdnNjcm9sbGJhciB7XFxuICByaWdodDogMDsgdG9wOiAwO1xcbiAgb3ZlcmZsb3cteDogaGlkZGVuO1xcbiAgb3ZlcmZsb3cteTogc2Nyb2xsO1xcbn1cXG4uQ29kZU1pcnJvci1oc2Nyb2xsYmFyIHtcXG4gIGJvdHRvbTogMDsgbGVmdDogMDtcXG4gIG92ZXJmbG93LXk6IGhpZGRlbjtcXG4gIG92ZXJmbG93LXg6IHNjcm9sbDtcXG59XFxuLkNvZGVNaXJyb3Itc2Nyb2xsYmFyLWZpbGxlciB7XFxuICByaWdodDogMDsgYm90dG9tOiAwO1xcbn1cXG4uQ29kZU1pcnJvci1ndXR0ZXItZmlsbGVyIHtcXG4gIGxlZnQ6IDA7IGJvdHRvbTogMDtcXG59XFxuXFxuLkNvZGVNaXJyb3ItZ3V0dGVycyB7XFxuICBwb3NpdGlvbjogYWJzb2x1dGU7IGxlZnQ6IDA7IHRvcDogMDtcXG4gIG1pbi1oZWlnaHQ6IDEwMCU7XFxuICB6LWluZGV4OiAzO1xcbn1cXG4uQ29kZU1pcnJvci1ndXR0ZXIge1xcbiAgd2hpdGUtc3BhY2U6IG5vcm1hbDtcXG4gIGhlaWdodDogMTAwJTtcXG4gIGRpc3BsYXk6IGlubGluZS1ibG9jaztcXG4gIHZlcnRpY2FsLWFsaWduOiB0b3A7XFxuICBtYXJnaW4tYm90dG9tOiAtNTBweDtcXG59XFxuLkNvZGVNaXJyb3ItZ3V0dGVyLXdyYXBwZXIge1xcbiAgcG9zaXRpb246IGFic29sdXRlO1xcbiAgei1pbmRleDogNDtcXG4gIGJhY2tncm91bmQ6IG5vbmUgIWltcG9ydGFudDtcXG4gIGJvcmRlcjogbm9uZSAhaW1wb3J0YW50O1xcbn1cXG4uQ29kZU1pcnJvci1ndXR0ZXItYmFja2dyb3VuZCB7XFxuICBwb3NpdGlvbjogYWJzb2x1dGU7XFxuICB0b3A6IDA7IGJvdHRvbTogMDtcXG4gIHotaW5kZXg6IDQ7XFxufVxcbi5Db2RlTWlycm9yLWd1dHRlci1lbHQge1xcbiAgcG9zaXRpb246IGFic29sdXRlO1xcbiAgY3Vyc29yOiBkZWZhdWx0O1xcbiAgei1pbmRleDogNDtcXG59XFxuLkNvZGVNaXJyb3ItZ3V0dGVyLXdyYXBwZXIgOjpzZWxlY3Rpb24geyBiYWNrZ3JvdW5kLWNvbG9yOiB0cmFuc3BhcmVudCB9XFxuLkNvZGVNaXJyb3ItZ3V0dGVyLXdyYXBwZXIgOjotbW96LXNlbGVjdGlvbiB7IGJhY2tncm91bmQtY29sb3I6IHRyYW5zcGFyZW50IH1cXG5cXG4uQ29kZU1pcnJvci1saW5lcyB7XFxuICBjdXJzb3I6IHRleHQ7XFxuICBtaW4taGVpZ2h0OiAxcHg7IC8qIHByZXZlbnRzIGNvbGxhcHNpbmcgYmVmb3JlIGZpcnN0IGRyYXcgKi9cXG59XFxuLkNvZGVNaXJyb3IgcHJlLkNvZGVNaXJyb3ItbGluZSxcXG4uQ29kZU1pcnJvciBwcmUuQ29kZU1pcnJvci1saW5lLWxpa2Uge1xcbiAgLyogUmVzZXQgc29tZSBzdHlsZXMgdGhhdCB0aGUgcmVzdCBvZiB0aGUgcGFnZSBtaWdodCBoYXZlIHNldCAqL1xcbiAgLW1vei1ib3JkZXItcmFkaXVzOiAwOyAtd2Via2l0LWJvcmRlci1yYWRpdXM6IDA7IGJvcmRlci1yYWRpdXM6IDA7XFxuICBib3JkZXItd2lkdGg6IDA7XFxuICBiYWNrZ3JvdW5kOiB0cmFuc3BhcmVudDtcXG4gIGZvbnQtZmFtaWx5OiBpbmhlcml0O1xcbiAgZm9udC1zaXplOiBpbmhlcml0O1xcbiAgbWFyZ2luOiAwO1xcbiAgd2hpdGUtc3BhY2U6IHByZTtcXG4gIHdvcmQtd3JhcDogbm9ybWFsO1xcbiAgbGluZS1oZWlnaHQ6IGluaGVyaXQ7XFxuICBjb2xvcjogaW5oZXJpdDtcXG4gIHotaW5kZXg6IDI7XFxuICBwb3NpdGlvbjogcmVsYXRpdmU7XFxuICBvdmVyZmxvdzogdmlzaWJsZTtcXG4gIC13ZWJraXQtdGFwLWhpZ2hsaWdodC1jb2xvcjogdHJhbnNwYXJlbnQ7XFxuICAtd2Via2l0LWZvbnQtdmFyaWFudC1saWdhdHVyZXM6IGNvbnRleHR1YWw7XFxuICBmb250LXZhcmlhbnQtbGlnYXR1cmVzOiBjb250ZXh0dWFsO1xcbn1cXG4uQ29kZU1pcnJvci13cmFwIHByZS5Db2RlTWlycm9yLWxpbmUsXFxuLkNvZGVNaXJyb3Itd3JhcCBwcmUuQ29kZU1pcnJvci1saW5lLWxpa2Uge1xcbiAgd29yZC13cmFwOiBicmVhay13b3JkO1xcbiAgd2hpdGUtc3BhY2U6IHByZS13cmFwO1xcbiAgd29yZC1icmVhazogbm9ybWFsO1xcbn1cXG5cXG4uQ29kZU1pcnJvci1saW5lYmFja2dyb3VuZCB7XFxuICBwb3NpdGlvbjogYWJzb2x1dGU7XFxuICBsZWZ0OiAwOyByaWdodDogMDsgdG9wOiAwOyBib3R0b206IDA7XFxuICB6LWluZGV4OiAwO1xcbn1cXG5cXG4uQ29kZU1pcnJvci1saW5ld2lkZ2V0IHtcXG4gIHBvc2l0aW9uOiByZWxhdGl2ZTtcXG4gIHotaW5kZXg6IDI7XFxuICBwYWRkaW5nOiAwLjFweDsgLyogRm9yY2Ugd2lkZ2V0IG1hcmdpbnMgdG8gc3RheSBpbnNpZGUgb2YgdGhlIGNvbnRhaW5lciAqL1xcbn1cXG5cXG4uQ29kZU1pcnJvci13aWRnZXQge31cXG5cXG4uQ29kZU1pcnJvci1ydGwgcHJlIHsgZGlyZWN0aW9uOiBydGw7IH1cXG5cXG4uQ29kZU1pcnJvci1jb2RlIHtcXG4gIG91dGxpbmU6IG5vbmU7XFxufVxcblxcbi8qIEZvcmNlIGNvbnRlbnQtYm94IHNpemluZyBmb3IgdGhlIGVsZW1lbnRzIHdoZXJlIHdlIGV4cGVjdCBpdCAqL1xcbi5Db2RlTWlycm9yLXNjcm9sbCxcXG4uQ29kZU1pcnJvci1zaXplcixcXG4uQ29kZU1pcnJvci1ndXR0ZXIsXFxuLkNvZGVNaXJyb3ItZ3V0dGVycyxcXG4uQ29kZU1pcnJvci1saW5lbnVtYmVyIHtcXG4gIC1tb3otYm94LXNpemluZzogY29udGVudC1ib3g7XFxuICBib3gtc2l6aW5nOiBjb250ZW50LWJveDtcXG59XFxuXFxuLkNvZGVNaXJyb3ItbWVhc3VyZSB7XFxuICBwb3NpdGlvbjogYWJzb2x1dGU7XFxuICB3aWR0aDogMTAwJTtcXG4gIGhlaWdodDogMDtcXG4gIG92ZXJmbG93OiBoaWRkZW47XFxuICB2aXNpYmlsaXR5OiBoaWRkZW47XFxufVxcblxcbi5Db2RlTWlycm9yLWN1cnNvciB7XFxuICBwb3NpdGlvbjogYWJzb2x1dGU7XFxuICBwb2ludGVyLWV2ZW50czogbm9uZTtcXG59XFxuLkNvZGVNaXJyb3ItbWVhc3VyZSBwcmUgeyBwb3NpdGlvbjogc3RhdGljOyB9XFxuXFxuZGl2LkNvZGVNaXJyb3ItY3Vyc29ycyB7XFxuICB2aXNpYmlsaXR5OiBoaWRkZW47XFxuICBwb3NpdGlvbjogcmVsYXRpdmU7XFxuICB6LWluZGV4OiAzO1xcbn1cXG5kaXYuQ29kZU1pcnJvci1kcmFnY3Vyc29ycyB7XFxuICB2aXNpYmlsaXR5OiB2aXNpYmxlO1xcbn1cXG5cXG4uQ29kZU1pcnJvci1mb2N1c2VkIGRpdi5Db2RlTWlycm9yLWN1cnNvcnMge1xcbiAgdmlzaWJpbGl0eTogdmlzaWJsZTtcXG59XFxuXFxuLkNvZGVNaXJyb3Itc2VsZWN0ZWQgeyBiYWNrZ3JvdW5kOiAjZDlkOWQ5OyB9XFxuLkNvZGVNaXJyb3ItZm9jdXNlZCAuQ29kZU1pcnJvci1zZWxlY3RlZCB7IGJhY2tncm91bmQ6ICNkN2Q0ZjA7IH1cXG4uQ29kZU1pcnJvci1jcm9zc2hhaXIgeyBjdXJzb3I6IGNyb3NzaGFpcjsgfVxcbi5Db2RlTWlycm9yLWxpbmU6OnNlbGVjdGlvbiwgLkNvZGVNaXJyb3ItbGluZSA+IHNwYW46OnNlbGVjdGlvbiwgLkNvZGVNaXJyb3ItbGluZSA+IHNwYW4gPiBzcGFuOjpzZWxlY3Rpb24geyBiYWNrZ3JvdW5kOiAjZDdkNGYwOyB9XFxuLkNvZGVNaXJyb3ItbGluZTo6LW1vei1zZWxlY3Rpb24sIC5Db2RlTWlycm9yLWxpbmUgPiBzcGFuOjotbW96LXNlbGVjdGlvbiwgLkNvZGVNaXJyb3ItbGluZSA+IHNwYW4gPiBzcGFuOjotbW96LXNlbGVjdGlvbiB7IGJhY2tncm91bmQ6ICNkN2Q0ZjA7IH1cXG5cXG4uY20tc2VhcmNoaW5nIHtcXG4gIGJhY2tncm91bmQtY29sb3I6ICNmZmE7XFxuICBiYWNrZ3JvdW5kLWNvbG9yOiByZ2JhKDI1NSwgMjU1LCAwLCAuNCk7XFxufVxcblxcbi8qIFVzZWQgdG8gZm9yY2UgYSBib3JkZXIgbW9kZWwgZm9yIGEgbm9kZSAqL1xcbi5jbS1mb3JjZS1ib3JkZXIgeyBwYWRkaW5nLXJpZ2h0OiAuMXB4OyB9XFxuXFxuQG1lZGlhIHByaW50IHtcXG4gIC8qIEhpZGUgdGhlIGN1cnNvciB3aGVuIHByaW50aW5nICovXFxuICAuQ29kZU1pcnJvciBkaXYuQ29kZU1pcnJvci1jdXJzb3JzIHtcXG4gICAgdmlzaWJpbGl0eTogaGlkZGVuO1xcbiAgfVxcbn1cXG5cXG4vKiBTZWUgaXNzdWUgIzI5MDEgKi9cXG4uY20tdGFiLXdyYXAtaGFjazphZnRlciB7IGNvbnRlbnQ6ICcnOyB9XFxuXFxuLyogSGVscCB1c2VycyB1c2UgbWFya3NlbGVjdGlvbiB0byBzYWZlbHkgc3R5bGUgdGV4dCBiYWNrZ3JvdW5kICovXFxuc3Bhbi5Db2RlTWlycm9yLXNlbGVjdGVkdGV4dCB7IGJhY2tncm91bmQ6IG5vbmU7IH1cXG5cIiwgXCJcIix7XCJ2ZXJzaW9uXCI6MyxcInNvdXJjZXNcIjpbXCJ3ZWJwYWNrOi8vLi9ub2RlX21vZHVsZXMvY29kZW1pcnJvci9saWIvY29kZW1pcnJvci5jc3NcIl0sXCJuYW1lc1wiOltdLFwibWFwcGluZ3NcIjpcIkFBQUEsV0FBVzs7QUFFWDtFQUNFLGdFQUFnRTtFQUNoRSxzQkFBc0I7RUFDdEIsYUFBYTtFQUNiLFlBQVk7RUFDWixjQUFjO0FBQ2hCOztBQUVBLFlBQVk7O0FBRVo7RUFDRSxjQUFjLEVBQUUsb0NBQW9DO0FBQ3REO0FBQ0E7O0VBRUUsY0FBYyxFQUFFLGtDQUFrQztBQUNwRDs7QUFFQTtFQUNFLHVCQUF1QixFQUFFLGlEQUFpRDtBQUM1RTs7QUFFQSxXQUFXOztBQUVYO0VBQ0UsNEJBQTRCO0VBQzVCLHlCQUF5QjtFQUN6QixtQkFBbUI7QUFDckI7QUFDQSx5QkFBeUI7QUFDekI7RUFDRSxvQkFBb0I7RUFDcEIsZUFBZTtFQUNmLGlCQUFpQjtFQUNqQixXQUFXO0VBQ1gsbUJBQW1CO0FBQ3JCOztBQUVBLDJCQUEyQixZQUFZLEVBQUU7QUFDekMsa0NBQWtDLFdBQVcsRUFBRTs7QUFFL0MsV0FBVzs7QUFFWDtFQUNFLDRCQUE0QjtFQUM1QixrQkFBa0I7RUFDbEIsUUFBUTtBQUNWO0FBQ0EsNkNBQTZDO0FBQzdDO0VBQ0UsNkJBQTZCO0FBQy9CO0FBQ0E7RUFDRSxXQUFXO0VBQ1gsb0JB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QTtFQUNFLGtCQUFrQjtFQUNsQixXQUFXO0VBQ1gsU0FBUztFQUNULGdCQUFnQjtFQUNoQixrQkFBa0I7QUFDcEI7O0FBRUE7RUFDRSxrQkFBa0I7RUFDbEIsb0JBQW9CO0FBQ3RCO0FBQ0EsMEJBQTBCLGdCQUFnQixFQUFFOztBQUU1QztFQUNFLGtCQUFrQjtFQUNsQixrQkFBa0I7RUFDbEIsVUFBVTtBQUNaO0FBQ0E7RUFDRSxtQkFBbUI7QUFDckI7O0FBRUE7RUFDRSxtQkFBbUI7QUFDckI7O0FBRUEsdUJBQXVCLG1CQUFtQixFQUFFO0FBQzVDLDJDQUEyQyxtQkFBbUIsRUFBRTtBQUNoRSx3QkFBd0IsaUJBQWlCLEVBQUU7QUFDM0MsNkdBQTZHLG1CQUFtQixFQUFFO0FBQ2xJLDRIQUE0SCxtQkFBbUIsRUFBRTs7QUFFako7RUFDRSxzQkFBc0I7RUFDdEIsdUNBQXVDO0FBQ3pDOztBQUVBLDRDQUE0QztBQUM1QyxtQkFBbUIsbUJBQW1CLEVBQUU7O0FBRXhDO0VBQ0Usa0NBQWtDO0VBQ2xDO0lBQ0Usa0JBQWtCO0VBQ3BCO0FBQ0Y7O0FBRUEsb0JBQW9CO0FBQ3BCLDBCQUEwQixXQUFXLEVBQUU7O0FBRXZDLGlFQUFpRTtBQUNqRSwrQkFBK0IsZ0JBQWdCLEVBQUVcIixcInNvdXJjZXNDb250ZW50XCI6W1wiLyogQkFTSUNTICovXFxuXFxuLkNvZGVNaXJyb3Ige1xcbiAgLyogU2V0IGhlaWdodCwgd2lkdGgsIGJvcmRlcnMsIGFuZCBnbG9iYWwgZm9udCBwcm9wZXJ0aWVzIGhlcmUgKi9cXG4gIGZvbnQtZmFtaWx5OiBtb25vc3BhY2U7XFxuICBoZWlnaHQ6IDMwMHB4O1xcbiAgY29sb3I6IGJsYWNrO1xcbiAgZGlyZWN0aW9uOiBsdHI7XFxufVxcblxcbi8qIFBBRERJTkcgKi9cXG5cXG4uQ29kZU1pcnJvci1saW5lcyB7XFxuICBwYWRkaW5nOiA0cHggMDsgLyogVmVydGljYWwgcGFkZGluZyBhcm91bmQgY29udGVudCAqL1xcbn1cXG4uQ29kZU1pcnJvciBwcmUuQ29kZU1pcnJvci1saW5lLFxcbi5Db2RlTWlycm9yIHByZS5Db2RlTWlycm9yLWxpbmUtbGlrZSB7XFxuICBwYWRkaW5nOiAwIDRweDsgLyogSG9yaXpvbnRhbCBwYWRkaW5nIG9mIGNvbnRlbnQgKi9cXG59XFxuXFxuLkNvZGVNaXJyb3Itc2Nyb2xsYmFyLWZpbGxlciwgLkNvZGVNaXJyb3ItZ3V0dGVyLWZpbGxlciB7XFxuICBiYWNrZ3JvdW5kLWNvbG9yOiB3aGl0ZTsgLyogVGhlIGxpdHRsZSBzcXVhcmUgYmV0d2VlbiBIIGFuZCBWIHNjcm9sbGJhcnMgKi9cXG59XFxuXFxuLyogR1VUVEVSICovXFxuXFxuLkNvZGVNaXJyb3ItZ3V0dGVycyB7XFxuICBib3JkZXItcmlnaHQ6IDFweCBzb2xpZCAjZGRkO1xcbiAgYmFja2dyb3VuZC1jb2xvcjogI2Y3ZjdmNztcXG4gIHdoaXRlLXNwYWNlOiBub3dyYXA7XFxufVxcbi5Db2RlTWlycm9yLWxpbmVudW1iZXJzIHt9XFxuLkNvZGVNaXJyb3ItbGluZW51bWJlciB7XFxuICBwYWRkaW5nOiAwIDNweCAwIDVweDtcXG4gIG1pbi13aWR0aDogMjBweDtcXG4gIHRleHQtYWxpZ246IHJpZ2h0O1xcbiAgY29sb3I6ICM5OTk7XFxuICB3aGl0ZS1zcGFjZTogbm93cmFwO1xcbn1cXG5cXG4uQ29kZU1pcnJvci1ndXR0ZXJtYXJrZXIgeyBjb2xvcjogYmxhY2s7IH1cXG4uQ29kZU1pcnJvci1ndXR0ZXJtYXJrZXItc3VidGxlIHsgY29sb3I6ICM5OTk7IH1cXG5cXG4vKiBDVVJTT1IgKi9cXG5cXG4uQ29kZU1pcnJvci1jdXJzb3Ige1xcbiAgYm9yZGVyLWxlZnQ6IDFweCBzb2xpZCBibGFjaztcXG4gIGJvcmRlci1yaWdodDogbm9uZTtcXG4gIHdpZHRoOiAwO1xcbn1cXG4vKiBTaG93biB3aGVuIG1vdmluZyBpbiBiaS1kaXJlY3Rpb25hbCB0ZXh0ICovXFxuLkNvZGVNaXJyb3IgZGl2LkNvZGVNaXJyb3Itc2Vjb25kYXJ5Y3Vyc29yIHtcXG4gIGJvcmRlci1sZWZ0OiAxcHggc29saWQgc2lsdmVyO1xcbn1cXG4uY20tZmF0LWN1cnNvciAuQ29kZU1pcnJvci1jdXJzb3Ige1xcbiAgd2lkdGg6IGF1dG87XFxuICBib3JkZXI6IDAgIWltcG9ydGFudDtcXG4gIGJhY2tncm91bmQ6ICM3ZTc7XFxufVxcbi5jbS1mYXQtY3Vyc29yIGRpdi5Db2RlTWlycm9yLWN1cnNvcnMge1xcbiAgei1pbmRleDogMTtcXG59XFxuLmNtLWZhdC1jdXJzb3IgLkNvZGVNaXJyb3ItbGluZTo6c2VsZWN0aW9uLFxcbi5jbS1mYXQtY3Vyc29yIC5Db2RlTWlycm9yLWxpbmUgPiBzcGFuOjpzZWxlY3Rpb24sIFxcbi5jbS1mYXQtY3Vyc29yIC5Db2RlTWlycm9yLWxpbmUgPiBzcGFuID4gc3Bhbjo6c2VsZWN0aW9uIHsgYmFja2dyb3VuZDogdHJhbnNwYXJlbnQ7IH1cXG4uY20tZmF0LWN1cnNvciAuQ29kZU1pcnJvci1saW5lOjotbW96LXNlbGVjdGlvbixcXG4uY20tZmF0LWN1cnNvciAuQ29kZU1pcnJvci1saW5lID4gc3Bhbjo6LW1vei1zZWxlY3Rpb24sXFxuLmNtLWZhdC1jdXJzb3IgLkNvZGVNaXJyb3ItbGluZSA+IHNwYW4gPiBzcGFuOjotbW96LXNlbGVjdGlvbiB7IGJhY2tncm91bmQ6IHRyYW5zcGFyZW50OyB9XFxuLmNtLWZhdC1jdXJzb3IgeyBjYXJldC1jb2xvcjogdHJhbnNwYXJlbnQ7IH1cXG5ALW1vei1rZXlmcmFtZXMgYmxpbmsge1xcbiAgMCUge31cXG4gIDUwJSB7IGJhY2tncm91bmQtY29sb3I6IHRyYW5zcGFyZW50OyB9XFxuICAxMDAlIHt9XFxufVxcbkAtd2Via2l0LWtleWZyYW1lcyBibGluayB7XFxuICAwJSB7fVxcbiAgNTAlIHsgYmFja2dyb3VuZC1jb2xvcjogdHJhbnNwYXJlbnQ7IH1cXG4gIDEwMCUge31cXG59XFxuQGtleWZyYW1lcyBibGluayB7XFxuICAwJSB7fVxcbiAgNTAlIHsgYmFja2dyb3VuZC1jb2xvcjogdHJhbnNwYXJlbnQ7IH1cXG4gIDEwMCUge31cXG59XFxuXFxuLyogQ2FuIHN0eWxlIGN1cnNvciBkaWZmZXJlbnQgaW4gb3ZlcndyaXRlIChub24taW5zZXJ0KSBtb2RlICovXFxuLkNvZGVNaXJyb3Itb3ZlcndyaXRlIC5Db2RlTWlycm9yLWN1cnNvciB7fVxcblxcbi5jbS10YWIgeyBkaXNwbGF5OiBpbmxpbmUtYmxvY2s7IHRleHQtZGVjb3JhdGlvbjogaW5oZXJpdDsgfVxcblxcbi5Db2RlTWlycm9yLXJ1bGVycyB7XFxuICBwb3NpdGlvbjogYWJzb2x1dGU7XFxuICBsZWZ0OiAwOyByaWdodDogMDsgdG9wOiAtNTBweDsgYm90dG9tOiAwO1xcbiAgb3ZlcmZsb3c6IGhpZGRlbjtcXG59XFxuLkNvZGVNaXJyb3ItcnVsZXIge1xcbiAgYm9yZGVyLWxlZnQ6IDFweCBzb2xpZCAjY2NjO1xcbiAgdG9wOiAwOyBib3R0b206IDA7XFxuICBwb3NpdGlvbjogYWJzb2x1dGU7XFxufVxcblxcbi8qIERFRkFVTFQgVEhFTUUgKi9cXG5cXG4uY20tcy1kZWZhdWx0IC5jbS1oZWFkZXIge2NvbG9yOiBibHVlO31cXG4uY20tcy1kZWZhdWx0IC5jbS1xdW90ZSB7Y29sb3I6ICMwOTA7fVxcbi5jbS1uZWdhdGl2ZSB7Y29sb3I6ICNkNDQ7fVxcbi5jbS1wb3NpdGl2ZSB7Y29sb3I6ICMyOTI7fVxcbi5jbS1oZWFkZXIsIC5jbS1zdHJvbmcge2ZvbnQtd2VpZ2h0OiBib2xkO31cXG4uY20tZW0ge2ZvbnQtc3R5bGU6IGl0YWxpYzt9XFxuLmNtLWxpbmsge3RleHQtZGVjb3JhdGlvbjogdW5kZXJsaW5lO31cXG4uY20tc3RyaWtldGhyb3VnaCB7dGV4dC1kZWNvcmF0aW9uOiBsaW5lLXRocm91Z2g7fVxcblxcbi5jbS1zLWRlZmF1bHQgLmNtLWtleXdvcmQge2NvbG9yOiAjNzA4O31cXG4uY20tcy1kZWZhdWx0IC5jbS1hdG9tIHtjb2xvcjogIzIxOTt9XFxuLmNtLXMtZGVmYXVsdCAuY20tbnVtYmVyIHtjb2xvcjogIzE2NDt9XFxuLmNtLXMtZGVmYXVsdCAuY20tZGVmIHtjb2xvcjogIzAwZjt9XFxuLmNtLXMtZGVmYXVsdCAuY20tdmFyaWFibGUsXFxuLmNtLXMtZGVmYXVsdCAuY20tcHVuY3R1YXRpb24sXFxuLmNtLXMtZGVmYXVsdCAuY20tcHJvcGVydHksXFxuLmNtLXMtZGVmYXVsdCAuY20tb3BlcmF0b3Ige31cXG4uY20tcy1kZWZhdWx0IC5jbS12YXJpYWJsZS0yIHtjb2xvcjogIzA1YTt9XFxuLmNtLXMtZGVmYXVsdCAuY20tdmFyaWFibGUtMywgLmNtLXMtZGVmYXVsdCAuY20tdHlwZSB7Y29sb3I6ICMwODU7fVxcbi5jbS1zLWRlZmF1bHQgLmNtLWNvbW1lbnQge2NvbG9yOiAjYTUwO31cXG4uY20tcy1kZWZhdWx0IC5jbS1zdHJpbmcge2NvbG9yOiAjYTExO31cXG4uY20tcy1kZWZhdWx0IC5jbS1zdHJpbmctMiB7Y29sb3I6ICNmNTA7fVxcbi5jbS1zLWRlZmF1bHQgLmNtLW1ldGEge2NvbG9yOiAjNTU1O31cXG4uY20tcy1kZWZhdWx0IC5jbS1xdWFsaWZpZXIge2NvbG9yOiAjNTU1O31cXG4uY20tcy1kZWZhdWx0IC5jbS1idWlsdGluIHtjb2xvcjogIzMwYTt9XFxuLmNtLXMtZGVmYXVsdCAuY20tYnJhY2tldCB7Y29sb3I6ICM5OTc7fVxcbi5jbS1zLWRlZmF1bHQgLmNtLXRhZyB7Y29sb3I6ICMxNzA7fVxcbi5jbS1zLWRlZmF1bHQgLmNtLWF0dHJpYnV0ZSB7Y29sb3I6ICMwMGM7fVxcbi5jbS1zLWRlZmF1bHQgLmNtLWhyIHtjb2xvcjogIzk5OTt9XFxuLmNtLXMtZGVmYXVsdCAuY20tbGluayB7Y29sb3I6ICMwMGM7fVxcblxcbi5jbS1zLWRlZmF1bHQgLmNtLWVycm9yIHtjb2xvcjogI2YwMDt9XFxuLmNtLWludmFsaWRjaGFyIHtjb2xvcjogI2YwMDt9XFxuXFxuLkNvZGVNaXJyb3ItY29tcG9zaW5nIHsgYm9yZGVyLWJvdHRvbTogMnB4IHNvbGlkOyB9XFxuXFxuLyogRGVmYXVsdCBzdHlsZXMgZm9yIGNvbW1vbiBhZGRvbnMgKi9cXG5cXG5kaXYuQ29kZU1pcnJvciBzcGFuLkNvZGVNaXJyb3ItbWF0Y2hpbmdicmFja2V0IHtjb2xvcjogIzBiMDt9XFxuZGl2LkNvZGVNaXJyb3Igc3Bhbi5Db2RlTWlycm9yLW5vbm1hdGNoaW5nYnJhY2tldCB7Y29sb3I6ICNhMjI7fVxcbi5Db2RlTWlycm9yLW1hdGNoaW5ndGFnIHsgYmFja2dyb3VuZDogcmdiYSgyNTUsIDE1MCwgMCwgLjMpOyB9XFxuLkNvZGVNaXJyb3ItYWN0aXZlbGluZS1iYWNrZ3JvdW5kIHtiYWNrZ3JvdW5kOiAjZThmMmZmO31cXG5cXG4vKiBTVE9QICovXFxuXFxuLyogVGhlIHJlc3Qgb2YgdGhpcyBmaWxlIGNvbnRhaW5zIHN0eWxlcyByZWxhdGVkIHRvIHRoZSBtZWNoYW5pY3Mgb2ZcXG4gICB0aGUgZWRpdG9yLiBZb3UgcHJvYmFibHkgc2hvdWxkbid0IHRvdWNoIHRoZW0uICovXFxuXFxuLkNvZGVNaXJyb3Ige1xcbiAgcG9zaXRpb246IHJlbGF0aXZlO1xcbiAgb3ZlcmZsb3c6IGhpZGRlbjtcXG4gIGJhY2tncm91bmQ6IHdoaXRlO1xcbn1cXG5cXG4uQ29kZU1pcnJvci1zY3JvbGwge1xcbiAgb3ZlcmZsb3c6IHNjcm9sbCAhaW1wb3J0YW50OyAvKiBUaGluZ3Mgd2lsbCBicmVhayBpZiB0aGlzIGlzIG92ZXJyaWRkZW4gKi9cXG4gIC8qIDUwcHggaXMgdGhlIG1hZ2ljIG1hcmdpbiB1c2VkIHRvIGhpZGUgdGhlIGVsZW1lbnQncyByZWFsIHNjcm9sbGJhcnMgKi9cXG4gIC8qIFNlZSBvdmVyZmxvdzogaGlkZGVuIGluIC5Db2RlTWlycm9yICovXFxuICBtYXJnaW4tYm90dG9tOiAtNTBweDsgbWFyZ2luLXJpZ2h0OiAtNTBweDtcXG4gIHBhZGRpbmctYm90dG9tOiA1MHB4O1xcbiAgaGVpZ2h0OiAxMDAlO1xcbiAgb3V0bGluZTogbm9uZTsgLyogUHJldmVudCBkcmFnZ2luZyBmcm9tIGhpZ2hsaWdodGluZyB0aGUgZWxlbWVudCAqL1xcbiAgcG9zaXRpb246IHJlbGF0aXZlO1xcbiAgei1pbmRleDogMDtcXG59XFxuLkNvZGVNaXJyb3Itc2l6ZXIge1xcbiAgcG9zaXRpb246IHJlbGF0aXZlO1xcbiAgYm9yZGVyLXJpZ2h0OiA1MHB4IHNvbGlkIHRyYW5zcGFyZW50O1xcbn1cXG5cXG4vKiBUaGUgZmFrZSwgdmlzaWJsZSBzY3JvbGxiYXJzLiBVc2VkIHRvIGZvcmNlIHJlZHJhdyBkdXJpbmcgc2Nyb2xsaW5nXFxuICAgYmVmb3JlIGFjdHVhbCBzY3JvbGxpbmcgaGFwcGVucywgdGh1cyBwcmV2ZW50aW5nIHNoYWtpbmcgYW5kXFxuICAgZmxpY2tlcmluZyBhcnRpZmFjdHMuICovXFxuLkNvZGVNaXJyb3ItdnNjcm9sbGJhciwgLkNvZGVNaXJyb3ItaHNjcm9sbGJhciwgLkNvZGVNaXJyb3Itc2Nyb2xsYmFyLWZpbGxlciwgLkNvZGVNaXJyb3ItZ3V0dGVyLWZpbGxlciB7XFxuICBwb3NpdGlvbjogYWJzb2x1dGU7XFxuICB6LWluZGV4OiA2O1xcbiAgZGlzcGxheTogbm9uZTtcXG4gIG91dGxpbmU6IG5vbmU7XFxufVxcbi5Db2RlTWlycm9yLXZzY3JvbGxiYXIge1xcbiAgcmlnaHQ6IDA7IHRvcDogMDtcXG4gIG92ZXJmbG93LXg6IGhpZGRlbjtcXG4gIG92ZXJmbG93LXk6IHNjcm9sbDtcXG59XFxuLkNvZGVNaXJyb3ItaHNjcm9sbGJhciB7XFxuICBib3R0b206IDA7IGxlZnQ6IDA7XFxuICBvdmVyZmxvdy15OiBoaWRkZW47XFxuICBvdmVyZmxvdy14OiBzY3JvbGw7XFxufVxcbi5Db2RlTWlycm9yLXNjcm9sbGJhci1maWxsZXIge1xcbiAgcmlnaHQ6IDA7IGJvdHRvbTogMDtcXG59XFxuLkNvZGVNaXJyb3ItZ3V0dGVyLWZpbGxlciB7XFxuICBsZWZ0OiAwOyBib3R0b206IDA7XFxufVxcblxcbi5Db2RlTWlycm9yLWd1dHRlcnMge1xcbiAgcG9zaXRpb246IGFic29sdXRlOyBsZWZ0OiAwOyB0b3A6IDA7XFxuICBtaW4taGVpZ2h0OiAxMDAlO1xcbiAgei1pbmRleDogMztcXG59XFxuLkNvZGVNaXJyb3ItZ3V0dGVyIHtcXG4gIHdoaXRlLXNwYWNlOiBub3JtYWw7XFxuICBoZWlnaHQ6IDEwMCU7XFxuICBkaXNwbGF5OiBpbmxpbmUtYmxvY2s7XFxuICB2ZXJ0aWNhbC1hbGlnbjogdG9wO1xcbiAgbWFyZ2luLWJvdHRvbTogLTUwcHg7XFxufVxcbi5Db2RlTWlycm9yLWd1dHRlci13cmFwcGVyIHtcXG4gIHBvc2l0aW9uOiBhYnNvbHV0ZTtcXG4gIHotaW5kZXg6IDQ7XFxuICBiYWNrZ3JvdW5kOiBub25lICFpbXBvcnRhbnQ7XFxuICBib3JkZXI6IG5vbmUgIWltcG9ydGFudDtcXG59XFxuLkNvZGVNaXJyb3ItZ3V0dGVyLWJhY2tncm91bmQge1xcbiAgcG9zaXRpb246IGFic29sdXRlO1xcbiAgdG9wOiAwOyBib3R0b206IDA7XFxuICB6LWluZGV4OiA0O1xcbn1cXG4uQ29kZU1pcnJvci1ndXR0ZXItZWx0IHtcXG4gIHBvc2l0aW9uOiBhYnNvbHV0ZTtcXG4gIGN1cnNvcjogZGVmYXVsdDtcXG4gIHotaW5kZXg6IDQ7XFxufVxcbi5Db2RlTWlycm9yLWd1dHRlci13cmFwcGVyIDo6c2VsZWN0aW9uIHsgYmFja2dyb3VuZC1jb2xvcjogdHJhbnNwYXJlbnQgfVxcbi5Db2RlTWlycm9yLWd1dHRlci13cmFwcGVyIDo6LW1vei1zZWxlY3Rpb24geyBiYWNrZ3JvdW5kLWNvbG9yOiB0cmFuc3BhcmVudCB9XFxuXFxuLkNvZGVNaXJyb3ItbGluZXMge1xcbiAgY3Vyc29yOiB0ZXh0O1xcbiAgbWluLWhlaWdodDogMXB4OyAvKiBwcmV2ZW50cyBjb2xsYXBzaW5nIGJlZm9yZSBmaXJzdCBkcmF3ICovXFxufVxcbi5Db2RlTWlycm9yIHByZS5Db2RlTWlycm9yLWxpbmUsXFxuLkNvZGVNaXJyb3IgcHJlLkNvZGVNaXJyb3ItbGluZS1saWtlIHtcXG4gIC8qIFJlc2V0IHNvbWUgc3R5bGVzIHRoYXQgdGhlIHJlc3Qgb2YgdGhlIHBhZ2UgbWlnaHQgaGF2ZSBzZXQgKi9cXG4gIC1tb3otYm9yZGVyLXJhZGl1czogMDsgLXdlYmtpdC1ib3JkZXItcmFkaXVzOiAwOyBib3JkZXItcmFkaXVzOiAwO1xcbiAgYm9yZGVyLXdpZHRoOiAwO1xcbiAgYmFja2dyb3VuZDogdHJhbnNwYXJlbnQ7XFxuICBmb250LWZhbWlseTogaW5oZXJpdDtcXG4gIGZvbnQtc2l6ZTogaW5oZXJpdDtcXG4gIG1hcmdpbjogMDtcXG4gIHdoaXRlLXNwYWNlOiBwcmU7XFxuICB3b3JkLXdyYXA6IG5vcm1hbDtcXG4gIGxpbmUtaGVpZ2h0OiBpbmhlcml0O1xcbiAgY29sb3I6IGluaGVyaXQ7XFxuICB6LWluZGV4OiAyO1xcbiAgcG9zaXRpb246IHJlbGF0aXZlO1xcbiAgb3ZlcmZsb3c6IHZpc2libGU7XFxuICAtd2Via2l0LXRhcC1oaWdobGlnaHQtY29sb3I6IHRyYW5zcGFyZW50O1xcbiAgLXdlYmtpdC1mb250LXZhcmlhbnQtbGlnYXR1cmVzOiBjb250ZXh0dWFsO1xcbiAgZm9udC12YXJpYW50LWxpZ2F0dXJlczogY29udGV4dHVhbDtcXG59XFxuLkNvZGVNaXJyb3Itd3JhcCBwcmUuQ29kZU1pcnJvci1saW5lLFxcbi5Db2RlTWlycm9yLXdyYXAgcHJlLkNvZGVNaXJyb3ItbGluZS1saWtlIHtcXG4gIHdvcmQtd3JhcDogYnJlYWstd29yZDtcXG4gIHdoaXRlLXNwYWNlOiBwcmUtd3JhcDtcXG4gIHdvcmQtYnJlYWs6IG5vcm1hbDtcXG59XFxuXFxuLkNvZGVNaXJyb3ItbGluZWJhY2tncm91bmQge1xcbiAgcG9zaXRpb246IGFic29sdXRlO1xcbiAgbGVmdDogMDsgcmlnaHQ6IDA7IHRvcDogMDsgYm90dG9tOiAwO1xcbiAgei1pbmRleDogMDtcXG59XFxuXFxuLkNvZGVNaXJyb3ItbGluZXdpZGdldCB7XFxuICBwb3NpdGlvbjogcmVsYXRpdmU7XFxuICB6LWluZGV4OiAyO1xcbiAgcGFkZGluZzogMC4xcHg7IC8qIEZvcmNlIHdpZGdldCBtYXJnaW5zIHRvIHN0YXkgaW5zaWRlIG9mIHRoZSBjb250YWluZXIgKi9cXG59XFxuXFxuLkNvZGVNaXJyb3Itd2lkZ2V0IHt9XFxuXFxuLkNvZGVNaXJyb3ItcnRsIHByZSB7IGRpcmVjdGlvbjogcnRsOyB9XFxuXFxuLkNvZGVNaXJyb3ItY29kZSB7XFxuICBvdXRsaW5lOiBub25lO1xcbn1cXG5cXG4vKiBGb3JjZSBjb250ZW50LWJveCBzaXppbmcgZm9yIHRoZSBlbGVtZW50cyB3aGVyZSB3ZSBleHBlY3QgaXQgKi9cXG4uQ29kZU1pcnJvci1zY3JvbGwsXFxuLkNvZGVNaXJyb3Itc2l6ZXIsXFxuLkNvZGVNaXJyb3ItZ3V0dGVyLFxcbi5Db2RlTWlycm9yLWd1dHRlcnMsXFxuLkNvZGVNaXJyb3ItbGluZW51bWJlciB7XFxuICAtbW96LWJveC1zaXppbmc6IGNvbnRlbnQtYm94O1xcbiAgYm94LXNpemluZzogY29udGVudC1ib3g7XFxufVxcblxcbi5Db2RlTWlycm9yLW1lYXN1cmUge1xcbiAgcG9zaXRpb246IGFic29sdXRlO1xcbiAgd2lkdGg6IDEwMCU7XFxuICBoZWlnaHQ6IDA7XFxuICBvdmVyZmxvdzogaGlkZGVuO1xcbiAgdmlzaWJpbGl0eTogaGlkZGVuO1xcbn1cXG5cXG4uQ29kZU1pcnJvci1jdXJzb3Ige1xcbiAgcG9zaXRpb246IGFic29sdXRlO1xcbiAgcG9pbnRlci1ldmVudHM6IG5vbmU7XFxufVxcbi5Db2RlTWlycm9yLW1lYXN1cmUgcHJlIHsgcG9zaXRpb246IHN0YXRpYzsgfVxcblxcbmRpdi5Db2RlTWlycm9yLWN1cnNvcnMge1xcbiAgdmlzaWJpbGl0eTogaGlkZGVuO1xcbiAgcG9zaXRpb246IHJlbGF0aXZlO1xcbiAgei1pbmRleDogMztcXG59XFxuZGl2LkNvZGVNaXJyb3ItZHJhZ2N1cnNvcnMge1xcbiAgdmlzaWJpbGl0eTogdmlzaWJsZTtcXG59XFxuXFxuLkNvZGVNaXJyb3ItZm9jdXNlZCBkaXYuQ29kZU1pcnJvci1jdXJzb3JzIHtcXG4gIHZpc2liaWxpdHk6IHZpc2libGU7XFxufVxcblxcbi5Db2RlTWlycm9yLXNlbGVjdGVkIHsgYmFja2dyb3VuZDogI2Q5ZDlkOTsgfVxcbi5Db2RlTWlycm9yLWZvY3VzZWQgLkNvZGVNaXJyb3Itc2VsZWN0ZWQgeyBiYWNrZ3JvdW5kOiAjZDdkNGYwOyB9XFxuLkNvZGVNaXJyb3ItY3Jvc3NoYWlyIHsgY3Vyc29yOiBjcm9zc2hhaXI7IH1cXG4uQ29kZU1pcnJvci1saW5lOjpzZWxlY3Rpb24sIC5Db2RlTWlycm9yLWxpbmUgPiBzcGFuOjpzZWxlY3Rpb24sIC5Db2RlTWlycm9yLWxpbmUgPiBzcGFuID4gc3Bhbjo6c2VsZWN0aW9uIHsgYmFja2dyb3VuZDogI2Q3ZDRmMDsgfVxcbi5Db2RlTWlycm9yLWxpbmU6Oi1tb3otc2VsZWN0aW9uLCAuQ29kZU1pcnJvci1saW5lID4gc3Bhbjo6LW1vei1zZWxlY3Rpb24sIC5Db2RlTWlycm9yLWxpbmUgPiBzcGFuID4gc3Bhbjo6LW1vei1zZWxlY3Rpb24geyBiYWNrZ3JvdW5kOiAjZDdkNGYwOyB9XFxuXFxuLmNtLXNlYXJjaGluZyB7XFxuICBiYWNrZ3JvdW5kLWNvbG9yOiAjZmZhO1xcbiAgYmFja2dyb3VuZC1jb2xvcjogcmdiYSgyNTUsIDI1NSwgMCwgLjQpO1xcbn1cXG5cXG4vKiBVc2VkIHRvIGZvcmNlIGEgYm9yZGVyIG1vZGVsIGZvciBhIG5vZGUgKi9cXG4uY20tZm9yY2UtYm9yZGVyIHsgcGFkZGluZy1yaWdodDogLjFweDsgfVxcblxcbkBtZWRpYSBwcmludCB7XFxuICAvKiBIaWRlIHRoZSBjdXJzb3Igd2hlbiBwcmludGluZyAqL1xcbiAgLkNvZGVNaXJyb3IgZGl2LkNvZGVNaXJyb3ItY3Vyc29ycyB7XFxuICAgIHZpc2liaWxpdHk6IGhpZGRlbjtcXG4gIH1cXG59XFxuXFxuLyogU2VlIGlzc3VlICMyOTAxICovXFxuLmNtLXRhYi13cmFwLWhhY2s6YWZ0ZXIgeyBjb250ZW50OiAnJzsgfVxcblxcbi8qIEhlbHAgdXNlcnMgdXNlIG1hcmtzZWxlY3Rpb24gdG8gc2FmZWx5IHN0eWxlIHRleHQgYmFja2dyb3VuZCAqL1xcbnNwYW4uQ29kZU1pcnJvci1zZWxlY3RlZHRleHQgeyBiYWNrZ3JvdW5kOiBub25lOyB9XFxuXCJdLFwic291cmNlUm9vdFwiOlwiXCJ9XSk7XG4vLyBFeHBvcnRzXG5leHBvcnQgZGVmYXVsdCBfX19DU1NfTE9BREVSX0VYUE9SVF9fXztcbiIsIi8vIEltcG9ydHNcbmltcG9ydCBfX19DU1NfTE9BREVSX0FQSV9TT1VSQ0VNQVBfSU1QT1JUX19fIGZyb20gXCIuL25vZGVfbW9kdWxlcy9jc3MtbG9hZGVyL2Rpc3QvcnVudGltZS9zb3VyY2VNYXBzLmpzXCI7XG5pbXBvcnQgX19fQ1NTX0xPQURFUl9BUElfSU1QT1JUX19fIGZyb20gXCIuL25vZGVfbW9kdWxlcy9jc3MtbG9hZGVyL2Rpc3QvcnVudGltZS9hcGkuanNcIjtcbmltcG9ydCBfX19DU1NfTE9BREVSX0FUX1JVTEVfSU1QT1JUXzBfX18gZnJvbSBcIi0hLi9ub2RlX21vZHVsZXMvY3NzLWxvYWRlci9kaXN0L2Nqcy5qcyEuL25vZGVfbW9kdWxlcy9jb2RlbWlycm9yL2xpYi9jb2RlbWlycm9yLmNzc1wiO1xuaW1wb3J0IF9fX0NTU19MT0FERVJfQVRfUlVMRV9JTVBPUlRfMV9fXyBmcm9tIFwiLSEuL25vZGVfbW9kdWxlcy9jc3MtbG9hZGVyL2Rpc3QvY2pzLmpzIS4vbm9kZV9tb2R1bGVzL2NvZGVtaXJyb3IvYWRkb24vaGludC9zaG93LWhpbnQuY3NzXCI7XG5pbXBvcnQgX19fQ1NTX0xPQURFUl9BVF9SVUxFX0lNUE9SVF8yX19fIGZyb20gXCItIS4vbm9kZV9tb2R1bGVzL2Nzcy1sb2FkZXIvZGlzdC9janMuanMhLi9ub2RlX21vZHVsZXMvY29kZW1pcnJvci9hZGRvbi9saW50L2xpbnQuY3NzXCI7XG5pbXBvcnQgX19fQ1NTX0xPQURFUl9BVF9SVUxFX0lNUE9SVF8zX19fIGZyb20gXCItIS4vbm9kZV9tb2R1bGVzL2Nzcy1sb2FkZXIvZGlzdC9janMuanMhLi9ub2RlX21vZHVsZXMvY29kZW1pcnJvci9hZGRvbi9zY3JvbGwvc2ltcGxlc2Nyb2xsYmFycy5jc3NcIjtcbnZhciBfX19DU1NfTE9BREVSX0VYUE9SVF9fXyA9IF9fX0NTU19MT0FERVJfQVBJX0lNUE9SVF9fXyhfX19DU1NfTE9BREVSX0FQSV9TT1VSQ0VNQVBfSU1QT1JUX19fKTtcbl9fX0NTU19MT0FERVJfRVhQT1JUX19fLmkoX19fQ1NTX0xPQURFUl9BVF9SVUxFX0lNUE9SVF8wX19fKTtcbl9fX0NTU19MT0FERVJfRVhQT1JUX19fLmkoX19fQ1NTX0xPQURFUl9BVF9SVUxFX0lNUE9SVF8xX19fKTtcbl9fX0NTU19MT0FERVJfRVhQT1JUX19fLmkoX19fQ1NTX0xPQURFUl9BVF9SVUxFX0lNUE9SVF8yX19fKTtcbl9fX0NTU19MT0FERVJfRVhQT1JUX19fLmkoX19fQ1NTX0xPQURFUl9BVF9SVUxFX0lNUE9SVF8zX19fKTtcbi8vIE1vZHVsZVxuX19fQ1NTX0xPQURFUl9FWFBPUlRfX18ucHVzaChbbW9kdWxlLmlkLCBcIioge1xcbiAgYm94LXNpemluZzogYm9yZGVyLWJveDtcXG59XFxuXFxuLmVkaXRvciB7XFxuICBmbG9hdDogbGVmdDtcXG4gIHdpZHRoOiA1MCU7XFxuICBtYXJnaW46IDA7XFxuICBwYWRkaW5nOiAyJTtcXG4gIGhlaWdodDogMTAwJTtcXG4gIGJhY2tncm91bmQtY29sb3I6IGdhaW5zYm9ybztcXG4gIGJvcmRlcjogZ2FpbnNib3JvO1xcbiAgYm9yZGVyLXJhZGl1czogMTBweDtcXG59XFxuLmVkaXRvciAuc2hvcnRjdXQge1xcbiAgY29sb3I6IGdyYXk7XFxuICBmb250LXNpemU6IDE0cHg7XFxuICBkaXNwbGF5OiBpbmxpbmU7XFxuICBtYXJnaW46IDAgNXB4O1xcbn1cXG4uZWRpdG9yIC5saW5lLWVycm9yIHtcXG4gIGJhY2tncm91bmQ6ICNmYmMyYzQgIWltcG9ydGFudDtcXG4gIGNvbG9yOiAjOGExZjExICFpbXBvcnRhbnQ7XFxufVxcbi5lZGl0b3IgLmVycm9yLW1hcmtlciB7XFxuICBjb2xvcjogYmxhY2s7XFxuICB3aWR0aDogMTBweCAhaW1wb3J0YW50O1xcbiAgYmFja2dyb3VuZC1jb2xvcjogI2ZmMDAwMDtcXG59XFxuLmVkaXRvciAuZXJyb3ItbWFya2VyIC5lcnJvci1tZXNzYWdlIHtcXG4gIGRpc3BsYXk6IG5vbmU7XFxuICBwb3NpdGlvbjogYWJzb2x1dGU7XFxuICBiYWNrZ3JvdW5kLWNvbG9yOiAjZGRkO1xcbiAgYm9yZGVyOiAxcHggc29saWQgIzk5OTtcXG4gIHBhZGRpbmc6IDZweDtcXG4gIHdpZHRoOiAxNDBweDtcXG4gIGxlZnQ6IDE1cHg7XFxuICB0b3A6IC0xZW07XFxufVxcbi5lZGl0b3IgLmVycm9yLW1hcmtlcjpob3ZlciAuZXJyb3ItbWVzc2FnZSB7XFxuICBkaXNwbGF5OiBibG9jaztcXG59XFxuXFxuLnNhdmVfbG9hZCB7XFxuICB3aWR0aDogMTAwJTtcXG4gIGhlaWdodDogMTAwJTtcXG4gIGZsb2F0OiBsZWZ0O1xcbn1cIiwgXCJcIix7XCJ2ZXJzaW9uXCI6MyxcInNvdXJjZXNcIjpbXCJ3ZWJwYWNrOi8vLi9zdHlsZS5zY3NzXCJdLFwibmFtZXNcIjpbXSxcIm1hcHBpbmdzXCI6XCJBQUtBO0VBQ0Usc0JBQUE7QUFBRjs7QUFHQTtFQUNFLFdBQUE7RUFDQSxVQUFBO0VBQ0EsU0FBQTtFQUNBLFdBQUE7RUFDQSxZQUFBO0VBQ0EsMkJBQUE7RUFDQSxpQkFBQTtFQUNBLG1CQUFBO0FBQUY7QUFDRTtFQUNFLFdBQUE7RUFDQSxlQUFBO0VBQ0EsZUFBQTtFQUNBLGFBQUE7QUFDSjtBQUNFO0VBQ0UsOEJBQUE7RUFDQSx5QkFBQTtBQUNKO0FBQ0U7RUFDRSxZQUFBO0VBQ0Esc0JBQUE7RUFDQSx5QkFBQTtBQUNKO0FBR0k7RUFDRSxhQUFBO0VBQ0Esa0JBQUE7RUFDQSxzQkFBQTtFQUNBLHNCQUFBO0VBQ0EsWUFBQTtFQUNBLFlBQUE7RUFDQSxVQUFBO0VBQ0EsU0FBQTtBQUROO0FBTUk7RUFDRSxjQUFBO0FBSk47O0FBUUE7RUFDRSxXQUFBO0VBQ0EsWUFBQTtFQUNBLFdBQUE7QUFMRlwiLFwic291cmNlc0NvbnRlbnRcIjpbXCJAaW1wb3J0IFxcXCJub2RlX21vZHVsZXMvY29kZW1pcnJvci9saWIvY29kZW1pcnJvci5jc3NcXFwiO1xcbkBpbXBvcnQgXFxcIm5vZGVfbW9kdWxlcy9jb2RlbWlycm9yL2FkZG9uL2hpbnQvc2hvdy1oaW50LmNzc1xcXCI7XFxuQGltcG9ydCBcXFwibm9kZV9tb2R1bGVzL2NvZGVtaXJyb3IvYWRkb24vbGludC9saW50LmNzc1xcXCI7XFxuQGltcG9ydCBcXFwibm9kZV9tb2R1bGVzL2NvZGVtaXJyb3IvYWRkb24vc2Nyb2xsL3NpbXBsZXNjcm9sbGJhcnMuY3NzXFxcIjtcXG5cXG4qIHtcXG4gIGJveC1zaXppbmc6IGJvcmRlci1ib3g7XFxufVxcblxcbi5lZGl0b3Ige1xcbiAgZmxvYXQ6IGxlZnQ7XFxuICB3aWR0aDogNTAlO1xcbiAgbWFyZ2luOiAwO1xcbiAgcGFkZGluZzogMiU7XFxuICBoZWlnaHQ6IDEwMCU7XFxuICBiYWNrZ3JvdW5kLWNvbG9yOiBnYWluc2Jvcm87XFxuICBib3JkZXI6IGdhaW5zYm9ybztcXG4gIGJvcmRlci1yYWRpdXM6IDEwcHg7XFxuICAuc2hvcnRjdXR7XFxuICAgIGNvbG9yOiBncmF5IDtcXG4gICAgZm9udC1zaXplOiAxNHB4IDtcXG4gICAgZGlzcGxheTogaW5saW5lO1xcbiAgICBtYXJnaW46IDAgNXB4O1xcbiAgfVxcbiAgLmxpbmUtZXJyb3Ige1xcbiAgICBiYWNrZ3JvdW5kOiAjZmJjMmM0ICFpbXBvcnRhbnQ7XFxuICAgIGNvbG9yOiAjOGExZjExICFpbXBvcnRhbnQ7XFxuICB9XFxuICAuZXJyb3ItbWFya2VyIHtcXG4gICAgY29sb3I6IGJsYWNrO1xcbiAgICB3aWR0aDogMTBweCAhaW1wb3J0YW50O1xcbiAgICBiYWNrZ3JvdW5kLWNvbG9yOiAjZmYwMDAwO1xcbiAgfVxcblxcbiAgLmVycm9yLW1hcmtlciB7XFxuICAgIC5lcnJvci1tZXNzYWdlIHtcXG4gICAgICBkaXNwbGF5OiBub25lO1xcbiAgICAgIHBvc2l0aW9uOiBhYnNvbHV0ZTtcXG4gICAgICBiYWNrZ3JvdW5kLWNvbG9yOiAjZGRkO1xcbiAgICAgIGJvcmRlcjogMXB4IHNvbGlkICM5OTk7XFxuICAgICAgcGFkZGluZzogNnB4O1xcbiAgICAgIHdpZHRoOiAxNDBweDtcXG4gICAgICBsZWZ0OiAxNXB4O1xcbiAgICAgIHRvcDogLTFlbTtcXG4gICAgfVxcbiAgfVxcblxcbiAgLmVycm9yLW1hcmtlcjpob3ZlciB7XFxuICAgIC5lcnJvci1tZXNzYWdlIHtcXG4gICAgICBkaXNwbGF5OiBibG9jaztcXG4gICAgfVxcbiAgfVxcbn1cXG4uc2F2ZV9sb2FkIHtcXG4gIHdpZHRoOiAxMDAlO1xcbiAgaGVpZ2h0OiAxMDAlO1xcbiAgZmxvYXQ6IGxlZnQ7XFxufVwiXSxcInNvdXJjZVJvb3RcIjpcIlwifV0pO1xuLy8gRXhwb3J0c1xuZXhwb3J0IGRlZmF1bHQgX19fQ1NTX0xPQURFUl9FWFBPUlRfX187XG4iLCJcInVzZSBzdHJpY3RcIjtcblxuLypcbiAgTUlUIExpY2Vuc2UgaHR0cDovL3d3dy5vcGVuc291cmNlLm9yZy9saWNlbnNlcy9taXQtbGljZW5zZS5waHBcbiAgQXV0aG9yIFRvYmlhcyBLb3BwZXJzIEBzb2tyYVxuKi9cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKGNzc1dpdGhNYXBwaW5nVG9TdHJpbmcpIHtcbiAgdmFyIGxpc3QgPSBbXTsgLy8gcmV0dXJuIHRoZSBsaXN0IG9mIG1vZHVsZXMgYXMgY3NzIHN0cmluZ1xuXG4gIGxpc3QudG9TdHJpbmcgPSBmdW5jdGlvbiB0b1N0cmluZygpIHtcbiAgICByZXR1cm4gdGhpcy5tYXAoZnVuY3Rpb24gKGl0ZW0pIHtcbiAgICAgIHZhciBjb250ZW50ID0gXCJcIjtcbiAgICAgIHZhciBuZWVkTGF5ZXIgPSB0eXBlb2YgaXRlbVs1XSAhPT0gXCJ1bmRlZmluZWRcIjtcblxuICAgICAgaWYgKGl0ZW1bNF0pIHtcbiAgICAgICAgY29udGVudCArPSBcIkBzdXBwb3J0cyAoXCIuY29uY2F0KGl0ZW1bNF0sIFwiKSB7XCIpO1xuICAgICAgfVxuXG4gICAgICBpZiAoaXRlbVsyXSkge1xuICAgICAgICBjb250ZW50ICs9IFwiQG1lZGlhIFwiLmNvbmNhdChpdGVtWzJdLCBcIiB7XCIpO1xuICAgICAgfVxuXG4gICAgICBpZiAobmVlZExheWVyKSB7XG4gICAgICAgIGNvbnRlbnQgKz0gXCJAbGF5ZXJcIi5jb25jYXQoaXRlbVs1XS5sZW5ndGggPiAwID8gXCIgXCIuY29uY2F0KGl0ZW1bNV0pIDogXCJcIiwgXCIge1wiKTtcbiAgICAgIH1cblxuICAgICAgY29udGVudCArPSBjc3NXaXRoTWFwcGluZ1RvU3RyaW5nKGl0ZW0pO1xuXG4gICAgICBpZiAobmVlZExheWVyKSB7XG4gICAgICAgIGNvbnRlbnQgKz0gXCJ9XCI7XG4gICAgICB9XG5cbiAgICAgIGlmIChpdGVtWzJdKSB7XG4gICAgICAgIGNvbnRlbnQgKz0gXCJ9XCI7XG4gICAgICB9XG5cbiAgICAgIGlmIChpdGVtWzRdKSB7XG4gICAgICAgIGNvbnRlbnQgKz0gXCJ9XCI7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBjb250ZW50O1xuICAgIH0pLmpvaW4oXCJcIik7XG4gIH07IC8vIGltcG9ydCBhIGxpc3Qgb2YgbW9kdWxlcyBpbnRvIHRoZSBsaXN0XG5cblxuICBsaXN0LmkgPSBmdW5jdGlvbiBpKG1vZHVsZXMsIG1lZGlhLCBkZWR1cGUsIHN1cHBvcnRzLCBsYXllcikge1xuICAgIGlmICh0eXBlb2YgbW9kdWxlcyA9PT0gXCJzdHJpbmdcIikge1xuICAgICAgbW9kdWxlcyA9IFtbbnVsbCwgbW9kdWxlcywgdW5kZWZpbmVkXV07XG4gICAgfVxuXG4gICAgdmFyIGFscmVhZHlJbXBvcnRlZE1vZHVsZXMgPSB7fTtcblxuICAgIGlmIChkZWR1cGUpIHtcbiAgICAgIGZvciAodmFyIGsgPSAwOyBrIDwgdGhpcy5sZW5ndGg7IGsrKykge1xuICAgICAgICB2YXIgaWQgPSB0aGlzW2tdWzBdO1xuXG4gICAgICAgIGlmIChpZCAhPSBudWxsKSB7XG4gICAgICAgICAgYWxyZWFkeUltcG9ydGVkTW9kdWxlc1tpZF0gPSB0cnVlO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuXG4gICAgZm9yICh2YXIgX2sgPSAwOyBfayA8IG1vZHVsZXMubGVuZ3RoOyBfaysrKSB7XG4gICAgICB2YXIgaXRlbSA9IFtdLmNvbmNhdChtb2R1bGVzW19rXSk7XG5cbiAgICAgIGlmIChkZWR1cGUgJiYgYWxyZWFkeUltcG9ydGVkTW9kdWxlc1tpdGVtWzBdXSkge1xuICAgICAgICBjb250aW51ZTtcbiAgICAgIH1cblxuICAgICAgaWYgKHR5cGVvZiBsYXllciAhPT0gXCJ1bmRlZmluZWRcIikge1xuICAgICAgICBpZiAodHlwZW9mIGl0ZW1bNV0gPT09IFwidW5kZWZpbmVkXCIpIHtcbiAgICAgICAgICBpdGVtWzVdID0gbGF5ZXI7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgaXRlbVsxXSA9IFwiQGxheWVyXCIuY29uY2F0KGl0ZW1bNV0ubGVuZ3RoID4gMCA/IFwiIFwiLmNvbmNhdChpdGVtWzVdKSA6IFwiXCIsIFwiIHtcIikuY29uY2F0KGl0ZW1bMV0sIFwifVwiKTtcbiAgICAgICAgICBpdGVtWzVdID0gbGF5ZXI7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgaWYgKG1lZGlhKSB7XG4gICAgICAgIGlmICghaXRlbVsyXSkge1xuICAgICAgICAgIGl0ZW1bMl0gPSBtZWRpYTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBpdGVtWzFdID0gXCJAbWVkaWEgXCIuY29uY2F0KGl0ZW1bMl0sIFwiIHtcIikuY29uY2F0KGl0ZW1bMV0sIFwifVwiKTtcbiAgICAgICAgICBpdGVtWzJdID0gbWVkaWE7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgaWYgKHN1cHBvcnRzKSB7XG4gICAgICAgIGlmICghaXRlbVs0XSkge1xuICAgICAgICAgIGl0ZW1bNF0gPSBcIlwiLmNvbmNhdChzdXBwb3J0cyk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgaXRlbVsxXSA9IFwiQHN1cHBvcnRzIChcIi5jb25jYXQoaXRlbVs0XSwgXCIpIHtcIikuY29uY2F0KGl0ZW1bMV0sIFwifVwiKTtcbiAgICAgICAgICBpdGVtWzRdID0gc3VwcG9ydHM7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgbGlzdC5wdXNoKGl0ZW0pO1xuICAgIH1cbiAgfTtcblxuICByZXR1cm4gbGlzdDtcbn07IiwiXCJ1c2Ugc3RyaWN0XCI7XG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKHVybCwgb3B0aW9ucykge1xuICBpZiAoIW9wdGlvbnMpIHtcbiAgICBvcHRpb25zID0ge307XG4gIH1cblxuICBpZiAoIXVybCkge1xuICAgIHJldHVybiB1cmw7XG4gIH1cblxuICB1cmwgPSBTdHJpbmcodXJsLl9fZXNNb2R1bGUgPyB1cmwuZGVmYXVsdCA6IHVybCk7IC8vIElmIHVybCBpcyBhbHJlYWR5IHdyYXBwZWQgaW4gcXVvdGVzLCByZW1vdmUgdGhlbVxuXG4gIGlmICgvXlsnXCJdLipbJ1wiXSQvLnRlc3QodXJsKSkge1xuICAgIHVybCA9IHVybC5zbGljZSgxLCAtMSk7XG4gIH1cblxuICBpZiAob3B0aW9ucy5oYXNoKSB7XG4gICAgdXJsICs9IG9wdGlvbnMuaGFzaDtcbiAgfSAvLyBTaG91bGQgdXJsIGJlIHdyYXBwZWQ/XG4gIC8vIFNlZSBodHRwczovL2RyYWZ0cy5jc3N3Zy5vcmcvY3NzLXZhbHVlcy0zLyN1cmxzXG5cblxuICBpZiAoL1tcIicoKSBcXHRcXG5dfCglMjApLy50ZXN0KHVybCkgfHwgb3B0aW9ucy5uZWVkUXVvdGVzKSB7XG4gICAgcmV0dXJuIFwiXFxcIlwiLmNvbmNhdCh1cmwucmVwbGFjZSgvXCIvZywgJ1xcXFxcIicpLnJlcGxhY2UoL1xcbi9nLCBcIlxcXFxuXCIpLCBcIlxcXCJcIik7XG4gIH1cblxuICByZXR1cm4gdXJsO1xufTsiLCJcInVzZSBzdHJpY3RcIjtcblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAoaXRlbSkge1xuICB2YXIgY29udGVudCA9IGl0ZW1bMV07XG4gIHZhciBjc3NNYXBwaW5nID0gaXRlbVszXTtcblxuICBpZiAoIWNzc01hcHBpbmcpIHtcbiAgICByZXR1cm4gY29udGVudDtcbiAgfVxuXG4gIGlmICh0eXBlb2YgYnRvYSA9PT0gXCJmdW5jdGlvblwiKSB7XG4gICAgdmFyIGJhc2U2NCA9IGJ0b2EodW5lc2NhcGUoZW5jb2RlVVJJQ29tcG9uZW50KEpTT04uc3RyaW5naWZ5KGNzc01hcHBpbmcpKSkpO1xuICAgIHZhciBkYXRhID0gXCJzb3VyY2VNYXBwaW5nVVJMPWRhdGE6YXBwbGljYXRpb24vanNvbjtjaGFyc2V0PXV0Zi04O2Jhc2U2NCxcIi5jb25jYXQoYmFzZTY0KTtcbiAgICB2YXIgc291cmNlTWFwcGluZyA9IFwiLyojIFwiLmNvbmNhdChkYXRhLCBcIiAqL1wiKTtcbiAgICB2YXIgc291cmNlVVJMcyA9IGNzc01hcHBpbmcuc291cmNlcy5tYXAoZnVuY3Rpb24gKHNvdXJjZSkge1xuICAgICAgcmV0dXJuIFwiLyojIHNvdXJjZVVSTD1cIi5jb25jYXQoY3NzTWFwcGluZy5zb3VyY2VSb290IHx8IFwiXCIpLmNvbmNhdChzb3VyY2UsIFwiICovXCIpO1xuICAgIH0pO1xuICAgIHJldHVybiBbY29udGVudF0uY29uY2F0KHNvdXJjZVVSTHMpLmNvbmNhdChbc291cmNlTWFwcGluZ10pLmpvaW4oXCJcXG5cIik7XG4gIH1cblxuICByZXR1cm4gW2NvbnRlbnRdLmpvaW4oXCJcXG5cIik7XG59OyIsIihmdW5jdGlvbihhLGIpe2lmKFwiZnVuY3Rpb25cIj09dHlwZW9mIGRlZmluZSYmZGVmaW5lLmFtZClkZWZpbmUoW10sYik7ZWxzZSBpZihcInVuZGVmaW5lZFwiIT10eXBlb2YgZXhwb3J0cyliKCk7ZWxzZXtiKCksYS5GaWxlU2F2ZXI9e2V4cG9ydHM6e319LmV4cG9ydHN9fSkodGhpcyxmdW5jdGlvbigpe1widXNlIHN0cmljdFwiO2Z1bmN0aW9uIGIoYSxiKXtyZXR1cm5cInVuZGVmaW5lZFwiPT10eXBlb2YgYj9iPXthdXRvQm9tOiExfTpcIm9iamVjdFwiIT10eXBlb2YgYiYmKGNvbnNvbGUud2FybihcIkRlcHJlY2F0ZWQ6IEV4cGVjdGVkIHRoaXJkIGFyZ3VtZW50IHRvIGJlIGEgb2JqZWN0XCIpLGI9e2F1dG9Cb206IWJ9KSxiLmF1dG9Cb20mJi9eXFxzKig/OnRleHRcXC9cXFMqfGFwcGxpY2F0aW9uXFwveG1sfFxcUypcXC9cXFMqXFwreG1sKVxccyo7LipjaGFyc2V0XFxzKj1cXHMqdXRmLTgvaS50ZXN0KGEudHlwZSk/bmV3IEJsb2IoW1wiXFx1RkVGRlwiLGFdLHt0eXBlOmEudHlwZX0pOmF9ZnVuY3Rpb24gYyhhLGIsYyl7dmFyIGQ9bmV3IFhNTEh0dHBSZXF1ZXN0O2Qub3BlbihcIkdFVFwiLGEpLGQucmVzcG9uc2VUeXBlPVwiYmxvYlwiLGQub25sb2FkPWZ1bmN0aW9uKCl7ZyhkLnJlc3BvbnNlLGIsYyl9LGQub25lcnJvcj1mdW5jdGlvbigpe2NvbnNvbGUuZXJyb3IoXCJjb3VsZCBub3QgZG93bmxvYWQgZmlsZVwiKX0sZC5zZW5kKCl9ZnVuY3Rpb24gZChhKXt2YXIgYj1uZXcgWE1MSHR0cFJlcXVlc3Q7Yi5vcGVuKFwiSEVBRFwiLGEsITEpO3RyeXtiLnNlbmQoKX1jYXRjaChhKXt9cmV0dXJuIDIwMDw9Yi5zdGF0dXMmJjI5OT49Yi5zdGF0dXN9ZnVuY3Rpb24gZShhKXt0cnl7YS5kaXNwYXRjaEV2ZW50KG5ldyBNb3VzZUV2ZW50KFwiY2xpY2tcIikpfWNhdGNoKGMpe3ZhciBiPWRvY3VtZW50LmNyZWF0ZUV2ZW50KFwiTW91c2VFdmVudHNcIik7Yi5pbml0TW91c2VFdmVudChcImNsaWNrXCIsITAsITAsd2luZG93LDAsMCwwLDgwLDIwLCExLCExLCExLCExLDAsbnVsbCksYS5kaXNwYXRjaEV2ZW50KGIpfX12YXIgZj1cIm9iamVjdFwiPT10eXBlb2Ygd2luZG93JiZ3aW5kb3cud2luZG93PT09d2luZG93P3dpbmRvdzpcIm9iamVjdFwiPT10eXBlb2Ygc2VsZiYmc2VsZi5zZWxmPT09c2VsZj9zZWxmOlwib2JqZWN0XCI9PXR5cGVvZiBnbG9iYWwmJmdsb2JhbC5nbG9iYWw9PT1nbG9iYWw/Z2xvYmFsOnZvaWQgMCxhPWYubmF2aWdhdG9yJiYvTWFjaW50b3NoLy50ZXN0KG5hdmlnYXRvci51c2VyQWdlbnQpJiYvQXBwbGVXZWJLaXQvLnRlc3QobmF2aWdhdG9yLnVzZXJBZ2VudCkmJiEvU2FmYXJpLy50ZXN0KG5hdmlnYXRvci51c2VyQWdlbnQpLGc9Zi5zYXZlQXN8fChcIm9iamVjdFwiIT10eXBlb2Ygd2luZG93fHx3aW5kb3chPT1mP2Z1bmN0aW9uKCl7fTpcImRvd25sb2FkXCJpbiBIVE1MQW5jaG9yRWxlbWVudC5wcm90b3R5cGUmJiFhP2Z1bmN0aW9uKGIsZyxoKXt2YXIgaT1mLlVSTHx8Zi53ZWJraXRVUkwsaj1kb2N1bWVudC5jcmVhdGVFbGVtZW50KFwiYVwiKTtnPWd8fGIubmFtZXx8XCJkb3dubG9hZFwiLGouZG93bmxvYWQ9ZyxqLnJlbD1cIm5vb3BlbmVyXCIsXCJzdHJpbmdcIj09dHlwZW9mIGI/KGouaHJlZj1iLGoub3JpZ2luPT09bG9jYXRpb24ub3JpZ2luP2Uoaik6ZChqLmhyZWYpP2MoYixnLGgpOmUoaixqLnRhcmdldD1cIl9ibGFua1wiKSk6KGouaHJlZj1pLmNyZWF0ZU9iamVjdFVSTChiKSxzZXRUaW1lb3V0KGZ1bmN0aW9uKCl7aS5yZXZva2VPYmplY3RVUkwoai5ocmVmKX0sNEU0KSxzZXRUaW1lb3V0KGZ1bmN0aW9uKCl7ZShqKX0sMCkpfTpcIm1zU2F2ZU9yT3BlbkJsb2JcImluIG5hdmlnYXRvcj9mdW5jdGlvbihmLGcsaCl7aWYoZz1nfHxmLm5hbWV8fFwiZG93bmxvYWRcIixcInN0cmluZ1wiIT10eXBlb2YgZiluYXZpZ2F0b3IubXNTYXZlT3JPcGVuQmxvYihiKGYsaCksZyk7ZWxzZSBpZihkKGYpKWMoZixnLGgpO2Vsc2V7dmFyIGk9ZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcImFcIik7aS5ocmVmPWYsaS50YXJnZXQ9XCJfYmxhbmtcIixzZXRUaW1lb3V0KGZ1bmN0aW9uKCl7ZShpKX0pfX06ZnVuY3Rpb24oYixkLGUsZyl7aWYoZz1nfHxvcGVuKFwiXCIsXCJfYmxhbmtcIiksZyYmKGcuZG9jdW1lbnQudGl0bGU9Zy5kb2N1bWVudC5ib2R5LmlubmVyVGV4dD1cImRvd25sb2FkaW5nLi4uXCIpLFwic3RyaW5nXCI9PXR5cGVvZiBiKXJldHVybiBjKGIsZCxlKTt2YXIgaD1cImFwcGxpY2F0aW9uL29jdGV0LXN0cmVhbVwiPT09Yi50eXBlLGk9L2NvbnN0cnVjdG9yL2kudGVzdChmLkhUTUxFbGVtZW50KXx8Zi5zYWZhcmksaj0vQ3JpT1NcXC9bXFxkXSsvLnRlc3QobmF2aWdhdG9yLnVzZXJBZ2VudCk7aWYoKGp8fGgmJml8fGEpJiZcInVuZGVmaW5lZFwiIT10eXBlb2YgRmlsZVJlYWRlcil7dmFyIGs9bmV3IEZpbGVSZWFkZXI7ay5vbmxvYWRlbmQ9ZnVuY3Rpb24oKXt2YXIgYT1rLnJlc3VsdDthPWo/YTphLnJlcGxhY2UoL15kYXRhOlteO10qOy8sXCJkYXRhOmF0dGFjaG1lbnQvZmlsZTtcIiksZz9nLmxvY2F0aW9uLmhyZWY9YTpsb2NhdGlvbj1hLGc9bnVsbH0say5yZWFkQXNEYXRhVVJMKGIpfWVsc2V7dmFyIGw9Zi5VUkx8fGYud2Via2l0VVJMLG09bC5jcmVhdGVPYmplY3RVUkwoYik7Zz9nLmxvY2F0aW9uPW06bG9jYXRpb24uaHJlZj1tLGc9bnVsbCxzZXRUaW1lb3V0KGZ1bmN0aW9uKCl7bC5yZXZva2VPYmplY3RVUkwobSl9LDRFNCl9fSk7Zi5zYXZlQXM9Zy5zYXZlQXM9ZyxcInVuZGVmaW5lZFwiIT10eXBlb2YgbW9kdWxlJiYobW9kdWxlLmV4cG9ydHM9Zyl9KTtcblxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9RmlsZVNhdmVyLm1pbi5qcy5tYXAiLCJcbiAgICAgIGltcG9ydCBBUEkgZnJvbSBcIiEuL25vZGVfbW9kdWxlcy9zdHlsZS1sb2FkZXIvZGlzdC9ydW50aW1lL2luamVjdFN0eWxlc0ludG9TdHlsZVRhZy5qc1wiO1xuICAgICAgaW1wb3J0IGRvbUFQSSBmcm9tIFwiIS4vbm9kZV9tb2R1bGVzL3N0eWxlLWxvYWRlci9kaXN0L3J1bnRpbWUvc3R5bGVEb21BUEkuanNcIjtcbiAgICAgIGltcG9ydCBpbnNlcnRGbiBmcm9tIFwiIS4vbm9kZV9tb2R1bGVzL3N0eWxlLWxvYWRlci9kaXN0L3J1bnRpbWUvaW5zZXJ0QnlTZWxlY3Rvci5qc1wiO1xuICAgICAgaW1wb3J0IHNldEF0dHJpYnV0ZXMgZnJvbSBcIiEuL25vZGVfbW9kdWxlcy9zdHlsZS1sb2FkZXIvZGlzdC9ydW50aW1lL3NldEF0dHJpYnV0ZXNXaXRob3V0QXR0cmlidXRlcy5qc1wiO1xuICAgICAgaW1wb3J0IGluc2VydFN0eWxlRWxlbWVudCBmcm9tIFwiIS4vbm9kZV9tb2R1bGVzL3N0eWxlLWxvYWRlci9kaXN0L3J1bnRpbWUvaW5zZXJ0U3R5bGVFbGVtZW50LmpzXCI7XG4gICAgICBpbXBvcnQgc3R5bGVUYWdUcmFuc2Zvcm1GbiBmcm9tIFwiIS4vbm9kZV9tb2R1bGVzL3N0eWxlLWxvYWRlci9kaXN0L3J1bnRpbWUvc3R5bGVUYWdUcmFuc2Zvcm0uanNcIjtcbiAgICAgIGltcG9ydCBjb250ZW50LCAqIGFzIG5hbWVkRXhwb3J0IGZyb20gXCIhIS4vbm9kZV9tb2R1bGVzL2Nzcy1sb2FkZXIvZGlzdC9janMuanMhLi9ub2RlX21vZHVsZXMvc2Fzcy1sb2FkZXIvZGlzdC9janMuanMhLi9zdHlsZS5zY3NzXCI7XG4gICAgICBcbiAgICAgIFxuXG52YXIgb3B0aW9ucyA9IHt9O1xuXG5vcHRpb25zLnN0eWxlVGFnVHJhbnNmb3JtID0gc3R5bGVUYWdUcmFuc2Zvcm1Gbjtcbm9wdGlvbnMuc2V0QXR0cmlidXRlcyA9IHNldEF0dHJpYnV0ZXM7XG5cbiAgICAgIG9wdGlvbnMuaW5zZXJ0ID0gaW5zZXJ0Rm4uYmluZChudWxsLCBcImhlYWRcIik7XG4gICAgXG5vcHRpb25zLmRvbUFQSSA9IGRvbUFQSTtcbm9wdGlvbnMuaW5zZXJ0U3R5bGVFbGVtZW50ID0gaW5zZXJ0U3R5bGVFbGVtZW50O1xuXG52YXIgdXBkYXRlID0gQVBJKGNvbnRlbnQsIG9wdGlvbnMpO1xuXG5cblxuZXhwb3J0ICogZnJvbSBcIiEhLi9ub2RlX21vZHVsZXMvY3NzLWxvYWRlci9kaXN0L2Nqcy5qcyEuL25vZGVfbW9kdWxlcy9zYXNzLWxvYWRlci9kaXN0L2Nqcy5qcyEuL3N0eWxlLnNjc3NcIjtcbiAgICAgICBleHBvcnQgZGVmYXVsdCBjb250ZW50ICYmIGNvbnRlbnQubG9jYWxzID8gY29udGVudC5sb2NhbHMgOiB1bmRlZmluZWQ7XG4iLCJcInVzZSBzdHJpY3RcIjtcblxudmFyIHN0eWxlc0luRE9NID0gW107XG5cbmZ1bmN0aW9uIGdldEluZGV4QnlJZGVudGlmaWVyKGlkZW50aWZpZXIpIHtcbiAgdmFyIHJlc3VsdCA9IC0xO1xuXG4gIGZvciAodmFyIGkgPSAwOyBpIDwgc3R5bGVzSW5ET00ubGVuZ3RoOyBpKyspIHtcbiAgICBpZiAoc3R5bGVzSW5ET01baV0uaWRlbnRpZmllciA9PT0gaWRlbnRpZmllcikge1xuICAgICAgcmVzdWx0ID0gaTtcbiAgICAgIGJyZWFrO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiByZXN1bHQ7XG59XG5cbmZ1bmN0aW9uIG1vZHVsZXNUb0RvbShsaXN0LCBvcHRpb25zKSB7XG4gIHZhciBpZENvdW50TWFwID0ge307XG4gIHZhciBpZGVudGlmaWVycyA9IFtdO1xuXG4gIGZvciAodmFyIGkgPSAwOyBpIDwgbGlzdC5sZW5ndGg7IGkrKykge1xuICAgIHZhciBpdGVtID0gbGlzdFtpXTtcbiAgICB2YXIgaWQgPSBvcHRpb25zLmJhc2UgPyBpdGVtWzBdICsgb3B0aW9ucy5iYXNlIDogaXRlbVswXTtcbiAgICB2YXIgY291bnQgPSBpZENvdW50TWFwW2lkXSB8fCAwO1xuICAgIHZhciBpZGVudGlmaWVyID0gXCJcIi5jb25jYXQoaWQsIFwiIFwiKS5jb25jYXQoY291bnQpO1xuICAgIGlkQ291bnRNYXBbaWRdID0gY291bnQgKyAxO1xuICAgIHZhciBpbmRleEJ5SWRlbnRpZmllciA9IGdldEluZGV4QnlJZGVudGlmaWVyKGlkZW50aWZpZXIpO1xuICAgIHZhciBvYmogPSB7XG4gICAgICBjc3M6IGl0ZW1bMV0sXG4gICAgICBtZWRpYTogaXRlbVsyXSxcbiAgICAgIHNvdXJjZU1hcDogaXRlbVszXSxcbiAgICAgIHN1cHBvcnRzOiBpdGVtWzRdLFxuICAgICAgbGF5ZXI6IGl0ZW1bNV1cbiAgICB9O1xuXG4gICAgaWYgKGluZGV4QnlJZGVudGlmaWVyICE9PSAtMSkge1xuICAgICAgc3R5bGVzSW5ET01baW5kZXhCeUlkZW50aWZpZXJdLnJlZmVyZW5jZXMrKztcbiAgICAgIHN0eWxlc0luRE9NW2luZGV4QnlJZGVudGlmaWVyXS51cGRhdGVyKG9iaik7XG4gICAgfSBlbHNlIHtcbiAgICAgIHZhciB1cGRhdGVyID0gYWRkRWxlbWVudFN0eWxlKG9iaiwgb3B0aW9ucyk7XG4gICAgICBvcHRpb25zLmJ5SW5kZXggPSBpO1xuICAgICAgc3R5bGVzSW5ET00uc3BsaWNlKGksIDAsIHtcbiAgICAgICAgaWRlbnRpZmllcjogaWRlbnRpZmllcixcbiAgICAgICAgdXBkYXRlcjogdXBkYXRlcixcbiAgICAgICAgcmVmZXJlbmNlczogMVxuICAgICAgfSk7XG4gICAgfVxuXG4gICAgaWRlbnRpZmllcnMucHVzaChpZGVudGlmaWVyKTtcbiAgfVxuXG4gIHJldHVybiBpZGVudGlmaWVycztcbn1cblxuZnVuY3Rpb24gYWRkRWxlbWVudFN0eWxlKG9iaiwgb3B0aW9ucykge1xuICB2YXIgYXBpID0gb3B0aW9ucy5kb21BUEkob3B0aW9ucyk7XG4gIGFwaS51cGRhdGUob2JqKTtcblxuICB2YXIgdXBkYXRlciA9IGZ1bmN0aW9uIHVwZGF0ZXIobmV3T2JqKSB7XG4gICAgaWYgKG5ld09iaikge1xuICAgICAgaWYgKG5ld09iai5jc3MgPT09IG9iai5jc3MgJiYgbmV3T2JqLm1lZGlhID09PSBvYmoubWVkaWEgJiYgbmV3T2JqLnNvdXJjZU1hcCA9PT0gb2JqLnNvdXJjZU1hcCAmJiBuZXdPYmouc3VwcG9ydHMgPT09IG9iai5zdXBwb3J0cyAmJiBuZXdPYmoubGF5ZXIgPT09IG9iai5sYXllcikge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG5cbiAgICAgIGFwaS51cGRhdGUob2JqID0gbmV3T2JqKTtcbiAgICB9IGVsc2Uge1xuICAgICAgYXBpLnJlbW92ZSgpO1xuICAgIH1cbiAgfTtcblxuICByZXR1cm4gdXBkYXRlcjtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAobGlzdCwgb3B0aW9ucykge1xuICBvcHRpb25zID0gb3B0aW9ucyB8fCB7fTtcbiAgbGlzdCA9IGxpc3QgfHwgW107XG4gIHZhciBsYXN0SWRlbnRpZmllcnMgPSBtb2R1bGVzVG9Eb20obGlzdCwgb3B0aW9ucyk7XG4gIHJldHVybiBmdW5jdGlvbiB1cGRhdGUobmV3TGlzdCkge1xuICAgIG5ld0xpc3QgPSBuZXdMaXN0IHx8IFtdO1xuXG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBsYXN0SWRlbnRpZmllcnMubGVuZ3RoOyBpKyspIHtcbiAgICAgIHZhciBpZGVudGlmaWVyID0gbGFzdElkZW50aWZpZXJzW2ldO1xuICAgICAgdmFyIGluZGV4ID0gZ2V0SW5kZXhCeUlkZW50aWZpZXIoaWRlbnRpZmllcik7XG4gICAgICBzdHlsZXNJbkRPTVtpbmRleF0ucmVmZXJlbmNlcy0tO1xuICAgIH1cblxuICAgIHZhciBuZXdMYXN0SWRlbnRpZmllcnMgPSBtb2R1bGVzVG9Eb20obmV3TGlzdCwgb3B0aW9ucyk7XG5cbiAgICBmb3IgKHZhciBfaSA9IDA7IF9pIDwgbGFzdElkZW50aWZpZXJzLmxlbmd0aDsgX2krKykge1xuICAgICAgdmFyIF9pZGVudGlmaWVyID0gbGFzdElkZW50aWZpZXJzW19pXTtcblxuICAgICAgdmFyIF9pbmRleCA9IGdldEluZGV4QnlJZGVudGlmaWVyKF9pZGVudGlmaWVyKTtcblxuICAgICAgaWYgKHN0eWxlc0luRE9NW19pbmRleF0ucmVmZXJlbmNlcyA9PT0gMCkge1xuICAgICAgICBzdHlsZXNJbkRPTVtfaW5kZXhdLnVwZGF0ZXIoKTtcblxuICAgICAgICBzdHlsZXNJbkRPTS5zcGxpY2UoX2luZGV4LCAxKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBsYXN0SWRlbnRpZmllcnMgPSBuZXdMYXN0SWRlbnRpZmllcnM7XG4gIH07XG59OyIsIlwidXNlIHN0cmljdFwiO1xuXG52YXIgbWVtbyA9IHt9O1xuLyogaXN0YW5idWwgaWdub3JlIG5leHQgICovXG5cbmZ1bmN0aW9uIGdldFRhcmdldCh0YXJnZXQpIHtcbiAgaWYgKHR5cGVvZiBtZW1vW3RhcmdldF0gPT09IFwidW5kZWZpbmVkXCIpIHtcbiAgICB2YXIgc3R5bGVUYXJnZXQgPSBkb2N1bWVudC5xdWVyeVNlbGVjdG9yKHRhcmdldCk7IC8vIFNwZWNpYWwgY2FzZSB0byByZXR1cm4gaGVhZCBvZiBpZnJhbWUgaW5zdGVhZCBvZiBpZnJhbWUgaXRzZWxmXG5cbiAgICBpZiAod2luZG93LkhUTUxJRnJhbWVFbGVtZW50ICYmIHN0eWxlVGFyZ2V0IGluc3RhbmNlb2Ygd2luZG93LkhUTUxJRnJhbWVFbGVtZW50KSB7XG4gICAgICB0cnkge1xuICAgICAgICAvLyBUaGlzIHdpbGwgdGhyb3cgYW4gZXhjZXB0aW9uIGlmIGFjY2VzcyB0byBpZnJhbWUgaXMgYmxvY2tlZFxuICAgICAgICAvLyBkdWUgdG8gY3Jvc3Mtb3JpZ2luIHJlc3RyaWN0aW9uc1xuICAgICAgICBzdHlsZVRhcmdldCA9IHN0eWxlVGFyZ2V0LmNvbnRlbnREb2N1bWVudC5oZWFkO1xuICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICAvLyBpc3RhbmJ1bCBpZ25vcmUgbmV4dFxuICAgICAgICBzdHlsZVRhcmdldCA9IG51bGw7XG4gICAgICB9XG4gICAgfVxuXG4gICAgbWVtb1t0YXJnZXRdID0gc3R5bGVUYXJnZXQ7XG4gIH1cblxuICByZXR1cm4gbWVtb1t0YXJnZXRdO1xufVxuLyogaXN0YW5idWwgaWdub3JlIG5leHQgICovXG5cblxuZnVuY3Rpb24gaW5zZXJ0QnlTZWxlY3RvcihpbnNlcnQsIHN0eWxlKSB7XG4gIHZhciB0YXJnZXQgPSBnZXRUYXJnZXQoaW5zZXJ0KTtcblxuICBpZiAoIXRhcmdldCkge1xuICAgIHRocm93IG5ldyBFcnJvcihcIkNvdWxkbid0IGZpbmQgYSBzdHlsZSB0YXJnZXQuIFRoaXMgcHJvYmFibHkgbWVhbnMgdGhhdCB0aGUgdmFsdWUgZm9yIHRoZSAnaW5zZXJ0JyBwYXJhbWV0ZXIgaXMgaW52YWxpZC5cIik7XG4gIH1cblxuICB0YXJnZXQuYXBwZW5kQ2hpbGQoc3R5bGUpO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGluc2VydEJ5U2VsZWN0b3I7IiwiXCJ1c2Ugc3RyaWN0XCI7XG5cbi8qIGlzdGFuYnVsIGlnbm9yZSBuZXh0ICAqL1xuZnVuY3Rpb24gaW5zZXJ0U3R5bGVFbGVtZW50KG9wdGlvbnMpIHtcbiAgdmFyIGVsZW1lbnQgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwic3R5bGVcIik7XG4gIG9wdGlvbnMuc2V0QXR0cmlidXRlcyhlbGVtZW50LCBvcHRpb25zLmF0dHJpYnV0ZXMpO1xuICBvcHRpb25zLmluc2VydChlbGVtZW50LCBvcHRpb25zLm9wdGlvbnMpO1xuICByZXR1cm4gZWxlbWVudDtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBpbnNlcnRTdHlsZUVsZW1lbnQ7IiwiXCJ1c2Ugc3RyaWN0XCI7XG5cbi8qIGlzdGFuYnVsIGlnbm9yZSBuZXh0ICAqL1xuZnVuY3Rpb24gc2V0QXR0cmlidXRlc1dpdGhvdXRBdHRyaWJ1dGVzKHN0eWxlRWxlbWVudCkge1xuICB2YXIgbm9uY2UgPSB0eXBlb2YgX193ZWJwYWNrX25vbmNlX18gIT09IFwidW5kZWZpbmVkXCIgPyBfX3dlYnBhY2tfbm9uY2VfXyA6IG51bGw7XG5cbiAgaWYgKG5vbmNlKSB7XG4gICAgc3R5bGVFbGVtZW50LnNldEF0dHJpYnV0ZShcIm5vbmNlXCIsIG5vbmNlKTtcbiAgfVxufVxuXG5tb2R1bGUuZXhwb3J0cyA9IHNldEF0dHJpYnV0ZXNXaXRob3V0QXR0cmlidXRlczsiLCJcInVzZSBzdHJpY3RcIjtcblxuLyogaXN0YW5idWwgaWdub3JlIG5leHQgICovXG5mdW5jdGlvbiBhcHBseShzdHlsZUVsZW1lbnQsIG9wdGlvbnMsIG9iaikge1xuICB2YXIgY3NzID0gXCJcIjtcblxuICBpZiAob2JqLnN1cHBvcnRzKSB7XG4gICAgY3NzICs9IFwiQHN1cHBvcnRzIChcIi5jb25jYXQob2JqLnN1cHBvcnRzLCBcIikge1wiKTtcbiAgfVxuXG4gIGlmIChvYmoubWVkaWEpIHtcbiAgICBjc3MgKz0gXCJAbWVkaWEgXCIuY29uY2F0KG9iai5tZWRpYSwgXCIge1wiKTtcbiAgfVxuXG4gIHZhciBuZWVkTGF5ZXIgPSB0eXBlb2Ygb2JqLmxheWVyICE9PSBcInVuZGVmaW5lZFwiO1xuXG4gIGlmIChuZWVkTGF5ZXIpIHtcbiAgICBjc3MgKz0gXCJAbGF5ZXJcIi5jb25jYXQob2JqLmxheWVyLmxlbmd0aCA+IDAgPyBcIiBcIi5jb25jYXQob2JqLmxheWVyKSA6IFwiXCIsIFwiIHtcIik7XG4gIH1cblxuICBjc3MgKz0gb2JqLmNzcztcblxuICBpZiAobmVlZExheWVyKSB7XG4gICAgY3NzICs9IFwifVwiO1xuICB9XG5cbiAgaWYgKG9iai5tZWRpYSkge1xuICAgIGNzcyArPSBcIn1cIjtcbiAgfVxuXG4gIGlmIChvYmouc3VwcG9ydHMpIHtcbiAgICBjc3MgKz0gXCJ9XCI7XG4gIH1cblxuICB2YXIgc291cmNlTWFwID0gb2JqLnNvdXJjZU1hcDtcblxuICBpZiAoc291cmNlTWFwICYmIHR5cGVvZiBidG9hICE9PSBcInVuZGVmaW5lZFwiKSB7XG4gICAgY3NzICs9IFwiXFxuLyojIHNvdXJjZU1hcHBpbmdVUkw9ZGF0YTphcHBsaWNhdGlvbi9qc29uO2Jhc2U2NCxcIi5jb25jYXQoYnRvYSh1bmVzY2FwZShlbmNvZGVVUklDb21wb25lbnQoSlNPTi5zdHJpbmdpZnkoc291cmNlTWFwKSkpKSwgXCIgKi9cIik7XG4gIH0gLy8gRm9yIG9sZCBJRVxuXG4gIC8qIGlzdGFuYnVsIGlnbm9yZSBpZiAgKi9cblxuXG4gIG9wdGlvbnMuc3R5bGVUYWdUcmFuc2Zvcm0oY3NzLCBzdHlsZUVsZW1lbnQsIG9wdGlvbnMub3B0aW9ucyk7XG59XG5cbmZ1bmN0aW9uIHJlbW92ZVN0eWxlRWxlbWVudChzdHlsZUVsZW1lbnQpIHtcbiAgLy8gaXN0YW5idWwgaWdub3JlIGlmXG4gIGlmIChzdHlsZUVsZW1lbnQucGFyZW50Tm9kZSA9PT0gbnVsbCkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuXG4gIHN0eWxlRWxlbWVudC5wYXJlbnROb2RlLnJlbW92ZUNoaWxkKHN0eWxlRWxlbWVudCk7XG59XG4vKiBpc3RhbmJ1bCBpZ25vcmUgbmV4dCAgKi9cblxuXG5mdW5jdGlvbiBkb21BUEkob3B0aW9ucykge1xuICB2YXIgc3R5bGVFbGVtZW50ID0gb3B0aW9ucy5pbnNlcnRTdHlsZUVsZW1lbnQob3B0aW9ucyk7XG4gIHJldHVybiB7XG4gICAgdXBkYXRlOiBmdW5jdGlvbiB1cGRhdGUob2JqKSB7XG4gICAgICBhcHBseShzdHlsZUVsZW1lbnQsIG9wdGlvbnMsIG9iaik7XG4gICAgfSxcbiAgICByZW1vdmU6IGZ1bmN0aW9uIHJlbW92ZSgpIHtcbiAgICAgIHJlbW92ZVN0eWxlRWxlbWVudChzdHlsZUVsZW1lbnQpO1xuICAgIH1cbiAgfTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBkb21BUEk7IiwiXCJ1c2Ugc3RyaWN0XCI7XG5cbi8qIGlzdGFuYnVsIGlnbm9yZSBuZXh0ICAqL1xuZnVuY3Rpb24gc3R5bGVUYWdUcmFuc2Zvcm0oY3NzLCBzdHlsZUVsZW1lbnQpIHtcbiAgaWYgKHN0eWxlRWxlbWVudC5zdHlsZVNoZWV0KSB7XG4gICAgc3R5bGVFbGVtZW50LnN0eWxlU2hlZXQuY3NzVGV4dCA9IGNzcztcbiAgfSBlbHNlIHtcbiAgICB3aGlsZSAoc3R5bGVFbGVtZW50LmZpcnN0Q2hpbGQpIHtcbiAgICAgIHN0eWxlRWxlbWVudC5yZW1vdmVDaGlsZChzdHlsZUVsZW1lbnQuZmlyc3RDaGlsZCk7XG4gICAgfVxuXG4gICAgc3R5bGVFbGVtZW50LmFwcGVuZENoaWxkKGRvY3VtZW50LmNyZWF0ZVRleHROb2RlKGNzcykpO1xuICB9XG59XG5cbm1vZHVsZS5leHBvcnRzID0gc3R5bGVUYWdUcmFuc2Zvcm07IiwiLy8gaW1wb3J0IHsgVHlwZUNoZWNrRXJyb3IgfSBmcm9tIFwiLi90eXBlLWNoZWNrXCI7XG5cbmV4cG9ydCB0eXBlIEFubm90YXRpb24gPSB7XG4gIHR5cGU/OiBUeXBlLFxuICBmcm9tTG9jPzogTG9jYXRpb24sIC8vIGluY2x1ZGVcbiAgZW5kTG9jPzogTG9jYXRpb24sIC8vIGV4Y2x1ZGVcbiAgZW9sTG9jPzogTG9jYXRpb24sIC8vIGxvYyBvZiB0aGUgbmV4dCBsaW5lIGJyZWFrXG4gIHNyYz86IHN0cmluZ1xufVxuZXhwb3J0IHR5cGUgTG9jYXRpb24gPSB7XG4gIHJvdzogbnVtYmVyLFxuICBjb2w6IG51bWJlcixcbiAgc3JjSWR4OiBudW1iZXIsXG59XG5cbi8vIGV4cG9ydCBlbnVtIFR5cGUge05VTSwgQk9PTCwgTk9ORSwgT0JKfTsgXG5leHBvcnQgdHlwZSBDYWxsYWJsZSA9IHt0YWc6IFwiY2FsbGFibGVcIjsgcGFyYW1zOiBBcnJheTxUeXBlPjsgcmV0OiBUeXBlIH07XG5leHBvcnQgdHlwZSBUeXBlID1cbiAgfCB7dGFnOiBcIm51bWJlclwifVxuICB8IHt0YWc6IFwiYm9vbFwifVxuICB8IHt0YWc6IFwibm9uZVwifVxuICB8IHt0YWc6IFwiY2xhc3NcIiwgbmFtZTogc3RyaW5nLCBwYXJhbXM6IEFycmF5PFR5cGU+IH1cbiAgfCB7dGFnOiBcImVpdGhlclwiLCBsZWZ0OiBUeXBlLCByaWdodDogVHlwZSB9XG4gIHwge3RhZzogXCJ0eXBldmFyXCIsIG5hbWU6IHN0cmluZyB9XG4gIHwgQ2FsbGFibGU7XG5cbmV4cG9ydCB0eXBlIFBhcmFtZXRlcjxBPiA9IHsgYT86IEEsIG5hbWU6IHN0cmluZywgdHlwZTogVHlwZSB9XG5cbmV4cG9ydCB0eXBlIFByb2dyYW08QT4gPSB7IGE/OiBBLCBmdW5zOiBBcnJheTxGdW5EZWY8QT4+LCBpbml0czogQXJyYXk8VmFySW5pdDxBPj4sIHR5cGVWYXJJbml0czogQXJyYXk8VHlwZVZhcjxBPj4sIGNsYXNzZXM6IEFycmF5PENsYXNzPEE+Piwgc3RtdHM6IEFycmF5PFN0bXQ8QT4+IH1cblxuZXhwb3J0IHR5cGUgQ2xhc3M8QT4gPSB7IGE/OiBBLCBuYW1lOiBzdHJpbmcsIGZpZWxkczogQXJyYXk8VmFySW5pdDxBPj4sIG1ldGhvZHM6IEFycmF5PEZ1bkRlZjxBPj4sIHR5cGVQYXJhbXM6IEFycmF5PHN0cmluZz4gfVxuXG5leHBvcnQgdHlwZSBUeXBlVmFyPEE+ID0geyBhPzogQSwgbmFtZTogc3RyaW5nLCBjYW5vbmljYWxOYW1lOiBzdHJpbmcsIHR5cGVzOiBBcnJheTxUeXBlPiB9XG5cbmV4cG9ydCB0eXBlIFZhckluaXQ8QT4gPSB7IGE/OiBBLCBuYW1lOiBzdHJpbmcsIHR5cGU6IFR5cGUsIHZhbHVlOiBMaXRlcmFsPEE+IH1cbmV4cG9ydCB0eXBlIE5vbmxvY2FsVmFySW5pdDxBPiA9IHsgYT86IEEsIG5hbWU6IHN0cmluZyB9O1xuXG5leHBvcnQgdHlwZSBGdW5EZWY8QT4gPSB7IGE/OiBBLCBuYW1lOiBzdHJpbmcsIHBhcmFtZXRlcnM6IEFycmF5PFBhcmFtZXRlcjxBPj4sIHJldDogVHlwZSwgaW5pdHM6IEFycmF5PFZhckluaXQ8QT4+LCBib2R5OiBBcnJheTxTdG10PEE+Piwgbm9ubG9jYWxzOiBBcnJheTxOb25sb2NhbFZhckluaXQ8QT4+LCBjaGlsZHJlbjogQXJyYXk8RnVuRGVmPEE+PiB9XG5cbmV4cG9ydCB0eXBlIFN0bXQ8QT4gPVxuICB8IHsgIGE/OiBBLCB0YWc6IFwiYXNzaWduXCIsIG5hbWU6IHN0cmluZywgdmFsdWU6IEV4cHI8QT4gfVxuICB8IHsgIGE/OiBBLCB0YWc6IFwicmV0dXJuXCIsIHZhbHVlOiBFeHByPEE+IH1cbiAgfCB7ICBhPzogQSwgdGFnOiBcImV4cHJcIiwgZXhwcjogRXhwcjxBPiB9XG4gIHwgeyAgYT86IEEsIHRhZzogXCJwYXNzXCIgfVxuICB8IHsgIGE/OiBBLCB0YWc6IFwiY29udGludWVcIiB9XG4gIHwgeyAgYT86IEEsIHRhZzogXCJicmVha1wiIH1cbiAgfCB7ICBhPzogQSwgdGFnOiBcImZpZWxkLWFzc2lnblwiLCBvYmo6IEV4cHI8QT4sIGZpZWxkOiBzdHJpbmcsIHZhbHVlOiBFeHByPEE+IH1cbiAgfCB7ICBhPzogQSwgdGFnOiBcImluZGV4LWFzc2lnblwiLCBvYmo6IEV4cHI8QT4sIGluZGV4OiBFeHByPEE+LCB2YWx1ZTogRXhwcjxBPiB9XG4gIHwgeyAgYT86IEEsIHRhZzogXCJpZlwiLCBjb25kOiBFeHByPEE+LCB0aG46IEFycmF5PFN0bXQ8QT4+LCBlbHM6IEFycmF5PFN0bXQ8QT4+IH1cbiAgfCB7ICBhPzogQSwgdGFnOiBcIndoaWxlXCIsIGNvbmQ6IEV4cHI8QT4sIGJvZHk6IEFycmF5PFN0bXQ8QT4+IH1cbiAgfCB7ICBhPzogQSwgdGFnOiBcIm5vbmxvY2FsXCIsIG5hbWU6IHN0cmluZyB9XG4gIHwgeyAgYT86IEEsIHRhZzogXCJmb3JcIiwgaXRlcmF0b3I6IHN0cmluZywgdmFsdWVzOiBFeHByPEE+LCBib2R5OiBBcnJheTxTdG10PEE+PiB9XG5cbmV4cG9ydCB0eXBlIExhbWJkYTxBPiA9IHsgIGE/OiBBLCB0YWc6IFwibGFtYmRhXCIsIHBhcmFtczogQXJyYXk8c3RyaW5nPiwgdHlwZTogQ2FsbGFibGUsIGV4cHI6IEV4cHI8QT4gfTtcbmV4cG9ydCB0eXBlIEV4cHI8QT4gPVxuICAgIHsgIGE/OiBBLCB0YWc6IFwibGl0ZXJhbFwiLCB2YWx1ZTogTGl0ZXJhbDxBPiB9XG4gIHwgeyAgYT86IEEsIHRhZzogXCJpZFwiLCBuYW1lOiBzdHJpbmcgfVxuICB8IHsgIGE/OiBBLCB0YWc6IFwiYmlub3BcIiwgb3A6IEJpbk9wLCBsZWZ0OiBFeHByPEE+LCByaWdodDogRXhwcjxBPn1cbiAgfCB7ICBhPzogQSwgdGFnOiBcInVuaW9wXCIsIG9wOiBVbmlPcCwgZXhwcjogRXhwcjxBPiB9XG4gIHwgeyAgYT86IEEsIHRhZzogXCJidWlsdGluMVwiLCBuYW1lOiBzdHJpbmcsIGFyZzogRXhwcjxBPiB9XG4gIHwgeyAgYT86IEEsIHRhZzogXCJidWlsdGluMlwiLCBuYW1lOiBzdHJpbmcsIGxlZnQ6IEV4cHI8QT4sIHJpZ2h0OiBFeHByPEE+fVxuICB8IHsgIGE/OiBBLCB0YWc6IFwiY2FsbFwiLCBmbjogRXhwcjxBPiwgYXJndW1lbnRzOiBBcnJheTxFeHByPEE+PiB9IFxuICB8IHsgIGE/OiBBLCB0YWc6IFwibG9va3VwXCIsIG9iajogRXhwcjxBPiwgZmllbGQ6IHN0cmluZyB9XG4gIHwgeyAgYT86IEEsIHRhZzogXCJpbmRleFwiLCBvYmo6IEV4cHI8QT4sIGluZGV4OiBFeHByPEE+IH1cbiAgfCB7ICBhPzogQSwgdGFnOiBcIm1ldGhvZC1jYWxsXCIsIG9iajogRXhwcjxBPiwgbWV0aG9kOiBzdHJpbmcsIGFyZ3VtZW50czogQXJyYXk8RXhwcjxBPj4gfVxuICB8IHsgIGE/OiBBLCB0YWc6IFwiY29uc3RydWN0XCIsIG5hbWU6IHN0cmluZyB9XG4gIHwgeyAgYT86IEEsIHRhZzogXCJsaXN0LWNvbXBcIiwgbGVmdDogRXhwcjxBPiwgZWxlbTogRXhwcjxBPiwgaXRlcmFibGU6IEV4cHI8QT4sIGNvbmQ/OiBFeHByPEE+fVxuICB8IExhbWJkYTxBPlxuICB8IHsgIGE/OiBBLCB0YWc6IFwiaWYtZXhwclwiLCBjb25kOiBFeHByPEE+LCB0aG46IEV4cHI8QT4sIGVsczogRXhwcjxBPiB9XG5cbi8vIGFkZCBhbm5vdGF0aW9uIGZvciByZXBvcnRpbmcgcm93L2NvbCBpbiBlcnJvcnNcbmV4cG9ydCB0eXBlIExpdGVyYWw8QT4gPSBcbiAgICB7IGE/OiBBLCB0YWc6IFwibnVtXCIsIHZhbHVlOiBudW1iZXIgfVxuICB8IHsgYT86IEEsIHRhZzogXCJib29sXCIsIHZhbHVlOiBib29sZWFuIH1cbiAgfCB7IGE/OiBBLCB0YWc6IFwibm9uZVwiIH1cbiAgfCB7IGE/OiBBLCB0YWc6IFwiemVyb1wiIH1cblxuLy8gVE9ETzogc2hvdWxkIHdlIHNwbGl0IHVwIGFyaXRobWV0aWMgb3BzIGZyb20gYm9vbCBvcHM/XG5leHBvcnQgZW51bSBCaW5PcCB7IFBsdXMsIE1pbnVzLCBNdWwsIElEaXYsIE1vZCwgRXEsIE5lcSwgTHRlLCBHdGUsIEx0LCBHdCwgSXMsIEFuZCwgT3J9O1xuXG5leHBvcnQgZW51bSBVbmlPcCB7IE5lZywgTm90IH07XG5cbnR5cGUgT3AgPSBCaW5PcCB8IFVuaU9wO1xuXG5cbmV4cG9ydCBmdW5jdGlvbiBzdHJpbmdpZnlPcChvcDogT3ApOiBzdHJpbmcge1xuICBzd2l0Y2ggKG9wKSB7XG4gICAgY2FzZSBCaW5PcC5QbHVzOiByZXR1cm4gXCIrXCI7XG4gICAgY2FzZSBCaW5PcC5NaW51czogcmV0dXJuIFwiLVwiO1xuICAgIGNhc2UgQmluT3AuTXVsOiByZXR1cm4gXCIqXCI7XG4gICAgY2FzZSBCaW5PcC5JRGl2OiByZXR1cm4gXCIvL1wiO1xuICAgIGNhc2UgQmluT3AuTW9kOiByZXR1cm4gXCIlXCI7XG4gICAgY2FzZSBCaW5PcC5FcTogcmV0dXJuIFwiPT1cIjtcbiAgICBjYXNlIEJpbk9wLk5lcTogcmV0dXJuIFwiIT1cIjtcbiAgICBjYXNlIEJpbk9wLkx0ZTogcmV0dXJuIFwiPD1cIjtcbiAgICBjYXNlIEJpbk9wLkd0ZTogcmV0dXJuIFwiPj1cIjtcbiAgICBjYXNlIEJpbk9wLkx0OiByZXR1cm4gXCI8XCI7XG4gICAgY2FzZSBCaW5PcC5HdDogcmV0dXJuIFwiPlwiO1xuICAgIGNhc2UgQmluT3AuSXM6IHJldHVybiBcImlzXCI7XG4gICAgY2FzZSBCaW5PcC5BbmQ6IHJldHVybiBcImFuZFwiO1xuICAgIGNhc2UgQmluT3AuT3I6IHJldHVybiBcIm9yXCI7XG4gICAgY2FzZSBVbmlPcC5OZWc6IHJldHVybiBcIi1cIjtcbiAgICBjYXNlIFVuaU9wLk5vdDogcmV0dXJuIFwibm90XCI7XG4gICAgZGVmYXVsdDogdGhyb3cgbmV3IEVycm9yKFwidW5kZWZpbmVkIG9wXCIpO1xuICB9XG59XG5cbmV4cG9ydCB0eXBlIFZhbHVlPEE+ID1cbiAgICBMaXRlcmFsPEE+XG4gIHwgeyBhPzogQSwgdGFnOiBcIm9iamVjdFwiLCBuYW1lOiBzdHJpbmcsIGFkZHJlc3M6IG51bWJlcn1cbiAgIiwiaW1wb3J0IENvZGVNaXJyb3IgZnJvbSBcImNvZGVtaXJyb3JcIjtcblxuXG5leHBvcnQgZnVuY3Rpb24gYXV0b2NvbXBsZXRlSGludChlZGl0b3I6IGFueSwga2V5d29yZHM6IHN0cmluZ1tdLCBnZXRUb2tlbjogYW55KSB7XG4gICAgLy8gRmluZCB0aGUgdG9rZW4gYXQgdGhlIGN1cnNvclxuICAgIHZhciBjdXJyUG9zID0gZWRpdG9yLmdldEN1cnNvcigpO1xuICAgIHZhciB0b2tlbiA9IGdldFRva2VuKGVkaXRvciwgY3VyclBvcyksXG4gICAgICAgIHRwcm9wID0gdG9rZW47XG4gICAgdmFyIGlzQ2xhc3NNZXRob2QgPSBmYWxzZTtcbiAgICBpZiAodG9rZW4uc3RyaW5nW3Rva2VuLnN0cmluZy5sZW5ndGggLSAxXSA9PT0gXCIuXCIpIHtcbiAgICAgICAgaXNDbGFzc01ldGhvZCA9IHRydWU7XG4gICAgICAgIHRva2VuID0gdHByb3AgPSB7XG4gICAgICAgICAgICBzdGFydDogY3VyclBvcy5jaCxcbiAgICAgICAgICAgIGVuZDogY3VyclBvcy5jaCxcbiAgICAgICAgICAgIHN0cmluZzogXCJcIixcbiAgICAgICAgICAgIHN0YXRlOiB0b2tlbi5zdGF0ZSxcbiAgICAgICAgICAgIHR5cGU6IFwicHJvcGVydHlcIixcbiAgICAgICAgfTtcbiAgICB9IGVsc2UgaWYgKHRva2VuLnR5cGUgPT0gXCJwcm9wZXJ0eVwiKSB7XG4gICAgICAgIGlzQ2xhc3NNZXRob2QgPSB0cnVlO1xuICAgIH1cbiAgICAvL2lnbm9yZSBhbnkgbm9uIHdvcmQgb3IgcHJvcGVydHkgdG9rZW5cbiAgICBlbHNlIGlmICghL15bXFx3JF9dKiQvLnRlc3QodG9rZW4uc3RyaW5nKSkge1xuICAgICAgICB0b2tlbiA9IHRwcm9wID0ge1xuICAgICAgICAgICAgc3RhcnQ6IGN1cnJQb3MuY2gsXG4gICAgICAgICAgICBlbmQ6IGN1cnJQb3MuY2gsXG4gICAgICAgICAgICBzdHJpbmc6IFwiXCIsXG4gICAgICAgICAgICBzdGF0ZTogdG9rZW4uc3RhdGUsXG4gICAgICAgICAgICBjbGFzc05hbWU6IHRva2VuLnN0cmluZyA9PSBcIjpcIiA/IFwicHl0aG9uLXR5cGVcIiA6IG51bGwsXG4gICAgICAgIH07XG4gICAgfVxuXG4gICAgaWYgKCFjb250ZXh0IHx8IGlzQ2xhc3NNZXRob2QpIHtcbiAgICAgICAgdmFyIGNvbnRleHQgPSBbXTtcbiAgICAgICAgY29udGV4dC5wdXNoKHRwcm9wKTtcblxuICAgICAgICB2YXIgY29tcGxldGlvbkxpc3QgPSBnZXRDb21wbGV0aW9ucyhrZXl3b3JkcywgdG9rZW4sIGNvbnRleHQpO1xuICAgICAgICBjb21wbGV0aW9uTGlzdCA9IGNvbXBsZXRpb25MaXN0LnNvcnQoKTtcbiAgICAgICAgLy9zaG93IGRyb3Bkb3duIHdpdGggb25lIHdvcmQgKHJlc3RyaWN0IGF1dG9tYXRpYyBhdXRvY29tcGxldGUgb2Ygc2luZ2xlIHdvcmQpXG4gICAgICAgIGlmIChjb21wbGV0aW9uTGlzdC5sZW5ndGggPT0gMSkge1xuICAgICAgICAgICAgY29tcGxldGlvbkxpc3QucHVzaChcIiBcIik7XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHtcbiAgICAgICAgbGlzdDogY29tcGxldGlvbkxpc3QsXG4gICAgICAgIGZyb206IENvZGVNaXJyb3IuUG9zKGN1cnJQb3MubGluZSwgdG9rZW4uc3RhcnQpLFxuICAgICAgICB0bzogQ29kZU1pcnJvci5Qb3MoY3VyclBvcy5saW5lLCB0b2tlbi5lbmQpLFxuICAgIH07XG59XG5cbmZ1bmN0aW9uIGdldENvbXBsZXRpb25zKHdvcmRMaXN0OiBhbnksIHRva2VuOiBhbnksIGNvbnRleHQ6IGFueSkge1xuICAgIHZhciBjb21wbGV0aW9uczogYW55W10gPSBbXTtcbiAgICB2YXIgcHJlZml4ID0gdG9rZW4uc3RyaW5nO1xuXG4gICAgaWYgKGNvbnRleHQpIHtcbiAgICAgICAgLy8gSWYgdGhpcyBpcyBhIHByb3BlcnR5LCBzZWUgaWYgaXQgYmVsb25ncyB0byBzb21lIG9iamVjdCB3ZSBjYW5cbiAgICAgICAgLy8gZmluZCBpbiB0aGUgY3VycmVudCBlbnZpcm9ubWVudC5cbiAgICAgICAgdmFyIG9iaiA9IGNvbnRleHQucG9wKCksXG4gICAgICAgICAgICBiYXNlO1xuXG4gICAgICAgIGNvbnN0IGhhc0NvbXBsZXRlTGlzdDogQXJyYXk8c3RyaW5nPiA9IFtcInZhcmlhYmxlXCIsIFwicHJvcGVydHlcIiwgXCJidWlsdGluXCIsIFwia2V5d29yZFwiXTtcbiAgICAgICAgaWYgKGhhc0NvbXBsZXRlTGlzdC5pbmRleE9mKG9iai50eXBlKSAhPT0gLTEpIHtcbiAgICAgICAgICAgIGJhc2UgPSBvYmouc3RyaW5nO1xuICAgICAgICB9XG5cbiAgICAgICAgd2hpbGUgKGJhc2UgIT0gbnVsbCAmJiBjb250ZXh0Lmxlbmd0aCkge1xuICAgICAgICAgICAgYmFzZSA9IGJhc2VbY29udGV4dC5wb3AoKS5zdHJpbmddO1xuICAgICAgICB9XG4gICAgICAgIGlmIChiYXNlICE9IG51bGwpIHtcbiAgICAgICAgICAgIGNvbXBsZXRpb25zID0gZ2F0aGVyQ29tcGxldGlvbnMod29yZExpc3QsIHByZWZpeCk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIGNvbXBsZXRpb25zO1xufVxuXG5mdW5jdGlvbiBnYXRoZXJDb21wbGV0aW9ucyh3b3JkTGlzdDogc3RyaW5nW10sIHByZWZpeDogc3RyaW5nKTogc3RyaW5nW10ge1xuICAgIHZhciBjb21wbGV0aW9uczogc3RyaW5nW10gPSBbXTtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IHdvcmRMaXN0Lmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIHZhciBzdHIgPSB3b3JkTGlzdFtpXTtcbiAgICAgICAgLy9vbmx5IGFkZCB3b3JkIGlmIG5vdCBhbHJlYWR5IGluIGFycmF5IGFuZCBwcmVmaXggbWF0Y2hlcyB3b3JkXG4gICAgICAgIGlmIChzdHIuaW5kZXhPZihwcmVmaXgpID09IDAgJiYgIXN0ckV4aXN0cyhjb21wbGV0aW9ucywgc3RyKSkge1xuICAgICAgICAgICAgY29tcGxldGlvbnMucHVzaChzdHIpO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiBjb21wbGV0aW9ucztcbn1cblxuZnVuY3Rpb24gc3RyRXhpc3RzKGFycjogc3RyaW5nW10sIGl0ZW06IHN0cmluZykge1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgYXJyLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIGlmIChhcnJbaV0gPT0gaXRlbSkge1xuICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIGZhbHNlO1xufVxuIiwiaW1wb3J0IHsgUHJvZ3JhbSwgU3RtdCwgRXhwciwgVmFsdWUsIENsYXNzLCBWYXJJbml0LCBGdW5EZWYgfSBmcm9tIFwiLi9pclwiXG5pbXBvcnQgeyBBbm5vdGF0aW9uLCBCaW5PcCwgVHlwZSwgVW5pT3AgfSBmcm9tIFwiLi9hc3RcIlxuaW1wb3J0IHsgQVBQTFksIEJPT0wsIGNyZWF0ZU1ldGhvZE5hbWUsIG1ha2VXYXNtRnVuVHlwZSwgTk9ORSwgTlVNIH0gZnJvbSBcIi4vdXRpbHNcIjtcblxuZXhwb3J0IHR5cGUgR2xvYmFsRW52ID0ge1xuICBnbG9iYWxzOiBNYXA8c3RyaW5nLCBib29sZWFuPjtcbiAgY2xhc3NlczogTWFwPHN0cmluZywgTWFwPHN0cmluZywgW251bWJlciwgVmFsdWU8QW5ub3RhdGlvbj5dPj47ICBcbiAgY2xhc3NJbmRpY2VzOiBNYXA8c3RyaW5nLCBudW1iZXI+O1xuICBmdW5jdGlvbk5hbWVzOiBNYXA8c3RyaW5nLCBzdHJpbmc+O1xuICBsb2NhbHM6IFNldDxzdHJpbmc+O1xuICBsYWJlbHM6IEFycmF5PHN0cmluZz47XG4gIG9mZnNldDogbnVtYmVyO1xuICB2dGFibGVNZXRob2RzOiBBcnJheTxbc3RyaW5nLCBudW1iZXJdPjtcbn1cblxuZXhwb3J0IGNvbnN0IGVtcHR5RW52IDogR2xvYmFsRW52ID0geyBcbiAgZ2xvYmFsczogbmV3IE1hcCgpLCBcbiAgY2xhc3NlczogbmV3IE1hcCgpLFxuICBjbGFzc0luZGljZXM6IG5ldyBNYXAoKSwgXG4gIGZ1bmN0aW9uTmFtZXM6IG5ldyBNYXAoKSxcbiAgbG9jYWxzOiBuZXcgU2V0KCksXG4gIGxhYmVsczogW10sXG4gIG9mZnNldDogMCxcbiAgdnRhYmxlTWV0aG9kczogW10gXG59O1xuXG50eXBlIENvbXBpbGVSZXN1bHQgPSB7XG4gIGdsb2JhbHM6IHN0cmluZ1tdLFxuICBmdW5jdGlvbnM6IHN0cmluZyxcbiAgbWFpblNvdXJjZTogc3RyaW5nLFxuICBuZXdFbnY6IEdsb2JhbEVudlxufTtcblxuZXhwb3J0IGZ1bmN0aW9uIG1ha2VMb2NhbHMobG9jYWxzOiBTZXQ8c3RyaW5nPikgOiBBcnJheTxzdHJpbmc+IHtcbiAgY29uc3QgbG9jYWxEZWZpbmVzIDogQXJyYXk8c3RyaW5nPiA9IFtdO1xuICBsb2NhbHMuZm9yRWFjaCh2ID0+IHtcbiAgICBsb2NhbERlZmluZXMucHVzaChgKGxvY2FsICQke3Z9IGkzMilgKTtcbiAgfSk7XG4gIHJldHVybiBsb2NhbERlZmluZXM7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBjb21waWxlKGFzdDogUHJvZ3JhbTxBbm5vdGF0aW9uPiwgZW52OiBHbG9iYWxFbnYpIDogQ29tcGlsZVJlc3VsdCB7XG4gIGNvbnN0IHdpdGhEZWZpbmVzID0gZW52O1xuXG4gIGNvbnN0IGRlZmluZWRWYXJzIDogU2V0PHN0cmluZz4gPSBuZXcgU2V0KCk7IC8vZ2V0TG9jYWxzKGFzdCk7XG4gIGRlZmluZWRWYXJzLmFkZChcIiRsYXN0XCIpO1xuICBkZWZpbmVkVmFycy5hZGQoXCIkc2VsZWN0b3JcIik7XG4gIGRlZmluZWRWYXJzLmFkZChcIiRzY3JhdGNoXCIpOyAvLyBmb3IgbWVtb3J5IGFsbG9jYXRpb25cbiAgZGVmaW5lZFZhcnMuZm9yRWFjaChlbnYubG9jYWxzLmFkZCwgZW52LmxvY2Fscyk7XG4gIGNvbnN0IGxvY2FsRGVmaW5lcyA9IG1ha2VMb2NhbHMoZGVmaW5lZFZhcnMpO1xuICBjb25zdCBnbG9iYWxOYW1lcyA9IGFzdC5pbml0cy5tYXAoaW5pdCA9PiBpbml0Lm5hbWUpO1xuICBjb25zdCBmdW5zIDogQXJyYXk8c3RyaW5nPiA9IFtdO1xuICBhc3QuZnVucy5mb3JFYWNoKGYgPT4ge1xuICAgIGZ1bnMucHVzaChjb2RlR2VuRGVmKGYsIHdpdGhEZWZpbmVzKS5qb2luKFwiXFxuXCIpKTtcbiAgfSk7XG4gIGNvbnN0IGNsYXNzZXMgOiBBcnJheTxzdHJpbmc+ID0gYXN0LmNsYXNzZXMubWFwKGNscyA9PiBjb2RlR2VuQ2xhc3MoY2xzLCB3aXRoRGVmaW5lcykpLmZsYXQoKTtcbiAgY29uc3QgYWxsRnVucyA9IGZ1bnMuY29uY2F0KGNsYXNzZXMpLmpvaW4oXCJcXG5cXG5cIik7XG4gIC8vIGNvbnN0IHN0bXRzID0gYXN0LmZpbHRlcigoc3RtdCkgPT4gc3RtdC50YWcgIT09IFwiZnVuXCIpO1xuICBjb25zdCBpbml0cyA9IGFzdC5pbml0cy5tYXAoaW5pdCA9PiBjb2RlR2VuSW5pdChpbml0LCB3aXRoRGVmaW5lcykpLmZsYXQoKTtcbiAgd2l0aERlZmluZXMubGFiZWxzID0gYXN0LmJvZHkubWFwKGJsb2NrID0+IGJsb2NrLmxhYmVsKTtcbiAgdmFyIGJvZHlDb21tYW5kcyA9IFwiKGxvY2FsLnNldCAkJHNlbGVjdG9yIChpMzIuY29uc3QgMCkpXFxuXCJcbiAgYm9keUNvbW1hbmRzICs9IFwiKGxvb3AgJGxvb3BcXG5cIlxuXG4gIHZhciBibG9ja0NvbW1hbmRzID0gXCIobG9jYWwuZ2V0ICQkc2VsZWN0b3IpXFxuXCJcbiAgYmxvY2tDb21tYW5kcyArPSBgKGJyX3RhYmxlICR7YXN0LmJvZHkubWFwKGJsb2NrID0+IGJsb2NrLmxhYmVsKS5qb2luKFwiIFwiKX0pYDtcbiAgYXN0LmJvZHkuZm9yRWFjaChibG9jayA9PiB7XG4gICAgYmxvY2tDb21tYW5kcyA9IGAoYmxvY2sgJHtibG9jay5sYWJlbH1cbiAgICAgICAgICAgICAgJHtibG9ja0NvbW1hbmRzfSAgICBcbiAgICAgICAgICAgICkgOzsgZW5kICR7YmxvY2subGFiZWx9XG4gICAgICAgICAgICAke2Jsb2NrLnN0bXRzLm1hcChzdG10ID0+IGNvZGVHZW5TdG10KHN0bXQsIHdpdGhEZWZpbmVzKS5qb2luKCdcXG4nKSkuam9pbignXFxuJyl9XG4gICAgICAgICAgICBgXG4gIH0pXG4gIGJvZHlDb21tYW5kcyArPSBibG9ja0NvbW1hbmRzO1xuICBib2R5Q29tbWFuZHMgKz0gXCIpIDs7IGVuZCAkbG9vcFwiXG5cbiAgLy8gY29uc3QgY29tbWFuZEdyb3VwcyA9IGFzdC5zdG10cy5tYXAoKHN0bXQpID0+IGNvZGVHZW5TdG10KHN0bXQsIHdpdGhEZWZpbmVzKSk7XG4gIGNvbnN0IGFsbENvbW1hbmRzID0gWy4uLmxvY2FsRGVmaW5lcywgLi4uaW5pdHMsIGJvZHlDb21tYW5kc107XG4gIHdpdGhEZWZpbmVzLmxvY2Fscy5jbGVhcigpO1xuICBhc3QuaW5pdHMuZm9yRWFjaCh4ID0+IHdpdGhEZWZpbmVzLmdsb2JhbHMuc2V0KHgubmFtZSwgdHJ1ZSkpO1xuICByZXR1cm4ge1xuICAgIGdsb2JhbHM6IGdsb2JhbE5hbWVzLFxuICAgIGZ1bmN0aW9uczogYWxsRnVucyxcbiAgICBtYWluU291cmNlOiBhbGxDb21tYW5kcy5qb2luKFwiXFxuXCIpLFxuICAgIG5ld0Vudjogd2l0aERlZmluZXNcbiAgfTtcbn1cblxuZnVuY3Rpb24gY29kZUdlblN0bXQoc3RtdDogU3RtdDxBbm5vdGF0aW9uPiwgZW52OiBHbG9iYWxFbnYpOiBBcnJheTxzdHJpbmc+IHtcbiAgc3dpdGNoIChzdG10LnRhZykge1xuICAgIGNhc2UgXCJzdG9yZVwiOlxuICAgICAgcmV0dXJuIFtcbiAgICAgICAgLi4uY29kZUdlblZhbHVlKHN0bXQuc3RhcnQsIGVudiksXG4gICAgICAgIC4uLmNvZGVHZW5WYWx1ZShzdG10Lm9mZnNldCwgZW52KSxcbiAgICAgICAgLi4uY29kZUdlblZhbHVlKHN0bXQudmFsdWUsIGVudiksXG4gICAgICAgIGBjYWxsICRzdG9yZWBcbiAgICAgIF1cbiAgICBjYXNlIFwiYXNzaWduXCI6XG4gICAgICB2YXIgdmFsU3RtdHMgPSBjb2RlR2VuRXhwcihzdG10LnZhbHVlLCBlbnYpO1xuICAgICAgaWYgKGVudi5sb2NhbHMuaGFzKHN0bXQubmFtZSkpIHtcbiAgICAgICAgcmV0dXJuIHZhbFN0bXRzLmNvbmNhdChbYChsb2NhbC5zZXQgJCR7c3RtdC5uYW1lfSlgXSk7IFxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcmV0dXJuIHZhbFN0bXRzLmNvbmNhdChbYChnbG9iYWwuc2V0ICQke3N0bXQubmFtZX0pYF0pOyBcbiAgICAgIH1cblxuICAgIGNhc2UgXCJyZXR1cm5cIjpcbiAgICAgIHZhciB2YWxTdG10cyA9IGNvZGVHZW5WYWx1ZShzdG10LnZhbHVlLCBlbnYpO1xuICAgICAgdmFsU3RtdHMucHVzaChcInJldHVyblwiKTtcbiAgICAgIHJldHVybiB2YWxTdG10cztcblxuICAgIGNhc2UgXCJleHByXCI6XG4gICAgICB2YXIgZXhwclN0bXRzID0gY29kZUdlbkV4cHIoc3RtdC5leHByLCBlbnYpO1xuICAgICAgcmV0dXJuIGV4cHJTdG10cy5jb25jYXQoW2AobG9jYWwuc2V0ICQkbGFzdClgXSk7XG5cbiAgICBjYXNlIFwicGFzc1wiOlxuICAgICAgcmV0dXJuIFtdXG5cbiAgICBjYXNlIFwiaWZqbXBcIjpcbiAgICAgIGNvbnN0IHRobklkeCA9IGVudi5sYWJlbHMuZmluZEluZGV4KGUgPT4gZSA9PT0gc3RtdC50aG4pO1xuICAgICAgY29uc3QgZWxzSWR4ID0gZW52LmxhYmVscy5maW5kSW5kZXgoZSA9PiBlID09PSBzdG10LmVscyk7XG5cbiAgICAgIHJldHVybiBbLi4uY29kZUdlblZhbHVlKHN0bXQuY29uZCwgZW52KSwgXG4gICAgICAgIGAoaWYgXG4gICAgICAgICAgKHRoZW5cbiAgICAgICAgICAgIChsb2NhbC5zZXQgJCRzZWxlY3RvciAoaTMyLmNvbnN0ICR7dGhuSWR4fSkpXG4gICAgICAgICAgICAoYnIgJGxvb3ApXG4gICAgICAgICAgKSBcbiAgICAgICAgICAoZWxzZSBcbiAgICAgICAgICAgIChsb2NhbC5zZXQgJCRzZWxlY3RvciAoaTMyLmNvbnN0ICR7ZWxzSWR4fSkpXG4gICAgICAgICAgICAoYnIgJGxvb3ApXG4gICAgICAgICAgKVxuICAgICAgICAgKWBdXG5cbiAgICBjYXNlIFwiam1wXCI6XG4gICAgICBjb25zdCBsYmxJZHggPSBlbnYubGFiZWxzLmZpbmRJbmRleChlID0+IGUgPT09IHN0bXQubGJsKTtcbiAgICAgIHJldHVybiBbYChsb2NhbC5zZXQgJCRzZWxlY3RvciAoaTMyLmNvbnN0ICR7bGJsSWR4fSkpYCwgYChiciAkbG9vcClgXVxuXG4gIH1cbn1cblxuZnVuY3Rpb24gY29kZUdlbkV4cHIoZXhwcjogRXhwcjxBbm5vdGF0aW9uPiwgZW52OiBHbG9iYWxFbnYpOiBBcnJheTxzdHJpbmc+IHtcbiAgc3dpdGNoIChleHByLnRhZykge1xuICAgIGNhc2UgXCJ2YWx1ZVwiOlxuICAgICAgcmV0dXJuIGNvZGVHZW5WYWx1ZShleHByLnZhbHVlLCBlbnYpXG5cbiAgICBjYXNlIFwiYmlub3BcIjpcbiAgICAgIGNvbnN0IGxoc1N0bXRzID0gY29kZUdlblZhbHVlKGV4cHIubGVmdCwgZW52KTtcbiAgICAgIGNvbnN0IHJoc1N0bXRzID0gY29kZUdlblZhbHVlKGV4cHIucmlnaHQsIGVudik7XG4gICAgICByZXR1cm4gWy4uLmxoc1N0bXRzLCAuLi5yaHNTdG10cywgY29kZUdlbkJpbk9wKGV4cHIub3ApXTtcblxuICAgIGNhc2UgXCJ1bmlvcFwiOlxuICAgICAgY29uc3QgZXhwclN0bXRzID0gY29kZUdlblZhbHVlKGV4cHIuZXhwciwgZW52KTtcbiAgICAgIHN3aXRjaChleHByLm9wKXtcbiAgICAgICAgY2FzZSBVbmlPcC5OZWc6XG4gICAgICAgICAgLy8gbmVnYXRlIGJpZ251bSBsZW5ndGggdG8gaW5kaWNhdGUgc2lnbiBjaGFuZ2VcbiAgICAgICAgICByZXR1cm4gW1xuICAgICAgICAgICAgLi4uZXhwclN0bXRzLFxuICAgICAgICAgICAgYChsb2NhbC5zZXQgJCRzY3JhdGNoKWAsIC8vIGJpZ251bSBhZGRyXG4gICAgICAgICAgICBgKGxvY2FsLmdldCAkJHNjcmF0Y2gpYCwgLy8gc3RvcmUgYWRkclxuICAgICAgICAgICAgYChpMzIuY29uc3QgMClgLCAvLyBzdG9yZSBvZmZzZXRcbiAgICAgICAgICAgIGAoaTMyLmNvbnN0IDApYCwgLy8gMCAtIGxlblxuICAgICAgICAgICAgYChsb2NhbC5nZXQgJCRzY3JhdGNoKWAsIC8vIGxvYWQgYWRkclxuICAgICAgICAgICAgYChpMzIuY29uc3QgMClgLCAvLyBsb2FkIG9mZnNldFxuICAgICAgICAgICAgYChjYWxsICRsb2FkKWAsIC8vIGxvYWQgYmlnbnVtIGxlblxuICAgICAgICAgICAgYChpMzIuc3ViKWAsIC8vIHN0b3JlIHZhbFxuICAgICAgICAgICAgYChjYWxsICRzdG9yZSlgLFxuICAgICAgICAgICAgYChsb2NhbC5nZXQgJCRzY3JhdGNoKWBcbiAgICAgICAgICBdO1xuICAgICAgICBjYXNlIFVuaU9wLk5vdDpcbiAgICAgICAgICByZXR1cm4gW2AoaTMyLmNvbnN0IDApYCwgLi4uZXhwclN0bXRzLCBgKGkzMi5lcSlgXTtcbiAgICAgIH1cblxuICAgIGNhc2UgXCJidWlsdGluMVwiOlxuICAgICAgY29uc3QgYXJnVHlwID0gZXhwci5hLnR5cGU7XG4gICAgICBjb25zdCBhcmdTdG10cyA9IGNvZGVHZW5WYWx1ZShleHByLmFyZywgZW52KTtcbiAgICAgIHZhciBjYWxsTmFtZSA9IGV4cHIubmFtZTtcbiAgICAgIGlmIChleHByLm5hbWUgPT09IFwicHJpbnRcIiAmJiBhcmdUeXAgPT09IE5VTSkge1xuICAgICAgICBjYWxsTmFtZSA9IFwicHJpbnRfbnVtXCI7XG4gICAgICB9IGVsc2UgaWYgKGV4cHIubmFtZSA9PT0gXCJwcmludFwiICYmIGFyZ1R5cCA9PT0gQk9PTCkge1xuICAgICAgICBjYWxsTmFtZSA9IFwicHJpbnRfYm9vbFwiO1xuICAgICAgfSBlbHNlIGlmIChleHByLm5hbWUgPT09IFwicHJpbnRcIiAmJiBhcmdUeXAgPT09IE5PTkUpIHtcbiAgICAgICAgY2FsbE5hbWUgPSBcInByaW50X25vbmVcIjtcbiAgICAgIH1cbiAgICAgIHJldHVybiBhcmdTdG10cy5jb25jYXQoW2AoY2FsbCAkJHtjYWxsTmFtZX0pYF0pO1xuXG4gICAgY2FzZSBcImJ1aWx0aW4yXCI6XG4gICAgICBjb25zdCBsZWZ0U3RtdHMgPSBjb2RlR2VuVmFsdWUoZXhwci5sZWZ0LCBlbnYpO1xuICAgICAgY29uc3QgcmlnaHRTdG10cyA9IGNvZGVHZW5WYWx1ZShleHByLnJpZ2h0LCBlbnYpO1xuICAgICAgcmV0dXJuIFsuLi5sZWZ0U3RtdHMsIC4uLnJpZ2h0U3RtdHMsIGAoY2FsbCAkJHtleHByLm5hbWV9KWBdXG5cbiAgICBjYXNlIFwiY2FsbFwiOlxuICAgICAgdmFyIHZhbFN0bXRzID0gZXhwci5hcmd1bWVudHMubWFwKChhcmcpID0+IGNvZGVHZW5WYWx1ZShhcmcsIGVudikpLmZsYXQoKTtcbiAgICAgIHZhbFN0bXRzLnB1c2goYChjYWxsICQke2V4cHIubmFtZX0pYCk7XG4gICAgICByZXR1cm4gdmFsU3RtdHM7XG5cbiAgICBjYXNlIFwiY2FsbF9pbmRpcmVjdFwiOlxuICAgICAgdmFyIHZhbFN0bXRzID0gY29kZUdlbkV4cHIoZXhwci5mbiwgZW52KTtcbiAgICAgIHZhciBmblN0bXRzID0gZXhwci5hcmd1bWVudHMubWFwKChhcmcpID0+IGNvZGVHZW5WYWx1ZShhcmcsIGVudikpLmZsYXQoKTtcbiAgICAgIHJldHVybiBbLi4uZm5TdG10cywgLi4udmFsU3RtdHMsIGAoY2FsbF9pbmRpcmVjdCAodHlwZSAke21ha2VXYXNtRnVuVHlwZShleHByLmFyZ3VtZW50cy5sZW5ndGgpfSkpYF07XG5cbiAgICBjYXNlIFwiYWxsb2NcIjpcbiAgICAgIHJldHVybiBbXG4gICAgICAgIC4uLmNvZGVHZW5WYWx1ZShleHByLmFtb3VudCwgZW52KSxcbiAgICAgICAgYGNhbGwgJGFsbG9jYFxuICAgICAgXTtcbiAgICBjYXNlIFwibG9hZFwiOlxuICAgICAgcmV0dXJuIFtcbiAgICAgICAgLi4uY29kZUdlblZhbHVlKGV4cHIuc3RhcnQsIGVudiksXG4gICAgICAgIC4uLmNvZGVHZW5WYWx1ZShleHByLm9mZnNldCwgZW52KSxcbiAgICAgICAgYGNhbGwgJGxvYWRgXG4gICAgICBdXG4gIH1cbn1cblxuZnVuY3Rpb24gY29kZUdlblZhbHVlKHZhbDogVmFsdWU8QW5ub3RhdGlvbj4sIGVudjogR2xvYmFsRW52KTogQXJyYXk8c3RyaW5nPiB7XG4gIHN3aXRjaCAodmFsLnRhZykge1xuICAgIGNhc2UgXCJudW1cIjpcbiAgICAgIHZhciB4ID0gQmlnSW50KHZhbC52YWx1ZSkgLy8gZm9yIGRpdmlzaW9uXG4gICAgICBpZiAoeCA9PT0gQmlnSW50KDApKVxuICAgICAgICByZXR1cm4gW1wiKGkzMi5jb25zdCAwKVwiXVxuICAgICAgdmFyIG4gPSAwXG4gICAgICB2YXIgZGlnaXRzIDogTnVtYmVyW10gPSBbXVxuICAgICAgd2hpbGUoeCAhPSBCaWdJbnQoMCkpIHtcbiAgICAgICAgICBpZiAoeCA8IDApIHtcbiAgICAgICAgICAgIHggKj0gQmlnSW50KC0xKVxuICAgICAgICAgIH1cbiAgICAgICAgICBkaWdpdHMucHVzaChOdW1iZXIoeCAmIEJpZ0ludCgweDdmZmZmZmZmKSkpXG4gICAgICAgICAgeCA9IHggLyBCaWdJbnQoMSA8PCAzMSkgXG4gICAgICAgICAgbiA9IG4gKyAxXG4gICAgICB9XG4gICAgICBuID0gbiArIDEgLy8gc3RvcmUgKG4rMSkgYmxvY2tzIChuOiBudW1iZXIgb2YgZGlnaXRzKVxuXG4gICAgICB2YXIgaSA9IDBcbiAgICAgIHZhciByZXR1cm5fdmFsIDogc3RyaW5nW10gPSBbXVxuICAgICAgXG4gICAgICByZXR1cm5fdmFsLnB1c2goYChpMzIuY29uc3QgJHtufSlgKTtcbiAgICAgIHJldHVybl92YWwucHVzaChgKGNhbGwgJGFsbG9jKWApO1xuICAgICAgcmV0dXJuX3ZhbC5wdXNoKGAobG9jYWwuc2V0ICQkc2NyYXRjaClgKTtcbiAgICAgIFxuICAgICAgLy8gc3RvcmUgdGhlIGJpZ251bSBpbiAobisxKSBibG9ja3NcbiAgICAgIC8vIHN0b3JlIG51bWJlciBvZiBibG9ja3MgaW4gdGhlIGZpcnN0IGJsb2NrXG4gICAgICByZXR1cm5fdmFsLnB1c2goYChsb2NhbC5nZXQgJCRzY3JhdGNoKWApO1xuICAgICAgcmV0dXJuX3ZhbC5wdXNoKGAoaTMyLmNvbnN0ICR7aX0pYCk7XG4gICAgICByZXR1cm5fdmFsLnB1c2goYChpMzIuY29uc3QgJHtuLTF9KWApO1xuICAgICAgcmV0dXJuX3ZhbC5wdXNoKGBjYWxsICRzdG9yZWApOyBcbiAgICAgIFxuICAgICAgaSA9IGkgKyAxO1xuICAgICAgLy8gc3RvcmUgdGhlIGRpZ2l0cyBpbiB0aGUgcmVzdCBvZiBibG9ja3NcbiAgICAgIGZvciAoaTsgaSA8IG47IGkrKykge1xuICAgICAgICByZXR1cm5fdmFsLnB1c2goYChsb2NhbC5nZXQgJCRzY3JhdGNoKWApO1xuICAgICAgICByZXR1cm5fdmFsLnB1c2goYChpMzIuY29uc3QgJHtpfSlgKTtcbiAgICAgICAgcmV0dXJuX3ZhbC5wdXNoKGAoaTMyLmNvbnN0ICR7ZGlnaXRzW2ktMV19KWApO1xuICAgICAgICByZXR1cm5fdmFsLnB1c2goYGNhbGwgJHN0b3JlYCk7ICAgIFxuICAgICAgfVxuICAgICAgcmV0dXJuX3ZhbC5wdXNoKGAobG9jYWwuZ2V0ICQkc2NyYXRjaClgKVxuICAgICAgcmV0dXJuIHJldHVybl92YWw7XG4gICAgY2FzZSBcIndhc21pbnRcIjpcbiAgICAgIHJldHVybiBbXCIoaTMyLmNvbnN0IFwiICsgdmFsLnZhbHVlICsgXCIpXCJdO1xuICAgIGNhc2UgXCJib29sXCI6XG4gICAgICByZXR1cm4gW2AoaTMyLmNvbnN0ICR7TnVtYmVyKHZhbC52YWx1ZSl9KWBdO1xuICAgIGNhc2UgXCJub25lXCI6XG4gICAgICByZXR1cm4gW2AoaTMyLmNvbnN0IDApYF07XG4gICAgY2FzZSBcImlkXCI6XG4gICAgICBpZiAoZW52LmxvY2Fscy5oYXModmFsLm5hbWUpKSB7XG4gICAgICAgIHJldHVybiBbYChsb2NhbC5nZXQgJCR7dmFsLm5hbWV9KWBdO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcmV0dXJuIFtgKGdsb2JhbC5nZXQgJCR7dmFsLm5hbWV9KWBdO1xuICAgICAgfVxuICB9XG59XG5cbmZ1bmN0aW9uIGNvZGVHZW5CaW5PcChvcCA6IEJpbk9wKSA6IHN0cmluZyB7XG4gIHN3aXRjaChvcCkge1xuICAgIGNhc2UgQmluT3AuUGx1czpcbiAgICAgIHJldHVybiBcIihjYWxsICQkYWRkKVwiXG4gICAgY2FzZSBCaW5PcC5NaW51czpcbiAgICAgIHJldHVybiBcIihjYWxsICQkc3ViKVwiXG4gICAgY2FzZSBCaW5PcC5NdWw6XG4gICAgICByZXR1cm4gXCIoY2FsbCAkJG11bClcIlxuICAgIGNhc2UgQmluT3AuSURpdjpcbiAgICAgIHJldHVybiBcIihjYWxsICQkZGl2KVwiXG4gICAgY2FzZSBCaW5PcC5Nb2Q6XG4gICAgICByZXR1cm4gXCIoY2FsbCAkJG1vZClcIlxuICAgIGNhc2UgQmluT3AuRXE6XG4gICAgICByZXR1cm4gXCIoY2FsbCAkJGVxKVwiXG4gICAgY2FzZSBCaW5PcC5OZXE6XG4gICAgICByZXR1cm4gXCIoY2FsbCAkJG5lcSlcIlxuICAgIGNhc2UgQmluT3AuTHRlOlxuICAgICAgcmV0dXJuIFwiKGNhbGwgJCRsdGUpXCJcbiAgICBjYXNlIEJpbk9wLkd0ZTpcbiAgICAgIHJldHVybiBcIihjYWxsICQkZ3RlKVwiXG4gICAgY2FzZSBCaW5PcC5MdDpcbiAgICAgIHJldHVybiBcIihjYWxsICQkbHQpXCJcbiAgICBjYXNlIEJpbk9wLkd0OlxuICAgICAgcmV0dXJuIFwiKGNhbGwgJCRndClcIlxuICAgIGNhc2UgQmluT3AuSXM6XG4gICAgICByZXR1cm4gXCIoaTMyLmVxKVwiO1xuICAgIGNhc2UgQmluT3AuQW5kOlxuICAgICAgcmV0dXJuIFwiKGkzMi5hbmQpXCJcbiAgICBjYXNlIEJpbk9wLk9yOlxuICAgICAgcmV0dXJuIFwiKGkzMi5vcilcIlxuICB9XG59XG5cbmZ1bmN0aW9uIGNvZGVHZW5Jbml0KGluaXQgOiBWYXJJbml0PEFubm90YXRpb24+LCBlbnYgOiBHbG9iYWxFbnYpIDogQXJyYXk8c3RyaW5nPiB7XG4gIGNvbnN0IHZhbHVlID0gY29kZUdlblZhbHVlKGluaXQudmFsdWUsIGVudik7XG4gIGlmIChlbnYubG9jYWxzLmhhcyhpbml0Lm5hbWUpKSB7XG4gICAgcmV0dXJuIFsuLi52YWx1ZSwgYChsb2NhbC5zZXQgJCR7aW5pdC5uYW1lfSlgXTsgXG4gIH0gZWxzZSB7XG4gICAgcmV0dXJuIFsuLi52YWx1ZSwgYChnbG9iYWwuc2V0ICQke2luaXQubmFtZX0pYF07IFxuICB9XG59XG5cbmZ1bmN0aW9uIGNvZGVHZW5EZWYoZGVmIDogRnVuRGVmPEFubm90YXRpb24+LCBlbnYgOiBHbG9iYWxFbnYpIDogQXJyYXk8c3RyaW5nPiB7XG4gIHZhciBkZWZpbmVkVmFycyA6IFNldDxzdHJpbmc+ID0gbmV3IFNldCgpO1xuICBkZWYuaW5pdHMuZm9yRWFjaCh2ID0+IGRlZmluZWRWYXJzLmFkZCh2Lm5hbWUpKTtcbiAgZGVmaW5lZFZhcnMuYWRkKFwiJGxhc3RcIik7XG4gIGRlZmluZWRWYXJzLmFkZChcIiRzZWxlY3RvclwiKTtcbiAgZGVmaW5lZFZhcnMuYWRkKFwiJHNjcmF0Y2hcIik7XG4gIC8vIGRlZi5wYXJhbWV0ZXJzLmZvckVhY2gocCA9PiBkZWZpbmVkVmFycy5kZWxldGUocC5uYW1lKSk7XG4gIGRlZmluZWRWYXJzLmZvckVhY2goZW52LmxvY2Fscy5hZGQsIGVudi5sb2NhbHMpO1xuICBkZWYucGFyYW1ldGVycy5mb3JFYWNoKHAgPT4gZW52LmxvY2Fscy5hZGQocC5uYW1lKSk7XG4gIGVudi5sYWJlbHMgPSBkZWYuYm9keS5tYXAoYmxvY2sgPT4gYmxvY2subGFiZWwpO1xuICBjb25zdCBsb2NhbERlZmluZXMgPSBtYWtlTG9jYWxzKGRlZmluZWRWYXJzKTtcbiAgY29uc3QgbG9jYWxzID0gbG9jYWxEZWZpbmVzLmpvaW4oXCJcXG5cIik7XG4gIGNvbnN0IGluaXRzID0gZGVmLmluaXRzLm1hcChpbml0ID0+IGNvZGVHZW5Jbml0KGluaXQsIGVudikpLmZsYXQoKS5qb2luKFwiXFxuXCIpO1xuICB2YXIgcGFyYW1zID0gZGVmLnBhcmFtZXRlcnMubWFwKHAgPT4gYChwYXJhbSAkJHtwLm5hbWV9IGkzMilgKS5qb2luKFwiIFwiKTtcbiAgdmFyIGJvZHlDb21tYW5kcyA9IFwiKGxvY2FsLnNldCAkJHNlbGVjdG9yIChpMzIuY29uc3QgMCkpXFxuXCJcbiAgYm9keUNvbW1hbmRzICs9IFwiKGxvb3AgJGxvb3BcXG5cIlxuXG4gIHZhciBibG9ja0NvbW1hbmRzID0gXCIobG9jYWwuZ2V0ICQkc2VsZWN0b3IpXFxuXCJcbiAgYmxvY2tDb21tYW5kcyArPSBgKGJyX3RhYmxlICR7ZGVmLmJvZHkubWFwKGJsb2NrID0+IGJsb2NrLmxhYmVsKS5qb2luKFwiIFwiKX0pYDtcbiAgZGVmLmJvZHkuZm9yRWFjaChibG9jayA9PiB7XG4gICAgYmxvY2tDb21tYW5kcyA9IGAoYmxvY2sgJHtibG9jay5sYWJlbH1cbiAgICAgICAgICAgICAgJHtibG9ja0NvbW1hbmRzfSAgICBcbiAgICAgICAgICAgICkgOzsgZW5kICR7YmxvY2subGFiZWx9XG4gICAgICAgICAgICAke2Jsb2NrLnN0bXRzLm1hcChzdG10ID0+IGNvZGVHZW5TdG10KHN0bXQsIGVudikuam9pbignXFxuJykpLmpvaW4oJ1xcbicpfVxuICAgICAgICAgICAgYFxuICB9KVxuICBib2R5Q29tbWFuZHMgKz0gYmxvY2tDb21tYW5kcztcbiAgYm9keUNvbW1hbmRzICs9IFwiKSA7OyBlbmQgJGxvb3BcIlxuICBlbnYubG9jYWxzLmNsZWFyKCk7XG4gIHJldHVybiBbYFxuICAoZnVuYyAkJHtkZWYubmFtZX0gJHtwYXJhbXN9IChyZXN1bHQgaTMyKVxuICAgICR7bG9jYWxzfVxuICAgICR7aW5pdHN9XG4gICAgJHtib2R5Q29tbWFuZHN9XG4gICAgKGkzMi5jb25zdCAwKVxuICAgIChyZXR1cm4pKWBdO1xufVxuXG5mdW5jdGlvbiBjb2RlR2VuQ2xhc3MoY2xzIDogQ2xhc3M8QW5ub3RhdGlvbj4sIGVudiA6IEdsb2JhbEVudikgOiBBcnJheTxzdHJpbmc+IHtcbiAgY29uc3QgbWV0aG9kcyA9IFsuLi5jbHMubWV0aG9kc107XG4gIG1ldGhvZHMuZm9yRWFjaChtZXRob2QgPT4gbWV0aG9kLm5hbWUgPSBjcmVhdGVNZXRob2ROYW1lKGNscy5uYW1lLCBtZXRob2QubmFtZSkpO1xuICBjb25zdCByZXN1bHQgPSBtZXRob2RzLm1hcChtZXRob2QgPT4gY29kZUdlbkRlZihtZXRob2QsIGVudikpO1xuICByZXR1cm4gcmVzdWx0LmZsYXQoKTtcbiAgfVxuIiwiZXhwb3J0IGNvbnN0IGRlZmF1bHRfa2V5d29yZHMgPSBbXG4gICAgXCJhbmRcIixcbiAgICBcImRlbFwiLFxuICAgIFwiZnJvbVwiLFxuICAgIFwibm90XCIsXG4gICAgXCJ3aGlsZVwiLFxuICAgIFwiYXNcIixcbiAgICBcImVsaWZcIixcbiAgICBcImdsb2JhbFwiLFxuICAgIFwib3JcIixcbiAgICBcIndpdGhcIixcbiAgICBcImFzc2VydFwiLFxuICAgIFwiZWxzZVwiLFxuICAgIFwiaWZcIixcbiAgICBcInBhc3NcIixcbiAgICBcInlpZWxkXCIsXG4gICAgXCJicmVha1wiLFxuICAgIFwiZXhjZXB0XCIsXG4gICAgXCJpbXBvcnRcIixcbiAgICBcInByaW50XCIsXG4gICAgXCJjbGFzc1wiLFxuICAgIFwiZXhlY1wiLFxuICAgIFwiaW5cIixcbiAgICBcInJhaXNlXCIsXG4gICAgXCJjb250aW51ZVwiLFxuICAgIFwiZmluYWxseVwiLFxuICAgIFwiaXNcIixcbiAgICBcInJldHVyblwiLFxuICAgIFwiZGVmXCIsXG4gICAgXCJmb3JcIixcbiAgICBcImxhbWJkYVwiLFxuICAgIFwidHJ5XCIsXG4gICAgXCJpbnRcIixcbiAgICBcImJvb2xcIixcbiAgICBcInN0clwiLFxuXTtcblxuZXhwb3J0IGNvbnN0IGRlZmF1bHRfZnVuY3Rpb25zID0gW1xuICAgIFwiYWJzKClcIixcbiAgICBcImRlbGF0dHIoKVwiLFxuICAgIFwiaGFzaCgpXCIsXG4gICAgXCJtZW1vcnl2aWV3KClcIixcbiAgICBcInNldCgpXCIsXG4gICAgXCJhbGwoKVwiLFxuICAgIFwiZGljdCgpXCIsXG4gICAgXCJoZWxwKClcIixcbiAgICBcIm1pbigpXCIsXG4gICAgXCJzZXRhdHRyKClcIixcbiAgICBcImFueSgpXCIsXG4gICAgXCJkaXIoKVwiLFxuICAgIFwiaGV4KClcIixcbiAgICBcIm5leHQoKVwiLFxuICAgIFwic2xpY2UoKVwiLFxuICAgIFwiYXNjaWkoKVwiLFxuICAgIFwiZGl2bW9kKClcIixcbiAgICBcImlkKClcIixcbiAgICBcIm9iamVjdCgpXCIsXG4gICAgXCJzb3J0ZWQoKVwiLFxuICAgIFwiYmluKClcIixcbiAgICBcImVudW1lcmF0ZSgpXCIsXG4gICAgXCJpbnB1dCgpXCIsXG4gICAgXCJvY3QoKVwiLFxuICAgIFwic3RhdGljbWV0aG9kKClcIixcbiAgICBcImV2YWwoKVwiLFxuICAgIFwib3BlbigpXCIsXG4gICAgXCJzdHIoKVwiLFxuICAgIFwiYnJlYWtwb2ludCgpXCIsXG4gICAgXCJleGVjKClcIixcbiAgICBcImlzaW5zdGFuY2UoKVwiLFxuICAgIFwib3JkKClcIixcbiAgICBcInN1bSgpXCIsXG4gICAgXCJieXRlYXJyYXkoKVwiLFxuICAgIFwiZmlsdGVyKClcIixcbiAgICBcImlzc3ViY2xhc3MoKVwiLFxuICAgIFwicG93KClcIixcbiAgICBcInN1cGVyKClcIixcbiAgICBcImJ5dGVzKClcIixcbiAgICBcImZsb2F0KClcIixcbiAgICBcIml0ZXIoKVwiLFxuICAgIFwicHJpbnQoKVwiLFxuICAgIFwidHVwbGUoKVwiLFxuICAgIFwiY2FsbGFibGUoKVwiLFxuICAgIFwiZm9ybWF0KClcIixcbiAgICBcImxlbigpXCIsXG4gICAgXCJwcm9wZXJ0eSgpXCIsXG4gICAgXCJ0eXBlKClcIixcbiAgICBcImNocigpXCIsXG4gICAgXCJmcm96ZW5zZXQoKVwiLFxuICAgIFwibGlzdCgpXCIsXG4gICAgXCJyYW5nZSgpXCIsXG4gICAgXCJ2YXJzKClcIixcbiAgICBcImNsYXNzbWV0aG9kKClcIixcbiAgICBcImdldGF0dHIoKVwiLFxuICAgIFwibG9jYWxzKClcIixcbiAgICBcInJlcHIoKVwiLFxuICAgIFwiemlwKClcIixcbiAgICBcImNvbXBpbGUoKVwiLFxuICAgIFwiZ2xvYmFscygpXCIsXG4gICAgXCJtYXAoKVwiLFxuICAgIFwicmV2ZXJzZWQoKVwiLFxuICAgIFwiX19pbXBvcnRfXygpXCIsXG4gICAgXCJjb21wbGV4KClcIixcbiAgICBcImhhc2F0dHIoKVwiLFxuICAgIFwibWF4KClcIixcbiAgICBcInJvdW5kKClcIixcbl07XG4iLCJpbXBvcnQgKiBhcyBBU1QgZnJvbSAnLi9hc3QnO1xuaW1wb3J0IHsgQW5ub3RhdGlvbiB9IGZyb20gJy4vYXN0JztcbmltcG9ydCAqIGFzIElSIGZyb20gJy4vaXInO1xuaW1wb3J0IHtmbGF0dGVuV2FzbUludH0gZnJvbSAnLi9sb3dlcic7XG5cbmV4cG9ydCBjb25zdCBSVU5USU1FX0VSUk9SX1NUUklORyA9IFwiUlVOVElNRSBFUlJPUlwiXG5leHBvcnQgY29uc3QgVFlQRV9FUlJPUl9TVFJJTkcgPSBcIlRZUEUgRVJST1JcIlxuXG4vKioqKioqIEZ1bGwgbGluZSBvZiBzcmMgdGhhdCBjb250YWlucyBhbiBlcnJvciAqKioqKiovXG5leHBvcnQgZnVuY3Rpb24gZnVsbFNyY0xpbmUoU1JDOiBzdHJpbmcsIGZyb21Mb2NJZHg6IG51bWJlciwgZnJvbUxvY0NvbDogbnVtYmVyLCBlb2xMb2NJZHg6IG51bWJlcikge1xuICAgIGNvbnN0IGxpbmVTdGFydCA9IGZyb21Mb2NJZHggLSBmcm9tTG9jQ29sICsgMTsgLy8gc3JjIGFuZCBjb2wgaGFzIGFuIG9mZnNldCBvZiAxXG4gICAgcmV0dXJuIFNSQy5zbGljZShsaW5lU3RhcnQsIGVvbExvY0lkeCk7XG59XG5cbi8vIFRPRE86IGhvdyB0byBkcmF3IHNxdWlnZ2xpZXMgaWYgdGhlIGVycm9yIHNwYW5zIG11bHRpcGxlIGxpbmVzP1xuZXhwb3J0IGZ1bmN0aW9uIGRyYXdTcXVpZ2dseShmcm9tTG9jUm93OiBudW1iZXIsIGVuZExvY1JvdzogbnVtYmVyLCBmcm9tTG9jQ29sOiBudW1iZXIsIGVuZExvY0NvbDogbnVtYmVyKSB7XG4gICAgcmV0dXJuIChmcm9tTG9jUm93ID09PSBlbmRMb2NSb3cpID8gYCR7JyAnLnJlcGVhdChmcm9tTG9jQ29sIC0gMSl9JHsnXicucmVwZWF0KGVuZExvY0NvbCAtIGZyb21Mb2NDb2wpfWAgOiAnJztcbn1cblxuXG4vKioqKioqIFJ1bnRpbWUgRXJyb3JzICoqKioqKiovXG5cbi8qKlxuICogUnVudGltZSBFcnJvciBiYXNlIGNsYXNzLlxuICovXG5leHBvcnQgY2xhc3MgUnVudGltZUVycm9yIGV4dGVuZHMgRXJyb3Ige1xuICAgIF9fcHJvdG9fXzogRXJyb3I7XG4gICAgYT86IEFubm90YXRpb24gfCB1bmRlZmluZWQ7XG4gICAgU1JDPzogc3RyaW5nIHwgdW5kZWZpbmVkO1xuICAgIG5vdGU6IHN0cmluZzsgXG5cbiAgICBjb25zdHJ1Y3RvcihTUkM/OiBzdHJpbmcsIGE/OiBBbm5vdGF0aW9uKSB7XG4gICAgICAgIGNvbnN0IHRydWVQcm90byA9IG5ldy50YXJnZXQucHJvdG90eXBlO1xuICAgICAgICBzdXBlcigpO1xuICAgICAgICAvLyBBbHRlcm5hdGl2ZWx5IHVzZSBPYmplY3Quc2V0UHJvdG90eXBlT2YgaWYgeW91IGhhdmUgYW4gRVM2IGVudmlyb25tZW50LlxuICAgICAgICB0aGlzLl9fcHJvdG9fXyA9IHRydWVQcm90bztcbiAgICAgICAgdGhpcy5hID0gKGEpID8/IHVuZGVmaW5lZDtcbiAgICAgICAgdGhpcy5TUkMgPSAoU1JDKSA/PyB1bmRlZmluZWQ7XG4gICAgICAgIHRoaXMubmFtZSA9IFJVTlRJTUVfRVJST1JfU1RSSU5HO1xuICAgICAgICB0aGlzLm1lc3NhZ2UgPSBcIllvdSBzaG91bGRuJ3Qgc2VlIHRoaXMuIENvbXBpbGVyJ3MgY3Vyc2VkLiBDaGVjayBpZiB5b3UgcHJlcGFyZWQgdGhlIGVycm9yIGJlZm9yZSB0aHJvd2luZyBpdCBvdXQuXCJcbiAgICAgICAgdGhpcy5ub3RlID0gXCJcIjtcbiAgICB9XG4gIFxuICAgIHB1YmxpYyBnZXRBKCk6IEFubm90YXRpb24gfCB1bmRlZmluZWQge1xuICAgICAgICByZXR1cm4gdGhpcy5hO1xuICAgIH1cblxuICAgIC8vIENyZWF0ZSBlcnJvciBtZXNzYWdlIGxhemlseSB0byByZWR1Y2UgbWVtb3J5IG92ZXJoZWFkXG4gICAgcHVibGljIHByZXBhcmUoKSB7XG4gICAgICAgIHZhciBsb2NTcXVpZ2dseVNyYyA9IFwiXCI7XG4gICAgICAgIGlmICh0aGlzLmEgJiYgdGhpcy5TUkMpIHtcbiAgICAgICAgICAgIGNvbnN0IGEgPSB0aGlzLmE7XG4gICAgICAgICAgICBjb25zdCBTUkMgPSB0aGlzLlNSQztcbiAgICAgICAgICAgIGNvbnN0IGZyb21Mb2MgPSBhLmZyb21Mb2M7XG4gICAgICAgICAgICBjb25zdCBlbmRMb2MgPSBhLmVuZExvYztcbiAgICAgICAgICAgIGNvbnN0IGVvbExvYyA9IGEuZW9sTG9jO1xuICAgICAgICAgICAgY29uc3QgbG9jID0gYCBvbiBsaW5lICR7ZnJvbUxvYy5yb3d9IGF0IGNvbCAke2Zyb21Mb2MuY29sfWA7XG4gICAgICAgICAgICBjb25zdCBzcmMgPSBmdWxsU3JjTGluZShTUkMsIGZyb21Mb2Muc3JjSWR4LCBmcm9tTG9jLmNvbCwgZW9sTG9jLnNyY0lkeCk7XG4gICAgICAgICAgICBjb25zdCBzcXVpZ2dseSA9IGRyYXdTcXVpZ2dseShmcm9tTG9jLnJvdywgZW5kTG9jLnJvdywgZnJvbUxvYy5jb2wsIGVuZExvYy5jb2wpO1xuICAgICAgICAgICAgbG9jU3F1aWdnbHlTcmMgPSBgJHtsb2N9XFxuXFxuJHtzcmN9XFxuJHtzcXVpZ2dseX1gO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IG1zZyA9IHRoaXMubm90ZSArIGxvY1NxdWlnZ2x5U3JjO1xuICAgICAgICB0aGlzLm1lc3NhZ2UgPSBtc2c7XG4gICAgfVxuXG4gICAgcHVibGljIGdldEVyck1zZygpOiBzdHJpbmcge1xuICAgICAgICByZXR1cm4gU3RyaW5nKHRoaXMpO1xuICAgIH1cbiAgXG59XG5cbi8qKlxuICogVXNlZCB0byByZWdpc3RlciBmb3IgcnVudGltZSBlcnJvcnNcbiAqL1xudHlwZSBSdW50aW1lRXJyb3JSZWdpc3RyeSA9IEFycmF5PFJ1bnRpbWVFcnJvcj5cbi8vIFRPRE86IFNob3VsZCB0aGUgZXJyb3IgcmVnaXN0cnkgYmUgZ2xvYmFsLCBiZSBwdXQgaW4gSW1wb3J0ZWRPYmplY3RzLCBvciBiZSBzb21ld2hlcmUgZWxzZT8gXG5leHBvcnQgY29uc3QgcnVudGltZUVycm9yUmVnaXN0cnkgPSBuZXcgQXJyYXk8UnVudGltZUVycm9yPigpO1xuZXhwb3J0IGZ1bmN0aW9uIHJlZ2lzdGVyUkUoZTogUnVudGltZUVycm9yLCByZWdpc3RyeTogUnVudGltZUVycm9yUmVnaXN0cnk9cnVudGltZUVycm9yUmVnaXN0cnkpOiBudW1iZXIge1xuICAgIHJlZ2lzdHJ5LnB1c2goZSk7XG4gICAgcmV0dXJuIHJlZ2lzdHJ5Lmxlbmd0aCAtIDE7XG59XG5leHBvcnQgZnVuY3Rpb24gZ2V0UkUocmVOdW06IG51bWJlciwgcmVnaXN0cnk6IFJ1bnRpbWVFcnJvclJlZ2lzdHJ5PXJ1bnRpbWVFcnJvclJlZ2lzdHJ5KSB7XG4gICAgcmV0dXJuIHJlZ2lzdHJ5W3JlTnVtXTtcbn1cblxuLyoqKiogQ29tbW9uIEVycm9yIGNoZWNraW5nIGJlaGF2aW9ycyAqKioqL1xuZnVuY3Rpb24gYXNzZXJ0X25vdF96ZXJvKGFyZzogYW55LCByZU51bTogYW55KSA6IGFueSB7XG4gICAgaWYgKGFyZyA9PT0gMCl7XG4gICAgICAgIGNvbnN0IHJlID0gZ2V0UkUocmVOdW0pO1xuICAgICAgICByZS5wcmVwYXJlKCk7XG4gICAgICAgIHRocm93IHJlO1xuICAgIH1cbiAgICByZXR1cm4gYXJnO1xufVxuXG5cbi8qKioqKioqKioqIERpdmlkZSBieSBaZXJvIEVycm9yICoqKioqKioqKioqL1xuZXhwb3J0IGNvbnN0IERpdmlkZUJ5WmVyb05vdGUgPSBcImNhbm5vdCBkaXZpZGUgYnkgemVyb1wiXG5leHBvcnQgY2xhc3MgRGl2aWRlQnlaZXJvRXJyb3IgZXh0ZW5kcyBSdW50aW1lRXJyb3Ige1xuICAgIG5vdGU6IHN0cmluZyA9IERpdmlkZUJ5WmVyb05vdGU7XG59XG5cbmV4cG9ydCBjb25zdCBkaXZpZGVfYnlfemVybyA9IGFzc2VydF9ub3RfemVybztcblxuZXhwb3J0IGZ1bmN0aW9uIGZsYXR0ZW5EaXZpZGVCeVplcm8oYTpBbm5vdGF0aW9uICwgcnZhbDpJUi5WYWx1ZTxBU1QuQW5ub3RhdGlvbj4pOiBJUi5TdG10PEFTVC5Bbm5vdGF0aW9uPiB7XG4gICAgY29uc3QgZXJyb3IgPSBuZXcgRGl2aWRlQnlaZXJvRXJyb3IoaW1wb3J0T2JqZWN0RXJyb3JzLnNyYywgYSk7XG4gICAgY29uc3QgcmVOdW0gPSByZWdpc3RlclJFKGVycm9yKTtcbiAgICBjb25zdCBwb3NBcmcgPSBmbGF0dGVuV2FzbUludChyZU51bSk7XG4gICAgcmV0dXJuIHsgdGFnOiBcImV4cHJcIiwgZXhwcjogeyB0YWc6IFwiY2FsbFwiLCBuYW1lOiBgZGl2aWRlX2J5X3plcm9gLCBhcmd1bWVudHM6IFtydmFsLCBwb3NBcmddfX1cbn1cblxuXG4vKioqKioqKioqIE9wZXJhdGlvbiBPbiBOb25lIEVycm9yICoqKioqKioqKi9cbi8vIFRPRE86IFNlcGFyYXRlIGludG8gZGlmZmVyZW50IGNhc2VzIChNZXRob2QgY2FsbCBvbiBOb25lLCBGaWVsZCBhY2Nlc3Mgb24gTm9uZSwgaW5kZXhpbmcgb24gTm9uZSwgZXRjLilcbmV4cG9ydCBjb25zdCBPcGVyYXRpb25Pbk5vbmVOb3RlID0gXCJjYW5ub3QgcGVyZm9ybSBvcGVyYXRpb24gb24gbm9uZVwiXG5leHBvcnQgY2xhc3MgT3BlcmF0aW9uT25Ob25lRXJyb3IgZXh0ZW5kcyBSdW50aW1lRXJyb3Ige1xuICAgIG5vdGU6IHN0cmluZyA9IE9wZXJhdGlvbk9uTm9uZU5vdGU7XG59XG5cbmV4cG9ydCBjb25zdCBhc3NlcnRfbm90X25vbmUgPSBhc3NlcnRfbm90X3plcm87XG5cbmV4cG9ydCBmdW5jdGlvbiBmbGF0dGVuQXNzZXJ0Tm90Tm9uZShhOiBBbm5vdGF0aW9uLCBvdmFsOklSLlZhbHVlPEFTVC5Bbm5vdGF0aW9uPik6IElSLlN0bXQ8QVNULkFubm90YXRpb24+IHtcbiAgICBjb25zdCBlcnJvciA9IG5ldyBPcGVyYXRpb25Pbk5vbmVFcnJvcihpbXBvcnRPYmplY3RFcnJvcnMuc3JjLCBhKTtcbiAgICBjb25zdCByZU51bSA9IHJlZ2lzdGVyUkUoZXJyb3IpO1xuICAgIGNvbnN0IHBvc0FyZyA9IGZsYXR0ZW5XYXNtSW50KHJlTnVtKTtcbiAgICByZXR1cm4geyB0YWc6IFwiZXhwclwiLCBleHByOiB7IHRhZzogXCJjYWxsXCIsIG5hbWU6IGBhc3NlcnRfbm90X25vbmVgLCBhcmd1bWVudHM6IFtvdmFsLCBwb3NBcmddfX1cbn1cblxuXG4vKioqKioqKiBXQVNNIEltcG9ydHMgKioqKioqKi9cbmV4cG9ydCBjb25zdCBpbXBvcnRPYmplY3RFcnJvcnMgOiBhbnkgPSB7XG4gICAgc3JjOiBcIlwiLCAgICAgICAgIC8vIEZvciByZXBvcnRpbmcgc291cmNlIGNvZGUgaW4gcnVudGltZSBlcnJvcnMuICBcbiAgICBhc3NlcnRfbm90X25vbmUsIFxuICAgIGRpdmlkZV9ieV96ZXJvLFxufVxuXG5leHBvcnQgY29uc3Qgd2FzbUVycm9ySW1wb3J0cyA6IHN0cmluZyA9IGBcbiAgICAoZnVuYyAkYXNzZXJ0X25vdF9ub25lIChpbXBvcnQgXCJlcnJvcnNcIiBcImFzc2VydF9ub3Rfbm9uZVwiKSAocGFyYW0gaTMyKSAocGFyYW0gaTMyKSAocmVzdWx0IGkzMikpXG4gICAgKGZ1bmMgJGRpdmlkZV9ieV96ZXJvIChpbXBvcnQgXCJlcnJvcnNcIiBcImRpdmlkZV9ieV96ZXJvXCIpICAocGFyYW0gaTMyKSAocGFyYW0gaTMyKSAocmVzdWx0IGkzMikpXG5gXG4iLCJpbXBvcnQgKiBhcyBBU1QgZnJvbSAnLi9hc3QnO1xuaW1wb3J0ICogYXMgSVIgZnJvbSAnLi9pcic7XG5pbXBvcnQgKiBhcyBFUlJPUlMgZnJvbSAnLi9lcnJvcnMnO1xuaW1wb3J0IHsgVHlwZSwgQW5ub3RhdGlvbiB9IGZyb20gJy4vYXN0JztcbmltcG9ydCB7IEdsb2JhbEVudiB9IGZyb20gJy4vY29tcGlsZXInO1xuaW1wb3J0IHsgQVBQTFksIENMQVNTLCBjcmVhdGVNZXRob2ROYW1lLCBCT09MLCBOT05FLCBOVU0gfSBmcm9tICcuL3V0aWxzJztcblxubGV0IG5hbWVDb3VudGVycyA6IE1hcDxzdHJpbmcsIG51bWJlcj4gPSBuZXcgTWFwKCk7XG5mdW5jdGlvbiBnZW5lcmF0ZU5hbWUoYmFzZSA6IHN0cmluZykgOiBzdHJpbmcge1xuICBpZihuYW1lQ291bnRlcnMuaGFzKGJhc2UpKSB7XG4gICAgdmFyIGN1ciA9IG5hbWVDb3VudGVycy5nZXQoYmFzZSk7XG4gICAgbmFtZUNvdW50ZXJzLnNldChiYXNlLCBjdXIgKyAxKTtcbiAgICByZXR1cm4gYmFzZSArIChjdXIgKyAxKTtcbiAgfVxuICBlbHNlIHtcbiAgICBuYW1lQ291bnRlcnMuc2V0KGJhc2UsIDEpO1xuICAgIHJldHVybiBiYXNlICsgMTtcbiAgfVxufVxuXG5leHBvcnQgZnVuY3Rpb24gY2xvc3VyZU5hbWUoZjogc3RyaW5nLCBhbmNlc3RvcnM6IEFycmF5PEFTVC5GdW5EZWY8QW5ub3RhdGlvbj4+KTogc3RyaW5nIHtcbiAgcmV0dXJuIGAke1tmLCAuLi5hbmNlc3RvcnMubWFwKGYgPT4gZi5uYW1lKV0ucmV2ZXJzZSgpLmpvaW4oXCJfJFwiKX1fJGNsb3N1cmUkYDtcbn1cblxuLy8gZnVuY3Rpb24gbGJsKGE6IFR5cGUsIGJhc2U6IHN0cmluZykgOiBbc3RyaW5nLCBJUi5TdG10PFR5cGU+XSB7XG4vLyAgIGNvbnN0IG5hbWUgPSBnZW5lcmF0ZU5hbWUoYmFzZSk7XG4vLyAgIHJldHVybiBbbmFtZSwge3RhZzogXCJsYWJlbFwiLCBhOiBhLCBuYW1lOiBuYW1lfV07XG4vLyB9XG52YXIgYmxvY2tzIDogQXJyYXk8SVIuQmFzaWNCbG9jazxBbm5vdGF0aW9uPj4gPSBbXTtcbmV4cG9ydCBmdW5jdGlvbiBsb3dlclByb2dyYW0ocCA6IEFTVC5Qcm9ncmFtPEFubm90YXRpb24+LCBlbnYgOiBHbG9iYWxFbnYpIDogSVIuUHJvZ3JhbTxBbm5vdGF0aW9uPiB7XG4gICAgbmFtZUNvdW50ZXJzID0gbmV3IE1hcCgpO1xuICAgIGJsb2NrcyA9IFtdO1xuICAgIHZhciBmaXJzdEJsb2NrIDogSVIuQmFzaWNCbG9jazxBbm5vdGF0aW9uPiA9IHsgIGE6IHAuYSwgbGFiZWw6IGdlbmVyYXRlTmFtZShcIiRzdGFydFByb2dcIiksIHN0bXRzOiBbXSB9XG4gICAgYmxvY2tzLnB1c2goZmlyc3RCbG9jayk7XG4gICAgcC5mdW5zLmZvckVhY2goZiA9PiBlbnYuZnVuY3Rpb25OYW1lcy5zZXQoZi5uYW1lLCBjbG9zdXJlTmFtZShmLm5hbWUsIFtdKSkpO1xuICAgIHZhciBbY2xvc3VyZXMsIGNpbml0cywgY3N0bXRzXSA9IGxvd2VyRnVuRGVmcyhwLmZ1bnMsIGVudik7XG4gICAgWy4uLmNsb3N1cmVzLCAuLi5wLmNsYXNzZXNdLmZvckVhY2goY2xzID0+IHtcbiAgICAgIGVudi5jbGFzc0luZGljZXMuc2V0KGNscy5uYW1lLCBlbnYudnRhYmxlTWV0aG9kcy5sZW5ndGgpXG4gICAgICBlbnYudnRhYmxlTWV0aG9kcy5wdXNoKC4uLmNscy5tZXRob2RzXG4gICAgICAgIC5maWx0ZXIobWV0aG9kID0+ICFtZXRob2QubmFtZS5pbmNsdWRlcyhcIl9faW5pdF9fXCIpKVxuICAgICAgICAubWFwKChtZXRob2QpOiBbc3RyaW5nLCBudW1iZXJdID0+IFtjcmVhdGVNZXRob2ROYW1lKGNscy5uYW1lLCBtZXRob2QubmFtZSksIG1ldGhvZC5wYXJhbWV0ZXJzLmxlbmd0aF0pKTtcbiAgICB9KTtcblxuICAgIHZhciBjbGFzc2VzID0gbG93ZXJDbGFzc2VzKFsuLi5jbG9zdXJlcywgLi4ucC5jbGFzc2VzXSwgZW52KTtcbiAgICB2YXIgW2luaXRzLCBnZW5lcmF0ZWRDbGFzc2VzXSA9IGZsYXR0ZW5TdG10cyhbLi4uY3N0bXRzLCAuLi5wLnN0bXRzXSwgYmxvY2tzLCBlbnYpO1xuICAgIHJldHVybiB7XG4gICAgICAgIGE6IHAuYSxcbiAgICAgICAgZnVuczogW10sXG4gICAgICAgIGluaXRzOiBbLi4uaW5pdHMsIC4uLmxvd2VyVmFySW5pdHMoWy4uLmNpbml0cywgLi4ucC5pbml0c10sIGVudildLFxuICAgICAgICBjbGFzc2VzOiBbLi4uY2xhc3NlcywgLi4uZ2VuZXJhdGVkQ2xhc3Nlc10sXG4gICAgICAgIGJvZHk6IGJsb2Nrc1xuICAgIH1cbn1cblxuZnVuY3Rpb24gbG93ZXJGdW5EZWZzKFxuICBmczogQXJyYXk8QVNULkZ1bkRlZjxBbm5vdGF0aW9uPj4sXG4gIGVudjogR2xvYmFsRW52XG4pOiBbQXJyYXk8QVNULkNsYXNzPEFubm90YXRpb24+PiwgQXJyYXk8QVNULlZhckluaXQ8QW5ub3RhdGlvbj4+LCBBcnJheTxBU1QuU3RtdDxBbm5vdGF0aW9uPj5dIHtcbiAgY29uc3QgZGVmcyA9IGZzLm1hcChmID0+IGxvd2VyRnVuRGVmKGYsIGVudiwgW10pKTtcbiAgcmV0dXJuIFtkZWZzLm1hcCh4ID0+IHhbMF0pLmZsYXQoKSwgZGVmcy5tYXAoeCA9PiB4WzFdKSwgZGVmcy5tYXAoeCA9PiB4WzJdKV07XG59XG5cbmZ1bmN0aW9uIGxvd2VyRnVuRGVmKFxuICBmOiBBU1QuRnVuRGVmPEFubm90YXRpb24+LFxuICBlbnY6IEdsb2JhbEVudixcbiAgYW5jZXN0b3JzOiBBcnJheTxBU1QuRnVuRGVmPEFubm90YXRpb24+PlxuKTogW0FycmF5PEFTVC5DbGFzczxBbm5vdGF0aW9uPj4sIEFTVC5WYXJJbml0PEFubm90YXRpb24+LCBBU1QuU3RtdDxBbm5vdGF0aW9uPl0ge1xuICB2YXIgbmFtZSA9IGNsb3N1cmVOYW1lKGYubmFtZSwgYW5jZXN0b3JzKTtcbiAgdmFyIHR5cGU6IFR5cGUgPSBDTEFTUyhuYW1lKTtcbiAgdmFyIHNlbGY6IEFTVC5QYXJhbWV0ZXI8QW5ub3RhdGlvbj4gPSB7IG5hbWU6IFwic2VsZlwiLCB0eXBlIH07XG5cbiAgdmFyIGVudkNvcHkgPSB7IC4uLmVudiwgZnVuY3Rpb25OYW1lczogbmV3IE1hcChlbnYuZnVuY3Rpb25OYW1lcykgfTtcbiAgZi5jaGlsZHJlbi5mb3JFYWNoKGMgPT4gZW52Q29weS5mdW5jdGlvbk5hbWVzLnNldChjLm5hbWUsIGNsb3N1cmVOYW1lKGMubmFtZSwgW2YsIC4uLmFuY2VzdG9yc10pKSk7XG5cbiAgdmFyIGRlZnMgPSBmLmNoaWxkcmVuLm1hcCh4ID0+IGxvd2VyRnVuRGVmKHgsIGVudkNvcHksIFtmLCAuLi5hbmNlc3RvcnNdKSk7XG4gIHZhciBhc3NpZ25TdG10OiBBU1QuU3RtdDxBbm5vdGF0aW9uPiA9IHsgdGFnOiBcImFzc2lnblwiLCBuYW1lOiBmLm5hbWUsIHZhbHVlOiB7IGE6IHsgdHlwZSB9LCB0YWc6IFwiY29uc3RydWN0XCIsIG5hbWUgfSB9XG4gIHZhciB2YXJJbml0OiBBU1QuVmFySW5pdDxBbm5vdGF0aW9uPiA9IHsgbmFtZTogZi5uYW1lLCB0eXBlLCB2YWx1ZTogeyB0YWc6IFwibm9uZVwiIH0gfVxuICAvLyBUT0RPKHBhc2hhYm91KTogY2hpbGRyZW4sIHBvcHVsYXRlIGZpZWxkcyBhbmQgbWV0aG9kcyBvZiBjbG9zdXJlIGNsYXNzXG4gIHJldHVybiBbXG4gICAgW3tcbiAgICAgIG5hbWUsXG4gICAgICBmaWVsZHM6IFtdLFxuICAgICAgbWV0aG9kczogW1xuICAgICAgICB7XG4gICAgICAgICAgbmFtZTogXCJfX2luaXRfX1wiLFxuICAgICAgICAgIHBhcmFtZXRlcnM6IFtzZWxmXSxcbiAgICAgICAgICByZXQ6IGYucmV0LFxuICAgICAgICAgIGluaXRzOiBbXSxcbiAgICAgICAgICBib2R5OiBbXSxcbiAgICAgICAgICBub25sb2NhbHM6IFtdLFxuICAgICAgICAgIGNoaWxkcmVuOiBbXVxuICAgICAgICB9LFxuICAgICAgICB7XG4gICAgICAgICAgLi4uZixcbiAgICAgICAgICBuYW1lOiBBUFBMWSxcbiAgICAgICAgICBwYXJhbWV0ZXJzOiBbc2VsZiwgLi4uZi5wYXJhbWV0ZXJzXSxcbiAgICAgICAgICBpbml0czogW3ZhckluaXQsIC4uLmRlZnMubWFwKHggPT4geFsxXSksIC4uLmYuaW5pdHNdLFxuICAgICAgICAgIGJvZHk6IFthc3NpZ25TdG10LCAuLi5kZWZzLm1hcCh4ID0+IHhbMl0pLCAuLi5mLmJvZHldXG4gICAgICAgIH1cbiAgICAgIF0sXG4gICAgICB0eXBlUGFyYW1zOiBbXVxuICAgIH0sIC4uLmRlZnMubWFwKHggPT4geFswXSkuZmxhdCgpXSxcbiAgICB2YXJJbml0LFxuICAgIGFzc2lnblN0bXRcbiAgXTtcbn1cblxuZnVuY3Rpb24gbG93ZXJNZXRob2REZWZzKGZzIDogQXJyYXk8QVNULkZ1bkRlZjxBbm5vdGF0aW9uPj4sIGVudiA6IEdsb2JhbEVudikgOiBbQXJyYXk8SVIuQ2xhc3M8QW5ub3RhdGlvbj4+LCBBcnJheTxJUi5GdW5EZWY8QW5ub3RhdGlvbj4+XSB7XG4gIGNvbnN0IGRlZnMgPSBmcy5tYXAoZiA9PiBsb3dlck1ldGhvZERlZihmLCBlbnYpKTtcbiAgcmV0dXJuIFtkZWZzLm1hcCh4ID0+IHhbMF0pLmZsYXQoKSwgZGVmcy5tYXAoeCA9PiB4WzFdKV07XG59XG5cbmZ1bmN0aW9uIGxvd2VyTWV0aG9kRGVmKGYgOiBBU1QuRnVuRGVmPEFubm90YXRpb24+LCBlbnYgOiBHbG9iYWxFbnYpIDogW0FycmF5PElSLkNsYXNzPEFubm90YXRpb24+PiwgSVIuRnVuRGVmPEFubm90YXRpb24+XSB7XG4gIHZhciBibG9ja3MgOiBBcnJheTxJUi5CYXNpY0Jsb2NrPEFubm90YXRpb24+PiA9IFtdO1xuICB2YXIgZmlyc3RCbG9jayA6IElSLkJhc2ljQmxvY2s8QW5ub3RhdGlvbj4gPSB7ICBhOiBmLmEsIGxhYmVsOiBnZW5lcmF0ZU5hbWUoXCIkc3RhcnRGdW5cIiksIHN0bXRzOiBbXSB9XG4gIGJsb2Nrcy5wdXNoKGZpcnN0QmxvY2spO1xuICB2YXIgW2JvZHlpbml0cywgY2xhc3Nlc10gPSBmbGF0dGVuU3RtdHMoZi5ib2R5LCBibG9ja3MsIGVudik7XG4gIHJldHVybiBbY2xhc3NlcywgeyAuLi5mLCBpbml0czogWy4uLmJvZHlpbml0cywgLi4ubG93ZXJWYXJJbml0cyhmLmluaXRzLCBlbnYpXSwgYm9keTogYmxvY2tzIH1dO1xufVxuXG5mdW5jdGlvbiBsb3dlclZhckluaXRzKGluaXRzOiBBcnJheTxBU1QuVmFySW5pdDxBbm5vdGF0aW9uPj4sIGVudjogR2xvYmFsRW52KSA6IEFycmF5PElSLlZhckluaXQ8QW5ub3RhdGlvbj4+IHtcbiAgICByZXR1cm4gaW5pdHMubWFwKGkgPT4gbG93ZXJWYXJJbml0KGksIGVudikpO1xufVxuXG5mdW5jdGlvbiBsb3dlclZhckluaXQoaW5pdDogQVNULlZhckluaXQ8QW5ub3RhdGlvbj4sIGVudjogR2xvYmFsRW52KSA6IElSLlZhckluaXQ8QW5ub3RhdGlvbj4ge1xuICAgIHJldHVybiB7XG4gICAgICAgIC4uLmluaXQsXG4gICAgICAgIHZhbHVlOiBsaXRlcmFsVG9WYWwoaW5pdC52YWx1ZSlcbiAgICB9XG59XG5cbmZ1bmN0aW9uIGxvd2VyQ2xhc3NlcyhjbGFzc2VzOiBBcnJheTxBU1QuQ2xhc3M8QW5ub3RhdGlvbj4+LCBlbnYgOiBHbG9iYWxFbnYpIDogQXJyYXk8SVIuQ2xhc3M8QW5ub3RhdGlvbj4+IHtcbiAgICByZXR1cm4gY2xhc3Nlcy5tYXAoYyA9PiBsb3dlckNsYXNzKGMsIGVudikpLmZsYXQoKTtcbn1cblxuZnVuY3Rpb24gbG93ZXJDbGFzcyhjbHM6IEFTVC5DbGFzczxBbm5vdGF0aW9uPiwgZW52IDogR2xvYmFsRW52KSA6IEFycmF5PElSLkNsYXNzPEFubm90YXRpb24+PiB7XG4gIC8vIGluaXQgbm90IGluIHZ0YWJsZSBcbiAgLy8gKHdlIGN1cnJlbnRseSBkbyBubyByZW9yZGVyaW5nLCB3ZSBsZWF2ZSB0aGF0IHRvIGluaGVyaXRhbmNlIHRlYW0pXG4gIGNvbnN0IFtjbGFzc2VzLCBtZXRob2RzXSA9IGxvd2VyTWV0aG9kRGVmcyhjbHMubWV0aG9kcywgZW52KTtcbiAgcmV0dXJuIFtcbiAgICAuLi5jbGFzc2VzLFxuICAgIHtcbiAgICAgIC4uLmNscyxcbiAgICAgIGZpZWxkczogbG93ZXJWYXJJbml0cyhjbHMuZmllbGRzLCBlbnYpLFxuICAgICAgbWV0aG9kc1xuICAgIH1cbiAgXTtcbn1cblxuZnVuY3Rpb24gbGl0ZXJhbFRvVmFsKGxpdDogQVNULkxpdGVyYWw8QW5ub3RhdGlvbj4pIDogSVIuVmFsdWU8QW5ub3RhdGlvbj4ge1xuICAgIHN3aXRjaChsaXQudGFnKSB7XG4gICAgICAgIGNhc2UgXCJudW1cIjpcbiAgICAgICAgICAgIHJldHVybiB7IC4uLmxpdCwgdmFsdWU6IEJpZ0ludCgobGl0LnZhbHVlKS50b0xvY2FsZVN0cmluZygnZnVsbHdpZGUnLCB7dXNlR3JvdXBpbmc6ZmFsc2V9KSkgfVxuICAgICAgICBjYXNlIFwiYm9vbFwiOlxuICAgICAgICAgICAgcmV0dXJuIGxpdFxuICAgICAgICBjYXNlIFwibm9uZVwiOlxuICAgICAgICAgICAgcmV0dXJuIGxpdCAgICAgICAgXG4gICAgfVxufVxuXG5mdW5jdGlvbiBmbGF0dGVuU3RtdHMocyA6IEFycmF5PEFTVC5TdG10PEFubm90YXRpb24+PiwgYmxvY2tzOiBBcnJheTxJUi5CYXNpY0Jsb2NrPEFubm90YXRpb24+PiwgZW52IDogR2xvYmFsRW52KSA6IFtBcnJheTxJUi5WYXJJbml0PEFubm90YXRpb24+PiwgQXJyYXk8SVIuQ2xhc3M8QW5ub3RhdGlvbj4+XSB7XG4gIHZhciBpbml0czogQXJyYXk8SVIuVmFySW5pdDxBbm5vdGF0aW9uPj4gPSBbXTtcbiAgdmFyIGNsYXNzZXM6IEFycmF5PElSLkNsYXNzPEFubm90YXRpb24+PiA9IFtdO1xuICBzLmZvckVhY2goc3RtdCA9PiB7XG4gICAgY29uc3QgcmVzID0gZmxhdHRlblN0bXQoc3RtdCwgYmxvY2tzLCBlbnYpO1xuICAgIGluaXRzLnB1c2goLi4ucmVzWzBdKTtcbiAgICBjbGFzc2VzLnB1c2goLi4ucmVzWzFdKTtcbiAgfSk7XG4gIHJldHVybiBbaW5pdHMsIGNsYXNzZXNdO1xufVxuXG5mdW5jdGlvbiBmbGF0dGVuTGlzdENvbXAoZTogYW55LCBlbnYgOiBHbG9iYWxFbnYsIGJsb2NrczogQXJyYXk8SVIuQmFzaWNCbG9jazxBbm5vdGF0aW9uPj4pIDogW0FycmF5PElSLlZhckluaXQ8QW5ub3RhdGlvbj4+LCBBcnJheTxJUi5TdG10PEFubm90YXRpb24+PiwgSVIuRXhwcjxBbm5vdGF0aW9uPiwgQXJyYXk8SVIuQ2xhc3M8QW5ub3RhdGlvbj4+XSB7XG4gIC8vIGNvbnNvbGUubG9nKFwibGlzdCBjb21wIGluIGlyXCIsIGUsIFwiLS0tLS0tLS0tLS0tLS0tLVwiKTtcbiAgdmFyIGNvbXBTdGFydExibCA9IGdlbmVyYXRlTmFtZShcIiRjb21wc3RhcnRcIik7XG4gIHZhciBjb21wYm9keUxibCA9IGdlbmVyYXRlTmFtZShcIiRjb21wYm9keVwiKTtcbiAgdmFyIGNvbXBFbmRMYmwgPSBnZW5lcmF0ZU5hbWUoXCIkY29tcGVuZFwiKTtcbiAgdmFyIGxpc3RBZGRMYmwgPSBnZW5lcmF0ZU5hbWUoXCIkbGlzdGFkZFwiKTtcbiAgLy8gdmFyIG5ld0xpc3ROYW1lID0gZ2VuZXJhdGVOYW1lKFwiJG5ld0xpc3RcIik7XG4gIHZhciBsb2NhbGVudiA9IGVudjtcbiAgbG9jYWxlbnYubGFiZWxzLnB1c2goY29tcFN0YXJ0TGJsLGNvbXBib2R5TGJsLGNvbXBFbmRMYmwsbGlzdEFkZExibCk7XG5cbiAgLy8gc3RhcnRcbiAgYmxvY2tzLnB1c2goeyAgYTogZS5hLCBsYWJlbDogY29tcFN0YXJ0TGJsLCBzdG10czogW10gfSlcbiAgLy8gYS5oYXNOZXh0KCkgY2FsbFxuICB2YXIgaGFzTmV4dENhbGwgOiBBU1QuRXhwcjxBU1QuQW5ub3RhdGlvbj4gPSB7dGFnOlwibWV0aG9kLWNhbGxcIiwgb2JqOmUuaXRlcmFibGUsIG1ldGhvZDpcImhhc05leHRcIiwgYXJndW1lbnRzOltdLCBhOnsuLi5lLmEsdGFnOkJPT0x9fTtcbiAgdmFyIFtjaW5pdHMsIGNzdG10cywgY2V4cHIsIGNlY2xhc3NdID0gZmxhdHRlbkV4cHJUb1ZhbChoYXNOZXh0Q2FsbCwgYmxvY2tzLCBsb2NhbGVudik7XG4gIHB1c2hTdG10c1RvTGFzdEJsb2NrKGJsb2NrcywgLi4uY3N0bXRzLCB7IHRhZzogXCJpZmptcFwiLCBjb25kOiBjZXhwciwgdGhuOiBjb21wYm9keUxibCwgZWxzOiBjb21wRW5kTGJsIH0pO1xuICAvLyBjb25zb2xlLmxvZyhjaW5pdHMsIGNzdG10cywgY2V4cHIpO1xuXG4gIC8vIGJvZHlcbiAgYmxvY2tzLnB1c2goeyAgYTogZS5hLCBsYWJlbDogY29tcGJvZHlMYmwsIHN0bXRzOiBbXSB9KVxuICAvLyBhc3NpZ24gYS5uZXh0KCkgdG8gZWxlbVxuICB2YXIgbmV4dENhbGwgOiBBU1QuRXhwcjxBU1QuQW5ub3RhdGlvbj4gPSB7dGFnOlwibWV0aG9kLWNhbGxcIiwgb2JqOmUuaXRlcmFibGUsIG1ldGhvZDpcIm5leHRcIiwgYXJndW1lbnRzOltdLCBhOnsgLi4uZS5hLCB0eXBlOiBOVU0gfX07XG4gIHZhciBlbGVtID0gXCJcIjtcbiAgaWYoZS5lbGVtLnRhZyA9PSBcImlkXCIpXG4gICAgZWxlbSA9IGUuZWxlbS5uYW1lO1xuICB2YXIgbmV4dEFzc2lnbiA6IEFTVC5TdG10PEFTVC5Bbm5vdGF0aW9uPltdID0gW3t0YWc6XCJhc3NpZ25cIixuYW1lOmVsZW0sIHZhbHVlOiBuZXh0Q2FsbCxhOnsgLi4uZS5hLCB0eXBlOiBOT05FIH19XTtcbiAgdmFyIFtib2R5aW5pdHMsYm9keWNsYXNzZXNdID0gZmxhdHRlblN0bXRzKG5leHRBc3NpZ24sIGJsb2NrcywgbG9jYWxlbnYpO1xuXG4gIC8vIGNvbmRcbiAgaWYgKGUuY29uZCl7XG4gICAgdmFyIFtkaW5pdHMsIGRzdG10cywgZGV4cHIsIGRlY2xhc3NdID0gZmxhdHRlbkV4cHJUb1ZhbChlLmNvbmQsIGJsb2NrcywgbG9jYWxlbnYpO1xuICAgIHB1c2hTdG10c1RvTGFzdEJsb2NrKGJsb2NrcywgLi4uZHN0bXRzLCB7IHRhZzogXCJpZmptcFwiLCBjb25kOiBkZXhwciwgdGhuOiBsaXN0QWRkTGJsLCBlbHM6IGNvbXBTdGFydExibCB9KTtcbiAgICAvLyBjb25zb2xlLmxvZyhcImRpbml0c1wiLCBkaW5pdHMsIFwiZHN0bXRzXCIsIGRzdG10cywgXCJkZXhwclwiLCBkZXhwcik7XG4gIH0gZWxzZSB7XG4gICAgcHVzaFN0bXRzVG9MYXN0QmxvY2soYmxvY2tzLCB7dGFnOlwiam1wXCIsIGxibDogbGlzdEFkZExibH0pO1xuICB9XG5cbiAgLy8gbGlzdCBhZGRcbiAgYmxvY2tzLnB1c2goeyAgYTogZS5hLCBsYWJlbDogbGlzdEFkZExibCwgc3RtdHM6IFtdIH0pXG4gIC8vIGRvIGxlZnQgZXhwclxuICB2YXIgW2Jpbml0cywgYnN0bXRzLCBiZXhwciwgYmVjbGFzc10gPSBmbGF0dGVuRXhwclRvVmFsKGUubGVmdCwgYmxvY2tzLCBsb2NhbGVudik7XG4gIGJvZHlpbml0cy5jb25jYXQoYmluaXRzKTtcbiAgLy8gY29uc29sZS5sb2coXCJiaW5pdHNcIiwgYmluaXRzLCBcImJzdG10c1wiLCBic3RtdHMsIFwiYmV4cHJcIiwgYmV4cHIsIFwiYm9keWluaXRzXCIsIGJvZHlpbml0cyk7XG5cbiAgLy8gZGlzcGxheSAoTkVFRCBUTyBBREQgVE8gQVJSQVkpXG4gIHZhciBkaXNwbGF5RXhwciA6IEFTVC5FeHByPEFTVC5Bbm5vdGF0aW9uPiA9IHt0YWc6XCJidWlsdGluMVwiLCBuYW1lOlwicHJpbnRcIiwgYXJnOmUubGVmdCwgYTplLmxlZnQuYX07XG4gIHZhciBkaXNwOiBBU1QuU3RtdDxBU1QuQW5ub3RhdGlvbj4gPSB7dGFnOlwiZXhwclwiLCBleHByOiBkaXNwbGF5RXhwciwgYTp7IC4uLmUuYSwgdHlwZTogTk9ORSB9fTtcbiAgLy8gdmFyIFtlaW5pdHMsIGVzdG10cywgZWV4cHJdID0gZmxhdHRlbkV4cHJUb1ZhbChkaXNwbGF5RXhwciwgbG9jYWxlbnYpO1xuICB2YXIgW2JvZHlfaW5pdCwgYm9keV9jbGFzc10gPSBmbGF0dGVuU3RtdChkaXNwLCBibG9ja3MsIGxvY2FsZW52KTtcbiAgYm9keWluaXRzLmNvbmNhdChib2R5X2luaXQpO1xuICAvLyBjb25zb2xlLmxvZyhcImVpbml0c1wiLCBlaW5pdHMsIFwiZXN0bXRzXCIsIGVzdG10cywgXCJlZXhwclwiLCBlZXhwcik7XG4gIHB1c2hTdG10c1RvTGFzdEJsb2NrKGJsb2NrcywgLi4uYnN0bXRzLCB7dGFnOlwiam1wXCIsIGxibDogY29tcFN0YXJ0TGJsfSk7XG5cbiAgLy8gZW5kXG4gIGJsb2Nrcy5wdXNoKHsgIGE6IGUuYSwgbGFiZWw6IGNvbXBFbmRMYmwsIHN0bXRzOiBbXSB9KVxuICBpZiAoZS5jb25kKVxuICAgIHJldHVybiBbWy4uLmNpbml0cywgLi4uYm9keWluaXRzLCAuLi5ib2R5X2luaXQsIC4uLmRpbml0cywgLi4uYmluaXRzXVxuICAgICAgLCBbLi4uY3N0bXRzLCAuLi5kc3RtdHMsIC4uLmJzdG10c11cbiAgICAgICwge1xuICAgICAgICBhOiBlLmEsXG4gICAgICAgIHRhZzogXCJ2YWx1ZVwiLFxuICAgICAgICB2YWx1ZToge1xuICAgICAgICAgIGE6IHsgLi4uZS5hLCB0eXBlOiBOVU0gfSxcbiAgICAgICAgICB0YWc6IFwiaWRcIixcbiAgICAgICAgICBuYW1lOiBlbGVtXG4gICAgICAgIH0sXG4gICAgICB9LFsuLi5jZWNsYXNzLCAuLi5ib2R5Y2xhc3NlcywgLi4uYm9keV9jbGFzcywgLi4uZGVjbGFzcywgLi4uYmVjbGFzc11dXG4gIGVsc2VcbiAgICByZXR1cm4gW1suLi5jaW5pdHMsIC4uLmJvZHlpbml0cywgLi4uYm9keV9pbml0LCAuLi5iaW5pdHNdXG4gICAgICAsIFsuLi5jc3RtdHMsIC4uLmJzdG10c11cbiAgICAgICwge1xuICAgICAgICBhOiBlLmEsXG4gICAgICAgIHRhZzogXCJ2YWx1ZVwiLFxuICAgICAgICB2YWx1ZToge1xuICAgICAgICAgIGE6IHsgLi4uZS5hLCB0eXBlOiBOVU0gfSxcbiAgICAgICAgICB0YWc6IFwiaWRcIixcbiAgICAgICAgICBuYW1lOiBlbGVtXG4gICAgICAgIH0sXG4gICAgICB9LFsuLi5jZWNsYXNzLCAuLi5ib2R5Y2xhc3NlcywgLi4uYm9keV9jbGFzcywgLi4uYmVjbGFzc11dXG59XG5cbmZ1bmN0aW9uIGZsYXR0ZW5TdG10KHMgOiBBU1QuU3RtdDxBbm5vdGF0aW9uPiwgYmxvY2tzOiBBcnJheTxJUi5CYXNpY0Jsb2NrPEFubm90YXRpb24+PiwgZW52IDogR2xvYmFsRW52KSA6IFtBcnJheTxJUi5WYXJJbml0PEFubm90YXRpb24+PiwgQXJyYXk8SVIuQ2xhc3M8QW5ub3RhdGlvbj4+XSB7XG4gIHN3aXRjaChzLnRhZykge1xuICAgIGNhc2UgXCJhc3NpZ25cIjpcbiAgICAgIHZhciBbdmFsaW5pdHMsIHZhbHN0bXRzLCB2YWxlLCBjbGFzc2VzXSA9IGZsYXR0ZW5FeHByVG9FeHByKHMudmFsdWUsIGJsb2NrcywgZW52KTtcbiAgICAgIGJsb2Nrc1tibG9ja3MubGVuZ3RoIC0gMV0uc3RtdHMucHVzaCguLi52YWxzdG10cywgeyBhOiBzLmEsIHRhZzogXCJhc3NpZ25cIiwgbmFtZTogcy5uYW1lLCB2YWx1ZTogdmFsZX0pO1xuICAgICAgcmV0dXJuIFt2YWxpbml0cywgY2xhc3Nlc107XG4gICAgICAvLyByZXR1cm4gW3ZhbGluaXRzLCBbXG4gICAgICAvLyAgIC4uLnZhbHN0bXRzLFxuICAgICAgLy8gICB7IGE6IHMuYSwgdGFnOiBcImFzc2lnblwiLCBuYW1lOiBzLm5hbWUsIHZhbHVlOiB2YWxlfVxuICAgICAgLy8gXV07XG5cbiAgICBjYXNlIFwicmV0dXJuXCI6XG4gICAgICB2YXIgW3ZhbGluaXRzLCB2YWxzdG10cywgdmFsLCBjbGFzc2VzXSA9IGZsYXR0ZW5FeHByVG9WYWwocy52YWx1ZSwgYmxvY2tzLCBlbnYpO1xuICAgICAgYmxvY2tzW2Jsb2Nrcy5sZW5ndGggLSAxXS5zdG10cy5wdXNoKFxuICAgICAgICAgIC4uLnZhbHN0bXRzLFxuICAgICAgICAgIHt0YWc6IFwicmV0dXJuXCIsIGE6IHMuYSwgdmFsdWU6IHZhbH1cbiAgICAgICk7XG4gICAgICByZXR1cm4gW3ZhbGluaXRzLCBjbGFzc2VzXTtcbiAgICAgIC8vIHJldHVybiBbdmFsaW5pdHMsIFtcbiAgICAgIC8vICAgICAuLi52YWxzdG10cyxcbiAgICAgIC8vICAgICB7dGFnOiBcInJldHVyblwiLCBhOiBzLmEsIHZhbHVlOiB2YWx9XG4gICAgICAvLyBdXTtcbiAgXG4gICAgY2FzZSBcImV4cHJcIjpcbiAgICAgIHZhciBbaW5pdHMsIHN0bXRzLCBlLCBjbGFzc2VzXSA9IGZsYXR0ZW5FeHByVG9FeHByKHMuZXhwciwgYmxvY2tzLCBlbnYpO1xuICAgICAgYmxvY2tzW2Jsb2Nrcy5sZW5ndGggLSAxXS5zdG10cy5wdXNoKFxuICAgICAgICAuLi5zdG10cywge3RhZzogXCJleHByXCIsIGE6IHMuYSwgZXhwcjogZSB9XG4gICAgICApO1xuICAgICAgcmV0dXJuIFtpbml0cywgY2xhc3Nlc107XG4gICAgLy8gIHJldHVybiBbaW5pdHMsIFsgLi4uc3RtdHMsIHt0YWc6IFwiZXhwclwiLCBhOiBzLmEsIGV4cHI6IGUgfSBdXTtcblxuICAgIGNhc2UgXCJwYXNzXCI6XG4gICAgICByZXR1cm4gW1tdLCBbXV07XG5cbiAgICBjYXNlIFwiZmllbGQtYXNzaWduXCI6IHtcbiAgICAgIHZhciBbb2luaXRzLCBvc3RtdHMsIG92YWwsIG9jbGFzc2VzXSA9IGZsYXR0ZW5FeHByVG9WYWwocy5vYmosIGJsb2NrcywgZW52KTtcbiAgICAgIHZhciBbbmluaXRzLCBuc3RtdHMsIG52YWwsIG5jbGFzc2VzXSA9IGZsYXR0ZW5FeHByVG9WYWwocy52YWx1ZSwgYmxvY2tzLCBlbnYpO1xuICAgICAgaWYocy5vYmouYS50eXBlLnRhZyAhPT0gXCJjbGFzc1wiKSB7IHRocm93IG5ldyBFcnJvcihcIkNvbXBpbGVyJ3MgY3Vyc2VkLCBnbyBob21lLlwiKTsgfVxuICAgICAgY29uc3QgY2xhc3NkYXRhID0gZW52LmNsYXNzZXMuZ2V0KHMub2JqLmEudHlwZS5uYW1lKTtcbiAgICAgIGNvbnN0IG9mZnNldCA6IElSLlZhbHVlPEFubm90YXRpb24+ID0geyB0YWc6IFwid2FzbWludFwiLCB2YWx1ZTogY2xhc3NkYXRhLmdldChzLmZpZWxkKVswXSB9O1xuICAgICAgcHVzaFN0bXRzVG9MYXN0QmxvY2soYmxvY2tzLFxuICAgICAgICAuLi5vc3RtdHMsIC4uLm5zdG10cywge1xuICAgICAgICAgIHRhZzogXCJzdG9yZVwiLFxuICAgICAgICAgIGE6IHMuYSxcbiAgICAgICAgICBzdGFydDogb3ZhbCxcbiAgICAgICAgICBvZmZzZXQ6IG9mZnNldCxcbiAgICAgICAgICB2YWx1ZTogbnZhbFxuICAgICAgICB9KTtcbiAgICAgIHJldHVybiBbWy4uLm9pbml0cywgLi4ubmluaXRzXSwgb2NsYXNzZXMuY29uY2F0KG5jbGFzc2VzKV07XG4gICAgfVxuICAgICAgLy8gcmV0dXJuIFtbLi4ub2luaXRzLCAuLi5uaW5pdHNdLCBbLi4ub3N0bXRzLCAuLi5uc3RtdHMsIHtcbiAgICAgIC8vICAgdGFnOiBcImZpZWxkLWFzc2lnblwiLFxuICAgICAgLy8gICBhOiBzLmEsXG4gICAgICAvLyAgIG9iajogb3ZhbCxcbiAgICAgIC8vICAgZmllbGQ6IHMuZmllbGQsXG4gICAgICAvLyAgIHZhbHVlOiBudmFsXG4gICAgICAvLyB9XV07XG5cbiAgICBjYXNlIFwiaWZcIjpcbiAgICAgIHZhciB0aGVuTGJsID0gZ2VuZXJhdGVOYW1lKFwiJHRoZW5cIilcbiAgICAgIHZhciBlbHNlTGJsID0gZ2VuZXJhdGVOYW1lKFwiJGVsc2VcIilcbiAgICAgIHZhciBlbmRMYmwgPSBnZW5lcmF0ZU5hbWUoXCIkZW5kXCIpXG4gICAgICB2YXIgZW5kam1wIDogSVIuU3RtdDxBbm5vdGF0aW9uPiA9IHsgdGFnOiBcImptcFwiLCBsYmw6IGVuZExibCB9O1xuICAgICAgdmFyIFtjaW5pdHMsIGNzdG10cywgY2V4cHIsIGNjbGFzc2VzXSA9IGZsYXR0ZW5FeHByVG9WYWwocy5jb25kLCBibG9ja3MsIGVudik7XG4gICAgICB2YXIgY29uZGptcCA6IElSLlN0bXQ8QW5ub3RhdGlvbj4gPSB7IHRhZzogXCJpZmptcFwiLCBjb25kOiBjZXhwciwgdGhuOiB0aGVuTGJsLCBlbHM6IGVsc2VMYmwgfTtcbiAgICAgIHB1c2hTdG10c1RvTGFzdEJsb2NrKGJsb2NrcywgLi4uY3N0bXRzLCBjb25kam1wKTtcbiAgICAgIGJsb2Nrcy5wdXNoKHsgIGE6IHMuYSwgbGFiZWw6IHRoZW5MYmwsIHN0bXRzOiBbXSB9KVxuICAgICAgdmFyIFt0aGVuaW5pdHMsIHRoZW5jbGFzc2VzXSA9IGZsYXR0ZW5TdG10cyhzLnRobiwgYmxvY2tzLCBlbnYpO1xuICAgICAgcHVzaFN0bXRzVG9MYXN0QmxvY2soYmxvY2tzLCBlbmRqbXApO1xuICAgICAgYmxvY2tzLnB1c2goeyAgYTogcy5hLCBsYWJlbDogZWxzZUxibCwgc3RtdHM6IFtdIH0pXG4gICAgICB2YXIgW2Vsc2Vpbml0cywgZWxzZWNsYXNzZXNdID0gZmxhdHRlblN0bXRzKHMuZWxzLCBibG9ja3MsIGVudik7XG4gICAgICBwdXNoU3RtdHNUb0xhc3RCbG9jayhibG9ja3MsIGVuZGptcCk7XG4gICAgICBibG9ja3MucHVzaCh7ICBhOiBzLmEsIGxhYmVsOiBlbmRMYmwsIHN0bXRzOiBbXSB9KVxuICAgICAgcmV0dXJuIFtbLi4uY2luaXRzLCAuLi50aGVuaW5pdHMsIC4uLmVsc2Vpbml0c10sIFsuLi5jY2xhc3NlcywgLi4udGhlbmNsYXNzZXMsIC4uLmVsc2VjbGFzc2VzXV1cblxuICAgICAgLy8gcmV0dXJuIFtbLi4uY2luaXRzLCAuLi50aGVuaW5pdHMsIC4uLmVsc2Vpbml0c10sIFtcbiAgICAgIC8vICAgLi4uY3N0bXRzLCBcbiAgICAgIC8vICAgY29uZGptcCxcbiAgICAgIC8vICAgc3RhcnRsYmwsXG4gICAgICAvLyAgIC4uLnRoZW5zdG10cyxcbiAgICAgIC8vICAgZW5kam1wLFxuICAgICAgLy8gICBlbHNsYmwsXG4gICAgICAvLyAgIC4uLmVsc2VzdG10cyxcbiAgICAgIC8vICAgZW5kam1wLFxuICAgICAgLy8gICBlbmRsYmwsXG4gICAgICAvLyBdXTtcbiAgICBcbiAgICBjYXNlIFwid2hpbGVcIjpcbiAgICAgIHZhciB3aGlsZVN0YXJ0TGJsID0gZ2VuZXJhdGVOYW1lKFwiJHdoaWxlc3RhcnRcIik7XG4gICAgICB2YXIgd2hpbGVib2R5TGJsID0gZ2VuZXJhdGVOYW1lKFwiJHdoaWxlYm9keVwiKTtcbiAgICAgIHZhciB3aGlsZUVuZExibCA9IGdlbmVyYXRlTmFtZShcIiR3aGlsZWVuZFwiKTtcblxuICAgICAgLy9wdXNoaW5nIGxhYmVscyB0byB1dGlsaXplIHRoZW0gZm9yIGNvbnRpbnVlIGFuZCBicmVhayBzdGF0ZW1lbnRzXG4gICAgICBlbnYubGFiZWxzLnB1c2god2hpbGVTdGFydExibCx3aGlsZWJvZHlMYmwsd2hpbGVFbmRMYmwpXG4gICAgICBcbiAgICAgIHB1c2hTdG10c1RvTGFzdEJsb2NrKGJsb2NrcywgeyB0YWc6IFwiam1wXCIsIGxibDogd2hpbGVTdGFydExibCB9KVxuICAgICAgYmxvY2tzLnB1c2goeyAgYTogcy5hLCBsYWJlbDogd2hpbGVTdGFydExibCwgc3RtdHM6IFtdIH0pXG4gICAgICB2YXIgW2Npbml0cywgY3N0bXRzLCBjZXhwciwgY2NsYXNzZXNdID0gZmxhdHRlbkV4cHJUb1ZhbChzLmNvbmQsIGJsb2NrcywgZW52KTtcbiAgICAgIHB1c2hTdG10c1RvTGFzdEJsb2NrKGJsb2NrcywgLi4uY3N0bXRzLCB7IHRhZzogXCJpZmptcFwiLCBjb25kOiBjZXhwciwgdGhuOiB3aGlsZWJvZHlMYmwsIGVsczogd2hpbGVFbmRMYmwgfSk7XG5cbiAgICAgIGJsb2Nrcy5wdXNoKHsgIGE6IHMuYSwgbGFiZWw6IHdoaWxlYm9keUxibCwgc3RtdHM6IFtdIH0pXG4gICAgICB2YXIgW2JvZHlpbml0cywgYm9keWNsYXNzZXNdID0gZmxhdHRlblN0bXRzKHMuYm9keSwgYmxvY2tzLCBlbnYpO1xuICAgICAgcHVzaFN0bXRzVG9MYXN0QmxvY2soYmxvY2tzLCB7IHRhZzogXCJqbXBcIiwgbGJsOiB3aGlsZVN0YXJ0TGJsIH0pO1xuXG4gICAgICBibG9ja3MucHVzaCh7ICBhOiBzLmEsIGxhYmVsOiB3aGlsZUVuZExibCwgc3RtdHM6IFtdIH0pXG5cbiAgICAgIHJldHVybiBbWy4uLmNpbml0cywgLi4uYm9keWluaXRzXSwgWy4uLmNjbGFzc2VzLCAuLi5ib2R5Y2xhc3Nlc11dXG4gICAgY2FzZSBcImNvbnRpbnVlXCI6XG4gICAgICBpZihlbnYubGFiZWxzLmxlbmd0aCA+IDIpXG4gICAgICAgIHB1c2hTdG10c1RvTGFzdEJsb2NrKGJsb2NrcywgeyB0YWc6IFwiam1wXCIsIGxibDogIGVudi5sYWJlbHNbZW52LmxhYmVscy5sZW5ndGgtM119KVxuICAgICAgcmV0dXJuIFtbXSwgW11dXG4gICAgY2FzZSBcImJyZWFrXCI6XG4gICAgICBpZihlbnYubGFiZWxzLmxlbmd0aCA+IDApXG4gICAgICAgIHB1c2hTdG10c1RvTGFzdEJsb2NrKGJsb2NrcywgeyB0YWc6IFwiam1wXCIsIGxibDogIGVudi5sYWJlbHNbZW52LmxhYmVscy5sZW5ndGgtMV19KVxuICAgICAgcmV0dXJuIFtbXSwgW11dXG4gICAgY2FzZSBcImZvclwiOlxuICAgICAgdmFyIGZvclN0YXJ0TGJsID0gZ2VuZXJhdGVOYW1lKFwiJGZvcnN0YXJ0XCIpO1xuICAgICAgdmFyIGZvcmJvZHlMYmwgPSBnZW5lcmF0ZU5hbWUoXCIkZm9yYm9keVwiKTtcbiAgICAgIHZhciBmb3JFbmRMYmwgPSBnZW5lcmF0ZU5hbWUoXCIkZm9yZW5kXCIpO1xuICAgICAgdmFyIGxvY2FsZW52ID0gZW52XG5cbiAgICAgIGxvY2FsZW52LmxhYmVscy5wdXNoKGZvclN0YXJ0TGJsLGZvcmJvZHlMYmwsZm9yRW5kTGJsKVxuICAgICAgLy8gcmVzZXQgdGhlIHZhbHVlcyBjbGFzcyB0byB0aGUgb3JpZ2luYWwgc3RhdGUgYXQgdGhlIHN0YXJ0IG9mIHRoZSBsb29wIC0gbmVzdGVkIGxvb3BzIHVzZSBjYXNlXG4gICAgICB2YXIgcmVzZXRDYWxsIDogQVNULkV4cHI8QVNULkFubm90YXRpb24+ID0gIHt0YWc6XCJtZXRob2QtY2FsbFwiLCBvYmo6cy52YWx1ZXMsIG1ldGhvZDpcInJlc2V0XCIsIGFyZ3VtZW50czpbXSwgYTp7Li4ucy5hLCB0eXBlOiBOT05FfX07XG4gICAgICB2YXIgcmVzZXRTdG10IDogQVNULlN0bXQ8QVNULkFubm90YXRpb24+W10gPSBbeyB0YWc6IFwiZXhwclwiLCBleHByOiByZXNldENhbGwgLCBhOnsgLi4ucy5hLCB0eXBlOiBOT05FIH19XTtcbiAgICAgIGZsYXR0ZW5TdG10cyhyZXNldFN0bXQsIGJsb2NrcywgbG9jYWxlbnYpOyBcbiAgICAgIFxuICAgICAgcHVzaFN0bXRzVG9MYXN0QmxvY2soYmxvY2tzLCB7dGFnOlwiam1wXCIsIGxibDogZm9yU3RhcnRMYmwgfSlcbiAgICAgIGJsb2Nrcy5wdXNoKHsgIGE6IHMuYSwgbGFiZWw6IGZvclN0YXJ0TGJsLCBzdG10czogW10gfSlcbiAgICAgIFxuICAgICAgdmFyIGhhc25leHRDYWxsIDogQVNULkV4cHI8QVNULkFubm90YXRpb24+ID0ge3RhZzpcIm1ldGhvZC1jYWxsXCIsIG9iajpzLnZhbHVlcywgbWV0aG9kOlwiaGFzbmV4dFwiLCBhcmd1bWVudHM6W10sIGE6ey4uLnMuYSwgdHlwZTogQk9PTH19XG4gICAgICB2YXIgbmV4dENhbGwgOiBBU1QuRXhwcjxBU1QuQW5ub3RhdGlvbj4gPSB7dGFnOlwibWV0aG9kLWNhbGxcIiwgb2JqOnMudmFsdWVzLCBtZXRob2Q6XCJuZXh0XCIsIGFyZ3VtZW50czpbXSwgYTogcy5hfVxuICAgICAgXG4gICAgICB2YXIgW2Npbml0cywgY3N0bXRzLCBjZXhwcl0gPSBmbGF0dGVuRXhwclRvVmFsKGhhc25leHRDYWxsLCBibG9ja3MsIGxvY2FsZW52KTsgXG4gICAgICBwdXNoU3RtdHNUb0xhc3RCbG9jayhibG9ja3MsIC4uLmNzdG10cywgeyB0YWc6IFwiaWZqbXBcIiwgY29uZDogY2V4cHIsIHRobjogZm9yYm9keUxibCwgZWxzOiBmb3JFbmRMYmwgfSk7XG4gICAgXG4gICAgICBibG9ja3MucHVzaCh7ICBhOiBzLmEsIGxhYmVsOiBmb3Jib2R5TGJsLCBzdG10czogW10gfSlcbiAgICAgIHZhciBuZXh0QXNzaWduIDogQVNULlN0bXQ8QVNULkFubm90YXRpb24+W10gPSBbe3RhZzpcImFzc2lnblwiLG5hbWU6cy5pdGVyYXRvciwgdmFsdWU6IG5leHRDYWxsLGE6cy5hIH1dXG4gICAgICBcbiAgICAgIGZsYXR0ZW5TdG10cyhuZXh0QXNzaWduLCBibG9ja3MsIGxvY2FsZW52KTsgLy8gdG8gYWRkIHdhc20gY29kZSBmb3IgaSA9IGMubmV4dCgpLiBoYXMgbm8gaW5pdHMgXG4gICAgICBcbiAgICAgIHZhciBbYm9keWluaXRzLCBib2R5Y2xhc3Nlc10gPSBmbGF0dGVuU3RtdHMocy5ib2R5LCBibG9ja3MsIGxvY2FsZW52KVxuICAgICAgcHVzaFN0bXRzVG9MYXN0QmxvY2soYmxvY2tzLCB7IHRhZzogXCJqbXBcIiwgbGJsOiBmb3JTdGFydExibCB9KTtcbiAgICBcbiAgICAgIGJsb2Nrcy5wdXNoKHsgIGE6IHMuYSwgbGFiZWw6IGZvckVuZExibCwgc3RtdHM6IFtdIH0pXG4gICAgXG4gICAgICByZXR1cm4gW1suLi5jaW5pdHMsIC4uLmJvZHlpbml0c10sIFsuLi5ib2R5Y2xhc3Nlc11dO1xuICB9XG59XG5cbmZ1bmN0aW9uIGZsYXR0ZW5FeHByVG9FeHByKGUgOiBBU1QuRXhwcjxBbm5vdGF0aW9uPiwgYmxvY2tzOiBBcnJheTxJUi5CYXNpY0Jsb2NrPEFubm90YXRpb24+PiwgZW52IDogR2xvYmFsRW52KSA6IFtBcnJheTxJUi5WYXJJbml0PEFubm90YXRpb24+PiwgQXJyYXk8SVIuU3RtdDxBbm5vdGF0aW9uPj4sIElSLkV4cHI8QW5ub3RhdGlvbj4sIEFycmF5PElSLkNsYXNzPEFubm90YXRpb24+Pl0ge1xuICBzd2l0Y2goZS50YWcpIHtcbiAgICBjYXNlIFwidW5pb3BcIjpcbiAgICAgIHZhciBbaW5pdHMsIHN0bXRzLCB2YWwsIGNsYXNzZXNdID0gZmxhdHRlbkV4cHJUb1ZhbChlLmV4cHIsIGJsb2NrcywgZW52KTtcbiAgICAgIHJldHVybiBbaW5pdHMsIHN0bXRzLCB7XG4gICAgICAgIC4uLmUsXG4gICAgICAgIGV4cHI6IHZhbFxuICAgICAgfSwgY2xhc3Nlc107XG4gICAgY2FzZSBcImJpbm9wXCI6XG4gICAgICB2YXIgW2xpbml0cywgbHN0bXRzLCBsdmFsLCBsY2xhc3Nlc10gPSBmbGF0dGVuRXhwclRvVmFsKGUubGVmdCwgYmxvY2tzLCBlbnYpO1xuICAgICAgdmFyIFtyaW5pdHMsIHJzdG10cywgcnZhbCwgcmNsYXNzZXNdID0gZmxhdHRlbkV4cHJUb1ZhbChlLnJpZ2h0LCBibG9ja3MsIGVudik7XG4gICAgICB2YXIgY2hlY2tEZW5vbSA6IEFycmF5PElSLlN0bXQ8QW5ub3RhdGlvbj4+ID0gW107XG4gICAgICBpZiAoZS5vcCA9PSBBU1QuQmluT3AuSURpdiB8fCBlLm9wID09IEFTVC5CaW5PcC5Nb2QpIHsgLy8gY2hlY2sgZGl2aXNpb24gYnkgemVyb1xuICAgICAgICBjaGVja0Rlbm9tLnB1c2goRVJST1JTLmZsYXR0ZW5EaXZpZGVCeVplcm8oZS5hLCBydmFsKSk7XG4gICAgICB9XG4gICAgICByZXR1cm4gW1suLi5saW5pdHMsIC4uLnJpbml0c10sIFsuLi5sc3RtdHMsIC4uLnJzdG10cywgLi4uY2hlY2tEZW5vbV0sIHtcbiAgICAgICAgICAuLi5lLFxuICAgICAgICAgIGxlZnQ6IGx2YWwsXG4gICAgICAgICAgcmlnaHQ6IHJ2YWxcbiAgICAgICAgfSwgWy4uLmxjbGFzc2VzLCAuLi5yY2xhc3Nlc11dO1xuICAgIGNhc2UgXCJidWlsdGluMVwiOlxuICAgICAgdmFyIFtpbml0cywgc3RtdHMsIHZhbCwgY2xhc3Nlc10gPSBmbGF0dGVuRXhwclRvVmFsKGUuYXJnLCBibG9ja3MsIGVudik7XG4gICAgICByZXR1cm4gW2luaXRzLCBzdG10cywge3RhZzogXCJidWlsdGluMVwiLCBhOiBlLmEsIG5hbWU6IGUubmFtZSwgYXJnOiB2YWx9LCBjbGFzc2VzXTtcbiAgICBjYXNlIFwiYnVpbHRpbjJcIjpcbiAgICAgIHZhciBbbGluaXRzLCBsc3RtdHMsIGx2YWwsIGxjbGFzc2VzXSA9IGZsYXR0ZW5FeHByVG9WYWwoZS5sZWZ0LCBibG9ja3MsIGVudik7XG4gICAgICB2YXIgW3Jpbml0cywgcnN0bXRzLCBydmFsLCByY2xhc3Nlc10gPSBmbGF0dGVuRXhwclRvVmFsKGUucmlnaHQsIGJsb2NrcywgZW52KTtcbiAgICAgIHJldHVybiBbWy4uLmxpbml0cywgLi4ucmluaXRzXSwgWy4uLmxzdG10cywgLi4ucnN0bXRzXSwge1xuICAgICAgICAgIC4uLmUsXG4gICAgICAgICAgbGVmdDogbHZhbCxcbiAgICAgICAgICByaWdodDogcnZhbFxuICAgICAgICB9LCBbLi4ubGNsYXNzZXMsIC4uLnJjbGFzc2VzXV07XG4gICAgY2FzZSBcImNhbGxcIjpcbiAgICAgIGNvbnN0IFtmaW5pdHMsIGZzdG10cywgZnZhbCwgZmNsYXNzZXNdID0gZmxhdHRlbkV4cHJUb1ZhbChlLmZuLCBibG9ja3MsIGVudik7XG4gICAgICBjb25zdCBjYWxscGFpcnMgPSBlLmFyZ3VtZW50cy5tYXAoYSA9PiBmbGF0dGVuRXhwclRvVmFsKGEsIGJsb2NrcywgZW52KSk7XG4gICAgICBjb25zdCBjYWxsaW5pdHMgPSBjYWxscGFpcnMubWFwKGNwID0+IGNwWzBdKS5mbGF0KCk7XG4gICAgICBjb25zdCBjYWxsc3RtdHMgPSBjYWxscGFpcnMubWFwKGNwID0+IGNwWzFdKS5mbGF0KCk7XG4gICAgICBjb25zdCBjYWxsdmFscyA9IGNhbGxwYWlycy5tYXAoY3AgPT4gY3BbMl0pLmZsYXQoKTtcbiAgICAgIGNvbnN0IGNhbGxjbGFzc2VzID0gY2FsbHBhaXJzLm1hcChjcCA9PiBjcFszXSkuZmxhdCgpO1xuICAgICAgY29uc3QgY2hlY2tPYmo6IElSLlN0bXQ8QW5ub3RhdGlvbj4gPSBFUlJPUlMuZmxhdHRlbkFzc2VydE5vdE5vbmUoZS5hLCBmdmFsKTtcbiAgICAgIGNvbnN0IHplcm9PZmZzZXQ6IElSLlZhbHVlPEFubm90YXRpb24+ID0geyB0YWc6IFwid2FzbWludFwiLCB2YWx1ZTogMCB9O1xuICAgICAgcmV0dXJuIFtcbiAgICAgICAgWy4uLmZpbml0cywgLi4uY2FsbGluaXRzXSxcbiAgICAgICAgWy4uLmZzdG10cywgY2hlY2tPYmosIC4uLmNhbGxzdG10c10sXG4gICAgICAgIHtcbiAgICAgICAgICAuLi5lLFxuICAgICAgICAgIHRhZzogXCJjYWxsX2luZGlyZWN0XCIsXG4gICAgICAgICAgZm46IHsgdGFnOiBcImxvYWRcIiwgc3RhcnQ6IGZ2YWwsIG9mZnNldDogemVyb09mZnNldCB9LFxuICAgICAgICAgIGFyZ3VtZW50czogW2Z2YWwsIC4uLmNhbGx2YWxzXVxuICAgICAgICB9LFxuICAgICAgICBbLi4uZmNsYXNzZXMsIC4uLmNhbGxjbGFzc2VzXVxuICAgICAgXTtcbiAgICBjYXNlIFwibWV0aG9kLWNhbGxcIjoge1xuICAgICAgY29uc3QgW29iamluaXRzLCBvYmpzdG10cywgb2JqdmFsLCBvYmpjbGFzc2VzXSA9IGZsYXR0ZW5FeHByVG9WYWwoZS5vYmosIGJsb2NrcywgZW52KTtcbiAgICAgIGNvbnN0IGFyZ3BhaXJzID0gZS5hcmd1bWVudHMubWFwKGEgPT4gZmxhdHRlbkV4cHJUb1ZhbChhLCBibG9ja3MsIGVudikpO1xuICAgICAgY29uc3QgYXJnaW5pdHMgPSBhcmdwYWlycy5tYXAoY3AgPT4gY3BbMF0pLmZsYXQoKTtcbiAgICAgIGNvbnN0IGFyZ3N0bXRzID0gYXJncGFpcnMubWFwKGNwID0+IGNwWzFdKS5mbGF0KCk7XG4gICAgICBjb25zdCBhcmd2YWxzID0gYXJncGFpcnMubWFwKGNwID0+IGNwWzJdKS5mbGF0KCk7XG4gICAgICBjb25zdCBhcmdjbGFzc2VzID0gYXJncGFpcnMubWFwKGNwID0+IGNwWzNdKS5mbGF0KCk7XG4gICAgICB2YXIgb2JqVHlwID0gZS5vYmouYTtcbiAgICAgIGlmKG9ialR5cC50eXBlLnRhZyAhPT0gXCJjbGFzc1wiKSB7IC8vIEkgZG9uJ3QgdGhpbmsgdGhpcyBlcnJvciBjYW4gaGFwcGVuXG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcIlJlcG9ydCB0aGlzIGFzIGEgYnVnIHRvIHRoZSBjb21waWxlciBkZXZlbG9wZXIsIHRoaXMgc2hvdWxkbid0IGhhcHBlbiBcIiArIG9ialR5cC50eXBlLnRhZyk7XG4gICAgICB9XG4gICAgICBjb25zdCBjbGFzc05hbWUgPSBvYmpUeXAudHlwZS5uYW1lO1xuICAgICAgY29uc3QgY2hlY2tPYmogOiBJUi5TdG10PEFubm90YXRpb24+ID0gRVJST1JTLmZsYXR0ZW5Bc3NlcnROb3ROb25lKGUuYSwgb2JqdmFsKTtcbiAgICAgIGNvbnN0IGNhbGxNZXRob2QgOiBJUi5FeHByPEFubm90YXRpb24+ID0geyB0YWc6IFwiY2FsbFwiLCBuYW1lOiBgJHtjbGFzc05hbWV9JCR7ZS5tZXRob2R9YCwgYXJndW1lbnRzOiBbb2JqdmFsLCAuLi5hcmd2YWxzXSB9XG4gICAgICByZXR1cm4gW1xuICAgICAgICBbLi4ub2JqaW5pdHMsIC4uLmFyZ2luaXRzXSxcbiAgICAgICAgWy4uLm9ianN0bXRzLCBjaGVja09iaiwgLi4uYXJnc3RtdHNdLFxuICAgICAgICBjYWxsTWV0aG9kLFxuICAgICAgICBbLi4ub2JqY2xhc3NlcywgLi4uYXJnY2xhc3Nlc11cbiAgICAgIF07XG4gICAgfVxuICAgIGNhc2UgXCJsb29rdXBcIjoge1xuICAgICAgY29uc3QgW29pbml0cywgb3N0bXRzLCBvdmFsLCBvY2xhc3Nlc10gPSBmbGF0dGVuRXhwclRvVmFsKGUub2JqLCBibG9ja3MsIGVudik7XG4gICAgICBpZihlLm9iai5hLnR5cGUudGFnICE9PSBcImNsYXNzXCIpIHsgdGhyb3cgbmV3IEVycm9yKFwiQ29tcGlsZXIncyBjdXJzZWQsIGdvIGhvbWVcIik7IH1cbiAgICAgIGNvbnN0IGNsYXNzZGF0YSA9IGVudi5jbGFzc2VzLmdldChlLm9iai5hLnR5cGUubmFtZSk7XG4gICAgICBjb25zdCBbb2Zmc2V0LCBfXSA9IGNsYXNzZGF0YS5nZXQoZS5maWVsZCk7XG4gICAgICBjb25zdCBjaGVja09iaiA6IElSLlN0bXQ8QW5ub3RhdGlvbj4gPSBFUlJPUlMuZmxhdHRlbkFzc2VydE5vdE5vbmUoZS5hLCBvdmFsKTtcbiAgICAgIHJldHVybiBbb2luaXRzLCBbLi4ub3N0bXRzLCBjaGVja09ial0sIHtcbiAgICAgICAgdGFnOiBcImxvYWRcIixcbiAgICAgICAgc3RhcnQ6IG92YWwsXG4gICAgICAgIG9mZnNldDogeyB0YWc6IFwid2FzbWludFwiLCB2YWx1ZTogb2Zmc2V0IH19LCBvY2xhc3Nlc107XG4gICAgfVxuXG4gICAgY2FzZSBcImNvbnN0cnVjdFwiOlxuICAgICAgY29uc3QgY2xhc3NkYXRhID0gZW52LmNsYXNzZXMuZ2V0KGUubmFtZSk7XG4gICAgICBjb25zdCBmaWVsZHMgPSBbLi4uY2xhc3NkYXRhLmVudHJpZXMoKV07XG4gICAgICBjb25zdCBuZXdOYW1lID0gZ2VuZXJhdGVOYW1lKFwibmV3T2JqXCIpO1xuICAgICAgY29uc3QgYWxsb2MgOiBJUi5FeHByPEFubm90YXRpb24+ID0geyB0YWc6IFwiYWxsb2NcIiwgYW1vdW50OiB7IHRhZzogXCJ3YXNtaW50XCIsIHZhbHVlOiBmaWVsZHMubGVuZ3RoICsgMX0gfTtcbiAgICAgIGNvbnN0IGFzc2lnbnMgOiBJUi5TdG10PEFubm90YXRpb24+W10gPSBmaWVsZHMubWFwKGYgPT4ge1xuICAgICAgICBjb25zdCBbXywgW2luZGV4LCB2YWx1ZV1dID0gZjtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICB0YWc6IFwic3RvcmVcIixcbiAgICAgICAgICBzdGFydDogeyB0YWc6IFwiaWRcIiwgbmFtZTogbmV3TmFtZSB9LFxuICAgICAgICAgIG9mZnNldDogeyB0YWc6IFwid2FzbWludFwiLCB2YWx1ZTogaW5kZXggfSxcbiAgICAgICAgICB2YWx1ZTogdmFsdWVcbiAgICAgICAgfVxuICAgICAgfSk7XG5cbiAgICAgIHJldHVybiBbXG4gICAgICAgIFsgeyBuYW1lOiBuZXdOYW1lLCB0eXBlOiBlLmEudHlwZSwgdmFsdWU6IHsgdGFnOiBcIm5vbmVcIiB9IH1dLFxuICAgICAgICBbIHsgdGFnOiBcImFzc2lnblwiLCBuYW1lOiBuZXdOYW1lLCB2YWx1ZTogYWxsb2MgfSwgeyAvLyBzdG9yZSBjbGFzcyBvZmZzZXRcbiAgICAgICAgICAgIHRhZzogXCJzdG9yZVwiLFxuICAgICAgICAgICAgc3RhcnQ6IHsgdGFnOiBcImlkXCIsIG5hbWU6IG5ld05hbWUgfSxcbiAgICAgICAgICAgIG9mZnNldDogeyB0YWc6IFwid2FzbWludFwiLCB2YWx1ZTogMCB9LFxuICAgICAgICAgICAgdmFsdWU6IHsgdGFnOiBcIndhc21pbnRcIiwgdmFsdWU6IGVudi5jbGFzc0luZGljZXMuZ2V0KGUubmFtZSkgfVxuICAgICAgICAgIH0sIC4uLmFzc2lnbnMsXG4gICAgICAgICAgeyB0YWc6IFwiZXhwclwiLCBleHByOiB7IHRhZzogXCJjYWxsXCIsIG5hbWU6IGAke2UubmFtZX0kX19pbml0X19gLCBhcmd1bWVudHM6IFt7IGE6IGUuYSwgdGFnOiBcImlkXCIsIG5hbWU6IG5ld05hbWUgfV0gfSB9XG4gICAgICAgIF0sXG4gICAgICAgIHsgYTogZS5hLCB0YWc6IFwidmFsdWVcIiwgdmFsdWU6IHsgYTogZS5hLCB0YWc6IFwiaWRcIiwgbmFtZTogbmV3TmFtZSB9IH0sXG4gICAgICAgIFtdXG4gICAgICBdO1xuICAgIGNhc2UgXCJsaXN0LWNvbXBcIjpcbiAgICAgIHJldHVybiBmbGF0dGVuTGlzdENvbXAoZSwgZW52LCBibG9ja3MpO1xuICAgIGNhc2UgXCJpZFwiOlxuICAgICAgcmV0dXJuIFtbXSwgW10sIHt0YWc6IFwidmFsdWVcIiwgdmFsdWU6IHsgLi4uZSB9fSwgW11dO1xuICAgIGNhc2UgXCJsaXRlcmFsXCI6XG4gICAgICByZXR1cm4gW1tdLCBbXSwge3RhZzogXCJ2YWx1ZVwiLCB2YWx1ZTogbGl0ZXJhbFRvVmFsKGUudmFsdWUpIH0sIFtdIF07XG4gICAgY2FzZSBcImlmLWV4cHJcIjoge1xuICAgICAgdmFyIHRoZW5MYmwgPSBnZW5lcmF0ZU5hbWUoXCIkaWZFeHByVGhlblwiKTtcbiAgICAgIHZhciBlbHNlTGJsID0gZ2VuZXJhdGVOYW1lKFwiJGlmRXhwckVsc2VcIik7XG4gICAgICB2YXIgZW5kTGJsID0gZ2VuZXJhdGVOYW1lKFwiJGlmRXhwckVuZFwiKTtcbiAgICAgIHZhciBpZkV4cHJUbXBWYWwgPSBnZW5lcmF0ZU5hbWUoXCIkaWZFeHByVG1wXCIpO1xuXG4gICAgICB2YXIgZW5kam1wIDogSVIuU3RtdDxBbm5vdGF0aW9uPiA9IHsgdGFnOiBcImptcFwiLCBsYmw6IGVuZExibCB9O1xuICAgICAgbGV0IFtjaW5pdHMsIGNzdG10cywgY2V4cHIsIGNjbGFzc2VzXSA9IGZsYXR0ZW5FeHByVG9WYWwoZS5jb25kLCBibG9ja3MsIGVudik7XG4gICAgICB2YXIgY29uZGptcCA6IElSLlN0bXQ8QW5ub3RhdGlvbj4gPSB7IHRhZzogXCJpZmptcFwiLCBjb25kOiBjZXhwciwgdGhuOiB0aGVuTGJsLCBlbHM6IGVsc2VMYmwgfTtcblxuICAgICAgcHVzaFN0bXRzVG9MYXN0QmxvY2soYmxvY2tzLCAuLi5jc3RtdHMsIGNvbmRqbXApO1xuXG4gICAgICBibG9ja3MucHVzaCh7IGE6IGUuYSwgbGFiZWw6IHRoZW5MYmwsIHN0bXRzOiBbXSB9KTtcbiAgICAgIHZhciBbdGhuaW5pdHMsIHRobnN0bXRzLCB0aG5leHByLCB0aG5jbGFzc2VzXSA9IGZsYXR0ZW5FeHByVG9FeHByKGUudGhuLCBibG9ja3MsIGVudik7XG4gICAgICBwdXNoU3RtdHNUb0xhc3RCbG9jayhibG9ja3MsIC4uLnRobnN0bXRzLCB7IGE6IGUuYSwgdGFnOiBcImFzc2lnblwiLCBuYW1lOiBpZkV4cHJUbXBWYWwsIHZhbHVlOiB0aG5leHByfSwgZW5kam1wKTtcblxuICAgICAgYmxvY2tzLnB1c2goeyBhOiBlLmEsIGxhYmVsOiBlbHNlTGJsLCBzdG10czogW10gfSk7XG4gICAgICB2YXIgW2Vsc2luaXRzLCBlbHNzdG10cywgZWxzZXhwciwgZWxzZWNsYXNzZXNdID0gZmxhdHRlbkV4cHJUb0V4cHIoZS5lbHMsIGJsb2NrcywgZW52KTtcbiAgICAgIHB1c2hTdG10c1RvTGFzdEJsb2NrKGJsb2NrcywuLi5lbHNzdG10cywgeyBhOiBlLmEsIHRhZzogXCJhc3NpZ25cIiwgbmFtZTogaWZFeHByVG1wVmFsLCB2YWx1ZTogZWxzZXhwcn0sIGVuZGptcCk7XG5cbiAgICAgIGJsb2Nrcy5wdXNoKHsgYTogZS5hLCBsYWJlbDogZW5kTGJsLCBzdG10czogW10gfSk7XG4gICAgICB2YXIgdmFyRGVmRm9yVG1wOiBJUi5WYXJJbml0PEFubm90YXRpb24+ID0geyBhOiBlLmEsIG5hbWU6IGlmRXhwclRtcFZhbCwgdHlwZTogZS5hLnR5cGUsIHZhbHVlOiB7IGE6IHsgdHlwZTogeyB0YWc6IFwibm9uZVwifSB9LCB0YWc6IFwibm9uZVwiIH0gfTtcblxuICAgICAgcmV0dXJuIFtcbiAgICAgICAgWy4uLmNpbml0cywgLi4uZWxzaW5pdHMsIC4uLnRobmluaXRzLCB2YXJEZWZGb3JUbXBdLFxuICAgICAgICBbXSxcbiAgICAgICAgeyBhOiBlLmEsIHRhZzpcInZhbHVlXCIsIHZhbHVlOiB7IGE6IGUuYSwgdGFnOiBcImlkXCIsIG5hbWU6IGlmRXhwclRtcFZhbCB9IH0sXG4gICAgICAgIFsuLi5jY2xhc3NlcywgLi4udGhuY2xhc3NlcywgLi4uZWxzZWNsYXNzZXNdXG4gICAgICBdO1xuICAgIH1cbiAgICBjYXNlIFwibGFtYmRhXCI6XG4gICAgICB2YXIgW2NsYXNzRGVmLCBjb25zdHJFeHByXSA9IGxhbWJkYVRvQ2xhc3MoZSk7XG5cbiAgICAgIGNvbnN0IGNsYXNzRmllbGRzID0gbmV3IE1hcCgpO1xuICAgICAgY2xhc3NEZWYuZmllbGRzLmZvckVhY2goKGZpZWxkLCBpKSA9PiBjbGFzc0ZpZWxkcy5zZXQoZmllbGQubmFtZSwgW2ksIGZpZWxkLnZhbHVlXSkpO1xuICAgICAgZW52LmNsYXNzZXMuc2V0KGNsYXNzRGVmLm5hbWUsIGNsYXNzRmllbGRzKTtcbiAgICAgIGVudi5jbGFzc0luZGljZXMuc2V0KGNsYXNzRGVmLm5hbWUsIGVudi52dGFibGVNZXRob2RzLmxlbmd0aCk7XG4gICAgICBlbnYudnRhYmxlTWV0aG9kcy5wdXNoKC4uLmNsYXNzRGVmLm1ldGhvZHNcbiAgICAgICAgLmZpbHRlcihtZXRob2QgPT4gIW1ldGhvZC5uYW1lLmluY2x1ZGVzKFwiX19pbml0X19cIikpXG4gICAgICAgIC5tYXAoKG1ldGhvZCk6IFtzdHJpbmcsIG51bWJlcl0gPT4gW1xuICAgICAgICAgIGNyZWF0ZU1ldGhvZE5hbWUoY2xhc3NEZWYubmFtZSwgbWV0aG9kLm5hbWUpLCBtZXRob2QucGFyYW1ldGVycy5sZW5ndGhcbiAgICAgICAgXSlcbiAgICAgICk7XG4gICAgICBjb25zdCBpckNsYXNzID0gbG93ZXJDbGFzcyhjbGFzc0RlZiwgZW52KTtcbiAgICAgIGlyQ2xhc3NbMF0uYSA9IGUuYTtcblxuICAgICAgY29uc3QgW2Npbml0cywgY3N0bXRzLCBjdmFsLCBjY2xhc3Nlc10gPSBmbGF0dGVuRXhwclRvRXhwcihjb25zdHJFeHByLCBibG9ja3MsIGVudik7XG4gICAgICByZXR1cm4gW2Npbml0cywgY3N0bXRzLCBjdmFsLCBbLi4uaXJDbGFzcywgLi4uY2NsYXNzZXNdXTtcbiAgfVxufVxuXG5mdW5jdGlvbiBsYW1iZGFUb0NsYXNzKGxhbWJkYTogQVNULkxhbWJkYTxBbm5vdGF0aW9uPikgOiBbQVNULkNsYXNzPEFubm90YXRpb24+LCBBU1QuRXhwcjxBbm5vdGF0aW9uPl0ge1xuICB2YXIgbGFtYmRhQ2xhc3NOYW1lID0gZ2VuZXJhdGVOYW1lKFwibGFtYmRhXCIpO1xuICB2YXIgcGFyYW1zID0gbGFtYmRhLnBhcmFtcy5tYXAoKHBhcmFtLCBpKSA9PiAoe1xuICAgIG5hbWU6IHBhcmFtLCBcbiAgICB0eXBlOiBsYW1iZGEudHlwZS5wYXJhbXNbaV1cbiAgfSkpO1xuICByZXR1cm4gW1xuICAgIHtcbiAgICAgIG5hbWU6IGxhbWJkYUNsYXNzTmFtZSxcbiAgICAgIGZpZWxkczogW10sXG4gICAgICBtZXRob2RzOiBbXG4gICAgICAgIHsgXG4gICAgICAgICAgbmFtZTogXCJfX2luaXRfX1wiLCBcbiAgICAgICAgICBwYXJhbWV0ZXJzOiBbeyBuYW1lOiBcInNlbGZcIiwgdHlwZTogQ0xBU1MobGFtYmRhQ2xhc3NOYW1lKSB9XSwgXG4gICAgICAgICAgcmV0OiBOT05FLCBcbiAgICAgICAgICBpbml0czogW10sIFxuICAgICAgICAgIGJvZHk6IFtdLFxuICAgICAgICAgIG5vbmxvY2FsczogW10sXG4gICAgICAgICAgY2hpbGRyZW46IFtdXG4gICAgICAgIH0sXG4gICAgICAgIHsgXG4gICAgICAgICAgbmFtZTogQVBQTFksIFxuICAgICAgICAgIHBhcmFtZXRlcnM6IFt7IG5hbWU6IFwic2VsZlwiLCB0eXBlOiBDTEFTUyhsYW1iZGFDbGFzc05hbWUpIH0sIC4uLnBhcmFtc10sIFxuICAgICAgICAgIHJldDogbGFtYmRhLnR5cGUucmV0LCBcbiAgICAgICAgICBpbml0czogW10sIFxuICAgICAgICAgIGJvZHk6IFt7IGE6IHsgdHlwZTogbGFtYmRhLnR5cGUucmV0IH0sIHRhZzogXCJyZXR1cm5cIiwgdmFsdWU6IGxhbWJkYS5leHByIH1dLFxuICAgICAgICAgIG5vbmxvY2FsczogW10sXG4gICAgICAgICAgY2hpbGRyZW46IFtdXG4gICAgICAgIH1cbiAgICAgIF0sXG4gICAgICB0eXBlUGFyYW1zOiBbXSxcbiAgICB9LFxuICAgIHsgYTogbGFtYmRhLmEsIHRhZzogXCJjb25zdHJ1Y3RcIiwgbmFtZTogbGFtYmRhQ2xhc3NOYW1lIH1cbiAgXTtcbn1cblxuZnVuY3Rpb24gZmxhdHRlbkV4cHJUb1ZhbChlIDogQVNULkV4cHI8QW5ub3RhdGlvbj4sIGJsb2NrczogQXJyYXk8SVIuQmFzaWNCbG9jazxBbm5vdGF0aW9uPj4sIGVudiA6IEdsb2JhbEVudikgOiBbQXJyYXk8SVIuVmFySW5pdDxBbm5vdGF0aW9uPj4sIEFycmF5PElSLlN0bXQ8QW5ub3RhdGlvbj4+LCBJUi5WYWx1ZTxBbm5vdGF0aW9uPiwgQXJyYXk8SVIuQ2xhc3M8QW5ub3RhdGlvbj4+XSB7XG4gIHZhciBbYmluaXRzLCBic3RtdHMsIGJleHByLCBiY2xhc3Nlc10gPSBmbGF0dGVuRXhwclRvRXhwcihlLCBibG9ja3MsIGVudik7XG4gIGlmKGJleHByLnRhZyA9PT0gXCJ2YWx1ZVwiKSB7XG4gICAgcmV0dXJuIFtiaW5pdHMsIGJzdG10cywgYmV4cHIudmFsdWUsIGJjbGFzc2VzXTtcbiAgfVxuICBlbHNlIHtcbiAgICB2YXIgbmV3TmFtZSA9IGdlbmVyYXRlTmFtZShcInZhbG5hbWVcIik7XG4gICAgdmFyIHNldE5ld05hbWUgOiBJUi5TdG10PEFubm90YXRpb24+ID0ge1xuICAgICAgdGFnOiBcImFzc2lnblwiLFxuICAgICAgYTogZS5hLFxuICAgICAgbmFtZTogbmV3TmFtZSxcbiAgICAgIHZhbHVlOiBiZXhwciBcbiAgICB9O1xuICAgIC8vIFRPRE86IHdlIGhhdmUgdG8gYWRkIGEgbmV3IHZhciBpbml0IGZvciB0aGUgbmV3IHZhcmlhYmxlIHdlJ3JlIGNyZWF0aW5nIGhlcmUuXG4gICAgLy8gYnV0IHdoYXQgc2hvdWxkIHRoZSBkZWZhdWx0IHZhbHVlIGJlP1xuICAgIHJldHVybiBbXG4gICAgICBbLi4uYmluaXRzLCB7IGE6IGUuYSwgbmFtZTogbmV3TmFtZSwgdHlwZTogZS5hLnR5cGUsIHZhbHVlOiB7IHRhZzogXCJub25lXCIgfSB9XSxcbiAgICAgIFsuLi5ic3RtdHMsIHNldE5ld05hbWVdLCAgXG4gICAgICB7dGFnOiBcImlkXCIsIG5hbWU6IG5ld05hbWUsIGE6IGUuYX0sXG4gICAgICBiY2xhc3Nlc1xuICAgIF07XG4gIH1cbn1cblxuZnVuY3Rpb24gcHVzaFN0bXRzVG9MYXN0QmxvY2soYmxvY2tzOiBBcnJheTxJUi5CYXNpY0Jsb2NrPEFubm90YXRpb24+PiwgLi4uc3RtdHM6IEFycmF5PElSLlN0bXQ8QW5ub3RhdGlvbj4+KSB7XG4gIGJsb2Nrc1tibG9ja3MubGVuZ3RoIC0gMV0uc3RtdHMucHVzaCguLi5zdG10cyk7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBmbGF0dGVuV2FzbUludCh2YWw6IG51bWJlcik6IElSLlZhbHVlPEFubm90YXRpb24+e1xuICByZXR1cm4geyB0YWc6IFwid2FzbWludFwiLCB2YWx1ZTogdmFsIH1cbn0iLCJpbXBvcnQgeyBBbm5vdGF0aW9uLCBDbGFzcywgRXhwciwgTGl0ZXJhbCwgUGFyYW1ldGVyLCBQcm9ncmFtLCBTdG10LCBUeXBlLCBWYXJJbml0IH0gZnJvbSAnLi9hc3QnO1xuaW1wb3J0IHsgQk9PTCwgQ0xBU1MsIE5PTkUsIE5VTSB9IGZyb20gJy4vdXRpbHMnO1xuXG5leHBvcnQgdHlwZSBHbG9iYWxNb3JwaEVudiA9IHtcbiAgICBjbGFzc2VzSW54OiBNYXA8c3RyaW5nLCBudW1iZXI+LFxuICAgIHR5cGVWYXJzOiBNYXA8c3RyaW5nLCBUeXBlPixcbiAgICBtb3JwaGVkQ2xhc3NlczogU2V0PHN0cmluZz5cbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGNvbmNyZXRpemVHZW5lcmljVHlwZXModHlwZTogVHlwZSwgZ2VudjogR2xvYmFsTW9ycGhFbnYpIDogVHlwZSB7XG4gICAgc3dpdGNoKHR5cGUudGFnKSB7XG4gICAgICAgIGNhc2UgXCJ0eXBldmFyXCI6XG4gICAgICAgICAgICByZXR1cm4gZ2Vudi50eXBlVmFycy5nZXQodHlwZS5uYW1lKTtcbiAgICAgICAgY2FzZSBcImNsYXNzXCI6XG4gICAgICAgICAgICBjb25zdCBjcGFyYW1zID0gdHlwZS5wYXJhbXMubWFwKHAgPT4gY29uY3JldGl6ZUdlbmVyaWNUeXBlcyhwLCBnZW52KSk7XG4gICAgICAgICAgICByZXR1cm4gey4uLnR5cGUsIHBhcmFtczogY3BhcmFtc307XG4gICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICByZXR1cm4gdHlwZTtcbiAgICB9XG59XG5cbmV4cG9ydCBmdW5jdGlvbiByZXNvbHZlWmVybyh0eXBlOiBUeXBlLCBhOiBBbm5vdGF0aW9uKSA6IExpdGVyYWw8QW5ub3RhdGlvbj4ge1xuICAgIHN3aXRjaCAodHlwZS50YWcpIHtcbiAgICAgICAgY2FzZSBcIm51bWJlclwiOlxuICAgICAgICAgICAgcmV0dXJuIHsgYTogeyAuLi5hLCB0eXBlOiBOVU19LCB0YWc6IFwibnVtXCIsIHZhbHVlOiAwIH07XG4gICAgICAgIGNhc2UgXCJib29sXCI6XG4gICAgICAgICAgICByZXR1cm4geyBhOiB7IC4uLmEsIHR5cGU6IEJPT0x9LCB0YWc6IFwiYm9vbFwiLCB2YWx1ZTogZmFsc2UgfTtcbiAgICAgICAgY2FzZSBcImNsYXNzXCI6XG4gICAgICAgICAgICByZXR1cm4geyBhOiB7IC4uLmEsIHR5cGU6IE5PTkV9LCB0YWc6IFwibm9uZVwiIH07XG4gICAgfVxufVxuXG5leHBvcnQgZnVuY3Rpb24gcHJvY2Vzc0V4cHJzKGV4cHI6IEV4cHI8QW5ub3RhdGlvbj4sIGdlbnY6IEdsb2JhbE1vcnBoRW52KSA6IEV4cHI8QW5ub3RhdGlvbj4ge1xuICAgIGlmIChleHByLmEudHlwZSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIHJldHVybiBleHByO1xuICAgIH1cbiAgICBleHByLmEudHlwZSA9IGNvbmNyZXRpemVHZW5lcmljVHlwZXMoZXhwci5hLnR5cGUsIGdlbnYpO1xuICAgIHN3aXRjaChleHByLnRhZykge1xuICAgICAgICBjYXNlIFwiYmlub3BcIjpcbiAgICAgICAgICAgIGNvbnN0IGJpbkwgPSBwcm9jZXNzRXhwcnMoZXhwci5sZWZ0LCBnZW52KTtcbiAgICAgICAgICAgIGNvbnN0IGJpblIgPSBwcm9jZXNzRXhwcnMoZXhwci5yaWdodCwgZ2Vudik7XG4gICAgICAgICAgICBpZiAoZXhwci5hLnR5cGUudGFnID09PSBcImNsYXNzXCIgJiYgZXhwci5hLnR5cGUucGFyYW1zLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICAgICAgICByZXR1cm4geyAuLi5leHByLCBhOiB7Li4uZXhwci5hLCB0eXBlOiBDTEFTUyhnZXRDYW5vbmljYWxUeXBlTmFtZShleHByLmEudHlwZSkpfSwgbGVmdDogYmluTCwgcmlnaHQ6IGJpblIgfTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiB7IC4uLmV4cHIsIGxlZnQ6IGJpbkwsIHJpZ2h0OiBiaW5SIH07XG4gICAgICAgIGNhc2UgXCJjYWxsXCI6XG4gICAgICAgICAgICBjb25zdCBjRXhwcnMgPSBleHByLmFyZ3VtZW50cy5tYXAoYSA9PiBwcm9jZXNzRXhwcnMoYSwgZ2VudikpO1xuICAgICAgICAgICAgaWYgKGV4cHIuYS50eXBlLnRhZyA9PT0gXCJjbGFzc1wiICYmIGV4cHIuYS50eXBlLnBhcmFtcy5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHsgLi4uZXhwciwgYTogey4uLmV4cHIuYSwgdHlwZTogQ0xBU1MoZ2V0Q2Fub25pY2FsVHlwZU5hbWUoZXhwci5hLnR5cGUpKX0sIGFyZ3VtZW50czogY0V4cHJzIH07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4geyAuLi5leHByLCBhcmd1bWVudHM6IGNFeHBycyB9O1xuICAgICAgICBjYXNlIFwiY29uc3RydWN0XCI6XG4gICAgICAgICAgICBpZiAoZXhwci5hLnR5cGUudGFnID09PSBcImNsYXNzXCIgJiYgZXhwci5hLnR5cGUucGFyYW1zLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICAgICAgICBjb25zdCBjb25zdHJ1Y3RDbmFtZSA9IGdldENhbm9uaWNhbFR5cGVOYW1lKGV4cHIuYS50eXBlKVxuICAgICAgICAgICAgICAgIHJldHVybiB7IC4uLmV4cHIsIGE6IHsuLi5leHByLmEsIHR5cGU6IENMQVNTKGNvbnN0cnVjdENuYW1lKX0sIG5hbWU6IGNvbnN0cnVjdENuYW1lIH07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gZXhwcjtcbiAgICAgICAgY2FzZSBcImlkXCI6XG4gICAgICAgICAgICBpZiAoZXhwci5hLnR5cGUudGFnID09PSBcImNsYXNzXCIgJiYgZXhwci5hLnR5cGUucGFyYW1zLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICAgICAgICByZXR1cm4geyAuLi5leHByLCBhOiB7Li4uZXhwci5hLCB0eXBlOiBDTEFTUyhnZXRDYW5vbmljYWxUeXBlTmFtZShleHByLmEudHlwZSkpfSB9O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIGV4cHI7XG4gICAgICAgIGNhc2UgXCJpbmRleFwiOlxuICAgICAgICAgICAgY29uc3QgaW54RXhwciA9IHByb2Nlc3NFeHBycyhleHByLmluZGV4LCBnZW52KTtcbiAgICAgICAgICAgIGNvbnN0IGlueE9iaiA9IHByb2Nlc3NFeHBycyhleHByLm9iaiwgZ2Vudik7XG4gICAgICAgICAgICBpZiAoZXhwci5hLnR5cGUudGFnID09PSBcImNsYXNzXCIgJiYgZXhwci5hLnR5cGUucGFyYW1zLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICAgICAgICByZXR1cm4geyAuLi5leHByLCBhOiB7Li4uZXhwci5hLCB0eXBlOiBDTEFTUyhnZXRDYW5vbmljYWxUeXBlTmFtZShleHByLmEudHlwZSkpfSwgaW5kZXg6IGlueEV4cHIsIG9iajogaW54T2JqIH07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4geyAuLi5leHByLCBpbmRleDogaW54RXhwciwgb2JqOiBpbnhPYmogfTtcbiAgICAgICAgY2FzZSBcImxvb2t1cFwiOlxuICAgICAgICAgICAgY29uc3QgbE9iaiA9IHByb2Nlc3NFeHBycyhleHByLm9iaiwgZ2Vudik7XG4gICAgICAgICAgICBpZiAoZXhwci5hLnR5cGUudGFnID09PSBcImNsYXNzXCIgJiYgZXhwci5hLnR5cGUucGFyYW1zLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICAgICAgICByZXR1cm4geyAuLi5leHByLCBhOiB7Li4uZXhwci5hLCB0eXBlOiBDTEFTUyhnZXRDYW5vbmljYWxUeXBlTmFtZShleHByLmEudHlwZSkpfSwgb2JqOiBsT2JqIH07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4geyAuLi5leHByLCBvYmo6IGxPYmogfTtcbiAgICAgICAgY2FzZSBcIm1ldGhvZC1jYWxsXCI6XG4gICAgICAgICAgICBjb25zdCBtY0V4cHJzID0gZXhwci5hcmd1bWVudHMubWFwKGEgPT4gcHJvY2Vzc0V4cHJzKGEsIGdlbnYpKTtcbiAgICAgICAgICAgIGNvbnN0IG1jT2JqID0gcHJvY2Vzc0V4cHJzKGV4cHIub2JqLCBnZW52KTtcbiAgICAgICAgICAgIGlmIChleHByLmEudHlwZS50YWcgPT09IFwiY2xhc3NcIiAmJiBleHByLmEudHlwZS5wYXJhbXMubGVuZ3RoID4gMCkge1xuICAgICAgICAgICAgICAgIHJldHVybiB7IC4uLmV4cHIsIGE6IHsuLi5leHByLmEsIHR5cGU6IENMQVNTKGdldENhbm9uaWNhbFR5cGVOYW1lKGV4cHIuYS50eXBlKSl9LCBhcmd1bWVudHM6IG1jRXhwcnMsIG9iajogbWNPYmogfTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiB7IC4uLmV4cHIsIGFyZ3VtZW50czogbWNFeHBycywgb2JqOiBtY09iaiB9O1xuICAgICAgICBjYXNlIFwidW5pb3BcIjpcbiAgICAgICAgICAgIGNvbnN0IHVleHByID0gcHJvY2Vzc0V4cHJzKGV4cHIuZXhwciwgZ2Vudik7XG4gICAgICAgICAgICBpZiAoZXhwci5hLnR5cGUudGFnID09PSBcImNsYXNzXCIgJiYgZXhwci5hLnR5cGUucGFyYW1zLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICAgICAgICByZXR1cm4geyAuLi5leHByLCBhOiB7Li4uZXhwci5hLCB0eXBlOiBDTEFTUyhnZXRDYW5vbmljYWxUeXBlTmFtZShleHByLmEudHlwZSkpfSwgZXhwcjogdWV4cHIgfTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiB7IC4uLmV4cHIsIGV4cHI6IHVleHByIH07XG4gICAgICAgIGNhc2UgXCJidWlsdGluMVwiOlxuICAgICAgICAgICAgY29uc3QgYjFhcmcgPSBwcm9jZXNzRXhwcnMoZXhwci5hcmcsIGdlbnYpO1xuICAgICAgICAgICAgaWYgKGV4cHIuYS50eXBlLnRhZyA9PT0gXCJjbGFzc1wiICYmIGV4cHIuYS50eXBlLnBhcmFtcy5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHsgLi4uZXhwciwgYTogey4uLmV4cHIuYSwgdHlwZTogQ0xBU1MoZ2V0Q2Fub25pY2FsVHlwZU5hbWUoZXhwci5hLnR5cGUpKX0sIGFyZzogYjFhcmcgfTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiB7IC4uLmV4cHIsIGFyZzogYjFhcmcgfTtcbiAgICAgICAgY2FzZSBcImJ1aWx0aW4yXCI6XG4gICAgICAgICAgICBjb25zdCBiMmxlZnQgPSBwcm9jZXNzRXhwcnMoZXhwci5sZWZ0LCBnZW52KTtcbiAgICAgICAgICAgIGNvbnN0IGIycmlnaHQgPSBwcm9jZXNzRXhwcnMoZXhwci5yaWdodCwgZ2Vudik7XG4gICAgICAgICAgICBpZiAoZXhwci5hLnR5cGUudGFnID09PSBcImNsYXNzXCIgJiYgZXhwci5hLnR5cGUucGFyYW1zLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICAgICAgICByZXR1cm4geyAuLi5leHByLCBhOiB7Li4uZXhwci5hLCB0eXBlOiBDTEFTUyhnZXRDYW5vbmljYWxUeXBlTmFtZShleHByLmEudHlwZSkpfSwgbGVmdDogYjJsZWZ0LCByaWdodDogYjJyaWdodCB9O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHsgLi4uZXhwciwgbGVmdDogYjJsZWZ0LCByaWdodDogYjJyaWdodCB9O1xuICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgcmV0dXJuIGV4cHI7XG4gICAgfVxufVxuXG5leHBvcnQgZnVuY3Rpb24gcHJvY2Vzc1N0bXRzKHN0bXQ6IFN0bXQ8QW5ub3RhdGlvbj4sIGdlbnY6IEdsb2JhbE1vcnBoRW52KSA6IFN0bXQ8QW5ub3RhdGlvbj4ge1xuICAgIGlmIChzdG10LmEudHlwZSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIHJldHVybiBzdG10O1xuICAgIH1cbiAgICBzdG10LmEudHlwZSA9IGNvbmNyZXRpemVHZW5lcmljVHlwZXMoc3RtdC5hLnR5cGUsIGdlbnYpO1xuICAgIHN3aXRjaChzdG10LnRhZykge1xuICAgICAgICBjYXNlIFwiYXNzaWduXCI6XG4gICAgICAgICAgICBjb25zdCBhc3NpZ25WYWx1ZUV4cHIgPSBwcm9jZXNzRXhwcnMoc3RtdC52YWx1ZSwgZ2Vudik7XG4gICAgICAgICAgICBpZiAoc3RtdC5hLnR5cGUudGFnID09PSBcImNsYXNzXCIgJiYgc3RtdC5hLnR5cGUucGFyYW1zLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICAgICAgICByZXR1cm4geyAuLi5zdG10LCBhOiB7Li4uc3RtdC5hLCB0eXBlOiBDTEFTUyhnZXRDYW5vbmljYWxUeXBlTmFtZShzdG10LmEudHlwZSkpfSwgdmFsdWU6IGFzc2lnblZhbHVlRXhwciB9O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHsgLi4uc3RtdCwgdmFsdWU6IGFzc2lnblZhbHVlRXhwciB9O1xuICAgICAgICBjYXNlIFwiZXhwclwiOlxuICAgICAgICAgICAgY29uc3QgZXhwciA9IHByb2Nlc3NFeHBycyhzdG10LmV4cHIsIGdlbnYpO1xuICAgICAgICAgICAgaWYgKHN0bXQuYS50eXBlLnRhZyA9PT0gXCJjbGFzc1wiICYmIHN0bXQuYS50eXBlLnBhcmFtcy5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHsuLi5zdG10LCBhOiB7Li4uc3RtdC5hLCB0eXBlOiBDTEFTUyhnZXRDYW5vbmljYWxUeXBlTmFtZShzdG10LmEudHlwZSkpfSwgZXhwciB9O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHsgLi4uc3RtdCwgZXhwciB9O1xuICAgICAgICBjYXNlIFwiZmllbGQtYXNzaWduXCI6XG4gICAgICAgICAgICBjb25zdCBmYW9iaiA9IHByb2Nlc3NFeHBycyhzdG10Lm9iaiwgZ2Vudik7XG4gICAgICAgICAgICBjb25zdCBmYXZhbCA9IHByb2Nlc3NFeHBycyhzdG10LnZhbHVlLCBnZW52KTtcbiAgICAgICAgICAgIGlmIChzdG10LmEudHlwZS50YWcgPT09IFwiY2xhc3NcIiAmJiBzdG10LmEudHlwZS5wYXJhbXMubGVuZ3RoID4gMCkge1xuICAgICAgICAgICAgICAgIHJldHVybiB7IC4uLnN0bXQsIGE6IHsuLi5zdG10LmEsIHR5cGU6IENMQVNTKGdldENhbm9uaWNhbFR5cGVOYW1lKHN0bXQuYS50eXBlKSl9LCBvYmo6IGZhb2JqLCB2YWx1ZTogZmF2YWwgfTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiB7IC4uLnN0bXQsIG9iajogZmFvYmosIHZhbHVlOiBmYXZhbCB9O1xuICAgICAgICBjYXNlIFwiaW5kZXgtYXNzaWduXCI6XG4gICAgICAgICAgICBjb25zdCBpYW9iaiA9IHByb2Nlc3NFeHBycyhzdG10Lm9iaiwgZ2Vudik7XG4gICAgICAgICAgICBjb25zdCBpaW54ID0gcHJvY2Vzc0V4cHJzKHN0bXQuaW5kZXgsIGdlbnYpO1xuICAgICAgICAgICAgY29uc3QgaXZhbCA9IHByb2Nlc3NFeHBycyhzdG10LnZhbHVlLCBnZW52KTtcbiAgICAgICAgICAgIGlmIChzdG10LmEudHlwZS50YWcgPT09IFwiY2xhc3NcIiAmJiBzdG10LmEudHlwZS5wYXJhbXMubGVuZ3RoID4gMCkge1xuICAgICAgICAgICAgICAgIHJldHVybiB7IC4uLnN0bXQsIGE6IHsuLi5zdG10LmEsIHR5cGU6IENMQVNTKGdldENhbm9uaWNhbFR5cGVOYW1lKHN0bXQuYS50eXBlKSl9LCBvYmo6IGlhb2JqLCBpbmRleDogaWlueCwgdmFsdWU6IGl2YWwgfTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiB7IC4uLnN0bXQsIG9iajogaWFvYmosIGluZGV4OiBpaW54LCB2YWx1ZTogaXZhbCB9O1xuICAgICAgICBjYXNlIFwiaWZcIjpcbiAgICAgICAgICAgIGNvbnN0IGlmY29uZCA9IHByb2Nlc3NFeHBycyhzdG10LmNvbmQsIGdlbnYpO1xuICAgICAgICAgICAgY29uc3QgaWZ0aG4gPSBzdG10LnRobi5tYXAoc3QgPT4gcHJvY2Vzc1N0bXRzKHN0LCBnZW52KSk7XG4gICAgICAgICAgICBjb25zdCBpZmVscyA9IHN0bXQuZWxzLm1hcChzdCA9PiBwcm9jZXNzU3RtdHMoc3QsIGdlbnYpKTtcbiAgICAgICAgICAgIGlmIChzdG10LmEudHlwZS50YWcgPT09IFwiY2xhc3NcIiAmJiBzdG10LmEudHlwZS5wYXJhbXMubGVuZ3RoID4gMCkge1xuICAgICAgICAgICAgICAgIHJldHVybiB7IC4uLnN0bXQsIGE6IHsuLi5zdG10LmEsIHR5cGU6IENMQVNTKGdldENhbm9uaWNhbFR5cGVOYW1lKHN0bXQuYS50eXBlKSl9LCBjb25kOiBpZmNvbmQsIHRobjogaWZ0aG4sIGVsczogaWZlbHMgfTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiB7IC4uLnN0bXQsIGNvbmQ6IGlmY29uZCwgdGhuOiBpZnRobiwgZWxzOiBpZmVscyB9O1xuICAgICAgICBjYXNlIFwicmV0dXJuXCI6XG4gICAgICAgICAgICBjb25zdCByZXRFeHByID0gcHJvY2Vzc0V4cHJzKHN0bXQudmFsdWUsIGdlbnYpO1xuICAgICAgICAgICAgaWYgKHN0bXQuYS50eXBlLnRhZyA9PT0gXCJjbGFzc1wiICYmIHN0bXQuYS50eXBlLnBhcmFtcy5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHsgLi4uc3RtdCwgYTogey4uLnN0bXQuYSwgdHlwZTogQ0xBU1MoZ2V0Q2Fub25pY2FsVHlwZU5hbWUoc3RtdC5hLnR5cGUpKX0sIHZhbHVlOiByZXRFeHByIH07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4geyAuLi5zdG10LCB2YWx1ZTogcmV0RXhwciB9O1xuICAgICAgICBjYXNlIFwid2hpbGVcIjpcbiAgICAgICAgICAgIGNvbnN0IHdjb25kID0gcHJvY2Vzc0V4cHJzKHN0bXQuY29uZCwgZ2Vudik7XG4gICAgICAgICAgICBjb25zdCB3Qm9keSA9IHN0bXQuYm9keS5tYXAoc3QgPT4gcHJvY2Vzc1N0bXRzKHN0LCBnZW52KSk7XG4gICAgICAgICAgICBpZiAoc3RtdC5hLnR5cGUudGFnID09PSBcImNsYXNzXCIgJiYgc3RtdC5hLnR5cGUucGFyYW1zLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICAgICAgICByZXR1cm4geyAuLi5zdG10LCBhOiB7Li4uc3RtdC5hLCB0eXBlOiBDTEFTUyhnZXRDYW5vbmljYWxUeXBlTmFtZShzdG10LmEudHlwZSkpfSAsY29uZDogd2NvbmQsIGJvZHk6IHdCb2R5IH07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4geyAuLi5zdG10LCBjb25kOiB3Y29uZCwgYm9keTogd0JvZHkgfTtcbiAgICAgICAgY2FzZSBcImZvclwiOlxuICAgICAgICAgICAgY29uc3Qge2JvZHksIGl0ZXJhdG9yLCB2YWx1ZXN9ID0gc3RtdDtcbiAgICAgICAgICAgIGNvbnN0IHdib2R5ID0gYm9keS5tYXAoc3QgPT4gcHJvY2Vzc1N0bXRzKHN0LCBnZW52KSk7XG4gICAgICAgICAgICBjb25zdCB3dmFsdWVzID0gcHJvY2Vzc0V4cHJzKHZhbHVlcywgZ2Vudik7XG4gICAgICAgICAgICBpZiAoc3RtdC5hLnR5cGUudGFnID09PSBcImNsYXNzXCIgJiYgc3RtdC5hLnR5cGUucGFyYW1zLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICAgICAgICByZXR1cm4geyAuLi5zdG10LCBhOiB7Li4uc3RtdC5hLCB0eXBlOiBDTEFTUyhnZXRDYW5vbmljYWxUeXBlTmFtZShzdG10LmEudHlwZSkpfSAsIGl0ZXJhdG9yLCBib2R5OiB3Ym9keSwgdmFsdWVzOiB3dmFsdWVzIH07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4geyAuLi5zdG10LCBpdGVyYXRvciwgdmFsdWVzOiB3dmFsdWVzLCBib2R5OiB3Ym9keSB9O1xuXG4gICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICByZXR1cm4gc3RtdDtcbiAgICB9XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBtb25vbW9ycGhpemVDbGFzcyhjbmFtZTogc3RyaW5nLCBjYW5vbmljYWxOYW1lOiBzdHJpbmcsIGNsYXNzZXM6IEFycmF5PENsYXNzPEFubm90YXRpb24+PiwgZ2VudjogR2xvYmFsTW9ycGhFbnYpIDogQ2xhc3M8QW5ub3RhdGlvbj4ge1xuICAgIGxldCBjQ2xhc3MgOiBDbGFzczxBbm5vdGF0aW9uPiA9IGNsYXNzZXNbZ2Vudi5jbGFzc2VzSW54LmdldChjbmFtZSldO1xuICAgIGxldCBtQ2xhc3MgOiBDbGFzczxBbm5vdGF0aW9uPiA9IEpTT04ucGFyc2UoSlNPTi5zdHJpbmdpZnkoY0NsYXNzKSlcbiAgICBtQ2xhc3MubmFtZSA9IGNhbm9uaWNhbE5hbWU7XG4gICAgbUNsYXNzLnR5cGVQYXJhbXMgPSBbXTtcbiAgICBtQ2xhc3MuZmllbGRzID0gbUNsYXNzLmZpZWxkcy5tYXAoZmllbGQgPT4ge1xuICAgICAgICBpZiAoZmllbGQudHlwZS50YWcgPT09IFwidHlwZXZhclwiIHx8IChmaWVsZC50eXBlLnRhZyA9PT0gXCJjbGFzc1wiICYmIGZpZWxkLnR5cGUucGFyYW1zLmxlbmd0aCA+IDApKSB7XG4gICAgICAgICAgICBmaWVsZC50eXBlID0gY29uY3JldGl6ZUdlbmVyaWNUeXBlcyhmaWVsZC50eXBlLCBnZW52KTtcbiAgICAgICAgICAgIGZpZWxkLnZhbHVlID0gcmVzb2x2ZVplcm8oZmllbGQudHlwZSwgZmllbGQuYSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGZpZWxkO1xuICAgIH0pO1xuICAgIG1DbGFzcy5tZXRob2RzID0gbUNsYXNzLm1ldGhvZHMubWFwKG1ldGhvZCA9PiB7XG4gICAgICAgIG1ldGhvZC5wYXJhbWV0ZXJzID0gbWV0aG9kLnBhcmFtZXRlcnMubWFwKHAgPT4ge1xuICAgICAgICAgICAgY29uc3QgcHR5cGUgPSBjb25jcmV0aXplR2VuZXJpY1R5cGVzKHAudHlwZSwgZ2Vudik7XG4gICAgICAgICAgICByZXR1cm4geyAuLi5wLCB0eXBlIDogcHR5cGUgfTtcbiAgICAgICAgfSk7XG4gICAgICAgIG1ldGhvZC5pbml0cyA9IG1ldGhvZC5pbml0cy5tYXAoaW5pdCA9PiB7XG4gICAgICAgICAgICBpZiAoaW5pdC50eXBlLnRhZyA9PT0gXCJ0eXBldmFyXCIgfHwgKGluaXQudHlwZS50YWcgPT09IFwiY2xhc3NcIiAmJiBpbml0LnR5cGUucGFyYW1zLmxlbmd0aCA+IDApKSB7XG4gICAgICAgICAgICAgICAgaW5pdC50eXBlID0gY29uY3JldGl6ZUdlbmVyaWNUeXBlcyhpbml0LnR5cGUsIGdlbnYpO1xuICAgICAgICAgICAgICAgIGluaXQudmFsdWUgPSByZXNvbHZlWmVybyhpbml0LnR5cGUsIGluaXQuYSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gaW5pdDtcbiAgICAgICAgfSk7XG4gICAgICAgIG1ldGhvZC5yZXQgPSBjb25jcmV0aXplR2VuZXJpY1R5cGVzKG1ldGhvZC5yZXQsIGdlbnYpO1xuXG4gICAgICAgIHJldHVybiBtZXRob2Q7XG4gICAgfSk7XG5cbiAgICBtQ2xhc3MuZmllbGRzID0gcHJvY2Vzc0luaXRzKG1DbGFzcy5maWVsZHMsIGNsYXNzZXMsIGdlbnYpO1xuICAgIG1DbGFzcy5tZXRob2RzID0gbUNsYXNzLm1ldGhvZHMubWFwKG0gPT4ge1xuICAgICAgICAvLyBhc3N1bWluZyBtZXRob2QgYW5ub3RhdGlvbiBpcyBub25lLCB3ZSBkb24ndCBkbyBhbnl0aGluZyB3aXRoIGl0XG4gICAgICAgIHJldHVybiB7IC4uLm0sIHBhcmFtZXRlcnM6IHByb2Nlc3NNZXRob2RQYXJhbXMobS5wYXJhbWV0ZXJzLCBjbGFzc2VzLCBnZW52KSwgaW5pdHM6IHByb2Nlc3NJbml0cyhtLmluaXRzLCBjbGFzc2VzLCBnZW52KSwgXG4gICAgICAgICAgICAgICAgYm9keTogbS5ib2R5Lm1hcChzID0+IHByb2Nlc3NTdG10cyhzLCBnZW52KSkgfTtcbiAgICB9KTtcblxuICAgIHJldHVybiBtQ2xhc3M7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBnZXRDYW5vbmljYWxUeXBlTmFtZSh0IDogVHlwZSkgOiBzdHJpbmcge1xuICAgIHN3aXRjaCAodC50YWcpIHtcbiAgICAgICAgY2FzZSBcIm51bWJlclwiOlxuICAgICAgICBjYXNlIFwiYm9vbFwiOlxuICAgICAgICAgICAgcmV0dXJuIHQudGFnO1xuICAgICAgICBjYXNlIFwiY2xhc3NcIjpcbiAgICAgICAgICAgIGNvbnN0IHBhcmFtTmFtZXMgPSB0LnBhcmFtcy5tYXAocCA9PiBnZXRDYW5vbmljYWxUeXBlTmFtZShwKSkuam9pbihcIiRcIik7XG4gICAgICAgICAgICByZXR1cm4gdC5uYW1lICsgXCIkXCIgKyBwYXJhbU5hbWVzO1xuICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBJbnZhbGlkIFN0YXRlIEV4Y2VwdGlvbiA6IHVuZXhwZWN0ZWQgdHlwZSBwYXNzZWQgYXMgYSBnZW5lcmljIHR5cGUgJHt0LnRhZ31gKTtcbiAgICB9XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBwcm9jZXNzTWV0aG9kUGFyYW1zKHBhcmFtczogQXJyYXk8UGFyYW1ldGVyPEFubm90YXRpb24+PiwgY2xhc3NlczogQXJyYXk8Q2xhc3M8QW5ub3RhdGlvbj4+LCBnZW52OiBHbG9iYWxNb3JwaEVudikgOiBBcnJheTxQYXJhbWV0ZXI8QW5ub3RhdGlvbj4+IHtcbiAgICByZXR1cm4gcGFyYW1zLm1hcChwYXJhbSA9PiB7XG4gICAgICAgIGlmIChwYXJhbS50eXBlLnRhZyA9PT0gXCJjbGFzc1wiICYmIHBhcmFtLnR5cGUucGFyYW1zLmxlbmd0aCA+IDApIHsgLy8gdGhpcyBpbXBsaWVzIGEgdmFyIGluaXQgb2YgYSBjbGFzcyB3aXRoIGdlbmVyaWMgdHlwZXNcbiAgICAgICAgICAgIGNvbnN0IGNhbm9uaWNhbE5hbWUgPSBnZXRDYW5vbmljYWxUeXBlTmFtZShwYXJhbS50eXBlKTtcbiAgICAgICAgICAgIGlmICghZ2Vudi5tb3JwaGVkQ2xhc3Nlcy5oYXMoY2Fub25pY2FsTmFtZSkpIHtcbiAgICAgICAgICAgICAgICBjb25zdCB0eXBlQ25hbWUgPSBwYXJhbS50eXBlLm5hbWU7XG4gICAgICAgICAgICAgICAgcGFyYW0udHlwZS5wYXJhbXMuZm9yRWFjaCgodHYsIGlueCkgPT4gZ2Vudi50eXBlVmFycy5zZXQoY2xhc3Nlc1tnZW52LmNsYXNzZXNJbnguZ2V0KHR5cGVDbmFtZSldLnR5cGVQYXJhbXNbaW54XSwgdHYpKTtcbiAgICAgICAgICAgICAgICBnZW52Lm1vcnBoZWRDbGFzc2VzLmFkZChjYW5vbmljYWxOYW1lKTtcbiAgICAgICAgICAgICAgICBjbGFzc2VzLnB1c2gobW9ub21vcnBoaXplQ2xhc3ModHlwZUNuYW1lLCBjYW5vbmljYWxOYW1lLCBjbGFzc2VzLCBnZW52KSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4geyAuLi5wYXJhbSwgdHlwZTogQ0xBU1MoY2Fub25pY2FsTmFtZSkgfTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcGFyYW07XG4gICAgfSk7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBwcm9jZXNzSW5pdHMoaW5pdHM6IEFycmF5PFZhckluaXQ8QW5ub3RhdGlvbj4+LCBjbGFzc2VzOiBBcnJheTxDbGFzczxBbm5vdGF0aW9uPj4sIGdlbnY6IEdsb2JhbE1vcnBoRW52KSA6IEFycmF5PFZhckluaXQ8QW5ub3RhdGlvbj4+IHtcbiAgICByZXR1cm4gaW5pdHMubWFwKGluaXQgPT4ge1xuICAgICAgICBpZiAoaW5pdC50eXBlLnRhZyA9PT0gXCJjbGFzc1wiICYmIGluaXQudHlwZS5wYXJhbXMubGVuZ3RoID4gMCkge1xuICAgICAgICAgICAgY29uc3QgY2Fub25pY2FsTmFtZSA9IGdldENhbm9uaWNhbFR5cGVOYW1lKGluaXQudHlwZSk7XG4gICAgICAgICAgICBpZiAoIWdlbnYubW9ycGhlZENsYXNzZXMuaGFzKGNhbm9uaWNhbE5hbWUpKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgdHlwZUNuYW1lID0gaW5pdC50eXBlLm5hbWU7XG4gICAgICAgICAgICAgICAgaW5pdC50eXBlLnBhcmFtcy5mb3JFYWNoKCh0diwgaW54KSA9PiBnZW52LnR5cGVWYXJzLnNldChjbGFzc2VzW2dlbnYuY2xhc3Nlc0lueC5nZXQodHlwZUNuYW1lKV0udHlwZVBhcmFtc1tpbnhdLCB0dikpO1xuICAgICAgICAgICAgICAgIGdlbnYubW9ycGhlZENsYXNzZXMuYWRkKGNhbm9uaWNhbE5hbWUpO1xuICAgICAgICAgICAgICAgIGNsYXNzZXMucHVzaChtb25vbW9ycGhpemVDbGFzcyh0eXBlQ25hbWUsIGNhbm9uaWNhbE5hbWUsIGNsYXNzZXMsIGdlbnYpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiB7IC4uLmluaXQsIHR5cGU6IENMQVNTKGNhbm9uaWNhbE5hbWUpIH07XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGluaXQ7XG4gICAgfSk7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBtb25vbW9ycGhpemVQcm9ncmFtKHByb2dyYW06IFByb2dyYW08QW5ub3RhdGlvbj4pIDogUHJvZ3JhbTxBbm5vdGF0aW9uPiB7XG4gICAgbGV0IGNsYXNzZXNJbnggOiBNYXA8c3RyaW5nLCBudW1iZXI+ID0gbmV3IE1hcCgpO1xuICAgIHByb2dyYW0uY2xhc3Nlcy5mb3JFYWNoKChjbGF6eiwgaW54KSA9PiBjbGFzc2VzSW54LnNldChjbGF6ei5uYW1lLCBpbngpKTtcbiAgICBsZXQgZ2VudiA6IEdsb2JhbE1vcnBoRW52ID0ge2NsYXNzZXNJbngsIHR5cGVWYXJzOiBuZXcgTWFwKCksIG1vcnBoZWRDbGFzc2VzOiBuZXcgU2V0KCl9O1xuICAgIGNvbnN0IGluaXRzID0gcHJvY2Vzc0luaXRzKHByb2dyYW0uaW5pdHMsIHByb2dyYW0uY2xhc3NlcywgZ2Vudik7XG4gICAgY29uc3QgbW9ub01vcnBoaXplZENsYXNzZXMgPSBwcm9ncmFtLmNsYXNzZXMuZmlsdGVyKGNsYXp6ID0+IGNsYXp6LnR5cGVQYXJhbXMubGVuZ3RoID09PSAwKTtcbiAgICBjb25zdCBwcm9jZXNzZWRTdG10cyA9IHByb2dyYW0uc3RtdHMubWFwKHMgPT4gcHJvY2Vzc1N0bXRzKHMsIGdlbnYpKTtcbiAgICByZXR1cm4geyAuLi5wcm9ncmFtLCBpbml0cywgY2xhc3NlczogbW9ub01vcnBoaXplZENsYXNzZXMsIHR5cGVWYXJJbml0czogW10sIHN0bXRzOiBwcm9jZXNzZWRTdG10cyB9O1xufVxuIiwiaW1wb3J0IHsgQmluT3AsIFBhcmFtZXRlciwgVHlwZSwgVW5pT3B9IGZyb20gXCIuL2FzdFwiO1xuaW1wb3J0IHsgU3RtdCwgRXhwciwgVmFsdWUsIFZhckluaXQsIEJhc2ljQmxvY2ssIFByb2dyYW0sIEZ1bkRlZiwgQ2xhc3MgfSBmcm9tIFwiLi9pclwiO1xuXG5pbXBvcnQgeyBpc1RhZ0Jvb2xlYW4sIGlzVGFnTm9uZSwgaXNUYWdJZCwgaXNUYWdCaWdJbnQsIGlzVGFnRXF1YWwsIGNoZWNrVmFsdWVFcXVhbGl0eSwgY2hlY2tDb21waWxlVmFsRXF1YWxpdHksIGNoZWNrU3RtdEVxdWFsaXR5IH0gZnJvbSBcIi4vb3B0aW1pemF0aW9uX3V0aWxzXCI7IFxuXG50eXBlIEVudiA9IHtcbiAgICB2YXJzOiBNYXA8c3RyaW5nLCBjb21waWxlVmFsPjtcbn1cblxuZXhwb3J0IHR5cGUgY29tcGlsZVZhbCA9IHtcbiAgICB0YWc6IFwibmFjXCJ8XCJ2YWxcInxcInVuZGVmXCIsIHZhbHVlPzogVmFsdWU8YW55Pjtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIG9wdGltaXplVmFsdWUodmFsOiBWYWx1ZTxhbnk+LCBlbnY6IEVudik6IFZhbHVlPGFueT57XG4gICAgaWYgKHZhbC50YWcgIT09IFwiaWRcIil7XG4gICAgICAgIHJldHVybiB2YWw7XG4gICAgfVxuICAgIGlmIChlbnYudmFycy5oYXModmFsLm5hbWUpKXtcbiAgICAgICAgaWYgKFtcIm5hY1wiLCBcInVuZGVmXCJdLmluY2x1ZGVzKGVudi52YXJzLmdldCh2YWwubmFtZSkudGFnKSlcbiAgICAgICAgICAgIHJldHVybiB2YWw7XG4gICAgICAgIHZhbCA9IGVudi52YXJzLmdldCh2YWwubmFtZSkudmFsdWU7XG4gICAgfVxuICAgIHJldHVybiB2YWw7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBjaGVja0lmRm9sZGFibGVCaW5PcChvcDogQmluT3AsIGxlZnRWYWw6IFZhbHVlPGFueT4sIHJpZ2h0VmFsOiBWYWx1ZTxhbnk+KTogYm9vbGVhbiB7XG4gICAgaWYgKFtCaW5PcC5JRGl2LCBCaW5PcC5Nb2RdLmluY2x1ZGVzKG9wKSl7XG4gICAgICAgIGlmICghaXNUYWdCaWdJbnQobGVmdFZhbCkgfHwgIWlzVGFnQmlnSW50KHJpZ2h0VmFsKSlcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIkNvbXBpbGVyIEVycm9yOiBGdW5jdGlvbiBzaG91bGQgYmUgaW52b2tlZCBvbmx5IGlmIHRoZSBleHByZXNzaW9uIGNhbiBiZSBmb2xkZWRcIik7XG4gICAgICAgIGlmIChyaWdodFZhbC52YWx1ZSA9PT0gMG4pIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgcmV0dXJuIHRydWU7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBldmFsdWF0ZUJpbk9wKG9wOiBCaW5PcCwgbGVmdFZhbDogVmFsdWU8YW55PiwgcmlnaHRWYWw6IFZhbHVlPGFueT4pOiBWYWx1ZTxhbnk+e1xuICAgIGlmKFtCaW5PcC5QbHVzLCBCaW5PcC5NaW51cyxCaW5PcC5JRGl2LEJpbk9wLk11bCwgQmluT3AuR3QsIEJpbk9wLkx0LCBCaW5PcC5HdGUsIEJpbk9wLkx0ZSwgQmluT3AuTW9kXS5pbmNsdWRlcyhvcCkpe1xuICAgICAgICBpZighaXNUYWdCaWdJbnQobGVmdFZhbCkgfHwgIWlzVGFnQmlnSW50KHJpZ2h0VmFsKSlcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIkNvbXBpbGVyIEVycm9yOiBGdW5jdGlvbiBzaG91bGQgYmUgaW52b2tlZCBvbmx5IGlmIHRoZSBleHByZXNzaW9uIGNhbiBiZSBmb2xkZWRcIik7XG4gICAgICAgIFxuICAgICAgICBzd2l0Y2gob3Ape1xuICAgICAgICAgICAgY2FzZSBCaW5PcC5QbHVzOiByZXR1cm4ge3RhZzogXCJudW1cIiwgdmFsdWU6IGxlZnRWYWwudmFsdWUgKyByaWdodFZhbC52YWx1ZX07XG4gICAgICAgICAgICBcbiAgICAgICAgICAgIGNhc2UgQmluT3AuTWludXM6IHJldHVybiB7dGFnOiBcIm51bVwiLCB2YWx1ZTogbGVmdFZhbC52YWx1ZSAtIHJpZ2h0VmFsLnZhbHVlfVxuICAgICAgICAgICAgXG4gICAgICAgICAgICBjYXNlIEJpbk9wLk11bDogcmV0dXJuIHt0YWc6IFwibnVtXCIsIHZhbHVlOiBsZWZ0VmFsLnZhbHVlICogcmlnaHRWYWwudmFsdWV9XG5cbiAgICAgICAgICAgIGNhc2UgQmluT3AuSURpdjogcmV0dXJuIHt0YWc6IFwibnVtXCIsIHZhbHVlOiBsZWZ0VmFsLnZhbHVlIC8gcmlnaHRWYWwudmFsdWV9XG4gICAgICAgICAgICBcbiAgICAgICAgICAgIGNhc2UgQmluT3AuTW9kOiByZXR1cm4ge3RhZzogXCJudW1cIiwgdmFsdWU6IGxlZnRWYWwudmFsdWUgJSByaWdodFZhbC52YWx1ZX1cbiAgICAgICAgICAgIFxuICAgICAgICAgICAgY2FzZSBCaW5PcC5HdDogcmV0dXJuIHt0YWc6IFwiYm9vbFwiLCB2YWx1ZTogbGVmdFZhbC52YWx1ZSA+IHJpZ2h0VmFsLnZhbHVlfVxuICAgICAgICAgICAgXG4gICAgICAgICAgICBjYXNlIEJpbk9wLkx0OiByZXR1cm4ge3RhZzogXCJib29sXCIsIHZhbHVlOiBsZWZ0VmFsLnZhbHVlIDwgcmlnaHRWYWwudmFsdWV9XG4gICAgICAgICAgICBcbiAgICAgICAgICAgIGNhc2UgQmluT3AuR3RlOiByZXR1cm4ge3RhZzogXCJib29sXCIsIHZhbHVlOiBsZWZ0VmFsLnZhbHVlID49IHJpZ2h0VmFsLnZhbHVlfVxuICAgICAgICAgICAgXG4gICAgICAgICAgICBjYXNlIEJpbk9wLkx0ZTogcmV0dXJuIHt0YWc6IFwiYm9vbFwiLCB2YWx1ZTogbGVmdFZhbC52YWx1ZSA8PSByaWdodFZhbC52YWx1ZX1cbiAgICAgICAgfVxuICAgIH1cbiAgICBlbHNlIGlmKFtCaW5PcC5BbmQsIEJpbk9wLk9yXS5pbmNsdWRlcyhvcCkpe1xuICAgICAgICBpZighaXNUYWdCb29sZWFuKGxlZnRWYWwpIHx8ICFpc1RhZ0Jvb2xlYW4ocmlnaHRWYWwpKVxuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiQ29tcGlsZXIgRXJyb3I6IEZ1bmN0aW9uIHNob3VsZCBiZSBpbnZva2VkIG9ubHkgaWYgdGhlIGV4cHJlc3Npb24gY2FuIGJlIGZvbGRlZFwiKTtcbiAgICAgICAgXG4gICAgICAgIHN3aXRjaChvcCl7XG4gICAgICAgICAgICBjYXNlIEJpbk9wLkFuZDogcmV0dXJuIHt0YWc6IFwiYm9vbFwiLCB2YWx1ZTogbGVmdFZhbC52YWx1ZSAmJiByaWdodFZhbC52YWx1ZX07XG5cbiAgICAgICAgICAgIGNhc2UgQmluT3AuT3I6IHJldHVybiB7dGFnOiBcImJvb2xcIiwgdmFsdWU6IGxlZnRWYWwudmFsdWUgfHwgcmlnaHRWYWwudmFsdWV9O1xuICAgICAgICB9XG4gICAgfVxuICAgIGVsc2UgaWYoW0Jpbk9wLkVxLCBCaW5PcC5OZXFdLmluY2x1ZGVzKG9wKSl7XG4gICAgICAgIGlmKCFpc1RhZ0VxdWFsKGxlZnRWYWwsIHJpZ2h0VmFsKSB8fCBpc1RhZ05vbmUobGVmdFZhbCkgfHwgaXNUYWdOb25lKHJpZ2h0VmFsKSB8fCBpc1RhZ0lkKGxlZnRWYWwpIHx8IGlzVGFnSWQocmlnaHRWYWwpKVxuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiQ29tcGlsZXIgRXJyb3I6IEZ1bmN0aW9uIHNob3VsZCBiZSBpbnZva2VkIG9ubHkgaWYgdGhlIGV4cHJlc3Npb24gY2FuIGJlIGZvbGRlZFwiKTtcbiAgICAgICAgc3dpdGNoKG9wKXtcbiAgICAgICAgICAgIGNhc2UgQmluT3AuRXE6IHJldHVybiB7dGFnOiBcImJvb2xcIiwgdmFsdWU6IGxlZnRWYWwudmFsdWUgPT09IHJpZ2h0VmFsLnZhbHVlfTtcblxuICAgICAgICB9XG4gICAgfVxuICAgIGVsc2V7XG4gICAgICAgIC8vSXMgb3BlcmF0b3IgaGFuZGxlclxuICAgICAgICBpZiAoIWlzVGFnTm9uZShsZWZ0VmFsKSB8fCAhaXNUYWdOb25lKHJpZ2h0VmFsKSlcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIkNvbXBpbGVyIEVycm9yOiBGdW5jdGlvbiBzaG91bGQgYmUgaW52b2tlZCBvbmx5IGlmIHRoZSBleHByZXNzaW9uIGNhbiBiZSBmb2xkZWRcIik7XG4gICAgICAgIHJldHVybiB7dGFnOiBcImJvb2xcIiwgdmFsdWU6IHRydWV9O1xuICAgIH1cbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGV2YWx1YXRlVW5pT3Aob3A6IFVuaU9wLCB2YWw6IFZhbHVlPGFueT4pOiBWYWx1ZTxhbnk+e1xuICAgIHN3aXRjaChvcCl7XG4gICAgICAgIGNhc2UgVW5pT3AuTmVnOlxuXG4gICAgICAgICAgICBpZiAoaXNUYWdJZCh2YWwpIHx8IGlzVGFnTm9uZSh2YWwpIHx8IGlzVGFnQm9vbGVhbih2YWwpKSBcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJDb21waWxlciBFcnJvclwiKTtcbiAgICAgICAgICAgIGNvbnN0IG1pbnVzMTogYmlnaW50ID0gLTFuO1xuICAgICAgICAgICAgcmV0dXJuIHt0YWc6IFwibnVtXCIsIHZhbHVlOiBtaW51czEgYXMgYmlnaW50ICogKHZhbC52YWx1ZSBhcyBiaWdpbnQpfTtcblxuICAgICAgICBjYXNlIFVuaU9wLk5vdDpcblxuICAgICAgICAgICAgaWYgKCFpc1RhZ0Jvb2xlYW4odmFsKSkgXG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiQ29tcGlsZXIgRXJyb3JcIik7XG4gICAgICAgICAgICBcbiAgICAgICAgICAgICAgICByZXR1cm4ge3RhZzogXCJib29sXCIsIHZhbHVlOiAhKHZhbC52YWx1ZSl9O1xuICAgIH1cbn1cblxuZXhwb3J0IGZ1bmN0aW9uIG9wdGltaXplRXhwcmVzc2lvbihlOiBFeHByPFR5cGU+LCBlbnY6IEVudik6IEV4cHI8VHlwZT57XG4gICAgc3dpdGNoKGUudGFnKSB7XG4gICAgICAgIGNhc2UgXCJ2YWx1ZVwiOlxuICAgICAgICAgICB2YXIgb3B0aW1pemVkVmFsdWU6IFZhbHVlPGFueT4gPSBvcHRpbWl6ZVZhbHVlKGUudmFsdWUsIGVudik7XG4gICAgICAgICAgIHJldHVybiB7Li4uZSwgdmFsdWU6IG9wdGltaXplZFZhbHVlfTtcbiAgICAgICAgY2FzZSBcImJpbm9wXCI6XG4gICAgICAgICAgICB2YXIgbGVmdCA9IG9wdGltaXplVmFsdWUoZS5sZWZ0LCBlbnYpO1xuICAgICAgICAgICAgdmFyIHJpZ2h0ID0gb3B0aW1pemVWYWx1ZShlLnJpZ2h0LCBlbnYpO1xuICAgICAgICAgICAgaWYgKGxlZnQudGFnID09PSBcImlkXCIgfHwgcmlnaHQudGFnID09PSBcImlkXCIgfHwgIWNoZWNrSWZGb2xkYWJsZUJpbk9wKGUub3AsIGxlZnQsIHJpZ2h0KSlcbiAgICAgICAgICAgICAgICByZXR1cm4gey4uLmUsIGxlZnQ6IGxlZnQsIHJpZ2h0OiByaWdodH07XG4gICAgICAgICAgICB2YXIgdmFsOiBWYWx1ZTxhbnk+ID0gZXZhbHVhdGVCaW5PcChlLm9wLCBsZWZ0LCByaWdodCk7XG4gICAgICAgICAgICByZXR1cm4ge3RhZzogXCJ2YWx1ZVwiLCB2YWx1ZTogdmFsfTtcbiAgICAgICAgY2FzZSBcInVuaW9wXCI6XG4gICAgICAgICAgICB2YXIgYXJnID0gb3B0aW1pemVWYWx1ZShlLmV4cHIsIGVudik7XG4gICAgICAgICAgICBpZiAoYXJnLnRhZyA9PT0gXCJpZFwiKVxuICAgICAgICAgICAgICAgIHJldHVybiB7Li4uZSwgZXhwcjogYXJnfTtcbiAgICAgICAgICAgIHZhciB2YWw6IFZhbHVlPGFueT4gPSBldmFsdWF0ZVVuaU9wKGUub3AsIGFyZyk7XG4gICAgICAgICAgICByZXR1cm4gZTtcbiAgICAgICAgICAgIC8vIE5PVEUoam9lKTogaGFkIHRvIHNraXAgdGhpcyBvcHRpbWl6YXRpb24gYi9jIG5lZ2F0aXZlIGxpdGVyYWxzIGZvciBiaWdudW1zIG5vdCBzdXBwb3J0ZWRcbiAgICAgICAgICAgIC8vIHJldHVybiB7dGFnOiBcInZhbHVlXCIsIHZhbHVlOiB2YWx9O1xuICAgICAgICBjYXNlIFwiYnVpbHRpbjFcIjpcbiAgICAgICAgICAgIHZhciBhcmcgPSBvcHRpbWl6ZVZhbHVlKGUuYXJnLCBlbnYpO1xuICAgICAgICAgICAgcmV0dXJuIHsuLi5lLCBhcmc6IGFyZ307XG4gICAgICAgIGNhc2UgXCJidWlsdGluMlwiOlxuICAgICAgICAgICAgdmFyIGxlZnQgPSBvcHRpbWl6ZVZhbHVlKGUubGVmdCwgZW52KTtcbiAgICAgICAgICAgIHZhciByaWdodCA9IG9wdGltaXplVmFsdWUoZS5yaWdodCwgZW52KTtcbiAgICAgICAgICAgIHJldHVybiB7Li4uZSwgbGVmdDpsZWZ0LCByaWdodDogcmlnaHR9O1xuICAgICAgICBjYXNlIFwiY2FsbFwiOlxuICAgICAgICAgICAgdmFyIG1vZGlmaWVkUGFyYW1zID0gZS5hcmd1bWVudHMubWFwKGEgPT4ge1xuICAgICAgICAgICAgICAgIHJldHVybiBvcHRpbWl6ZVZhbHVlKGEsIGVudik7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIHJldHVybiB7Li4uZSwgYXJndW1lbnRzOiBtb2RpZmllZFBhcmFtc307XG4gICAgICAgIGNhc2UgXCJhbGxvY1wiOlxuICAgICAgICAgICAgdmFyIGFtb3VudCA9IG9wdGltaXplVmFsdWUoZS5hbW91bnQsIGVudik7XG4gICAgICAgICAgICByZXR1cm4gey4uLmUsIGFtb3VudDogYW1vdW50fTtcbiAgICAgICAgY2FzZSBcImxvYWRcIjpcbiAgICAgICAgICAgIHZhciBzdGFydCA9IG9wdGltaXplVmFsdWUoZS5zdGFydCwgZW52KTtcbiAgICAgICAgICAgIHZhciBvZmZzZXQgPSBvcHRpbWl6ZVZhbHVlKGUub2Zmc2V0LCBlbnYpO1xuICAgICAgICAgICAgcmV0dXJuIHsuLi5lLCBzdGFydDogc3RhcnQsIG9mZnNldDogb2Zmc2V0fTtcbiAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgIHJldHVybiBlO1xuICAgIH1cbn1cblxuZXhwb3J0IGZ1bmN0aW9uIG9wdGltaXplU3RhdGVtZW50cyhzdG10OiBTdG10PGFueT4sIGVudjogRW52KTogU3RtdDxhbnk+e1xuICAgIHN3aXRjaChzdG10LnRhZyl7XG4gICAgICAgIGNhc2UgXCJhc3NpZ25cIjpcbiAgICAgICAgICAgIHZhciBvcHRpbWl6ZWRFeHByZXNzaW9uOiBFeHByPGFueT4gPSBvcHRpbWl6ZUV4cHJlc3Npb24oc3RtdC52YWx1ZSwgZW52KTtcbiAgICAgICAgICAgIGlmIChvcHRpbWl6ZWRFeHByZXNzaW9uLnRhZyA9PT0gXCJ2YWx1ZVwiKXtcbiAgICAgICAgICAgICAgICBpZiAob3B0aW1pemVkRXhwcmVzc2lvbi52YWx1ZS50YWcgPT09IFwiaWRcIil7XG4gICAgICAgICAgICAgICAgICAgIGVudi52YXJzLnNldChzdG10Lm5hbWUsIHt0YWc6IFwibmFjXCJ9KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZXtcbiAgICAgICAgICAgICAgICAgICAgZW52LnZhcnMuc2V0KHN0bXQubmFtZSwge3RhZzogXCJ2YWxcIiwgdmFsdWU6IG9wdGltaXplZEV4cHJlc3Npb24udmFsdWV9KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNle1xuICAgICAgICAgICAgICAgIGVudi52YXJzLnNldChzdG10Lm5hbWUsIHt0YWc6IFwibmFjXCJ9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiB7Li4uc3RtdCwgdmFsdWU6IG9wdGltaXplZEV4cHJlc3Npb259O1xuICAgICAgICBjYXNlIFwicmV0dXJuXCI6XG4gICAgICAgICAgICB2YXIgb3B0aW1pemVkVmFsdWU6IFZhbHVlPGFueT4gPSBvcHRpbWl6ZVZhbHVlKHN0bXQudmFsdWUsIGVudik7XG4gICAgICAgICAgICByZXR1cm4gey4uLnN0bXQsIHZhbHVlOiBvcHRpbWl6ZWRWYWx1ZX07XG4gICAgICAgIGNhc2UgXCJleHByXCI6XG4gICAgICAgICAgICB2YXIgb3B0aW1pemVkRXhwcmVzc2lvbjogRXhwcjxhbnk+ID0gb3B0aW1pemVFeHByZXNzaW9uKHN0bXQuZXhwciwgZW52KTtcbiAgICAgICAgICAgIHJldHVybiB7Li4uc3RtdCwgZXhwcjogb3B0aW1pemVkRXhwcmVzc2lvbn07XG4gICAgICAgIGNhc2UgXCJwYXNzXCI6XG4gICAgICAgICAgICByZXR1cm4gc3RtdDtcbiAgICAgICAgY2FzZSBcImlmam1wXCI6XG4gICAgICAgICAgICB2YXIgb3B0aW1pemVkVmFsdWU6IFZhbHVlPGFueT4gPSBvcHRpbWl6ZVZhbHVlKHN0bXQuY29uZCwgZW52KTtcbiAgICAgICAgICAgIHJldHVybiB7Li4uc3RtdCwgY29uZDogb3B0aW1pemVkVmFsdWV9O1xuICAgICAgICBjYXNlIFwiam1wXCI6XG4gICAgICAgICAgICByZXR1cm4gc3RtdDtcbiAgICAgICAgY2FzZSBcInN0b3JlXCI6XG4gICAgICAgICAgICByZXR1cm4gc3RtdDtcbiAgICB9XG59XG5cbi8vQXNzdW1pbmcganVtcHMgaWYgaXQgb2NjdXJzIHdpbGwgb2NjdXIgYXQgdGhlIGxhc3Qgc3RhdGVtZW50IG9mIHRoZSBibG9ja1xuZXhwb3J0IGZ1bmN0aW9uIGNvbXB1dGVQcmVkZWNlc3NvclN1Y2Nlc3NvcihiYXNpY0Jsb2NrczogQXJyYXk8QmFzaWNCbG9jazxhbnk+Pik6IFtNYXA8c3RyaW5nLCBzdHJpbmdbXT4sIE1hcDxzdHJpbmcsIHN0cmluZ1tdPiwgTWFwPHN0cmluZywgQmFzaWNCbG9jazxhbnk+Pl17XG4gICAgbGV0IHN1Y2NzOiBNYXA8c3RyaW5nLCBzdHJpbmdbXT4gPSBuZXcgTWFwPHN0cmluZywgc3RyaW5nW10+KCk7XG4gICAgbGV0IHByZWRzOiBNYXA8c3RyaW5nLCBzdHJpbmdbXT4gPSBuZXcgTWFwPHN0cmluZywgc3RyaW5nW10+KCk7XG4gICAgbGV0IGJsb2NrTWFwcGluZzogTWFwPHN0cmluZywgQmFzaWNCbG9jazxhbnk+PiA9IG5ldyBNYXA8c3RyaW5nLCBCYXNpY0Jsb2NrPGFueT4+KCk7XG4gICAgYmFzaWNCbG9ja3MuZm9yRWFjaChiYXNpY0Jsb2NrPT57XG4gICAgICAgIGJsb2NrTWFwcGluZy5zZXQoYmFzaWNCbG9jay5sYWJlbCwgYmFzaWNCbG9jayk7XG4gICAgICAgIGNvbnN0IGxhc3RTdG10ID0gYmFzaWNCbG9jay5zdG10c1tiYXNpY0Jsb2NrLnN0bXRzLmxlbmd0aC0xXTtcbiAgICAgICAgaWYobGFzdFN0bXQgIT09IHVuZGVmaW5lZCAmJiBsYXN0U3RtdC50YWcgPT09IFwiaWZqbXBcIil7XG4gICAgICAgICAgICAvL0Fzc2lnbmluZyBzdWNjZXNzb3JzXG4gICAgICAgICAgICBpZiAoc3VjY3MuaGFzKGJhc2ljQmxvY2subGFiZWwpICYmICFzdWNjcy5nZXQoYmFzaWNCbG9jay5sYWJlbCkuaW5jbHVkZXMobGFzdFN0bXQudGhuKSlcbiAgICAgICAgICAgICAgICBzdWNjcy5zZXQoYmFzaWNCbG9jay5sYWJlbCwgWy4uLnN1Y2NzLmdldChiYXNpY0Jsb2NrLmxhYmVsKSwgbGFzdFN0bXQudGhuXSk7XG4gICAgICAgICAgICBlbHNlIGlmICghc3VjY3MuaGFzKGJhc2ljQmxvY2subGFiZWwpKVxuICAgICAgICAgICAgICAgIHN1Y2NzLnNldChiYXNpY0Jsb2NrLmxhYmVsLCBbbGFzdFN0bXQudGhuXSk7XG4gICAgICAgICAgICBcblxuICAgICAgICAgICAgaWYgKHN1Y2NzLmhhcyhiYXNpY0Jsb2NrLmxhYmVsKSAmJiAhc3VjY3MuZ2V0KGJhc2ljQmxvY2subGFiZWwpLmluY2x1ZGVzKGxhc3RTdG10LmVscykpXG4gICAgICAgICAgICAgICAgc3VjY3Muc2V0KGJhc2ljQmxvY2subGFiZWwsIFsuLi5zdWNjcy5nZXQoYmFzaWNCbG9jay5sYWJlbCksIGxhc3RTdG10LmVsc10pO1xuICAgICAgICAgICAgZWxzZSBpZiAoIXN1Y2NzLmhhcyhiYXNpY0Jsb2NrLmxhYmVsKSlcbiAgICAgICAgICAgICAgICBzdWNjcy5zZXQoYmFzaWNCbG9jay5sYWJlbCwgW2xhc3RTdG10LmVsc10pO1xuXG4gICAgICAgICAgICAvL0Fzc2lnbmluZyBwcmVkZWNlc3NvcnNcbiAgICAgICAgICAgIGlmKHByZWRzLmhhcyhsYXN0U3RtdC50aG4pICYmICFwcmVkcy5nZXQobGFzdFN0bXQudGhuKS5pbmNsdWRlcyhiYXNpY0Jsb2NrLmxhYmVsKSlcbiAgICAgICAgICAgICAgICBwcmVkcy5zZXQobGFzdFN0bXQudGhuLCBbLi4ucHJlZHMuZ2V0KGxhc3RTdG10LnRobiksIGJhc2ljQmxvY2subGFiZWxdKTtcbiAgICAgICAgICAgIGVsc2UgaWYgKCFwcmVkcy5oYXMobGFzdFN0bXQudGhuKSlcbiAgICAgICAgICAgICAgICBwcmVkcy5zZXQobGFzdFN0bXQudGhuLCBbYmFzaWNCbG9jay5sYWJlbF0pO1xuXG4gICAgICAgICAgICBpZihwcmVkcy5oYXMobGFzdFN0bXQuZWxzKSAmJiAhcHJlZHMuZ2V0KGxhc3RTdG10LmVscykuaW5jbHVkZXMoYmFzaWNCbG9jay5sYWJlbCkpXG4gICAgICAgICAgICAgICAgcHJlZHMuc2V0KGxhc3RTdG10LmVscywgWy4uLnByZWRzLmdldChsYXN0U3RtdC5lbHMpLCBiYXNpY0Jsb2NrLmxhYmVsXSk7XG4gICAgICAgICAgICBlbHNlIGlmICghcHJlZHMuaGFzKGxhc3RTdG10LmVscykpXG4gICAgICAgICAgICAgICAgcHJlZHMuc2V0KGxhc3RTdG10LmVscywgW2Jhc2ljQmxvY2subGFiZWxdKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChsYXN0U3RtdCAhPT0gdW5kZWZpbmVkICYmIGxhc3RTdG10LnRhZyA9PT0gXCJqbXBcIil7XG4gICAgICAgICAgICAvL0Fzc2lnbmluZyBzdWNjZXNzb3JzXG4gICAgICAgICAgICBpZiAoc3VjY3MuaGFzKGJhc2ljQmxvY2subGFiZWwpICYmICFzdWNjcy5nZXQoYmFzaWNCbG9jay5sYWJlbCkuaW5jbHVkZXMobGFzdFN0bXQubGJsKSlcbiAgICAgICAgICAgICAgICBzdWNjcy5zZXQoYmFzaWNCbG9jay5sYWJlbCwgWy4uLnN1Y2NzLmdldChiYXNpY0Jsb2NrLmxhYmVsKSwgbGFzdFN0bXQubGJsXSk7XG4gICAgICAgICAgICBlbHNlIGlmICghc3VjY3MuaGFzKGJhc2ljQmxvY2subGFiZWwpKVxuICAgICAgICAgICAgICAgIHN1Y2NzLnNldChiYXNpY0Jsb2NrLmxhYmVsLCBbbGFzdFN0bXQubGJsXSk7XG5cbiAgICAgICAgICAgIC8vQXNzaWduaW5nIHByZWRlY2Vzc29yc1xuICAgICAgICAgICAgaWYgKHByZWRzLmhhcyhsYXN0U3RtdC5sYmwpICYmICFwcmVkcy5nZXQobGFzdFN0bXQubGJsKS5pbmNsdWRlcyhiYXNpY0Jsb2NrLmxhYmVsKSlcbiAgICAgICAgICAgICAgICBwcmVkcy5zZXQobGFzdFN0bXQubGJsLCBbLi4ucHJlZHMuZ2V0KGxhc3RTdG10LmxibCksIGJhc2ljQmxvY2subGFiZWxdKTtcbiAgICAgICAgICAgIGVsc2UgaWYgKCFwcmVkcy5oYXMobGFzdFN0bXQubGJsKSlcbiAgICAgICAgICAgICAgICBwcmVkcy5zZXQobGFzdFN0bXQubGJsLCBbYmFzaWNCbG9jay5sYWJlbF0pO1xuICAgICAgICB9XG4gICAgfSk7XG4gICAgcmV0dXJuIFtwcmVkcywgc3VjY3MsIGJsb2NrTWFwcGluZ107XG5cbn1cblxuZnVuY3Rpb24gY29tcHV0ZUluaXRFbnYodmFyRGVmczogQXJyYXk8VmFySW5pdDxhbnk+PiwgZHVtbXlFbnY6IGJvb2xlYW4pOiBFbnZ7XG4gICAgdmFyIGVudjogRW52ID0ge3ZhcnM6IG5ldyBNYXA8c3RyaW5nLCBjb21waWxlVmFsPigpfTtcbiAgICB2YXJEZWZzLmZvckVhY2goZGVmID0+IHtcbiAgICAgICAgaWYgKCFkdW1teUVudilcbiAgICAgICAgICAgIGVudi52YXJzLnNldChkZWYubmFtZSwge3RhZzogXCJ2YWxcIiwgdmFsdWU6IGRlZi52YWx1ZX0pO1xuICAgICAgICBlbHNlXG4gICAgICAgICAgICBlbnYudmFycy5zZXQoZGVmLm5hbWUsIHt0YWc6IFwidW5kZWZcIn0pO1xuICAgIH0pO1xuICAgIHJldHVybiBlbnY7XG59XG5cbmZ1bmN0aW9uIG1lcmdlRW52aXJvbm1lbnQoYTogRW52LCBiOiBFbnYpOiBFbnZ7XG4gICAgdmFyIHJldHVybkVudjogRW52ID0ge3ZhcnM6IG5ldyBNYXA8c3RyaW5nLCBjb21waWxlVmFsPigpfTtcblxuICAgIGEudmFycy5mb3JFYWNoKChhVmFsdWU6IGNvbXBpbGVWYWwsIGtleTogc3RyaW5nKSA9PiB7XG4gICAgICAgIGNvbnN0IGJWYWx1ZTogY29tcGlsZVZhbCA9IGIudmFycy5nZXQoa2V5KTtcbiAgICAgICAgaWYgKGJWYWx1ZS50YWcgPT09IFwibmFjXCIgfHwgYVZhbHVlLnRhZyA9PT0gXCJuYWNcIilcbiAgICAgICAgICAgIHJldHVybkVudi52YXJzLnNldChrZXksIHt0YWc6IFwibmFjXCJ9KTtcbiAgICAgICAgZWxzZSBpZiAoYVZhbHVlLnRhZyA9PT0gXCJ1bmRlZlwiICYmIGJWYWx1ZS50YWcgPT09IFwidW5kZWZcIil7XG4gICAgICAgICAgICByZXR1cm5FbnYudmFycy5zZXQoa2V5LCB7dGFnOiBcInVuZGVmXCJ9KVxuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKGFWYWx1ZS50YWcgPT09IFwidW5kZWZcIil7XG4gICAgICAgICAgICByZXR1cm5FbnYudmFycy5zZXQoa2V5LCB7dGFnOiBcInZhbFwiLCB2YWx1ZTogYlZhbHVlLnZhbHVlfSlcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChiVmFsdWUudGFnID09PSBcInVuZGVmXCIpe1xuICAgICAgICAgICAgcmV0dXJuRW52LnZhcnMuc2V0KGtleSwge3RhZzogXCJ2YWxcIiwgdmFsdWU6IGFWYWx1ZS52YWx1ZX0pO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKGNoZWNrVmFsdWVFcXVhbGl0eShhVmFsdWUudmFsdWUsIGJWYWx1ZS52YWx1ZSkpXG4gICAgICAgICAgICByZXR1cm5FbnYudmFycy5zZXQoa2V5LCB7dGFnOiBcInZhbFwiLCB2YWx1ZTogYVZhbHVlLnZhbHVlfSk7XG4gICAgICAgIGVsc2VcbiAgICAgICAgICAgIHJldHVybkVudi52YXJzLnNldChrZXksIHt0YWc6IFwibmFjXCJ9KTtcbiAgICB9KTtcblxuICAgIHJldHVybiByZXR1cm5FbnY7XG59XG5cbmZ1bmN0aW9uIHVwZGF0ZUVudmlyb25tZW50QnlCbG9jayhpbkVudjogRW52LCBibG9jazogQmFzaWNCbG9jazxhbnk+KTogRW52e1xuICAgIHZhciBvdXRFbnY6IEVudiA9IHt2YXJzOiBuZXcgTWFwKGluRW52LnZhcnMpfTtcbiAgICBibG9jay5zdG10cy5mb3JFYWNoKHN0YXRlbWVudCA9PiB7XG4gICAgICAgIGlmIChzdGF0ZW1lbnQgPT09IHVuZGVmaW5lZCkgeyBjb25zb2xlLmxvZyhibG9jay5zdG10cyk7IH1cbiAgICAgICAgaWYgKHN0YXRlbWVudC50YWcgPT09IFwiYXNzaWduXCIpe1xuICAgICAgICAgICAgY29uc3Qgb3B0aW1pemVkRXhwcmVzc2lvbiA9IG9wdGltaXplRXhwcmVzc2lvbihzdGF0ZW1lbnQudmFsdWUsIG91dEVudik7XG4gICAgICAgICAgICBpZiAob3B0aW1pemVkRXhwcmVzc2lvbi50YWcgPT09IFwidmFsdWVcIil7XG4gICAgICAgICAgICAgICAgaWYgKG9wdGltaXplZEV4cHJlc3Npb24udmFsdWUudGFnID09PSBcImlkXCIpe1xuICAgICAgICAgICAgICAgICAgICBvdXRFbnYudmFycy5zZXQoc3RhdGVtZW50Lm5hbWUsIHt0YWc6IFwibmFjXCJ9KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZXtcbiAgICAgICAgICAgICAgICAgICAgb3V0RW52LnZhcnMuc2V0KHN0YXRlbWVudC5uYW1lLCB7dGFnOiBcInZhbFwiLCB2YWx1ZTogb3B0aW1pemVkRXhwcmVzc2lvbi52YWx1ZX0pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2V7XG4gICAgICAgICAgICAgICAgb3V0RW52LnZhcnMuc2V0KHN0YXRlbWVudC5uYW1lLCB7dGFnOiBcIm5hY1wifSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9KTtcbiAgICByZXR1cm4gb3V0RW52O1xufVxuXG5mdW5jdGlvbiBkdXBsaWNhdGVFbnYoZW52OiBFbnYpOiBFbnZ7XG4gICAgcmV0dXJuIHt2YXJzOiBuZXcgTWFwKGVudi52YXJzKX07XG59XG5cbmZ1bmN0aW9uIGFkZFBhcmFtc1RvRW52KHBhcmFtczogQXJyYXk8UGFyYW1ldGVyPGFueT4+LCBlbnY6IEVudiwgZHVtbXlFbnY6IGJvb2xlYW4pe1xuICAgIHBhcmFtcy5mb3JFYWNoKHAgPT4ge1xuICAgICAgICBpZiAoZHVtbXlFbnYpe1xuICAgICAgICAgICAgZW52LnZhcnMuc2V0KHAubmFtZSwge3RhZzogXCJ1bmRlZlwifSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZXtcbiAgICAgICAgICAgIGVudi52YXJzLnNldChwLm5hbWUsIHt0YWc6IFwibmFjXCJ9KTtcbiAgICAgICAgfVxuICAgIH0pO1xufVxuXG5mdW5jdGlvbiBvcHRpbWl6ZUJsb2NrKGJsb2NrOiBCYXNpY0Jsb2NrPGFueT4sIGVudjogRW52KTogW0Jhc2ljQmxvY2s8YW55PiwgYm9vbGVhbl17XG4gICAgdmFyIGJsb2NrT3B0aW1pemVkOiBib29sZWFuID0gZmFsc2U7XG4gICAgdmFyIG5ld1N0bXRzOiBTdG10PGFueT5bXSA9IGJsb2NrLnN0bXRzLm1hcChzID0+IHtcbiAgICAgICAgdmFyIG9wdGltaXplZHN0YXRlbWVudCA9IG9wdGltaXplU3RhdGVtZW50cyhzLCBlbnYpO1xuICAgICAgICBpZiAoIWJsb2NrT3B0aW1pemVkICYmICFjaGVja1N0bXRFcXVhbGl0eShvcHRpbWl6ZWRzdGF0ZW1lbnQsIHMpKSBibG9ja09wdGltaXplZCA9IHRydWU7XG4gICAgICAgIHJldHVybiBvcHRpbWl6ZWRzdGF0ZW1lbnQ7XG4gICAgfSk7XG4gICAgcmV0dXJuIFt7Li4uYmxvY2ssIHN0bXRzOiBuZXdTdG10c30sIGJsb2NrT3B0aW1pemVkXTtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIG9wdGltaXplRnVuY3Rpb24oZnVuYzogRnVuRGVmPGFueT4pOiBGdW5EZWY8YW55PntcbiAgICB2YXIgW2luRW52TWFwcGluZywgX291dEVudk1hcHBpbmddOiBbTWFwPHN0cmluZywgRW52PiwgTWFwPHN0cmluZywgRW52Pl0gPSBnZW5lcmF0ZUVudmlyb25tZW50RnVuY3Rpb25zKGZ1bmMpO1xuXG4gICAgdmFyIGZ1bmN0aW9uT3B0aW1pemVkOiBib29sZWFuID0gZmFsc2U7XG4gICAgLy9Xcml0ZSBjb2RlIHRvIG9wdGltaXplIGZ1bmN0aW9ucyBoZXJlXG4gICAgdmFyIG5ld0JvZHk6IEFycmF5PEJhc2ljQmxvY2s8YW55Pj4gPSBmdW5jLmJvZHkubWFwKGIgPT4ge1xuICAgICAgICB2YXIgdGVtcEJsb2NrRW52OiBFbnYgPSBkdXBsaWNhdGVFbnYoaW5FbnZNYXBwaW5nLmdldChiLmxhYmVsKSk7XG4gICAgICAgIHZhciBbb3B0aW1pemVkQmxvY2ssIGJsb2NrT3B0aW1pemVkXTogW0Jhc2ljQmxvY2s8YW55PiwgYm9vbGVhbl0gPSBvcHRpbWl6ZUJsb2NrKGIsIHRlbXBCbG9ja0Vudik7XG4gICAgICAgIGlmICghZnVuY3Rpb25PcHRpbWl6ZWQgJiYgYmxvY2tPcHRpbWl6ZWQpIGZ1bmN0aW9uT3B0aW1pemVkID0gdHJ1ZTtcbiAgICAgICAgcmV0dXJuIG9wdGltaXplZEJsb2NrO1xuICAgIH0pO1xuXG4gICAgLyogTk9URShqb2UpOiB0YWtpbmcgb3V0IGFsbCByZWN1cnNpdmUgb3B0aW1pemF0aW9uIGJlY2F1c2UgdGhlcmUgaXMgbm8gZWFzeVxuICAgICAqIHdheSB0byBhZGQgZmFsbHRocm91Z2ggY2FzZXMgYWJvdmUgKi9cbiAgICAvLyBpZiAoZnVuY3Rpb25PcHRpbWl6ZWQpIHJldHVybiBvcHRpbWl6ZUZ1bmN0aW9uKHsuLi5mdW5jLCBib2R5OiBuZXdCb2R5fSlcblxuICAgIHJldHVybiB7Li4uZnVuYywgYm9keTogbmV3Qm9keX07XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBvcHRpbWl6ZUNsYXNzKGM6IENsYXNzPGFueT4pOiBDbGFzczxhbnk+e1xuICAgIHZhciBvcHRpbWl6ZWRNZXRob2RzOiBBcnJheTxGdW5EZWY8YW55Pj4gPSBjLm1ldGhvZHMubWFwKG0gPT4ge1xuICAgICAgICByZXR1cm4gb3B0aW1pemVGdW5jdGlvbihtKTtcbiAgICB9KVxuICAgIHJldHVybiB7Li4uYywgbWV0aG9kczogb3B0aW1pemVkTWV0aG9kc307XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBnZW5lcmF0ZUVudmlyb25tZW50UHJvZ3JhbShwcm9ncmFtOiBQcm9ncmFtPGFueT4pOiBbTWFwPHN0cmluZywgRW52PiwgTWFwPHN0cmluZywgRW52Pl17XG4gICAgdmFyIGluaXRpYWxFbnYgPSBjb21wdXRlSW5pdEVudihwcm9ncmFtLmluaXRzLCBmYWxzZSk7XG5cbiAgICB2YXIgaW5FbnZNYXBwaW5nOiBNYXA8c3RyaW5nLCBFbnY+ID0gbmV3IE1hcDxzdHJpbmcsIEVudj4oKTtcbiAgICB2YXIgb3V0RW52TWFwcGluZzogTWFwPHN0cmluZywgRW52PiA9IG5ldyBNYXA8c3RyaW5nLCBFbnY+KCk7XG5cbiAgICB2YXIgZHVtbXlFbnYgPSBjb21wdXRlSW5pdEVudihwcm9ncmFtLmluaXRzLCB0cnVlKTtcblxuICAgIHByb2dyYW0uYm9keS5mb3JFYWNoKGYgPT4ge1xuICAgICAgICBpbkVudk1hcHBpbmcuc2V0KGYubGFiZWwsIGR1cGxpY2F0ZUVudihkdW1teUVudikpO1xuICAgICAgICBvdXRFbnZNYXBwaW5nLnNldChmLmxhYmVsLCBkdXBsaWNhdGVFbnYoZHVtbXlFbnYpKTtcbiAgICB9KTtcblxuICAgIHZhciBbcHJlZHMsIHN1Y2NzLCBibG9ja01hcHBpbmddOiBbTWFwPHN0cmluZywgc3RyaW5nW10+LCBNYXA8c3RyaW5nLCBzdHJpbmdbXT4sIE1hcDxzdHJpbmcsIEJhc2ljQmxvY2s8YW55Pj5dID0gY29tcHV0ZVByZWRlY2Vzc29yU3VjY2Vzc29yKHByb2dyYW0uYm9keSk7XG5cbiAgICBwcmVkcy5zZXQocHJvZ3JhbS5ib2R5WzBdLmxhYmVsLCBbXCJWRFwiXSk7XG4gICAgc3VjY3Muc2V0KFwiVkRcIiwgW3Byb2dyYW0uYm9keVswXS5sYWJlbF0pO1xuICAgIG91dEVudk1hcHBpbmcuc2V0KFwiVkRcIiwgaW5pdGlhbEVudik7XG5cbiAgICBnZW5lcmF0ZUVudmlyb25tZW50cyhbcHJvZ3JhbS5ib2R5WzBdLmxhYmVsXSwgaW5FbnZNYXBwaW5nLCBvdXRFbnZNYXBwaW5nLCBwcmVkcywgc3VjY3MsIGJsb2NrTWFwcGluZyk7XG5cbiAgICByZXR1cm4gW2luRW52TWFwcGluZywgb3V0RW52TWFwcGluZ107XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBnZW5lcmF0ZUVudmlyb25tZW50RnVuY3Rpb25zKGZ1bmM6IEZ1bkRlZjxhbnk+KTogW01hcDxzdHJpbmcsIEVudj4sIE1hcDxzdHJpbmcsIEVudj5de1xuICAgIHZhciBpbml0aWFsRW52ICA9IGNvbXB1dGVJbml0RW52KGZ1bmMuaW5pdHMsIGZhbHNlKTtcbiAgICBhZGRQYXJhbXNUb0VudihmdW5jLnBhcmFtZXRlcnMsIGluaXRpYWxFbnYsIGZhbHNlKTtcblxuICAgIHZhciBpbkVudk1hcHBpbmc6IE1hcDxzdHJpbmcsIEVudj4gPSBuZXcgTWFwPHN0cmluZywgRW52PigpO1xuICAgIHZhciBvdXRFbnZNYXBwaW5nOiBNYXA8c3RyaW5nLCBFbnY+ID0gbmV3IE1hcDxzdHJpbmcsIEVudj4oKTtcblxuICAgIHZhciBkdW1teUVudiA9IGNvbXB1dGVJbml0RW52KGZ1bmMuaW5pdHMsIHRydWUpO1xuICAgIGFkZFBhcmFtc1RvRW52KGZ1bmMucGFyYW1ldGVycywgaW5pdGlhbEVudiwgdHJ1ZSk7XG5cbiAgICBmdW5jLmJvZHkuZm9yRWFjaChmID0+IHtcbiAgICAgICAgaW5FbnZNYXBwaW5nLnNldChmLmxhYmVsLCBkdXBsaWNhdGVFbnYoZHVtbXlFbnYpKTtcbiAgICAgICAgb3V0RW52TWFwcGluZy5zZXQoZi5sYWJlbCwgZHVwbGljYXRlRW52KGR1bW15RW52KSk7XG4gICAgfSk7XG5cbiAgICBpbkVudk1hcHBpbmcuc2V0KGZ1bmMuYm9keVswXS5sYWJlbCwgaW5pdGlhbEVudik7XG5cbiAgICB2YXIgW3ByZWRzLCBzdWNjcywgYmxvY2tNYXBwaW5nXTogW01hcDxzdHJpbmcsIHN0cmluZ1tdPiwgTWFwPHN0cmluZywgc3RyaW5nW10+LCBNYXA8c3RyaW5nLCBCYXNpY0Jsb2NrPGFueT4+XSA9IGNvbXB1dGVQcmVkZWNlc3NvclN1Y2Nlc3NvcihmdW5jLmJvZHkpO1xuXG4gICAgcHJlZHMuc2V0KGZ1bmMuYm9keVswXS5sYWJlbCwgW1wiVkRcIl0pO1xuICAgIHN1Y2NzLnNldChcIlZEXCIsIFtmdW5jLmJvZHlbMF0ubGFiZWxdKTtcbiAgICBvdXRFbnZNYXBwaW5nLnNldChcIlZEXCIsIGluaXRpYWxFbnYpO1xuICAgIFxuICAgIGdlbmVyYXRlRW52aXJvbm1lbnRzKFtmdW5jLmJvZHlbMF0ubGFiZWxdLCBpbkVudk1hcHBpbmcsIG91dEVudk1hcHBpbmcsIHByZWRzLCBzdWNjcywgYmxvY2tNYXBwaW5nKTtcblxuICAgIHJldHVybiBbaW5FbnZNYXBwaW5nLCBvdXRFbnZNYXBwaW5nXTtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIG9wdGltaXplUHJvZ3JhbShwcm9ncmFtOiBQcm9ncmFtPGFueT4pOiBQcm9ncmFtPGFueT57XG5cbiAgICB2YXIgW2luRW52TWFwcGluZywgX291dEVudk1hcHBpbmddOiBbTWFwPHN0cmluZywgRW52PiwgTWFwPHN0cmluZywgRW52Pl0gPSBnZW5lcmF0ZUVudmlyb25tZW50UHJvZ3JhbShwcm9ncmFtKTtcblxuICAgIC8vV3JpdGUgY29kZSB0byBvcHRpbWl6ZSB0aGUgcHJvZ3JhbSB1c2luZyB0aGUgZW52aXJvbm1lbnRcbiAgICB2YXIgcHJvZ3JhbU9wdGltaXplZDogYm9vbGVhbiA9IGZhbHNlO1xuICAgIHZhciBuZXdCb2R5OiBBcnJheTxCYXNpY0Jsb2NrPGFueT4+ID0gcHJvZ3JhbS5ib2R5Lm1hcChiID0+IHtcbiAgICAgICAgdmFyIHRlbXBCbG9ja0VudjogRW52ID0gZHVwbGljYXRlRW52KGluRW52TWFwcGluZy5nZXQoYi5sYWJlbCkpO1xuICAgICAgICB2YXIgW29wdGltaXplZEJsb2NrLCBibG9ja09wdGltaXplZF06IFtCYXNpY0Jsb2NrPGFueT4sIGJvb2xlYW5dID0gb3B0aW1pemVCbG9jayhiLCB0ZW1wQmxvY2tFbnYpO1xuICAgICAgICBpZiAoIXByb2dyYW1PcHRpbWl6ZWQgJiYgYmxvY2tPcHRpbWl6ZWQpIHByb2dyYW1PcHRpbWl6ZWQgPSB0cnVlO1xuICAgICAgICByZXR1cm4gb3B0aW1pemVkQmxvY2s7XG4gICAgfSk7XG4gICAgLyogTk9URShqb2UpOiB0dXJuaW5nIHRoaXMgb2ZmOyBpdCAoYSkgZG9lc24ndCBoYXZlIGZhbGx0aHJvdWdoIGNhc2VzIGZvciBuZXdcbiAgICAgKiBleHByZXNzaW9ucyBhbmQgKGIpIHdoZW4gSSBhZGQgZmFsbHRocm91Z2ggY2FzZXMsIGl0IHN0YWNrLW92ZXJmbG93cyAqL1xuICAgIC8vaWYgKHByb2dyYW1PcHRpbWl6ZWQpIHByb2dyYW0gPSBvcHRpbWl6ZVByb2dyYW0oey4uLnByb2dyYW0sIGJvZHk6IG5ld0JvZHl9KTtcblxuICAgIHZhciBuZXdDbGFzczogQXJyYXk8Q2xhc3M8YW55Pj4gPSBwcm9ncmFtLmNsYXNzZXMubWFwKGMgPT4ge1xuICAgICAgICByZXR1cm4gb3B0aW1pemVDbGFzcyhjKTtcbiAgICB9KTtcblxuICAgIHZhciBuZXdGdW5jdGlvbnM6IEFycmF5PEZ1bkRlZjxhbnk+PiA9IHByb2dyYW0uZnVucy5tYXAoZiA9PiB7XG4gICAgICAgIHJldHVybiBvcHRpbWl6ZUZ1bmN0aW9uKGYpO1xuICAgIH0pO1xuXG4gICAgcmV0dXJuIHsuLi5wcm9ncmFtLCBib2R5OiBuZXdCb2R5LCBjbGFzc2VzOiBuZXdDbGFzcywgZnVuczogbmV3RnVuY3Rpb25zfTtcbn1cblxuZnVuY3Rpb24gbWVyZ2VBbGxQcmVkcyhwcmVkZWNlc3NvckJsb2NrczogQXJyYXk8c3RyaW5nPiwgb3V0RW52TWFwcGluZzogTWFwPHN0cmluZywgRW52Pik6IEVudntcbiAgICBpZiAocHJlZGVjZXNzb3JCbG9ja3MubGVuZ3RoID09PSAwKXtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBDb21waWxlRXJyb3I6IEJsb2NrIHdpdGggcHJlZGVjZXNzb3JzYCk7XG4gICAgfVxuICAgIHZhciBpbkVudjogRW52ID0gb3V0RW52TWFwcGluZy5nZXQocHJlZGVjZXNzb3JCbG9ja3NbMF0pO1xuICAgIFxuICAgIHByZWRlY2Vzc29yQmxvY2tzLnNsaWNlKDEpLmZvckVhY2goYiA9PiB7XG4gICAgICAgIGluRW52ID0gbWVyZ2VFbnZpcm9ubWVudChpbkVudiwgb3V0RW52TWFwcGluZy5nZXQoYikpO1xuICAgIH0pO1xuICAgIFxuICAgIHJldHVybiBpbkVudjtcbn1cblxuZnVuY3Rpb24gY2hlY2tFbnZFcXVhbGl0eShhOiBFbnYsIGI6IEVudik6IGJvb2xlYW57XG4gICAgXG4gICAgY29uc3QgYVZhcnMgPSBhLnZhcnM7XG4gICAgY29uc3QgYlZhcnMgPSBiLnZhcnM7XG5cbiAgICBmb3IgKGNvbnN0IGtleSBvZiBhVmFycy5rZXlzKCkpe1xuICAgICAgICBjb25zdCBhVmFsdWUgPSBhVmFycy5nZXQoa2V5KTtcbiAgICAgICAgY29uc3QgYlZhbHVlID0gYlZhcnMuZ2V0KGtleSk7XG4gICAgICAgIFxuICAgICAgICBpZiAoIWNoZWNrQ29tcGlsZVZhbEVxdWFsaXR5KGFWYWx1ZSwgYlZhbHVlKSkgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICByZXR1cm4gdHJ1ZTtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGdlbmVyYXRlRW52aXJvbm1lbnRzKHdvcmtMaXN0OiBBcnJheTxzdHJpbmc+LCBpbkVudk1hcHBpbmc6IE1hcDxzdHJpbmcsIEVudj4sIG91dEVudk1hcHBpbmc6IE1hcDxzdHJpbmcsIEVudj4sIHByZWRzOiBNYXA8c3RyaW5nLCBzdHJpbmdbXT4sIHN1Y2NzOiBNYXA8c3RyaW5nLCBzdHJpbmdbXT4sIGJsb2NrTWFwcGluZzogTWFwPHN0cmluZywgQmFzaWNCbG9jazxhbnk+Pil7XG4gICAgaWYgKHdvcmtMaXN0Lmxlbmd0aCA9PT0gMClcbiAgICAgICAgcmV0dXJuO1xuICAgIGNvbnN0IGN1cnJCbG9jazogc3RyaW5nID0gd29ya0xpc3QucG9wKCk7XG4gICAgY29uc3QgbmV3SW5FbnY6IEVudiA9IG1lcmdlQWxsUHJlZHMocHJlZHMuZ2V0KGN1cnJCbG9jayksIG91dEVudk1hcHBpbmcpO1xuICAgIGlmIChjaGVja0VudkVxdWFsaXR5KGluRW52TWFwcGluZy5nZXQoY3VyckJsb2NrKSwgbmV3SW5FbnYpKXtcbiAgICAgICAgZ2VuZXJhdGVFbnZpcm9ubWVudHMod29ya0xpc3QsIGluRW52TWFwcGluZywgb3V0RW52TWFwcGluZywgcHJlZHMsIHN1Y2NzLCBibG9ja01hcHBpbmcpO1xuICAgICAgICByZXR1cm47XG4gICAgfVxuICAgIGluRW52TWFwcGluZy5zZXQoY3VyckJsb2NrLCBuZXdJbkVudik7XG4gICAgb3V0RW52TWFwcGluZy5zZXQoY3VyckJsb2NrLCB1cGRhdGVFbnZpcm9ubWVudEJ5QmxvY2sobmV3SW5FbnYsIGJsb2NrTWFwcGluZy5nZXQoY3VyckJsb2NrKSkpO1xuICAgIFxuICAgIGNvbnN0IHdsQWRkaXRpb246IHN0cmluZ1tdID0gKHN1Y2NzLmdldChjdXJyQmxvY2spID09PSB1bmRlZmluZWQpPyhbXSk6KHN1Y2NzLmdldChjdXJyQmxvY2spKTtcbiAgICBnZW5lcmF0ZUVudmlyb25tZW50cyhbLi4ud29ya0xpc3QsIC4uLndsQWRkaXRpb25dLCBpbkVudk1hcHBpbmcsIG91dEVudk1hcHBpbmcsIHByZWRzLCBzdWNjcywgYmxvY2tNYXBwaW5nKTtcblxuICAgIHJldHVybjtcbn1cbiIsImltcG9ydCB7IEV4cHIsIFN0bXQsIFZhbHVlIH0gZnJvbSBcIi4vaXJcIjtcbmltcG9ydCB7IFR5cGUgfSBmcm9tIFwiLi9hc3RcIjtcbmltcG9ydCB7IGNvbXBpbGVWYWwgfSBmcm9tIFwiLi9vcHRpbWl6YXRpb25cIjtcblxuZXhwb3J0IGZ1bmN0aW9uIGlzVGFnSWQodmFsdWU6IFZhbHVlPGFueT4pOiB2YWx1ZSBpcyB7IHRhZzogXCJpZFwiLCAgbmFtZTogc3RyaW5nLCBhPzogYW55fSB7XG4gICAgcmV0dXJuIHZhbHVlLnRhZyA9PT0gXCJpZFwiO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gaXNUYWdOb25lKHZhbHVlOiBWYWx1ZTxhbnk+KTogdmFsdWUgaXMgeyB0YWc6IFwibm9uZVwiLCBhPzogYW55fSB7XG4gICAgcmV0dXJuIHZhbHVlLnRhZyA9PT0gXCJub25lXCI7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBpc1RhZ0Jvb2xlYW4odmFsdWU6IFZhbHVlPGFueT4pOiB2YWx1ZSBpcyB7IHRhZzogXCJib29sXCIsIHZhbHVlOiBib29sZWFuLCBhPzogYW55fSB7XG4gICAgcmV0dXJuIHZhbHVlLnRhZyA9PT0gXCJib29sXCI7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBpc1RhZ0JpZ0ludCh2YWx1ZTogVmFsdWU8YW55Pik6IHZhbHVlIGlzIHsgdGFnOiBcIm51bVwiLCB2YWx1ZTogYmlnaW50LCBhPzogYW55fSB7XG4gICAgcmV0dXJuIHZhbHVlLnRhZyA9PT0gXCJudW1cIjtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGlzVGFnTnVtYmVyKHZhbHVlOiBWYWx1ZTxhbnk+KTogdmFsdWUgaXMgeyB0YWc6IFwid2FzbWludFwiLCB2YWx1ZTogbnVtYmVyLCBhPzogYW55fSB7XG4gICAgcmV0dXJuIHZhbHVlLnRhZyA9PT0gXCJ3YXNtaW50XCI7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBpc1RhZ0VxdWFsKGE6IFZhbHVlPGFueT4sIGI6IFZhbHVlPGFueT4pOiBib29sZWFuIHtcbiAgICBpZihpc1RhZ0JpZ0ludChhKSAmJiBpc1RhZ0JpZ0ludChiKSB8fCBpc1RhZ0Jvb2xlYW4oYSkgJiYgaXNUYWdCb29sZWFuKGIpIHx8IGlzVGFnTm9uZShhKSAmJiBpc1RhZ05vbmUoYikpXG4gICAgICAgIHJldHVybiB0cnVlXG4gICAgZWxzZVxuICAgICAgICByZXR1cm4gZmFsc2Vcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGNoZWNrVmFsdWVFcXVhbGl0eShhOiBWYWx1ZTxhbnk+LCBiOiBWYWx1ZTxhbnk+KTogYm9vbGVhbntcbiAgICBpZiAoYS50YWcgIT09IGIudGFnKVxuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgZWxzZSBpZiAoYS50YWcgPT09IFwibm9uZVwiIHx8IGIudGFnID09PSBcIm5vbmVcIilcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgZWxzZSBpZiAoYS50YWcgPT09IFwiaWRcIiB8fCBiLnRhZyA9PT0gXCJpZFwiKXtcbiAgICAgICAgaWYgKGIudGFnICE9PSBcImlkXCIgfHwgYS50YWcgIT09IGIudGFnKSB0aHJvdyBuZXcgRXJyb3IoYENvbXBpbGVyIEVycm9yIWApOyAvL1dpbGwgbmV2ZXIgYmUgZXhlY3V0ZWQgKHRvIGNvbnZpbmNlIHR5cGVzY3JpcHQpXG4gICAgICAgIGlmIChhLm5hbWUgPT09IGIubmFtZSkgcmV0dXJuIHRydWU7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgZWxzZSBpZiAoYS52YWx1ZSA9PT0gYi52YWx1ZSlcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgcmV0dXJuIGZhbHNlO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gY2hlY2tDb21waWxlVmFsRXF1YWxpdHkoYTogY29tcGlsZVZhbCwgYjogY29tcGlsZVZhbCk6IGJvb2xlYW57XG4gICAgaWYgKGEudGFnICE9PSBiLnRhZylcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIGlmIChhLnRhZyA9PT0gXCJ2YWxcIil7XG4gICAgICAgIHJldHVybiBjaGVja1ZhbHVlRXF1YWxpdHkoYS52YWx1ZSwgYi52YWx1ZSk7XG4gICAgfVxuICAgIHJldHVybiB0cnVlO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gY2hlY2tFeHByRXF1YWxpdHkoYTogRXhwcjxhbnk+LCBiOiBFeHByPGFueT4pOiBib29sZWFue1xuICAgIGlmIChhLnRhZyAhPT0gYi50YWcpXG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICBzd2l0Y2goYS50YWcpe1xuICAgICAgICBjYXNlIFwidmFsdWVcIjpcbiAgICAgICAgICAgIGlmIChiLnRhZyAhPT0gXCJ2YWx1ZVwiKSB0aHJvdyBuZXcgRXJyb3IoYENvbXBpbGVyIEVycm9yIWApOyAvL1dpbGwgbmV2ZXIgYmUgZXhlY3V0ZWQsIHNhbml0eSBjaGVja1xuICAgICAgICAgICAgcmV0dXJuIGNoZWNrVmFsdWVFcXVhbGl0eShhLnZhbHVlLCBiLnZhbHVlKTtcbiAgICAgICAgY2FzZSBcImJpbm9wXCI6XG4gICAgICAgICAgICBpZiAoYi50YWcgIT09IFwiYmlub3BcIikgdGhyb3cgbmV3IEVycm9yKGBDb21waWxlciBFcnJvciFgKTsgLy9XaWxsIG5ldmVyIGJlIGV4ZWN1dGVkLCBzYW5pdHkgY2hlY2tcbiAgICAgICAgICAgIGlmIChhLm9wICE9PSBiLm9wKSByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICByZXR1cm4gY2hlY2tWYWx1ZUVxdWFsaXR5KGEubGVmdCwgYi5sZWZ0KSAmJiBjaGVja1ZhbHVlRXF1YWxpdHkoYS5yaWdodCwgYi5yaWdodCk7XG4gICAgICAgIGNhc2UgXCJ1bmlvcFwiOlxuICAgICAgICAgICAgaWYgKGIudGFnICE9PSBcInVuaW9wXCIpIHRocm93IG5ldyBFcnJvcihgQ29tcGlsZXIgRXJyb3IhYCk7IC8vV2lsbCBuZXZlciBiZSBleGVjdXRlZCwgc2FuaXR5IGNoZWNrXG4gICAgICAgICAgICBpZiAoYS5vcCAhPT0gYi5vcCkgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgcmV0dXJuIGNoZWNrVmFsdWVFcXVhbGl0eShhLmV4cHIsIGIuZXhwcik7XG4gICAgICAgIGNhc2UgXCJidWlsdGluMVwiOlxuICAgICAgICAgICAgaWYgKGIudGFnICE9PSBcImJ1aWx0aW4xXCIpIHRocm93IG5ldyBFcnJvcihgQ29tcGlsZXIgRXJyb3IhYCk7IC8vV2lsbCBuZXZlciBiZSBleGVjdXRlZCwgc2FudGl5IGNoZWNrXG4gICAgICAgICAgICBpZiAoYS5uYW1lICE9PSBiLm5hbWUpIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgIHJldHVybiBjaGVja1ZhbHVlRXF1YWxpdHkoYS5hcmcsIGIuYXJnKTtcbiAgICAgICAgY2FzZSBcImJ1aWx0aW4yXCI6XG4gICAgICAgICAgICBpZiAoYi50YWcgIT09IFwiYnVpbHRpbjJcIikgdGhyb3cgbmV3IEVycm9yKGBDb21waWxlciBFcnJvciFgKTsgLy9XaWxsIG5ldmVyIGJlIGV4ZWN1dGVkLCBzYW5pdHkgY2hlY2tcbiAgICAgICAgICAgIGlmIChhLm5hbWUgIT09IGIubmFtZSkgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgcmV0dXJuIGNoZWNrVmFsdWVFcXVhbGl0eShhLmxlZnQsIGIubGVmdCkgJiYgY2hlY2tWYWx1ZUVxdWFsaXR5KGEucmlnaHQsIGIucmlnaHQpO1xuICAgICAgICBjYXNlIFwiY2FsbFwiOlxuICAgICAgICAgICAgaWYgKGIudGFnICE9PSBcImNhbGxcIikgdGhyb3cgbmV3IEVycm9yKGBDb21waWxlciBFcnJvciFgKTsgLy9XaWxsIG5ldmVyIGJlIGV4ZWN1dGVkLCBzYW5pdHkgY2hlY2tcbiAgICAgICAgICAgIGlmIChhLm5hbWUgIT09IGIubmFtZSB8fCBhLmFyZ3VtZW50cy5sZW5ndGggIT09IGIuYXJndW1lbnRzLmxlbmd0aCkgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgZm9yIChsZXQgaW5kZXggPSAwOyBpbmRleCA8IGEuYXJndW1lbnRzLmxlbmd0aDsgaW5kZXgrKyl7XG4gICAgICAgICAgICAgICAgY29uc3QgYXJnQSA9IGEuYXJndW1lbnRzW2luZGV4XTtcbiAgICAgICAgICAgICAgICBjb25zdCBhcmdCID0gYi5hcmd1bWVudHNbaW5kZXhdO1xuICAgICAgICAgICAgICAgIGlmICghY2hlY2tWYWx1ZUVxdWFsaXR5KGFyZ0EsIGFyZ0IpKSByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgY2FzZSBcImFsbG9jXCI6XG4gICAgICAgICAgICBpZiAoYi50YWcgIT09IFwiYWxsb2NcIikgdGhyb3cgbmV3IEVycm9yKGBDb21waWxlciBFcnJvciFgKTsgLy9XaWxsIG5ldmVyIGJlIGV4ZWN1dGVkLCBzYW5pdHkgY2hlY2tcbiAgICAgICAgICAgIHJldHVybiBjaGVja1ZhbHVlRXF1YWxpdHkoYS5hbW91bnQsIGIuYW1vdW50KTtcbiAgICAgICAgY2FzZSBcImxvYWRcIjpcbiAgICAgICAgICAgIGlmIChiLnRhZyAhPT0gXCJsb2FkXCIpIHRocm93IG5ldyBFcnJvcihgQ29tcGlsZXIgRXJyb3IhYCk7IC8vV2lsbCBuZXZlciBiZSBleGVjdXRlZCwgc2FuaXR5IGNoZWNrXG4gICAgICAgICAgICByZXR1cm4gY2hlY2tWYWx1ZUVxdWFsaXR5KGEuc3RhcnQsIGIuc3RhcnQpICYmIGNoZWNrVmFsdWVFcXVhbGl0eShhLm9mZnNldCwgYi5vZmZzZXQpO1xuICAgIH1cbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGNoZWNrU3RtdEVxdWFsaXR5KGE6IFN0bXQ8YW55PiwgYjogU3RtdDxhbnk+KTogYm9vbGVhbntcbiAgICBpZiAoYS50YWcgIT09IGIudGFnKVxuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgc3dpdGNoKGEudGFnKXtcbiAgICAgICAgY2FzZSBcImFzc2lnblwiOlxuICAgICAgICAgICAgaWYgKGIudGFnICE9PSBcImFzc2lnblwiKSB0aHJvdyBuZXcgRXJyb3IoYENvbXBpbGVyIEVycm9yIWApOyAvL1dpbGwgbmV2ZXIgYmUgZXhlY3V0ZWQsIHNhbml0eSBjaGVja1xuICAgICAgICAgICAgaWYgKGEubmFtZSAhPT0gYi5uYW1lKSByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICByZXR1cm4gY2hlY2tFeHByRXF1YWxpdHkoYS52YWx1ZSwgYi52YWx1ZSk7XG4gICAgICAgIGNhc2UgXCJyZXR1cm5cIjpcbiAgICAgICAgICAgIGlmIChiLnRhZyAhPT0gXCJyZXR1cm5cIikgdGhyb3cgbmV3IEVycm9yKGBDb21waWxlciBFcnJvciFgKTsgLy9XaWxsIG5ldmVyIGJlIGV4ZWN1dGVkLCBzYW5pdHkgY2hlY2tcbiAgICAgICAgICAgIHJldHVybiBjaGVja1ZhbHVlRXF1YWxpdHkoYS52YWx1ZSwgYi52YWx1ZSk7XG4gICAgICAgIGNhc2UgXCJleHByXCI6XG4gICAgICAgICAgICBpZiAoYi50YWcgIT09IFwiZXhwclwiKSB0aHJvdyBuZXcgRXJyb3IoYENvbXBpbGVyIEVycm9yIWApOyAvL1dpbGwgbmV2ZXIgYmUgZXhlY3V0ZWQsIHNhbml0eSBjaGVja1xuICAgICAgICAgICAgcmV0dXJuIGNoZWNrRXhwckVxdWFsaXR5KGEuZXhwciwgYi5leHByKTtcbiAgICAgICAgY2FzZSBcInBhc3NcIjpcbiAgICAgICAgICAgIGlmIChiLnRhZyAhPT0gXCJwYXNzXCIpIHRocm93IG5ldyBFcnJvcihgQ29tcGlsZXIgRXJyb3IhYCk7IC8vV2lsbCBuZXZlciBiZSBleGVjdXRlZCwgc2FuaXR5IGNoZWNrXG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgY2FzZSBcImlmam1wXCI6XG4gICAgICAgICAgICBpZiAoYi50YWcgIT09IFwiaWZqbXBcIikgdGhyb3cgbmV3IEVycm9yKGBDb21waWxlciBFcnJvciFgKTsgLy9XaWxsIG5ldmVyIGJlIGV4ZWN1dGVkLCBzYW5pdHkgY2hlY2tcbiAgICAgICAgICAgIGlmICgoYS50aG4gIT09IGIudGhuKSB8fCAoYS5lbHMgIT09IGIuZWxzKSkgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgcmV0dXJuIGNoZWNrVmFsdWVFcXVhbGl0eShhLmNvbmQsIGIuY29uZCk7XG4gICAgICAgIGNhc2UgXCJqbXBcIjpcbiAgICAgICAgICAgIGlmIChiLnRhZyAhPT0gXCJqbXBcIikgdGhyb3cgbmV3IEVycm9yKGBDb21waWxlciBFcnJvciFgKTsgLy9XaWxsIG5ldmVyIGJlIGV4ZWN1dGVkLCBzYW5pdHkgY2hlY2tcbiAgICAgICAgICAgIHJldHVybiAoYS5sYmwgPT09IGIubGJsKTtcbiAgICAgICAgY2FzZSBcInN0b3JlXCI6XG4gICAgICAgICAgICBpZiAoYi50YWcgIT09IFwic3RvcmVcIikgdGhyb3cgbmV3IEVycm9yKGBDb21waWxlciBFcnJvciFgKTsgLy9XaWxsIG5ldmVyIGJlIGV4ZWN1dGVkLCBzYW5pdHkgY2hlY2tcbiAgICAgICAgICAgIHJldHVybiBjaGVja1ZhbHVlRXF1YWxpdHkoYS5zdGFydCwgYi5zdGFydCkgJiYgY2hlY2tWYWx1ZUVxdWFsaXR5KGEub2Zmc2V0LCBiLm9mZnNldCk7XG4gICAgfVxufVxuIiwiaW1wb3J0IHsgcGFyc2VyIH0gZnJvbSBcIkBsZXplci9weXRob25cIjtcbmltcG9ydCB7IFRyZWVDdXJzb3IgfSBmcm9tIFwiQGxlemVyL2NvbW1vblwiO1xuaW1wb3J0IHsgUHJvZ3JhbSwgRXhwciwgU3RtdCwgVW5pT3AsIEJpbk9wLCBQYXJhbWV0ZXIsIFR5cGUsIEZ1bkRlZiwgVmFySW5pdCwgQ2xhc3MsIExpdGVyYWwsIEFubm90YXRpb24sIExvY2F0aW9uLCBOb25sb2NhbFZhckluaXQsIFR5cGVWYXIgfSBmcm9tIFwiLi9hc3RcIjtcbmltcG9ydCB7IE5VTSwgQk9PTCwgTk9ORSwgQ0xBU1MsIENBTExBQkxFIH0gZnJvbSBcIi4vdXRpbHNcIjtcbmltcG9ydCB7IHN0cmluZ2lmeVRyZWUgfSBmcm9tIFwiLi90cmVlcHJpbnRlclwiO1xuXG5jb25zdCBNS0xBTUJEQSA9IFwibWtsYW1iZGFcIjtcblxuZXhwb3J0IHR5cGUgUGFyc2VyRW52ID0ge1xuICBsaW5lQnJlYWtJbmRpY2VzOiBBcnJheTxudW1iZXI+OyAvLyBpbmRleCBvZiBsaW5lIGJyZWFrIGNoYXJhY3RlcnMgaW4gdGhlIHNvdXJjZSBjb2RlOyB1c2VkIHRvIGNhbGN1bGF0ZSByb3cvY29sXG59XG5cbi8qKlxuICogQmluYXJ5IHNlYXJjaCBvbiBzb3J0ZWQgYXJyYXkuIFxuICogUmV0dXJucyB0aGUgaW5kZXggYXQgd2hpY2ggdGFyZ2V0IHNob3VsZCBiZSBpbnNlcnRlZCBpbiBhcnIgYW5kIHRoZSB2YWx1ZSBhdCB0aGF0IGluZGV4IG9mIGFyci5cbiAqIFxuICogQHBhcmFtIGFyciBzb3J0ZWQgYXJyYXlcbiAqIEBwYXJhbSB0YXJnZXQgdGFyZ2V0IHRvIGluc2VydFxuICogQHJldHVybnMgaWR4IHRvIGluc2VydCB0YXJnZXQgaW4gYXJyIGFuZCB0aGUgdmFsdWUgYXQgdGhhdCBpbmRleCBvZiBhcnJcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGJpbmFyeVNlYXJjaChhcnI6IEFycmF5PG51bWJlcj4sIHRhcmdldDogbnVtYmVyKTogbnVtYmVye1xuICB2YXIgbGVmdCA9IDA7XG4gIHZhciByaWdodCA9IGFyci5sZW5ndGg7XG4gIHZhciBhbnMgPSAwO1xuICB3aGlsZSAobGVmdCA8PSByaWdodCkge1xuICAgIGNvbnN0IG1pZCA9IChsZWZ0ICsgcmlnaHQpID4+IDE7XG4gICAgaWYgKGFyclttaWRdIDwgdGFyZ2V0KSB7XG4gICAgICBhbnMgPSBtaWQ7XG4gICAgICBsZWZ0ID0gbWlkICsgMTtcbiAgICB9IGVsc2Uge1xuICAgICAgcmlnaHQgPSBtaWQgLSAxO1xuICAgIH1cbiAgfVxuICAvLyBjb25zb2xlLmxvZyhhcnIsIHRhcmdldCwgYW5zKVxuICByZXR1cm4gYW5zO1xufVxuXG4vKipcbiAqIENvbnZlcnQgYSBpbmRleCBpbiBzb3VyY2UgdG8gc291cmNlIGBMb2NhdGlvbmAgb2JqZWN0LCB3aGljaCBjb250YWlucyByb3cgYW5kIGNvbCBpbmZvcm1hdGlvblxuICogQHBhcmFtIHNyY0lkeCBpbmRleCBpbiBzb3VyY2VcbiAqIEBwYXJhbSBlbnYgUGFyc2VyRW52LCB1c2VzIGxpbmVCcmVha0luZGljZXNcbiAqIEByZXR1cm5zIExvY2F0aW9uIG9iamVjdCBvZiB0aGUgY29ycmVzcG9uZGluZyBpbmRleFxuICovXG5leHBvcnQgZnVuY3Rpb24gaW5kVG9Mb2Moc3JjSWR4OiBudW1iZXIsIGVudjogUGFyc2VyRW52KTogTG9jYXRpb24ge1xuICBjb25zdCByb3cgPSBiaW5hcnlTZWFyY2goZW52LmxpbmVCcmVha0luZGljZXMsIHNyY0lkeCkgKyAxO1xuICBjb25zdCBjb2wgPSBzcmNJZHggLSBlbnYubGluZUJyZWFrSW5kaWNlc1tyb3cgLSAxXTtcbiAgcmV0dXJuIHsgcm93OiByb3csIGNvbDogY29sLCBzcmNJZHg6IHNyY0lkeCB9XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBuZXh0TGluZUJyZWFrTG9jKGxvYzogTG9jYXRpb24sIGVudjogUGFyc2VyRW52KTogTG9jYXRpb24ge1xuICAvLyBpZiBlbmRpbmcgaW5kZXggaXMgYXQgdGhlIGJlZ2lubmluZyBvZiBhIG5ldyBsaW5lLCB0aGVuIHRoZSBsaW5lIGJyZWFrIHNob3VsZCBiZSBhdCBvbmUgcm93IGFib3ZlXG4gIGNvbnN0IHJvdyA9IChsb2MuY29sID09PSAxKSA/IGxvYy5yb3cgLSAxIDogbG9jLnJvdztcbiAgY29uc3QgY29sID0gZW52LmxpbmVCcmVha0luZGljZXNbcm93XSAtIGVudi5saW5lQnJlYWtJbmRpY2VzW3JvdyAtIDFdO1xuICByZXR1cm4geyByb3c6IHJvdywgY29sOiBjb2wsIHNyY0lkeDogZW52LmxpbmVCcmVha0luZGljZXNbcm93XSB9XG59XG5cbi8qKlxuICogV3JhcHBlciBhcm91bmQgdGhlIHJlZ3VsYXIgdHJhdmVyc2VyIHRvIGdpdmUgdGhlIGdlbmVyYXRlZCBBU1Qgbm9kZSBhIExvY2F0aW9uIGluZm9ybWF0aW9uLlxuICogVGhpcyByZXF1aXJlcyBlYWNoIEFTVCBub2RlIHRvIGhhdmUgaXRzIG93biB0cmF2ZXJzZXI6IFxuICogICBBbiBBU1Qgbm9kZSBzaG91bGQgYmUgZ2VuZXJhdGVkIGJ5IHRyYXZlcnNpbmcgYSBjb2xsZWN0aW9uIG9mICdjb250aW51b3VzJyBsZXplciB0cmVlIG5vZGVzLlxuICogICBUaGUgdHJhdmVyc2VyIHNob3VsZCBzdGFydCBhdCB0aGUgaGlnaGVzdCBsZWZ0LW1vc3QgbGV6ZXIgbm9kZSwgXG4gKiAgIGFuZCBlbmQgYXQgdGhlIGhpZ2hlc3QgcmlnaHQtbW9zdCBsZXplciBub2RlLlxuICogICBVc3VhbGx5LCB0aGUgc3RhcnQgYW5kIGVuZCBub2RlIGFyZSB0aGUgc2FtZTogdGhlIEFTVCBub2RlIFxuICogICBjb3JyZXNwb25kcyB0byBhIHN1Yi1sZXplciB0cmVlIHJvb3RlZCBhdCBhIHNpbmdsZSBub2RlLlxuICogQHBhcmFtIHRyYXZlcnNlciByZWd1bGFyIGxlemVyIHRyZWUgdG8gQVNUIHRyYXZlcnNlciBcbiAqIEBwYXJhbSBzdG9yZVNyYyBpZiB0aGUgbG9jYXRpb24gYWRkZWQgc2hvdWxkIGNvbnRhaW4gc291cmNlIHN0cmluZ1xuICogQHJldHVybnMgbmV3IHRyYXZlcnNlciB0aGF0IGFkZHMgbG9jYXRpb24gaW5mb3JtYXRpb24gb250byB0aGUgQVNUIG5vZGUgdGhhdCB0aGUgcmVndWxhciB0cmF2ZXJzZXIgcHJvZHVjZXNcbiAqL1xuZnVuY3Rpb24gd3JhcF9sb2NzPFQgZXh0ZW5kcyBGdW5jdGlvbj4odHJhdmVyc2VyOiBULCBzdG9yZVNyYzogYm9vbGVhbiA9IGZhbHNlKTogVCB7XG4gIHJldHVybiA8YW55PmZ1bmN0aW9uIChjOiBUcmVlQ3Vyc29yLCBzOiBzdHJpbmcsIGVudjogUGFyc2VyRW52LCAuLi5hcmdzOiBhbnkpIHtcbiAgICBjb25zdCBmcm9tTG9jID0gaW5kVG9Mb2MoYy5mcm9tLCBlbnYpO1xuICAgIGNvbnN0IG5vZGUgPSB0cmF2ZXJzZXIoYywgcywgZW52LCAuLi5hcmdzKTtcbiAgICBjb25zdCBlbmRMb2MgPSBpbmRUb0xvYyhjLnRvLCBlbnYpO1xuICAgIGNvbnN0IGVvbExvYyA9IG5leHRMaW5lQnJlYWtMb2MoZW5kTG9jLCBlbnYpO1xuICAgIGlmIChzdG9yZVNyYykgLy8gb25seSBzdG9yZSBmdWxsIHNyYyBpbiB0aGUgUHJvZ3JhbSBub2RlXG4gICAgICByZXR1cm4geyAuLi5ub2RlLCBhOiB7IC4uLm5vZGUuYSwgZnJvbUxvYzogZnJvbUxvYywgZW5kTG9jOiBlbmRMb2MsIGVvbExvYzogZW9sTG9jLCBzcmM6IHMgfSB9XG4gICAgZWxzZSByZXR1cm4geyAuLi5ub2RlLCBhOiB7IC4uLm5vZGUuYSwgZnJvbUxvYzogZnJvbUxvYywgZW5kTG9jOiBlbmRMb2MsIGVvbExvYzogZW9sTG9jIH0gfVxuICB9O1xufVxuXG5leHBvcnQgY29uc3QgdHJhdmVyc2VMaXRlcmFsID0gd3JhcF9sb2NzKHRyYXZlcnNlTGl0ZXJhbEhlbHBlcik7XG5leHBvcnQgZnVuY3Rpb24gdHJhdmVyc2VMaXRlcmFsSGVscGVyKGM6IFRyZWVDdXJzb3IsIHM6IHN0cmluZywgZW52OiBQYXJzZXJFbnYpOiBMaXRlcmFsPEFubm90YXRpb24+IHtcbiAgc3dpdGNoIChjLnR5cGUubmFtZSkge1xuICAgIGNhc2UgXCJOdW1iZXJcIjpcbiAgICAgIHJldHVybiB7XG4gICAgICAgIHRhZzogXCJudW1cIixcbiAgICAgICAgdmFsdWU6IE51bWJlcihzLnN1YnN0cmluZyhjLmZyb20sIGMudG8pKVxuICAgICAgfVxuICAgIGNhc2UgXCJCb29sZWFuXCI6XG4gICAgICByZXR1cm4ge1xuICAgICAgICB0YWc6IFwiYm9vbFwiLFxuICAgICAgICB2YWx1ZTogcy5zdWJzdHJpbmcoYy5mcm9tLCBjLnRvKSA9PT0gXCJUcnVlXCJcbiAgICAgIH1cbiAgICBjYXNlIFwiTm9uZVwiOlxuICAgICAgcmV0dXJuIHtcbiAgICAgICAgdGFnOiBcIm5vbmVcIlxuICAgICAgfVxuICAgIGNhc2UgXCJWYXJpYWJsZU5hbWVcIjpcbiAgICAgIGxldCB2bmFtZSA9IHMuc3Vic3RyaW5nKGMuZnJvbSwgYy50bykudHJpbSgpO1xuICAgICAgaWYgKHZuYW1lICE9PSBcIl9fWkVST19fXCIpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiUGFyc2VFcnJvcjogTm90IGEgbGl0ZXJhbFwiKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiB7IFxuICAgICAgICB0YWc6IFwiemVyb1wiIFxuICAgICAgfTtcbiAgICBkZWZhdWx0OlxuICAgICAgdGhyb3cgbmV3IEVycm9yKFwiTm90IGxpdGVyYWxcIilcbiAgfVxufVxuXG5leHBvcnQgY29uc3QgdHJhdmVyc2VFeHByID0gd3JhcF9sb2NzKHRyYXZlcnNlRXhwckhlbHBlcik7XG5leHBvcnQgZnVuY3Rpb24gdHJhdmVyc2VFeHBySGVscGVyKGM6IFRyZWVDdXJzb3IsIHM6IHN0cmluZywgZW52OiBQYXJzZXJFbnYpOiBFeHByPEFubm90YXRpb24+IHtcbiAgc3dpdGNoIChjLnR5cGUubmFtZSkge1xuICAgIGNhc2UgXCJOdW1iZXJcIjpcbiAgICBjYXNlIFwiQm9vbGVhblwiOlxuICAgIGNhc2UgXCJOb25lXCI6XG4gICAgICByZXR1cm4ge1xuICAgICAgICB0YWc6IFwibGl0ZXJhbFwiLFxuICAgICAgICB2YWx1ZTogdHJhdmVyc2VMaXRlcmFsKGMsIHMsIGVudilcbiAgICAgIH1cbiAgICBjYXNlIFwiVmFyaWFibGVOYW1lXCI6XG4gICAgICByZXR1cm4ge1xuICAgICAgICB0YWc6IFwiaWRcIixcbiAgICAgICAgbmFtZTogcy5zdWJzdHJpbmcoYy5mcm9tLCBjLnRvKVxuICAgICAgfVxuICAgIGNhc2UgXCJBcnJheUNvbXByZWhlbnNpb25FeHByZXNzaW9uXCI6XG4gICAgICBjLmZpcnN0Q2hpbGQoKTsgLy8gJ1snXG4gICAgICBjLm5leHRTaWJsaW5nKCk7XG4gICAgICBjb25zdCBsZWZ0ID0gdHJhdmVyc2VFeHByKGMsIHMsIGVudik7IC8vIGxlZnRcbiAgICAgIGMubmV4dFNpYmxpbmcoKTsgLy8gZm9yXG4gICAgICBjLm5leHRTaWJsaW5nKCk7XG4gICAgICBjb25zdCBlbGVtID0gdHJhdmVyc2VFeHByKGMsIHMsIGVudik7IC8vIGVsZW1cbiAgICAgIGMubmV4dFNpYmxpbmcoKTsgLy8gaW5cbiAgICAgIGMubmV4dFNpYmxpbmcoKTtcbiAgICAgIC8vIGNvbmRpdGlvbnMgZm9yIHBhcnNpbmcgaXRlcmFibGUgdG8gYmUgYWRkZWQgLS0hIVxuICAgICAgY29uc3QgaXRlcmFibGUgPSB0cmF2ZXJzZUV4cHIoYywgcywgZW52KTsgLy8gaXRlcmFibGVcbiAgICAgIGMubmV4dFNpYmxpbmcoKTtcbiAgICAgIHZhciBjb25kO1xuICAgICAgaWYgKHMuc3Vic3RyaW5nKGMuZnJvbSwgYy50bykgIT09ICddJyl7XG4gICAgICAgIGlmIChzLnN1YnN0cmluZyhjLmZyb20sIGMudG8pICE9PSAnaWYnKVxuICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIlBBUlNFIFRZUEUgRVJST1I6IG9ubHkgaWYgY29uZGl0aW9uIGFsbG93ZWQgaW4gY29tcHJlaGVuc2lvbnNcIik7XG4gICAgICAgIGMubmV4dFNpYmxpbmcoKTtcbiAgICAgICAgY29uZCA9IHRyYXZlcnNlRXhwcihjLCBzLCBlbnYpOyAvLyBjb25kIHdoaWNoIGV2YWx1YXRlcyB0byBhIGJpbmFyeSBleHByXG4gICAgICB9XG4gICAgICBjLnBhcmVudCgpO1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgdGFnOiBcImxpc3QtY29tcFwiLFxuICAgICAgICBsZWZ0LFxuICAgICAgICBlbGVtLFxuICAgICAgICBpdGVyYWJsZSxcbiAgICAgICAgY29uZFxuICAgICAgfVxuICAgIGNhc2UgXCJDYWxsRXhwcmVzc2lvblwiOlxuICAgICAgYy5maXJzdENoaWxkKCk7XG4gICAgICBjb25zdCBjYWxsRXhwciA9IHRyYXZlcnNlRXhwcihjLCBzLCBlbnYpO1xuXG4gICAgICBjLm5leHRTaWJsaW5nKCk7IC8vIGdvIHRvIGFyZ2xpc3RcbiAgICAgIGlmIChjYWxsRXhwci50YWcgPT09IFwiaWRcIiAmJiBjYWxsRXhwci5uYW1lID09PSBNS0xBTUJEQSkge1xuICAgICAgICBjLmZpcnN0Q2hpbGQoKTtcbiAgICAgICAgYy5uZXh0U2libGluZygpOyBcbiAgICAgICAgY29uc3QgY2FsbGFibGVUeXBlID0gdHJhdmVyc2VUeXBlKGMsIHMsIGVudik7XG4gICAgICAgIGlmIChjYWxsYWJsZVR5cGUudGFnICE9PSBcImNhbGxhYmxlXCIpIHtcbiAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYEZpcnN0IGFyZ3VtZW50IHRvICR7TUtMQU1CREF9IG11c3QgYmUgY2FsbGFibGUuYCk7XG4gICAgICAgIH1cblxuICAgICAgICBjLm5leHRTaWJsaW5nKCk7IC8vIEZvY3VzIG9uICxcbiAgICAgICAgYy5uZXh0U2libGluZygpOyAvLyBGb2N1cyBvbiBsYW1iZGFcbiAgICAgICAgbGV0IG1heWJlTGFtYmRhID0gYztcbiAgICAgICAgaWYobWF5YmVMYW1iZGEudHlwZS5uYW1lICE9PSBcIkxhbWJkYUV4cHJlc3Npb25cIikge1xuICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgU2Vjb25kIGFyZ3VtZW50IHRvICR7TUtMQU1CREF9IG11c3QgYmUgYSBsYW1kYmEuYCk7XG4gICAgICAgIH1cbiAgICAgICAgYy5maXJzdENoaWxkKCk7IC8vIEZvY3VzIG9uIG9iamVjdFxuICAgICAgICBjLm5leHRTaWJsaW5nKCk7IC8vIEZvY3VzIG9uIGxhbWJkYVxuICAgICAgICB2YXIgcGFyYW1zID0gdHJhdmVyc2VMYW1iZGFQYXJhbXMoYywgcyk7XG4gICAgICAgIGMubmV4dFNpYmxpbmcoKTsgXG4gICAgICAgIGMubmV4dFNpYmxpbmcoKTsgXG4gICAgICAgIHZhciBleHByID0gdHJhdmVyc2VFeHByKGMsIHMsIGVudik7XG4gICAgICAgIGMucGFyZW50KCk7XG4gICAgICAgIGMucGFyZW50KCk7XG4gICAgICAgIGMucGFyZW50KCk7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgdGFnOiBcImxhbWJkYVwiLFxuICAgICAgICAgIHR5cGU6IGNhbGxhYmxlVHlwZSxcbiAgICAgICAgICBwYXJhbXMsXG4gICAgICAgICAgZXhwcixcbiAgICAgICAgfTtcbiAgICAgIH1cblxuICAgICAgbGV0IGFyZ3MgPSB0cmF2ZXJzZUFyZ3VtZW50cyhjLCBzLCBlbnYpO1xuICAgICAgYy5wYXJlbnQoKTsgLy8gcG9wIENhbGxFeHByZXNzaW9uXG5cblxuICAgICAgaWYgKGNhbGxFeHByLnRhZyA9PT0gXCJsb29rdXBcIikge1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgIHRhZzogXCJtZXRob2QtY2FsbFwiLFxuICAgICAgICAgIG9iajogY2FsbEV4cHIub2JqLFxuICAgICAgICAgIG1ldGhvZDogY2FsbEV4cHIuZmllbGQsXG4gICAgICAgICAgYXJndW1lbnRzOiBhcmdzXG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSBpZiAoY2FsbEV4cHIudGFnID09PSBcImlkXCIpIHtcbiAgICAgICAgY29uc3QgY2FsbE5hbWUgPSBjYWxsRXhwci5uYW1lO1xuICAgICAgICB2YXIgZXhwcjogRXhwcjxBbm5vdGF0aW9uPjtcbiAgICAgICAgaWYgKGNhbGxOYW1lID09PSBcInByaW50XCIgfHwgY2FsbE5hbWUgPT09IFwiYWJzXCIpIHtcbiAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgdGFnOiBcImJ1aWx0aW4xXCIsXG4gICAgICAgICAgICBuYW1lOiBjYWxsTmFtZSxcbiAgICAgICAgICAgIGFyZzogYXJnc1swXVxuICAgICAgICAgIH07XG4gICAgICAgIH0gZWxzZSBpZiAoY2FsbE5hbWUgPT09IFwibWF4XCIgfHwgY2FsbE5hbWUgPT09IFwibWluXCIgfHwgY2FsbE5hbWUgPT09IFwicG93XCIpIHtcbiAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgdGFnOiBcImJ1aWx0aW4yXCIsXG4gICAgICAgICAgICBuYW1lOiBjYWxsTmFtZSxcbiAgICAgICAgICAgIGxlZnQ6IGFyZ3NbMF0sXG4gICAgICAgICAgICByaWdodDogYXJnc1sxXVxuICAgICAgICAgIH1cbiAgICAgICAgfSBcbiAgICAgIH0gXG4gICAgICByZXR1cm4geyB0YWc6IFwiY2FsbFwiLCBmbjogY2FsbEV4cHIsIGFyZ3VtZW50czogYXJnc307XG4gICAgY2FzZSBcIkJpbmFyeUV4cHJlc3Npb25cIjpcbiAgICAgIGMuZmlyc3RDaGlsZCgpOyAvLyBnbyB0byBsaHMgXG4gICAgICBjb25zdCBsaHNFeHByID0gdHJhdmVyc2VFeHByKGMsIHMsIGVudik7XG4gICAgICBjLm5leHRTaWJsaW5nKCk7IC8vIGdvIHRvIG9wXG4gICAgICB2YXIgb3BTdHIgPSBzLnN1YnN0cmluZyhjLmZyb20sIGMudG8pO1xuICAgICAgdmFyIG9wO1xuICAgICAgc3dpdGNoIChvcFN0cikge1xuICAgICAgICBjYXNlIFwiK1wiOlxuICAgICAgICAgIG9wID0gQmluT3AuUGx1cztcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSBcIi1cIjpcbiAgICAgICAgICBvcCA9IEJpbk9wLk1pbnVzO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIFwiKlwiOlxuICAgICAgICAgIG9wID0gQmluT3AuTXVsO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIFwiLy9cIjpcbiAgICAgICAgICBvcCA9IEJpbk9wLklEaXY7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgXCIlXCI6XG4gICAgICAgICAgb3AgPSBCaW5PcC5Nb2Q7XG4gICAgICAgICAgYnJlYWtcbiAgICAgICAgY2FzZSBcIj09XCI6XG4gICAgICAgICAgb3AgPSBCaW5PcC5FcTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSBcIiE9XCI6XG4gICAgICAgICAgb3AgPSBCaW5PcC5OZXE7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgXCI8PVwiOlxuICAgICAgICAgIG9wID0gQmluT3AuTHRlO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIFwiPj1cIjpcbiAgICAgICAgICBvcCA9IEJpbk9wLkd0ZTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSBcIjxcIjpcbiAgICAgICAgICBvcCA9IEJpbk9wLkx0O1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIFwiPlwiOlxuICAgICAgICAgIG9wID0gQmluT3AuR3Q7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgXCJpc1wiOlxuICAgICAgICAgIG9wID0gQmluT3AuSXM7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgXCJhbmRcIjpcbiAgICAgICAgICBvcCA9IEJpbk9wLkFuZDtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSBcIm9yXCI6XG4gICAgICAgICAgb3AgPSBCaW5PcC5PcjtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJDb3VsZCBub3QgcGFyc2Ugb3AgYXQgXCIgKyBjLmZyb20gKyBcIiBcIiArIGMudG8gKyBcIjogXCIgKyBzLnN1YnN0cmluZyhjLmZyb20sIGMudG8pKVxuICAgICAgfVxuICAgICAgYy5uZXh0U2libGluZygpOyAvLyBnbyB0byByaHNcbiAgICAgIGNvbnN0IHJoc0V4cHIgPSB0cmF2ZXJzZUV4cHIoYywgcywgZW52KTtcbiAgICAgIGMucGFyZW50KCk7XG4gICAgICByZXR1cm4ge1xuICAgICAgICB0YWc6IFwiYmlub3BcIixcbiAgICAgICAgb3A6IG9wLFxuICAgICAgICBsZWZ0OiBsaHNFeHByLFxuICAgICAgICByaWdodDogcmhzRXhwclxuICAgICAgfVxuICAgIGNhc2UgXCJQYXJlbnRoZXNpemVkRXhwcmVzc2lvblwiOlxuICAgICAgYy5maXJzdENoaWxkKCk7IC8vIEZvY3VzIG9uIChcbiAgICAgIGMubmV4dFNpYmxpbmcoKTsgLy8gRm9jdXMgb24gaW5zaWRlXG4gICAgICB2YXIgZXhwciA9IHRyYXZlcnNlRXhwcihjLCBzLCBlbnYpO1xuICAgICAgYy5wYXJlbnQoKTtcbiAgICAgIHJldHVybiBleHByO1xuICAgIGNhc2UgXCJVbmFyeUV4cHJlc3Npb25cIjpcbiAgICAgIGMuZmlyc3RDaGlsZCgpOyAvLyBGb2N1cyBvbiBvcFxuICAgICAgdmFyIG9wU3RyID0gcy5zdWJzdHJpbmcoYy5mcm9tLCBjLnRvKTtcbiAgICAgIHZhciBvcDtcbiAgICAgIHN3aXRjaCAob3BTdHIpIHtcbiAgICAgICAgY2FzZSBcIi1cIjpcbiAgICAgICAgICBvcCA9IFVuaU9wLk5lZztcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSBcIm5vdFwiOlxuICAgICAgICAgIG9wID0gVW5pT3AuTm90O1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIkNvdWxkIG5vdCBwYXJzZSBvcCBhdCBcIiArIGMuZnJvbSArIFwiIFwiICsgYy50byArIFwiOiBcIiArIHMuc3Vic3RyaW5nKGMuZnJvbSwgYy50bykpXG4gICAgICB9XG4gICAgICBjLm5leHRTaWJsaW5nKCk7IC8vIGdvIHRvIGV4cHJcbiAgICAgIHZhciBleHByID0gdHJhdmVyc2VFeHByKGMsIHMsIGVudik7XG4gICAgICBjLnBhcmVudCgpO1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgdGFnOiBcInVuaW9wXCIsXG4gICAgICAgIG9wOiBvcCxcbiAgICAgICAgZXhwcjogZXhwclxuICAgICAgfVxuICAgIGNhc2UgXCJNZW1iZXJFeHByZXNzaW9uXCI6XG4gICAgICBjLmZpcnN0Q2hpbGQoKTsgLy8gRm9jdXMgb24gb2JqZWN0XG4gICAgICB2YXIgb2JqRXhwciA9IHRyYXZlcnNlRXhwcihjLCBzLCBlbnYpO1xuICAgICAgYy5uZXh0U2libGluZygpOyAvLyBGb2N1cyBvbiAuXG4gICAgICBjLm5leHRTaWJsaW5nKCk7IC8vIEZvY3VzIG9uIHByb3BlcnR5XG4gICAgICB2YXIgcHJvcE5hbWUgPSBzLnN1YnN0cmluZyhjLmZyb20sIGMudG8pO1xuICAgICAgYy5wYXJlbnQoKTtcbiAgICAgIHJldHVybiB7XG4gICAgICAgIHRhZzogXCJsb29rdXBcIixcbiAgICAgICAgb2JqOiBvYmpFeHByLFxuICAgICAgICBmaWVsZDogcHJvcE5hbWVcbiAgICAgIH1cbiAgICBjYXNlIFwic2VsZlwiOlxuICAgICAgcmV0dXJuIHtcbiAgICAgICAgdGFnOiBcImlkXCIsXG4gICAgICAgIG5hbWU6IFwic2VsZlwiXG4gICAgICB9O1xuICAgIGNhc2UgXCJDb25kaXRpb25hbEV4cHJlc3Npb25cIjpcbiAgICAgIGMuZmlyc3RDaGlsZCgpO1xuICAgICAgdmFyIHRobiA9IHRyYXZlcnNlRXhwcihjLCBzLCBlbnYpO1xuICAgICAgYy5uZXh0U2libGluZygpOy8vaWZcbiAgICAgIGMubmV4dFNpYmxpbmcoKTtcbiAgICAgIHZhciBjb25kOmFueSA9IHRyYXZlcnNlRXhwcihjLCBzLCBlbnYpO1xuICAgICAgYy5uZXh0U2libGluZygpOy8vZWxzZVxuICAgICAgYy5uZXh0U2libGluZygpO1xuICAgICAgdmFyIGVscyA9IHRyYXZlcnNlRXhwcihjLCBzLCBlbnYpO1xuICAgICAgYy5wYXJlbnQoKTtcbiAgICAgIHJldHVybiB7dGFnOlwiaWYtZXhwclwiLCB0aG4sIGNvbmQsIGVsc307XG4gICAgZGVmYXVsdDpcbiAgICAgIHRocm93IG5ldyBFcnJvcihcIkNvdWxkIG5vdCBwYXJzZSBleHByIGF0IFwiICsgYy5mcm9tICsgXCIgXCIgKyBjLnRvICsgXCI6IFwiICsgcy5zdWJzdHJpbmcoYy5mcm9tLCBjLnRvKSk7XG4gIH1cbn1cblxuZXhwb3J0IGZ1bmN0aW9uIHRyYXZlcnNlQXJndW1lbnRzKGM6IFRyZWVDdXJzb3IsIHM6IHN0cmluZywgZW52OiBQYXJzZXJFbnYpOiBBcnJheTxFeHByPEFubm90YXRpb24+PiB7XG4gIGMuZmlyc3RDaGlsZCgpOyAgLy8gRm9jdXNlcyBvbiBvcGVuIHBhcmVuXG4gIGNvbnN0IGFyZ3MgPSBbXTtcbiAgYy5uZXh0U2libGluZygpO1xuICB3aGlsZSAoYy50eXBlLm5hbWUgIT09IFwiKVwiKSB7XG4gICAgbGV0IGV4cHIgPSB0cmF2ZXJzZUV4cHIoYywgcywgZW52KTtcbiAgICBhcmdzLnB1c2goZXhwcik7XG4gICAgYy5uZXh0U2libGluZygpOyAvLyBGb2N1c2VzIG9uIGVpdGhlciBcIixcIiBvciBcIilcIlxuICAgIGMubmV4dFNpYmxpbmcoKTsgLy8gRm9jdXNlcyBvbiBhIFZhcmlhYmxlTmFtZVxuICB9XG4gIGMucGFyZW50KCk7ICAgICAgIC8vIFBvcCB0byBBcmdMaXN0XG4gIHJldHVybiBhcmdzO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gdHJhdmVyc2VMYW1iZGFQYXJhbXMoYyA6IFRyZWVDdXJzb3IsIHMgOiBzdHJpbmcpIDogQXJyYXk8c3RyaW5nPiB7XG4gIGxldCBoYXNOZXh0ID0gYy5maXJzdENoaWxkKCk7ICAvLyBGb2N1c2VzIG9uIG9wZW4gcGFyZW5cbiAgaWYgKCFoYXNOZXh0KSB7XG4gICAgcmV0dXJuIFtdO1xuICB9XG4gIGNvbnN0IHBhcmFtcyA9IFtdO1xuICB3aGlsZShoYXNOZXh0KSB7XG4gICAgbGV0IHBhcmFtTmFtZSA9IHMuc3Vic3RyaW5nKGMuZnJvbSwgYy50byk7XG4gICAgcGFyYW1zLnB1c2gocGFyYW1OYW1lKTtcbiAgICBjLm5leHRTaWJsaW5nKCk7IC8vIEZvY3VzZXMgb24gZWl0aGVyIFwiLFwiIG9yIFwiOlwiXG4gICAgaGFzTmV4dCA9IGMubmV4dFNpYmxpbmcoKTsgXG4gIH0gXG4gIGMucGFyZW50KCk7ICAgICAgIC8vIFBvcCB0byBBcmdMaXN0XG4gIHJldHVybiBwYXJhbXM7XG59XG5cbmV4cG9ydCBjb25zdCB0cmF2ZXJzZVN0bXQgPSB3cmFwX2xvY3ModHJhdmVyc2VTdG10SGVscGVyKTtcbmV4cG9ydCBmdW5jdGlvbiB0cmF2ZXJzZVN0bXRIZWxwZXIoYzogVHJlZUN1cnNvciwgczogc3RyaW5nLCBlbnY6IFBhcnNlckVudik6IFN0bXQ8QW5ub3RhdGlvbj4ge1xuICBzd2l0Y2ggKGMubm9kZS50eXBlLm5hbWUpIHtcbiAgICBjYXNlIFwiUmV0dXJuU3RhdGVtZW50XCI6XG4gICAgICBjLmZpcnN0Q2hpbGQoKTsgIC8vIEZvY3VzIHJldHVybiBrZXl3b3JkXG5cbiAgICAgIHZhciB2YWx1ZTogRXhwcjxBbm5vdGF0aW9uPjtcbiAgICAgIGlmIChjLm5leHRTaWJsaW5nKCkpIC8vIEZvY3VzIGV4cHJlc3Npb25cbiAgICAgICAgdmFsdWUgPSB0cmF2ZXJzZUV4cHIoYywgcywgZW52KTtcbiAgICAgIGVsc2VcbiAgICAgICAgdmFsdWUgPSB7IHRhZzogXCJsaXRlcmFsXCIsIHZhbHVlOiB7IHRhZzogXCJub25lXCIgfSB9O1xuICAgICAgYy5wYXJlbnQoKTtcbiAgICAgIHJldHVybiB7IHRhZzogXCJyZXR1cm5cIiwgdmFsdWUgfTtcbiAgICBjYXNlIFwiQXNzaWduU3RhdGVtZW50XCI6XG4gICAgICBjLmZpcnN0Q2hpbGQoKTsgLy8gZ28gdG8gbmFtZVxuICAgICAgY29uc3QgdGFyZ2V0ID0gdHJhdmVyc2VFeHByKGMsIHMsIGVudik7XG4gICAgICBjLm5leHRTaWJsaW5nKCk7IC8vIGdvIHRvIGVxdWFsc1xuICAgICAgYy5uZXh0U2libGluZygpOyAvLyBnbyB0byB2YWx1ZVxuICAgICAgdmFyIHZhbHVlID0gdHJhdmVyc2VFeHByKGMsIHMsIGVudik7XG4gICAgICBjLnBhcmVudCgpO1xuXG4gICAgICBpZiAodGFyZ2V0LnRhZyA9PT0gXCJsb29rdXBcIikge1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgIHRhZzogXCJmaWVsZC1hc3NpZ25cIixcbiAgICAgICAgICBvYmo6IHRhcmdldC5vYmosXG4gICAgICAgICAgZmllbGQ6IHRhcmdldC5maWVsZCxcbiAgICAgICAgICB2YWx1ZTogdmFsdWVcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIGlmICh0YXJnZXQudGFnID09PSBcImlkXCIpIHtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICB0YWc6IFwiYXNzaWduXCIsXG4gICAgICAgICAgbmFtZTogdGFyZ2V0Lm5hbWUsXG4gICAgICAgICAgdmFsdWU6IHZhbHVlXG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcIlVua25vd24gdGFyZ2V0IHdoaWxlIHBhcnNpbmcgYXNzaWdubWVudFwiKTtcbiAgICAgIH1cbiAgICBjYXNlIFwiRXhwcmVzc2lvblN0YXRlbWVudFwiOlxuICAgICAgYy5maXJzdENoaWxkKCk7XG4gICAgICBjb25zdCBleHByID0gdHJhdmVyc2VFeHByKGMsIHMsIGVudik7XG4gICAgICBjLnBhcmVudCgpOyAvLyBwb3AgZ29pbmcgaW50byBzdG10XG4gICAgICByZXR1cm4geyB0YWc6IFwiZXhwclwiLCBleHByOiBleHByIH1cbiAgICAvLyBjYXNlIFwiRnVuY3Rpb25EZWZpbml0aW9uXCI6XG4gICAgLy8gICBjLmZpcnN0Q2hpbGQoKTsgIC8vIEZvY3VzIG9uIGRlZlxuICAgIC8vICAgYy5uZXh0U2libGluZygpOyAvLyBGb2N1cyBvbiBuYW1lIG9mIGZ1bmN0aW9uXG4gICAgLy8gICB2YXIgbmFtZSA9IHMuc3Vic3RyaW5nKGMuZnJvbSwgYy50byk7XG4gICAgLy8gICBjLm5leHRTaWJsaW5nKCk7IC8vIEZvY3VzIG9uIFBhcmFtTGlzdFxuICAgIC8vICAgdmFyIHBhcmFtZXRlcnMgPSB0cmF2ZXJzZVBhcmFtZXRlcnMoYywgcylcbiAgICAvLyAgIGMubmV4dFNpYmxpbmcoKTsgLy8gRm9jdXMgb24gQm9keSBvciBUeXBlRGVmXG4gICAgLy8gICBsZXQgcmV0IDogVHlwZSA9IE5PTkU7XG4gICAgLy8gICBpZihjLnR5cGUubmFtZSA9PT0gXCJUeXBlRGVmXCIpIHtcbiAgICAvLyAgICAgYy5maXJzdENoaWxkKCk7XG4gICAgLy8gICAgIHJldCA9IHRyYXZlcnNlVHlwZShjLCBzKTtcbiAgICAvLyAgICAgYy5wYXJlbnQoKTtcbiAgICAvLyAgIH1cbiAgICAvLyAgIGMuZmlyc3RDaGlsZCgpOyAgLy8gRm9jdXMgb24gOlxuICAgIC8vICAgdmFyIGJvZHkgPSBbXTtcbiAgICAvLyAgIHdoaWxlKGMubmV4dFNpYmxpbmcoKSkge1xuICAgIC8vICAgICBib2R5LnB1c2godHJhdmVyc2VTdG10KGMsIHMpKTtcbiAgICAvLyAgIH1cbiAgICAvLyBjb25zb2xlLmxvZyhcIkJlZm9yZSBwb3AgdG8gYm9keTogXCIsIGMudHlwZS5uYW1lKTtcbiAgICAvLyAgIGMucGFyZW50KCk7ICAgICAgLy8gUG9wIHRvIEJvZHlcbiAgICAvLyBjb25zb2xlLmxvZyhcIkJlZm9yZSBwb3AgdG8gZGVmOiBcIiwgYy50eXBlLm5hbWUpO1xuICAgIC8vICAgYy5wYXJlbnQoKTsgICAgICAvLyBQb3AgdG8gRnVuY3Rpb25EZWZpbml0aW9uXG4gICAgLy8gICByZXR1cm4ge1xuICAgIC8vICAgICB0YWc6IFwiZnVuXCIsXG4gICAgLy8gICAgIG5hbWUsIHBhcmFtZXRlcnMsIGJvZHksIHJldFxuICAgIC8vICAgfVxuICAgIGNhc2UgXCJJZlN0YXRlbWVudFwiOlxuICAgICAgYy5maXJzdENoaWxkKCk7IC8vIEZvY3VzIG9uIGlmXG4gICAgICBjLm5leHRTaWJsaW5nKCk7IC8vIEZvY3VzIG9uIGNvbmRcbiAgICAgIHZhciBjb25kID0gdHJhdmVyc2VFeHByKGMsIHMsIGVudik7XG4gICAgICAvLyBjb25zb2xlLmxvZyhcIkNvbmQ6XCIsIGNvbmQpO1xuICAgICAgYy5uZXh0U2libGluZygpOyAvLyBGb2N1cyBvbiA6IHRoblxuICAgICAgYy5maXJzdENoaWxkKCk7IC8vIEZvY3VzIG9uIDpcbiAgICAgIHZhciB0aG4gPSBbXTtcbiAgICAgIHZhciBlbHMgPSBbXTtcbiAgICAgIHdoaWxlKGMubmV4dFNpYmxpbmcoKSkgeyAgLy8gRm9jdXMgb24gdGhuIHN0bXRzXG4gICAgICAgIHRobi5wdXNoKHRyYXZlcnNlU3RtdChjLHMsIGVudikpO1xuICAgICAgfVxuICAgICAgLy8gY29uc29sZS5sb2coXCJUaG46XCIsIHRobik7XG4gICAgICBjLnBhcmVudCgpO1xuICAgICAgXG4gICAgICBpZiAoYy5uZXh0U2libGluZygpKSB7ICAvLyBGb2N1cyBvbiBlbHNlXG4gICAgICAgIGMubmV4dFNpYmxpbmcoKTsgLy8gRm9jdXMgb24gOiBlbHNcbiAgICAgICAgYy5maXJzdENoaWxkKCk7IC8vIEZvY3VzIG9uIDpcbiAgICAgICAgd2hpbGUoYy5uZXh0U2libGluZygpKSB7IC8vIEZvY3VzIG9uIGVscyBzdG10c1xuICAgICAgICAgIGVscy5wdXNoKHRyYXZlcnNlU3RtdChjLCBzLCBlbnYpKTtcbiAgICAgICAgfVxuICAgICAgICBjLnBhcmVudCgpOyAgXG4gICAgICB9XG4gICAgICBjLnBhcmVudCgpO1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgdGFnOiBcImlmXCIsXG4gICAgICAgIGNvbmQ6IGNvbmQsXG4gICAgICAgIHRobjogdGhuLFxuICAgICAgICBlbHM6IGVsc1xuICAgICAgfVxuICAgIGNhc2UgXCJXaGlsZVN0YXRlbWVudFwiOlxuICAgICAgYy5maXJzdENoaWxkKCk7IC8vIEZvY3VzIG9uIHdoaWxlXG4gICAgICBjLm5leHRTaWJsaW5nKCk7IC8vIEZvY3VzIG9uIGNvbmRpdGlvblxuICAgICAgdmFyIGNvbmQgPSB0cmF2ZXJzZUV4cHIoYywgcywgZW52KTtcbiAgICAgIGMubmV4dFNpYmxpbmcoKTsgLy8gRm9jdXMgb24gYm9keVxuXG4gICAgICB2YXIgYm9keSA9IFtdO1xuICAgICAgYy5maXJzdENoaWxkKCk7IC8vIEZvY3VzIG9uIDpcbiAgICAgIHdoaWxlIChjLm5leHRTaWJsaW5nKCkpIHtcbiAgICAgICAgYm9keS5wdXNoKHRyYXZlcnNlU3RtdChjLCBzLCBlbnYpKTtcbiAgICAgIH1cbiAgICAgIGMucGFyZW50KCk7XG4gICAgICBjLnBhcmVudCgpO1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgdGFnOiBcIndoaWxlXCIsXG4gICAgICAgIGNvbmQsXG4gICAgICAgIGJvZHlcbiAgICAgIH1cbiAgICBjYXNlIFwiUGFzc1N0YXRlbWVudFwiOlxuICAgICAgcmV0dXJuIHsgdGFnOiBcInBhc3NcIiB9XG4gICAgICBjYXNlIFwiQ29udGludWVTdGF0ZW1lbnRcIjpcbiAgICAgICAgcmV0dXJuIHsgdGFnOiBcImNvbnRpbnVlXCIgfVxuICAgIGNhc2UgXCJCcmVha1N0YXRlbWVudFwiOlxuICAgICAgICByZXR1cm4geyB0YWc6IFwiYnJlYWtcIiB9XG4gICAgY2FzZSBcIkZvclN0YXRlbWVudFwiOlxuICAgICAgYy5maXJzdENoaWxkKCk7IC8vIEZvY3VzIG9uIGZvclxuICAgICAgYy5uZXh0U2libGluZygpOyAvLyBGb2N1cyBvbiB2YXJpYWJsZW5hbWVcbiAgICAgIGlmKGMudHlwZS5uYW1lIT1cIlZhcmlhYmxlTmFtZVwiKVxuICAgICAgIHRocm93IG5ldyBFcnJvcihcIkl0ZXJhdG9yIG11c3QgYmUgYSB2YXJpYWJsZVwiKVxuICAgICAgdmFyIGl0ZXJhdG9yID0gcy5zdWJzdHJpbmcoYy5mcm9tLCBjLnRvKTsgICAvLyBjb25zaWRlcmluZyBpdGVyYXRvciBhcyBzdHJpbmdcbiAgICAgIGMubmV4dFNpYmxpbmcoKTsgLy8gRm9jdXMgb24gaW5cbiAgICAgIGMubmV4dFNpYmxpbmcoKTsgLy8gRm9jdXMgb24gdmFsdWVzL2xpc3RcbiAgICAgIHZhciB2YWx1ZXMgPSB0cmF2ZXJzZUV4cHIoYywgcywgZW52KTtcbiAgICAgIGMubmV4dFNpYmxpbmcoKTsgLy8gRm9jdXMgb24gQm9keVxuICAgICAgdmFyIGJvZHkgPSBbXTtcbiAgICAgIGMuZmlyc3RDaGlsZCgpOyAvLyBGb2N1cyBvbiA6XG4gICAgICB3aGlsZShjLm5leHRTaWJsaW5nKCkpIHtcbiAgICAgICAgYm9keS5wdXNoKHRyYXZlcnNlU3RtdChjLCBzLCBlbnYpKTtcbiAgICAgIH1cbiAgICAgIGMucGFyZW50KCk7IFxuICAgICAgYy5wYXJlbnQoKTtcbiAgICAgIHJldHVybiB7dGFnOlwiZm9yXCIsaXRlcmF0b3IsdmFsdWVzLGJvZHl9XG4gICAgZGVmYXVsdDpcbiAgICAgIHRocm93IG5ldyBFcnJvcihcIkNvdWxkIG5vdCBwYXJzZSBzdG10IGF0IFwiICsgYy5ub2RlLmZyb20gKyBcIiBcIiArIGMubm9kZS50byArIFwiOiBcIiArIHMuc3Vic3RyaW5nKGMuZnJvbSwgYy50bykpO1xuICB9XG59XG5cbmV4cG9ydCBmdW5jdGlvbiB0cmF2ZXJzZVR5cGUoYyA6IFRyZWVDdXJzb3IsIHMgOiBzdHJpbmcsIGVudjogUGFyc2VyRW52KSA6IFR5cGUge1xuICBzd2l0Y2ggKGMudHlwZS5uYW1lKSB7XG4gICAgY2FzZSBcIlZhcmlhYmxlTmFtZVwiOlxuICAgICAgbGV0IG5hbWUgPSBzLnN1YnN0cmluZyhjLmZyb20sIGMudG8pO1xuICAgICAgc3dpdGNoKG5hbWUpIHtcbiAgICAgICAgY2FzZSBcImludFwiOiByZXR1cm4gTlVNO1xuICAgICAgICBjYXNlIFwiYm9vbFwiOiByZXR1cm4gQk9PTDtcbiAgICAgICAgZGVmYXVsdDogcmV0dXJuIENMQVNTKG5hbWUpO1xuICAgICAgfVxuICAgIGNhc2UgXCJOb25lXCI6IC8vIE5vbmUgaXMgbWVudGlvbmFibGUgaW4gQ2FsbGFibGUgdHlwZXNcbiAgICAgIHJldHVybiBOT05FO1xuICAgIGNhc2UgXCJNZW1iZXJFeHByZXNzaW9uXCI6XG4gICAgICBjLmZpcnN0Q2hpbGQoKTsgLy8gZm9jdXMgb24gY2xhc3NcbiAgICAgIGxldCBjbmFtZSA9IHMuc3Vic3RyaW5nKGMuZnJvbSwgYy50bykudHJpbSgpO1xuICAgICAgaWYoY25hbWUgPT09IFwiQ2FsbGFibGVcIikge1xuICAgICAgICAgIGMubmV4dFNpYmxpbmcoKTtcbiAgICAgICAgICBjLm5leHRTaWJsaW5nKCk7XG4gICAgICAgICAgY29uc3QgcGFyYW1zID0gdHJhdmVyc2VUeXBlTGlzdChjLCBzLCBlbnYpO1xuICAgICAgICAgIGMubmV4dFNpYmxpbmcoKTtcbiAgICAgICAgICBjLm5leHRTaWJsaW5nKCk7XG4gICAgICAgICAgY29uc3QgcmV0ID0gdHJhdmVyc2VUeXBlKGMsIHMsIGVudik7XG4gICAgICAgICAgYy5wYXJlbnQoKTtcbiAgICAgICAgICAvLyByZXR1cm4gTk9ORTtcbiAgICAgICAgICByZXR1cm4gQ0FMTEFCTEUocGFyYW1zLCByZXQpO1xuICAgICAgfVxuICAgICAgYy5uZXh0U2libGluZygpOyAvLyBmb2N1cyBvbiBbXG4gICAgICBjLm5leHRTaWJsaW5nKCk7IC8vIGZvY3VzIG9uIFZhcmlhYmxlTmFtZSBvciBdXG4gICAgICBjb25zdCBwYXJhbXMgOiBBcnJheTxUeXBlPiA9IFtdO1xuICAgICAgd2hpbGUgKGMudHlwZS5uYW1lIGFzIGFueSAhPT0gXCJdXCIpIHtcbiAgICAgICAgcGFyYW1zLnB1c2godHJhdmVyc2VUeXBlKGMsIHMsIGVudikpO1xuICAgICAgICBjLm5leHRTaWJsaW5nKCk7IC8vIGZvY3VzIG9uICwgb3IgXVxuICAgICAgICBjLm5leHRTaWJsaW5nKCk7IC8vIGZvY3VzIG9uIFZhcmlhYmxlTmFtZSBvciBdXG4gICAgICB9XG4gICAgICBjLnBhcmVudCgpO1xuICAgICAgcmV0dXJuIHsgdGFnOiBcImNsYXNzXCIsIG5hbWU6IGNuYW1lLCBwYXJhbXMgfVxuICAgIGRlZmF1bHQ6XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXCJQYXJzZUVycm9yIDogQ291bGQgbm90IHBhcnNlIHR5cGVcIik7XG4gIH1cbn1cblxuZXhwb3J0IGZ1bmN0aW9uIHRyYXZlcnNlVHlwZUxpc3QoYzogVHJlZUN1cnNvciwgczogc3RyaW5nLCBlbnY6IFBhcnNlckVudik6IEFycmF5PFR5cGU+IHtcbiAgLy8gY29uc29sZS5lcnJvcihzLnN1YnN0cmluZyhjLmZyb20sIGMudG8pKTtcbiAgYy5maXJzdENoaWxkKCk7IC8vIEZvY3VzZXMgb24gb3BlbiBwYXJlblxuICBjb25zdCB0eXBlcyA9IFtdO1xuICBjLm5leHRTaWJsaW5nKCk7IC8vIEZvY3VzZXMgb24gYSBWYXJpYWJsZU5hbWVcbiAgd2hpbGUgKGMudHlwZS5uYW1lICE9PSBcIl1cIikge1xuICAgIGxldCB0eXAgPSB0cmF2ZXJzZVR5cGUoYywgcywgZW52KTtcbiAgICBjLm5leHRTaWJsaW5nKCk7IC8vIEZvY3VzZXMgb24gXCJUeXBlRGVmXCIsIGhvcGVmdWxseSwgb3IgXCIsXCIgaWYgbWlzdGFrZVxuICAgIGMubmV4dFNpYmxpbmcoKTsgLy8gTW92ZSBvbiB0byBjb21tYSBvciBcIilcIlxuICAgIHR5cGVzLnB1c2godHlwKTtcbiAgfVxuICBjLnBhcmVudCgpOyAvLyBQb3AgdG8gUGFyYW1MaXN0XG4gIHJldHVybiB0eXBlcztcbn1cblxuZXhwb3J0IGNvbnN0IHRyYXZlcnNlUGFyYW1ldGVyID0gd3JhcF9sb2NzKHRyYXZlcnNlUGFyYW1ldGVySGVscGVyKTtcbmV4cG9ydCBmdW5jdGlvbiB0cmF2ZXJzZVBhcmFtZXRlckhlbHBlcihjOiBUcmVlQ3Vyc29yLCBzOiBzdHJpbmcsIGVudjogUGFyc2VyRW52KTogUGFyYW1ldGVyPEFubm90YXRpb24+IHtcbiAgbGV0IG5hbWUgPSBzLnN1YnN0cmluZyhjLmZyb20sIGMudG8pO1xuICBjLm5leHRTaWJsaW5nKCk7IC8vIEZvY3VzZXMgb24gXCJUeXBlRGVmXCIsIGhvcGVmdWxseSwgb3IgXCIsXCIgaWYgbWlzdGFrZVxuICBsZXQgbmV4dFRhZ05hbWUgPSBjLnR5cGUubmFtZTsgLy8gTk9URShqb2UpOiBhIGJpdCBvZiBhIGhhY2sgc28gdGhlIG5leHQgbGluZSBkb2Vzbid0IGlmLXNwbGl0XG4gIGlmIChuZXh0VGFnTmFtZSAhPT0gXCJUeXBlRGVmXCIpIHsgdGhyb3cgbmV3IEVycm9yKFwiTWlzc2VkIHR5cGUgYW5ub3RhdGlvbiBmb3IgcGFyYW1ldGVyIFwiICsgbmFtZSkgfTtcbiAgYy5maXJzdENoaWxkKCk7ICAvLyBFbnRlciBUeXBlRGVmXG4gIGMubmV4dFNpYmxpbmcoKTsgLy8gRm9jdXNlcyBvbiB0eXBlIGl0c2VsZlxuICBsZXQgdHlwID0gdHJhdmVyc2VUeXBlKGMsIHMsIGVudik7XG4gIGMucGFyZW50KCk7XG4gIHJldHVybiB7IG5hbWUsIHR5cGU6IHR5cCB9O1xufVxuXG5cbmV4cG9ydCBmdW5jdGlvbiB0cmF2ZXJzZVBhcmFtZXRlcnMoYzogVHJlZUN1cnNvciwgczogc3RyaW5nLCBlbnY6IFBhcnNlckVudik6IEFycmF5PFBhcmFtZXRlcjxBbm5vdGF0aW9uPj4ge1xuICBjLmZpcnN0Q2hpbGQoKTsgIC8vIEZvY3VzZXMgb24gb3BlbiBwYXJlblxuICBjb25zdCBwYXJhbWV0ZXJzID0gW107XG4gIGMubmV4dFNpYmxpbmcoKTsgLy8gRm9jdXNlcyBvbiBhIFZhcmlhYmxlTmFtZVxuICB3aGlsZSAoYy50eXBlLm5hbWUgIT09IFwiKVwiKSB7XG4gICAgcGFyYW1ldGVycy5wdXNoKHRyYXZlcnNlUGFyYW1ldGVyKGMsIHMsIGVudikpO1xuICAgIGMubmV4dFNpYmxpbmcoKTsgLy8gTW92ZSBvbiB0byBjb21tYSBvciBcIilcIlxuICAgIGMubmV4dFNpYmxpbmcoKTsgLy8gRm9jdXNlcyBvbiBhIFZhcmlhYmxlTmFtZSBvciBcbiAgfVxuICBjLnBhcmVudCgpOyAgICAgICAvLyBQb3AgdG8gUGFyYW1MaXN0XG4gIHJldHVybiBwYXJhbWV0ZXJzO1xufVxuXG5leHBvcnQgY29uc3QgdHJhdmVyc2VWYXJJbml0ID0gd3JhcF9sb2NzKHRyYXZlcnNlVmFySW5pdEhlbHBlcik7XG5leHBvcnQgZnVuY3Rpb24gdHJhdmVyc2VWYXJJbml0SGVscGVyKGM6IFRyZWVDdXJzb3IsIHM6IHN0cmluZywgZW52OiBQYXJzZXJFbnYpOiBWYXJJbml0PEFubm90YXRpb24+IHtcbiAgYy5maXJzdENoaWxkKCk7IC8vIGdvIHRvIG5hbWVcbiAgdmFyIG5hbWUgPSBzLnN1YnN0cmluZyhjLmZyb20sIGMudG8pO1xuICBjLm5leHRTaWJsaW5nKCk7IC8vIGdvIHRvIDogdHlwZVxuXG4gIGlmIChjLnR5cGUubmFtZSAhPT0gXCJUeXBlRGVmXCIpIHtcbiAgICBjLnBhcmVudCgpO1xuICAgIHRocm93IEVycm9yKFwiaW52YWxpZCB2YXJpYWJsZSBpbml0XCIpO1xuICB9XG4gIGMuZmlyc3RDaGlsZCgpOyAvLyBnbyB0byA6XG4gIGMubmV4dFNpYmxpbmcoKTsgLy8gZ28gdG8gdHlwZVxuICBjb25zdCB0eXBlID0gdHJhdmVyc2VUeXBlKGMsIHMsIGVudik7XG4gIGMucGFyZW50KCk7XG5cbiAgYy5uZXh0U2libGluZygpOyAvLyBnbyB0byA9XG4gIGMubmV4dFNpYmxpbmcoKTsgLy8gZ28gdG8gdmFsdWVcbiAgdmFyIHZhbHVlID0gdHJhdmVyc2VMaXRlcmFsKGMsIHMsIGVudik7XG4gIGMucGFyZW50KCk7XG5cbiAgcmV0dXJuIHsgbmFtZSwgdHlwZSwgdmFsdWUgfVxufVxuXG5leHBvcnQgY29uc3QgdHJhdmVyc2VUeXBlVmFySW5pdCA9IHdyYXBfbG9jcyh0cmF2ZXJzZVR5cGVWYXJJbml0SGVscGVyKTtcbmV4cG9ydCBmdW5jdGlvbiB0cmF2ZXJzZVR5cGVWYXJJbml0SGVscGVyKGMgOiBUcmVlQ3Vyc29yLCBzIDogc3RyaW5nLCBlbnY6IFBhcnNlckVudikgOiBUeXBlVmFyPEFubm90YXRpb24+IHtcbiAgYy5maXJzdENoaWxkKCk7IC8vIGZvY3VzIG9uIHR5cGUgdmFyIG5hbWVcbiAgdmFyIG5hbWUgPSBzLnN1YnN0cmluZyhjLmZyb20sIGMudG8pLnRyaW0oKTtcbiAgYy5uZXh0U2libGluZygpOyAvLyBmb2N1cyBvbiBBc3NpZ25PcFxuICBjLm5leHRTaWJsaW5nKCk7IC8vIGZvY3VzIG9uIENhbGxFeHByZXNzaW9uXG5cbiAgYy5maXJzdENoaWxkKCk7IC8vIGZvY3VzIG9uIFR5cGVWYXJcbiAgYy5uZXh0U2libGluZygpOyAvLyBmb2N1cyBvbiBBcmdMaXN0XG5cbiAgYy5maXJzdENoaWxkKCk7ICAvLyBGb2N1c2VzIG9uIG9wZW4gcGFyZW5zXG4gIGMubmV4dFNpYmxpbmcoKTsgLy8gRm9jdXNlcyBvbiBhIFN0cmluZyB8IGNsb3NlIHBhcmVuc1xuICBsZXQgY2Fub25pY2FsTmFtZSA6IHN0cmluZyA9IG5hbWU7XG4gIGlmIChjLnR5cGUubmFtZSA9PT0gXCJTdHJpbmdcIikge1xuICAgIGNhbm9uaWNhbE5hbWUgPSBzLnN1YnN0cmluZyhjLmZyb20gKyAxLCBjLnRvIC0gMSkudHJpbSgpO1xuICAgIGMubmV4dFNpYmxpbmcoKTsgLy8gRm9jdXMgb24gb3IgY2xvc2UgcGFyZW5zXG4gIH1cblxuICBpZiAoYy50eXBlLm5hbWUgIT09IFwiKVwiKSB7XG4gICAgdGhyb3cgRXJyb3IoXCJQYXJzZUVycm9yIDogY29uc3RyYWluZWQgdHlwZSB2YXJpYWJsZXMgYXJlIG5vdCBzdXBwb3J0ZWQuXCIpO1xuICB9XG5cbiAgYy5wYXJlbnQoKTsgLy8gZ28gdG8gQXJnTGlzdFxuICBjLnBhcmVudCgpOyAvLyBnbyB0byBDYWxsRXhwcmVzc2lvblxuICBjLnBhcmVudCgpOyAvLyBnbyB0byBBc3NpZ21lbnRTdGF0ZW1lbnRcblxuICAvLyBUT0RPIDogTmVlZCB0byBkZWxldGUgdGhpcyBvbmNlIHdlIGhhdmUgcmVtb3ZlZCB0eXBlcyBmcm9tIEFTVFxuICBjb25zdCB0eXBlcyA6IEFycmF5PFR5cGU+ID0gW107XG4gIHJldHVybiB7IG5hbWUsIGNhbm9uaWNhbE5hbWUsIHR5cGVzfTtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIHRyYXZlcnNlU2NvcGVEZWYoYyA6IFRyZWVDdXJzb3IsIHMgOiBzdHJpbmcsIGVudjogUGFyc2VyRW52KSA6IE5vbmxvY2FsVmFySW5pdDxudWxsPiB7XG4gIGMuZmlyc3RDaGlsZCgpOyAvLyBnbyB0byBzY29wZVxuICBpZihjLnR5cGUubmFtZSAhPT0gXCJub25sb2NhbFwiKSB7XG4gICAgYy5wYXJlbnQoKTtcbiAgICB0aHJvdyBFcnJvcihcImludmFsaWQgdmFyaWFibGUgc2NvcGVcIik7XG4gIH1cbiAgYy5uZXh0U2libGluZygpOyAvLyBnbyB0byBuYW1lXG4gIGNvbnN0IG5hbWUgPSBzLnN1YnN0cmluZyhjLmZyb20sIGMudG8pO1xuICBjLnBhcmVudCgpO1xuXG4gIHJldHVybiB7IG5hbWUgfTtcbn1cblxuZXhwb3J0IGNvbnN0IHRyYXZlcnNlRnVuRGVmID0gd3JhcF9sb2NzKHRyYXZlcnNlRnVuRGVmSGVscGVyKTtcbmV4cG9ydCBmdW5jdGlvbiB0cmF2ZXJzZUZ1bkRlZkhlbHBlcihjOiBUcmVlQ3Vyc29yLCBzOiBzdHJpbmcsIGVudjogUGFyc2VyRW52KTogRnVuRGVmPEFubm90YXRpb24+IHtcbiAgYy5maXJzdENoaWxkKCk7ICAvLyBGb2N1cyBvbiBkZWZcbiAgYy5uZXh0U2libGluZygpOyAvLyBGb2N1cyBvbiBuYW1lIG9mIGZ1bmN0aW9uXG4gIHZhciBuYW1lID0gcy5zdWJzdHJpbmcoYy5mcm9tLCBjLnRvKTtcbiAgYy5uZXh0U2libGluZygpOyAvLyBGb2N1cyBvbiBQYXJhbUxpc3RcbiAgdmFyIHBhcmFtZXRlcnMgPSB0cmF2ZXJzZVBhcmFtZXRlcnMoYywgcywgZW52KVxuICBjLm5leHRTaWJsaW5nKCk7IC8vIEZvY3VzIG9uIEJvZHkgb3IgVHlwZURlZlxuICBsZXQgcmV0OiBUeXBlID0gTk9ORTtcbiAgaWYgKGMudHlwZS5uYW1lID09PSBcIlR5cGVEZWZcIikge1xuICAgIGMuZmlyc3RDaGlsZCgpO1xuICAgIHJldCA9IHRyYXZlcnNlVHlwZShjLCBzLCBlbnYpO1xuICAgIGMucGFyZW50KCk7XG4gICAgYy5uZXh0U2libGluZygpO1xuICB9XG4gIGMuZmlyc3RDaGlsZCgpOyAgLy8gRm9jdXMgb24gOlxuICB2YXIgaW5pdHMgPSBbXTtcbiAgdmFyIG5vbmxvY2FsczogQXJyYXk8Tm9ubG9jYWxWYXJJbml0PEFubm90YXRpb24+PiA9IFtdO1xuICB2YXIgY2hpbGRyZW46IEFycmF5PEZ1bkRlZjxBbm5vdGF0aW9uPj4gPSBbXTtcbiAgdmFyIGJvZHkgPSBbXTtcblxuICB2YXIgaGFzQ2hpbGQgPSBjLm5leHRTaWJsaW5nKCk7XG5cbiAgd2hpbGUoaGFzQ2hpbGQpIHtcbiAgICBpZiAoaXNWYXJJbml0KGMsIHMsIGVudikpIHtcbiAgICAgIGluaXRzLnB1c2godHJhdmVyc2VWYXJJbml0KGMsIHMsIGVudikpO1xuICAgIH0gZWxzZSBpZiAoaXNTY29wZURlZihjLCBzKSkge1xuICAgICAgbm9ubG9jYWxzLnB1c2godHJhdmVyc2VTY29wZURlZihjLCBzLCBlbnYpKTtcbiAgICB9IGVsc2UgaWYgKGlzRnVuRGVmKGMsIHMsIGVudikpIHtcbiAgICAgIGNoaWxkcmVuLnB1c2godHJhdmVyc2VGdW5EZWYoYywgcywgZW52KSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGJyZWFrO1xuICAgIH1cbiAgICBoYXNDaGlsZCA9IGMubmV4dFNpYmxpbmcoKTtcbiAgfVxuXG4gIHdoaWxlIChoYXNDaGlsZCkge1xuICAgIGJvZHkucHVzaCh0cmF2ZXJzZVN0bXQoYywgcywgZW52KSk7XG4gICAgaGFzQ2hpbGQgPSBjLm5leHRTaWJsaW5nKCk7XG4gIH1cblxuICAvLyBjb25zb2xlLmxvZyhcIkJlZm9yZSBwb3AgdG8gYm9keTogXCIsIGMudHlwZS5uYW1lKTtcbiAgYy5wYXJlbnQoKTsgICAgICAvLyBQb3AgdG8gQm9keVxuICAvLyBjb25zb2xlLmxvZyhcIkJlZm9yZSBwb3AgdG8gZGVmOiBcIiwgYy50eXBlLm5hbWUpO1xuICBjLnBhcmVudCgpOyAgICAgIC8vIFBvcCB0byBGdW5jdGlvbkRlZmluaXRpb25cbiAgcmV0dXJuIHsgbmFtZSwgcGFyYW1ldGVycywgcmV0LCBpbml0cywgYm9keSwgbm9ubG9jYWxzLCBjaGlsZHJlbiB9O1xufVxuXG5leHBvcnQgZnVuY3Rpb24gdHJhdmVyc2VHZW5lcmljUGFyYW1zKGMgOiBUcmVlQ3Vyc29yLCBzIDogc3RyaW5nKSA6IEFycmF5PHN0cmluZz4ge1xuICBjb25zdCB0eXBlUGFyYW1zIDogQXJyYXk8c3RyaW5nPiA9IFtdO1xuICBpZiAoYy50eXBlLm5hbWUgIT09IFwiQXJnTGlzdFwiKSB7XG4gICAgcmV0dXJuIHR5cGVQYXJhbXM7XG4gIH1cblxuICBjLmZpcnN0Q2hpbGQoKTsgLy8gRm9jdXMgb24gKFxuICBjLm5leHRTaWJsaW5nKCk7IC8vIEZvY3VzIG9uIGZpcnN0IGFyZ3VtZW50XG4gIGxldCBhcmcxQyA9IGM7IFxuICBpZiAoYXJnMUMudHlwZS5uYW1lICE9PSBcIk1lbWJlckV4cHJlc3Npb25cIikge1xuICAgIGMucGFyZW50KCk7XG4gICAgcmV0dXJuIHR5cGVQYXJhbXM7XG4gIH1cblxuICBjLmZpcnN0Q2hpbGQoKTtcbiAgaWYgKHMuc3Vic3RyaW5nKGMuZnJvbSwgYy50bykudHJpbSgpICE9PSBcIkdlbmVyaWNcIikge1xuICAgIGMucGFyZW50KCk7XG4gICAgYy5wYXJlbnQoKTtcbiAgICByZXR1cm4gdHlwZVBhcmFtcztcbiAgfVxuXG4gIGMubmV4dFNpYmxpbmcoKTsgLy8gRm9jdXMgb24gW1xuICBjLm5leHRTaWJsaW5nKCk7IC8vIEZvY3VzIG9uIFZhcmlhYmxlTmFtZSBvciBdXG4gIGxldCB0eXBlVmFyQyA9IGM7XG4gIHdoaWxlICh0eXBlVmFyQy50eXBlLm5hbWUgIT09IFwiXVwiKSB7XG4gICAgdHlwZVBhcmFtcy5wdXNoKHMuc3Vic3RyaW5nKHR5cGVWYXJDLmZyb20sIHR5cGVWYXJDLnRvKS50cmltKCkpO1xuICAgIHR5cGVWYXJDLm5leHRTaWJsaW5nKCk7IC8vIEZvY3VzIG9uICwgb3IgXVxuICAgIHR5cGVWYXJDLm5leHRTaWJsaW5nKCk7IC8vIEZvY3VzIG9uIFZhcmlhYmxlTmFtZVxuICB9XG5cbiAgYy5wYXJlbnQoKTsgLy8gLyBHbyBiYWNrIHRvIE1lbWJlckV4cHJlc3Npb25cbiAgYy5wYXJlbnQoKTsgLy8gR28gYmFjayB0byBBcmdMaXN0XG5cbiAgcmV0dXJuIHR5cGVQYXJhbXM7XG59XG5cbmV4cG9ydCBjb25zdCB0cmF2ZXJzZUNsYXNzID0gd3JhcF9sb2NzKHRyYXZlcnNlQ2xhc3NIZWxwZXIpO1xuZXhwb3J0IGZ1bmN0aW9uIHRyYXZlcnNlQ2xhc3NIZWxwZXIoYzogVHJlZUN1cnNvciwgczogc3RyaW5nLCBlbnY6IFBhcnNlckVudik6IENsYXNzPEFubm90YXRpb24+IHtcbiAgY29uc3QgZmllbGRzOiBBcnJheTxWYXJJbml0PEFubm90YXRpb24+PiA9IFtdO1xuICBjb25zdCBtZXRob2RzOiBBcnJheTxGdW5EZWY8QW5ub3RhdGlvbj4+ID0gW107XG4gIGMuZmlyc3RDaGlsZCgpO1xuICBjLm5leHRTaWJsaW5nKCk7IC8vIEZvY3VzIG9uIGNsYXNzIG5hbWVcbiAgY29uc3QgY2xhc3NOYW1lID0gcy5zdWJzdHJpbmcoYy5mcm9tLCBjLnRvKTtcbiAgYy5uZXh0U2libGluZygpOyAvLyBGb2N1cyBvbiBhcmdsaXN0L3N1cGVyY2xhc3MvZ2VuZXJpYyB0eXBlIHZhcnMocylcblxuICBjb25zdCB0eXBlUGFyYW1zIDogQXJyYXk8c3RyaW5nPiA9IHRyYXZlcnNlR2VuZXJpY1BhcmFtcyhjLCBzKTtcblxuICBjLm5leHRTaWJsaW5nKCk7IC8vIEZvY3VzIG9uIGJvZHlcbiAgYy5maXJzdENoaWxkKCk7ICAvLyBGb2N1cyBjb2xvblxuICB3aGlsZSAoYy5uZXh0U2libGluZygpKSB7IC8vIEZvY3VzZXMgZmlyc3QgZmllbGRcbiAgICBpZiAoaXNWYXJJbml0KGMsIHMsIGVudikpIHtcbiAgICAgIGZpZWxkcy5wdXNoKHRyYXZlcnNlVmFySW5pdChjLCBzLCBlbnYpKTtcbiAgICB9IGVsc2UgaWYgKGlzRnVuRGVmKGMsIHMsIGVudikpIHtcbiAgICAgIG1ldGhvZHMucHVzaCh0cmF2ZXJzZUZ1bkRlZihjLCBzLCBlbnYpKTtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKGBDb3VsZCBub3QgcGFyc2UgdGhlIGJvZHkgb2YgY2xhc3M6ICR7Y2xhc3NOYW1lfWApO1xuICAgIH1cbiAgfVxuICBjLnBhcmVudCgpO1xuICBjLnBhcmVudCgpO1xuXG4gIGlmICghbWV0aG9kcy5maW5kKG1ldGhvZCA9PiBtZXRob2QubmFtZSA9PT0gXCJfX2luaXRfX1wiKSkge1xuICAgIGNvbnN0IHR5cGVWYXJzIDogVHlwZVtdID0gdHlwZVBhcmFtcy5tYXAodHAgPT4ge1xuICAgICAgcmV0dXJuIENMQVNTKHRwKTtcbiAgICB9KVxuICAgIG1ldGhvZHMucHVzaCh7IG5hbWU6IFwiX19pbml0X19cIiwgcGFyYW1ldGVyczogW3sgbmFtZTogXCJzZWxmXCIsIHR5cGU6IENMQVNTKGNsYXNzTmFtZSwgdHlwZVZhcnMpIH1dLCByZXQ6IE5PTkUsIGluaXRzOiBbXSwgYm9keTogW10sIG5vbmxvY2FsczogW10sIGNoaWxkcmVuOiBbXSB9KTtcbiAgfVxuICByZXR1cm4ge1xuICAgIG5hbWU6IGNsYXNzTmFtZSxcbiAgICB0eXBlUGFyYW1zLFxuICAgIGZpZWxkcyxcbiAgICBtZXRob2RzXG4gIH07XG59XG5cbmV4cG9ydCBmdW5jdGlvbiB0cmF2ZXJzZURlZnMoYzogVHJlZUN1cnNvciwgczogc3RyaW5nLCBlbnY6IFBhcnNlckVudik6IFtBcnJheTxWYXJJbml0PEFubm90YXRpb24+PiwgQXJyYXk8RnVuRGVmPEFubm90YXRpb24+PiwgQXJyYXk8Q2xhc3M8QW5ub3RhdGlvbj4+XSB7XG4gIGNvbnN0IGluaXRzOiBBcnJheTxWYXJJbml0PEFubm90YXRpb24+PiA9IFtdO1xuICBjb25zdCBmdW5zOiBBcnJheTxGdW5EZWY8QW5ub3RhdGlvbj4+ID0gW107XG4gIGNvbnN0IGNsYXNzZXM6IEFycmF5PENsYXNzPEFubm90YXRpb24+PiA9IFtdO1xuXG4gIHdoaWxlICh0cnVlKSB7XG4gICAgaWYgKGlzVmFySW5pdChjLCBzLCBlbnYpKSB7XG4gICAgICBpbml0cy5wdXNoKHRyYXZlcnNlVmFySW5pdChjLCBzLCBlbnYpKTtcbiAgICB9IGVsc2UgaWYgKGlzRnVuRGVmKGMsIHMsIGVudikpIHtcbiAgICAgIGZ1bnMucHVzaCh0cmF2ZXJzZUZ1bkRlZihjLCBzLCBlbnYpKTtcbiAgICB9IGVsc2UgaWYgKGlzQ2xhc3NEZWYoYywgcywgZW52KSkge1xuICAgICAgY2xhc3Nlcy5wdXNoKHRyYXZlcnNlQ2xhc3MoYywgcywgZW52KSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiBbaW5pdHMsIGZ1bnMsIGNsYXNzZXNdO1xuICAgIH1cbiAgICBjLm5leHRTaWJsaW5nKCk7XG4gIH1cblxufVxuXG5leHBvcnQgZnVuY3Rpb24gaXNWYXJJbml0KGM6IFRyZWVDdXJzb3IsIHM6IHN0cmluZywgZW52OiBQYXJzZXJFbnYpOiBCb29sZWFuIHtcbiAgaWYgKGMudHlwZS5uYW1lID09PSBcIkFzc2lnblN0YXRlbWVudFwiKSB7XG4gICAgYy5maXJzdENoaWxkKCk7IC8vIEZvY3VzIG9uIGxoc1xuICAgIGMubmV4dFNpYmxpbmcoKTsgLy8gZ28gdG8gOiB0eXBlXG5cbiAgICBjb25zdCBpc1ZhciA9IGMudHlwZS5uYW1lIGFzIGFueSA9PT0gXCJUeXBlRGVmXCI7XG4gICAgYy5wYXJlbnQoKTtcbiAgICByZXR1cm4gaXNWYXI7XG4gIH0gZWxzZSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBpc1R5cGVWYXJJbml0KGMgOiBUcmVlQ3Vyc29yLCBzIDogc3RyaW5nKSA6IEJvb2xlYW4ge1xuICBpZiAoYy50eXBlLm5hbWUgPT09IFwiQXNzaWduU3RhdGVtZW50XCIpIHtcbiAgICBjLmZpcnN0Q2hpbGQoKTsgLy8gRm9jdXMgb24gbGhzXG4gICAgYy5uZXh0U2libGluZygpOyAvLyBnbyB0byBBc3NpZ25PcFxuICAgIGMubmV4dFNpYmxpbmcoKTsgLy8gZ28gdG8gQ2FsbEV4cHJlc3Npb25cblxuICAgIGlmIChjLnR5cGUubmFtZSBhcyBhbnkgIT09IFwiQ2FsbEV4cHJlc3Npb25cIikge1xuICAgICAgYy5wYXJlbnQoKTtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG5cbiAgICBjLmZpcnN0Q2hpbGQoKTsgLy8gRm9jdXMgb24gVHlwZVZhclxuICAgIGlmIChjLnR5cGUubmFtZSBhcyBhbnkgIT09IFwiVmFyaWFibGVOYW1lXCIgfHwgcy5zdWJzdHJpbmcoYy5mcm9tLCBjLnRvKS50cmltKCkgIT09IFwiVHlwZVZhclwiKSB7XG4gICAgICBjLnBhcmVudCgpO1xuICAgICAgYy5wYXJlbnQoKTtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG5cbiAgICBjLnBhcmVudCgpO1xuICAgIGMucGFyZW50KCk7XG4gICAgcmV0dXJuIHRydWU7ICBcbiAgfSBlbHNlIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGlzU2NvcGVEZWYoYyA6IFRyZWVDdXJzb3IsIHMgOiBzdHJpbmcpIDogQm9vbGVhbiB7XG4gIHJldHVybiBjLnR5cGUubmFtZSA9PT0gXCJTY29wZVN0YXRlbWVudFwiO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gaXNGdW5EZWYoYzogVHJlZUN1cnNvciwgczogc3RyaW5nLCBlbnY6IFBhcnNlckVudik6IEJvb2xlYW4ge1xuICByZXR1cm4gYy50eXBlLm5hbWUgPT09IFwiRnVuY3Rpb25EZWZpbml0aW9uXCI7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBpc0NsYXNzRGVmKGM6IFRyZWVDdXJzb3IsIHM6IHN0cmluZywgZW52OiBQYXJzZXJFbnYpOiBCb29sZWFuIHtcbiAgcmV0dXJuIGMudHlwZS5uYW1lID09PSBcIkNsYXNzRGVmaW5pdGlvblwiO1xufVxuXG5leHBvcnQgY29uc3QgdHJhdmVyc2UgPSB3cmFwX2xvY3ModHJhdmVyc2VIZWxwZXIsIHRydWUpO1xuZXhwb3J0IGZ1bmN0aW9uIHRyYXZlcnNlSGVscGVyKGM6IFRyZWVDdXJzb3IsIHM6IHN0cmluZywgZW52OiBQYXJzZXJFbnYpOiBQcm9ncmFtPEFubm90YXRpb24+IHtcbiAgc3dpdGNoIChjLm5vZGUudHlwZS5uYW1lKSB7XG4gICAgY2FzZSBcIlNjcmlwdFwiOlxuICAgICAgY29uc3QgaW5pdHM6IEFycmF5PFZhckluaXQ8QW5ub3RhdGlvbj4+ID0gW107XG4gICAgICBjb25zdCBmdW5zOiBBcnJheTxGdW5EZWY8QW5ub3RhdGlvbj4+ID0gW107XG4gICAgICBjb25zdCBjbGFzc2VzOiBBcnJheTxDbGFzczxBbm5vdGF0aW9uPj4gPSBbXTtcbiAgICAgIGNvbnN0IHN0bXRzOiBBcnJheTxTdG10PEFubm90YXRpb24+PiA9IFtdO1xuICAgICAgY29uc3QgdHlwZVZhckluaXRzIDogQXJyYXk8VHlwZVZhcjxBbm5vdGF0aW9uPj4gPSBbXTtcbiAgICAgIHZhciBoYXNDaGlsZCA9IGMuZmlyc3RDaGlsZCgpO1xuXG4gICAgICB3aGlsZSAoaGFzQ2hpbGQpIHtcbiAgICAgICAgaWYgKGlzVmFySW5pdChjLCBzLCBlbnYpKSB7XG4gICAgICAgICAgaW5pdHMucHVzaCh0cmF2ZXJzZVZhckluaXQoYywgcywgZW52KSk7XG4gICAgICAgIH0gZWxzZSBpZiAoaXNUeXBlVmFySW5pdChjLCBzKSkge1xuICAgICAgICAgIHR5cGVWYXJJbml0cy5wdXNoKHRyYXZlcnNlVHlwZVZhckluaXQoYywgcywgZW52KSk7XG4gICAgICAgIH0gZWxzZSBpZiAoaXNGdW5EZWYoYywgcywgZW52KSkge1xuICAgICAgICAgIGZ1bnMucHVzaCh0cmF2ZXJzZUZ1bkRlZihjLCBzLCBlbnYpKTtcbiAgICAgICAgfSBlbHNlIGlmIChpc0NsYXNzRGVmKGMsIHMsIGVudikpIHtcbiAgICAgICAgICBjbGFzc2VzLnB1c2godHJhdmVyc2VDbGFzcyhjLCBzLCBlbnYpKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgICBoYXNDaGlsZCA9IGMubmV4dFNpYmxpbmcoKTtcbiAgICAgIH1cblxuICAgICAgd2hpbGUgKGhhc0NoaWxkKSB7XG4gICAgICAgIHN0bXRzLnB1c2godHJhdmVyc2VTdG10KGMsIHMsIGVudikpO1xuICAgICAgICBoYXNDaGlsZCA9IGMubmV4dFNpYmxpbmcoKTtcbiAgICAgIH1cbiAgICAgIGMucGFyZW50KCk7XG4gICAgICByZXR1cm4geyBmdW5zLCBpbml0cywgdHlwZVZhckluaXRzLCBjbGFzc2VzLCBzdG10cyB9O1xuICAgIGRlZmF1bHQ6XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXCJDb3VsZCBub3QgcGFyc2UgcHJvZ3JhbSBhdCBcIiArIGMubm9kZS5mcm9tICsgXCIgXCIgKyBjLm5vZGUudG8pO1xuICB9XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBwYXJzZShzb3VyY2U6IHN0cmluZyk6IFByb2dyYW08QW5ub3RhdGlvbj4ge1xuICBjb25zdCBlbnY6IFBhcnNlckVudiA9IHtcbiAgICBsaW5lQnJlYWtJbmRpY2VzOiBbXSxcbiAgfVxuICBzb3VyY2UgKz0gXCJcXG5cIjtcbiAgZW52LmxpbmVCcmVha0luZGljZXMgPSBbLTFdO1xuICBmb3IgKHZhciBpID0gMDsgaSA8IHNvdXJjZS5sZW5ndGg7IGkrKykge1xuICAgIGlmIChzb3VyY2VbaV0gPT0gJ1xcbicpIHtcbiAgICAgIGVudi5saW5lQnJlYWtJbmRpY2VzLnB1c2goaSk7XG4gICAgfVxuICB9XG4gIGNvbnN0IHQgPSBwYXJzZXIucGFyc2Uoc291cmNlKTtcbiAgY29uc3Qgc3RyID0gc3RyaW5naWZ5VHJlZSh0LmN1cnNvcigpLCBzb3VyY2UsIDApO1xuICBjb25zdCBhc3QgPSB0cmF2ZXJzZSh0LmN1cnNvcigpLCBzb3VyY2UsIGVudik7XG4gIHJldHVybiBhc3Q7XG59XG4iLCJpbXBvcnQgeyBydW4sIENvbmZpZywgYXVnbWVudEVudiB9IGZyb20gXCIuL3J1bm5lclwiO1xuLy8gaW1wb3J0IHsgR2xvYmFsRW52IH0gZnJvbSBcIi4vY29tcGlsZXJcIjtcbmltcG9ydCB7IEdsb2JhbEVudiB9IGZyb20gXCIuL2NvbXBpbGVyXCI7XG5pbXBvcnQgeyB0YywgZGVmYXVsdFR5cGVFbnYsIEdsb2JhbFR5cGVFbnYgfSBmcm9tIFwiLi90eXBlLWNoZWNrXCI7XG5pbXBvcnQgeyBQcm9ncmFtIH0gZnJvbSBcIi4vaXJcIjtcbmltcG9ydCB7IG9wdGltaXplUHJvZ3JhbSB9IGZyb20gXCIuL29wdGltaXphdGlvblwiO1xuaW1wb3J0IHsgVmFsdWUsIFR5cGUsIEFubm90YXRpb24gfSBmcm9tIFwiLi9hc3RcIjtcbmltcG9ydCB7IHBhcnNlIH0gZnJvbSBcIi4vcGFyc2VyXCI7XG5pbXBvcnQgeyBsb3dlclByb2dyYW0gfSBmcm9tIFwiLi9sb3dlclwiO1xuXG5pbnRlcmZhY2UgUkVQTCB7XG4gIHJ1bihzb3VyY2UgOiBzdHJpbmcpIDogUHJvbWlzZTxhbnk+O1xufVxuXG5leHBvcnQgY2xhc3MgQmFzaWNSRVBMIHtcbiAgY3VycmVudEVudjogR2xvYmFsRW52XG4gIGN1cnJlbnRUeXBlRW52OiBHbG9iYWxUeXBlRW52XG4gIGZ1bmN0aW9uczogc3RyaW5nXG4gIGltcG9ydE9iamVjdDogYW55XG4gIG1lbW9yeTogYW55XG4gIGNvbnN0cnVjdG9yKGltcG9ydE9iamVjdCA6IGFueSkge1xuICAgIHRoaXMuaW1wb3J0T2JqZWN0ID0gaW1wb3J0T2JqZWN0O1xuICAgIGlmKCFpbXBvcnRPYmplY3QuanMpIHtcbiAgICAgIGNvbnN0IG1lbW9yeSA9IG5ldyBXZWJBc3NlbWJseS5NZW1vcnkoe2luaXRpYWw6MjAwMCwgbWF4aW11bToyMDAwfSk7XG4gICAgICBjb25zdCB2aWV3ID0gbmV3IEludDMyQXJyYXkobWVtb3J5LmJ1ZmZlcik7XG4gICAgICB2aWV3WzBdID0gNDtcbiAgICAgIHRoaXMuaW1wb3J0T2JqZWN0LmpzID0geyBtZW1vcnk6IG1lbW9yeSB9O1xuICAgIH1cbiAgICB0aGlzLmN1cnJlbnRFbnYgPSB7XG4gICAgICBnbG9iYWxzOiBuZXcgTWFwKCksXG4gICAgICBjbGFzc2VzOiBuZXcgTWFwKCksXG4gICAgICBjbGFzc0luZGljZXM6IG5ldyBNYXAoKSxcbiAgICAgIGZ1bmN0aW9uTmFtZXM6IG5ldyBNYXAoKSxcbiAgICAgIGxvY2FsczogbmV3IFNldCgpLFxuICAgICAgbGFiZWxzOiBbXSxcbiAgICAgIG9mZnNldDogMSxcbiAgICAgIHZ0YWJsZU1ldGhvZHM6IFtdXG4gICAgfTtcbiAgICB0aGlzLmN1cnJlbnRUeXBlRW52ID0gZGVmYXVsdFR5cGVFbnY7XG4gICAgdGhpcy5mdW5jdGlvbnMgPSBcIlwiO1xuICB9XG4gIGFzeW5jIHJ1bihzb3VyY2UgOiBzdHJpbmcpIDogUHJvbWlzZTxWYWx1ZTxBbm5vdGF0aW9uPj4ge1xuICAgIGNvbnN0IGNvbmZpZyA6IENvbmZpZyA9IHtpbXBvcnRPYmplY3Q6IHRoaXMuaW1wb3J0T2JqZWN0LCBlbnY6IHRoaXMuY3VycmVudEVudiwgdHlwZUVudjogdGhpcy5jdXJyZW50VHlwZUVudiwgZnVuY3Rpb25zOiB0aGlzLmZ1bmN0aW9uc307XG4gICAgY29uc3QgW3Jlc3VsdCwgbmV3RW52LCBuZXdUeXBlRW52LCBuZXdGdW5jdGlvbnMsIGluc3RhbmNlXSA9IGF3YWl0IHJ1bihzb3VyY2UsIGNvbmZpZyk7XG4gICAgdGhpcy5jdXJyZW50RW52ID0gbmV3RW52O1xuICAgIHRoaXMuY3VycmVudFR5cGVFbnYgPSBuZXdUeXBlRW52O1xuICAgIHRoaXMuZnVuY3Rpb25zICs9IG5ld0Z1bmN0aW9ucztcbiAgICBjb25zdCBjdXJyZW50R2xvYmFscyA9IHRoaXMuaW1wb3J0T2JqZWN0LmVudiB8fCB7fTtcbiAgICBPYmplY3Qua2V5cyhpbnN0YW5jZS5pbnN0YW5jZS5leHBvcnRzKS5mb3JFYWNoKGsgPT4ge1xuICAgICAgY29uc3QgbWF5YmVHbG9iYWwgPSBpbnN0YW5jZS5pbnN0YW5jZS5leHBvcnRzW2tdO1xuICAgICAgaWYobWF5YmVHbG9iYWwgaW5zdGFuY2VvZiBXZWJBc3NlbWJseS5HbG9iYWwpIHtcbiAgICAgICAgY3VycmVudEdsb2JhbHNba10gPSBtYXliZUdsb2JhbDtcbiAgICAgIH1cbiAgICB9KTtcbiAgICB0aGlzLmltcG9ydE9iamVjdC5lbnYgPSBjdXJyZW50R2xvYmFscztcbiAgICByZXR1cm4gcmVzdWx0O1xuICB9XG4gIG9wdGltaXplKHNvdXJjZTogc3RyaW5nKTogWyBQcm9ncmFtPEFubm90YXRpb24+LCBQcm9ncmFtPEFubm90YXRpb24+IF0ge1xuICAgIC8vIGNvbnNvbGUubG9nKHN0bXQpO1xuICAgIGNvbnN0IGNvbmZpZyA6IENvbmZpZyA9IHtpbXBvcnRPYmplY3Q6IHRoaXMuaW1wb3J0T2JqZWN0LCBlbnY6IHRoaXMuY3VycmVudEVudiwgdHlwZUVudjogdGhpcy5jdXJyZW50VHlwZUVudiwgZnVuY3Rpb25zOiB0aGlzLmZ1bmN0aW9uc307XG4gICAgY29uc3QgcGFyc2VkID0gcGFyc2Uoc291cmNlKTtcbiAgICBjb25zdCBbdHByb2dyYW0sIHRlbnZdID0gdGMoY29uZmlnLnR5cGVFbnYsIHBhcnNlZCk7XG4gICAgY29uc3QgZ2xvYmFsRW52ID0gYXVnbWVudEVudihjb25maWcuZW52LCB0cHJvZ3JhbSk7XG4gICAgY29uc3QgaXJwcm9ncmFtID0gbG93ZXJQcm9ncmFtKHRwcm9ncmFtLCBnbG9iYWxFbnYpO1xuICAgIGlmKCF0aGlzLmltcG9ydE9iamVjdC5qcykge1xuICAgICAgY29uc3QgbWVtb3J5ID0gbmV3IFdlYkFzc2VtYmx5Lk1lbW9yeSh7aW5pdGlhbDoyMDAwLCBtYXhpbXVtOjIwMDB9KTtcbiAgICAgIHRoaXMuaW1wb3J0T2JqZWN0LmpzID0geyBtZW1vcnk6IG1lbW9yeSB9O1xuICAgIH1cbiAgICByZXR1cm4gWyBpcnByb2dyYW0sIG9wdGltaXplUHJvZ3JhbShpcnByb2dyYW0pIF07XG4gIH1cbiAgdGMoc291cmNlOiBzdHJpbmcpOiBUeXBlIHtcbiAgICBjb25zdCBjb25maWc6IENvbmZpZyA9IHsgaW1wb3J0T2JqZWN0OiB0aGlzLmltcG9ydE9iamVjdCwgZW52OiB0aGlzLmN1cnJlbnRFbnYsIHR5cGVFbnY6IHRoaXMuY3VycmVudFR5cGVFbnYsIGZ1bmN0aW9uczogdGhpcy5mdW5jdGlvbnMgfTtcbiAgICBjb25zdCBwYXJzZWQgPSBwYXJzZShzb3VyY2UpO1xuICAgIGNvbnN0IFtyZXN1bHQsIF9dID0gdGModGhpcy5jdXJyZW50VHlwZUVudiwgcGFyc2VkKTtcbiAgICByZXR1cm4gcmVzdWx0LmEudHlwZTtcbiAgfVxufSIsIi8vIFRoaXMgaXMgYSBtYXNodXAgb2YgdHV0b3JpYWxzIGZyb206XG4vL1xuLy8gLSBodHRwczovL2dpdGh1Yi5jb20vQXNzZW1ibHlTY3JpcHQvd2FidC5qcy9cbi8vIC0gaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4tVVMvZG9jcy9XZWJBc3NlbWJseS9Vc2luZ190aGVfSmF2YVNjcmlwdF9BUElcblxuaW1wb3J0IHdhYnQgZnJvbSAnd2FidCc7XG5pbXBvcnQgeyBjb21waWxlLCBHbG9iYWxFbnYgfSBmcm9tICcuL2NvbXBpbGVyJztcbmltcG9ydCB7cGFyc2V9IGZyb20gJy4vcGFyc2VyJztcbmltcG9ydCB7ZW1wdHlMb2NhbFR5cGVFbnYsIEdsb2JhbFR5cGVFbnYsIHRjLCB0Y1N0bXR9IGZyb20gICcuL3R5cGUtY2hlY2snO1xuaW1wb3J0IHsgQW5ub3RhdGlvbiwgRnVuRGVmLCBQcm9ncmFtLCBUeXBlLCBWYWx1ZSB9IGZyb20gJy4vYXN0JztcbmltcG9ydCB7IFB5VmFsdWUsIE5PTkUsIEJPT0wsIE5VTSwgQ0xBU1MsIG1ha2VXYXNtRnVuVHlwZSB9IGZyb20gXCIuL3V0aWxzXCI7XG5pbXBvcnQgeyBjbG9zdXJlTmFtZSwgbG93ZXJQcm9ncmFtIH0gZnJvbSAnLi9sb3dlcic7XG5pbXBvcnQgeyBtb25vbW9ycGhpemVQcm9ncmFtIH0gZnJvbSAnLi9tb25vbW9ycGhpemVyJztcbmltcG9ydCB7IG9wdGltaXplUHJvZ3JhbSB9IGZyb20gJy4vb3B0aW1pemF0aW9uJztcbmltcG9ydCB7IHdhc21FcnJvckltcG9ydHMgfSBmcm9tICcuL2Vycm9ycyc7XG5cbmV4cG9ydCB0eXBlIENvbmZpZyA9IHtcbiAgaW1wb3J0T2JqZWN0OiBhbnk7XG4gIC8vIGVudjogY29tcGlsZXIuR2xvYmFsRW52LFxuICBlbnY6IEdsb2JhbEVudixcbiAgdHlwZUVudjogR2xvYmFsVHlwZUVudixcbiAgZnVuY3Rpb25zOiBzdHJpbmcgICAgICAgIC8vIHByZWx1ZGUgZnVuY3Rpb25zXG59XG5cbi8vIE5PVEUoam9lKTogVGhpcyBpcyBhIGhhY2sgdG8gZ2V0IHRoZSBDTEkgUmVwbCB0byBydW4uIFdBQlQgcmVnaXN0ZXJzIGEgZ2xvYmFsXG4vLyB1bmNhdWdodCBleG4gaGFuZGxlciwgYW5kIHRoaXMgaXMgbm90IGFsbG93ZWQgd2hlbiBydW5uaW5nIHRoZSBSRVBMXG4vLyAoaHR0cHM6Ly9ub2RlanMub3JnL2FwaS9yZXBsLmh0bWwjcmVwbF9nbG9iYWxfdW5jYXVnaHRfZXhjZXB0aW9ucykuIE5vIHJlYXNvblxuLy8gaXMgZ2l2ZW4gZm9yIHRoaXMgaW4gdGhlIGRvY3MgcGFnZSwgYW5kIEkgaGF2ZW4ndCBzcGVudCB0aW1lIG9uIHRoZSBkb21haW5cbi8vIG1vZHVsZSB0byBmaWd1cmUgb3V0IHdoYXQncyBnb2luZyBvbiBoZXJlLiBJdCBkb2Vzbid0IHNlZW0gY3JpdGljYWwgZm9yIFdBQlRcbi8vIHRvIGhhdmUgdGhpcyBzdXBwb3J0LCBzbyB3ZSBwYXRjaCBpdCBhd2F5LlxuaWYodHlwZW9mIHByb2Nlc3MgIT09IFwidW5kZWZpbmVkXCIpIHtcbiAgY29uc3Qgb2xkUHJvY2Vzc09uID0gcHJvY2Vzcy5vbjtcbiAgcHJvY2Vzcy5vbiA9ICguLi5hcmdzIDogYW55KSA6IGFueSA9PiB7XG4gICAgaWYoYXJnc1swXSA9PT0gXCJ1bmNhdWdodEV4Y2VwdGlvblwiKSB7IHJldHVybjsgfVxuICAgIGVsc2UgeyByZXR1cm4gb2xkUHJvY2Vzc09uLmFwcGx5KHByb2Nlc3MsIGFyZ3MpOyB9XG4gIH07XG59XG5cbmV4cG9ydCBhc3luYyBmdW5jdGlvbiBydW5XYXQoc291cmNlIDogc3RyaW5nLCBpbXBvcnRPYmplY3QgOiBhbnkpIDogUHJvbWlzZTxhbnk+IHtcbiAgY29uc3Qgd2FidEludGVyZmFjZSA9IGF3YWl0IHdhYnQoKTtcbiAgY29uc3QgbXlNb2R1bGUgPSB3YWJ0SW50ZXJmYWNlLnBhcnNlV2F0KFwidGVzdC53YXRcIiwgc291cmNlKTtcbiAgdmFyIGFzQmluYXJ5ID0gbXlNb2R1bGUudG9CaW5hcnkoe30pO1xuICB2YXIgd2FzbU1vZHVsZSA9IGF3YWl0IFdlYkFzc2VtYmx5Lmluc3RhbnRpYXRlKGFzQmluYXJ5LmJ1ZmZlciwgaW1wb3J0T2JqZWN0KTtcbiAgY29uc3QgcmVzdWx0ID0gKHdhc21Nb2R1bGUuaW5zdGFuY2UuZXhwb3J0cy5leHBvcnRlZF9mdW5jIGFzIGFueSkoKTtcbiAgcmV0dXJuIFtyZXN1bHQsIHdhc21Nb2R1bGVdO1xufVxuXG5cbmV4cG9ydCBmdW5jdGlvbiBhdWdtZW50RW52KGVudjogR2xvYmFsRW52LCBwcm9nOiBQcm9ncmFtPEFubm90YXRpb24+KSA6IEdsb2JhbEVudiB7XG4gIGNvbnN0IG5ld0dsb2JhbHMgPSBuZXcgTWFwKGVudi5nbG9iYWxzKTtcbiAgY29uc3QgbmV3Q2xhc3NlcyA9IG5ldyBNYXAoZW52LmNsYXNzZXMpO1xuICBjb25zdCBuZXdDbGFzc0luZGljZXMgPSBuZXcgTWFwKGVudi5jbGFzc0luZGljZXMpO1xuICBjb25zdCBmdW5jdGlvbk5hbWVzID0gbmV3IE1hcChlbnYuZnVuY3Rpb25OYW1lcyk7XG5cbiAgdmFyIG5ld09mZnNldCA9IGVudi5vZmZzZXQ7XG4gIHByb2cuaW5pdHMuZm9yRWFjaCgodikgPT4ge1xuICAgIG5ld0dsb2JhbHMuc2V0KHYubmFtZSwgdHJ1ZSk7XG4gIH0pO1xuICBwcm9nLmZ1bnMuZm9yRWFjaChmID0+IHtcbiAgICBmdW5jdGlvbk5hbWVzLnNldChmLm5hbWUsIGNsb3N1cmVOYW1lKGYubmFtZSwgW10pKTtcbiAgICBjb25zdCBhZGRDbGFzc2VzID0gKGY6IEZ1bkRlZjxBbm5vdGF0aW9uPiwgYW5jZXN0b3JzOiBBcnJheTxGdW5EZWY8QW5ub3RhdGlvbj4+KSA9PiB7XG4gICAgICBuZXdDbGFzc2VzLnNldChjbG9zdXJlTmFtZShmLm5hbWUsIGFuY2VzdG9ycyksIG5ldyBNYXAoKSk7XG4gICAgICBmLmNoaWxkcmVuLmZvckVhY2goYyA9PiBhZGRDbGFzc2VzKGMsIFtmLCAuLi5hbmNlc3RvcnNdKSk7XG4gICAgfVxuICAgIGFkZENsYXNzZXMoZiwgW10pO1xuICB9KTtcbiAgcHJvZy5jbGFzc2VzLmZvckVhY2goY2xzID0+IHtcbiAgICBjb25zdCBjbGFzc0ZpZWxkcyA9IG5ldyBNYXAoKTtcbiAgICBjbHMuZmllbGRzLmZvckVhY2goKGZpZWxkLCBpKSA9PiBjbGFzc0ZpZWxkcy5zZXQoZmllbGQubmFtZSwgW2kgKyAxLCBmaWVsZC52YWx1ZV0pKTtcbiAgICBuZXdDbGFzc2VzLnNldChjbHMubmFtZSwgY2xhc3NGaWVsZHMpO1xuICB9KTtcbiAgcmV0dXJuIHtcbiAgICBnbG9iYWxzOiBuZXdHbG9iYWxzLFxuICAgIGNsYXNzZXM6IG5ld0NsYXNzZXMsXG4gICAgY2xhc3NJbmRpY2VzOiBuZXdDbGFzc0luZGljZXMsXG4gICAgZnVuY3Rpb25OYW1lcyxcbiAgICBsb2NhbHM6IGVudi5sb2NhbHMsXG4gICAgbGFiZWxzOiBlbnYubGFiZWxzLFxuICAgIG9mZnNldDogbmV3T2Zmc2V0LFxuICAgIHZ0YWJsZU1ldGhvZHM6IGVudi52dGFibGVNZXRob2RzLFxuICB9XG59XG5cbi8vIGV4cG9ydCBhc3luYyBmdW5jdGlvbiBydW4oc291cmNlIDogc3RyaW5nLCBjb25maWc6IENvbmZpZykgOiBQcm9taXNlPFtWYWx1ZSwgY29tcGlsZXIuR2xvYmFsRW52LCBHbG9iYWxUeXBlRW52LCBzdHJpbmddPiB7XG5leHBvcnQgYXN5bmMgZnVuY3Rpb24gcnVuKHNvdXJjZSA6IHN0cmluZywgY29uZmlnOiBDb25maWcpIDogUHJvbWlzZTxbVmFsdWU8QW5ub3RhdGlvbj4sIEdsb2JhbEVudiwgR2xvYmFsVHlwZUVudiwgc3RyaW5nLCBXZWJBc3NlbWJseS5XZWJBc3NlbWJseUluc3RhbnRpYXRlZFNvdXJjZV0+IHtcbiAgY29uZmlnLmltcG9ydE9iamVjdC5lcnJvcnMuc3JjID0gc291cmNlOyAvLyBmb3IgZXJyb3IgcmVwb3J0aW5nXG4gIGNvbnN0IHBhcnNlZCA9IHBhcnNlKHNvdXJjZSk7XG4gIGNvbnN0IFt0cHJvZ3JhbSwgdGVudl0gPSB0Yyhjb25maWcudHlwZUVudiwgcGFyc2VkKTtcbiAgY29uc3QgdG1wcm9ncmFtID0gbW9ub21vcnBoaXplUHJvZ3JhbSh0cHJvZ3JhbSk7XG4gIGNvbnN0IGdsb2JhbEVudiA9IGF1Z21lbnRFbnYoY29uZmlnLmVudiwgdG1wcm9ncmFtKTtcbiAgY29uc3QgaXJwcm9ncmFtID0gbG93ZXJQcm9ncmFtKHRtcHJvZ3JhbSwgZ2xvYmFsRW52KTtcbiAgY29uc3Qgb3B0SXIgPSBvcHRpbWl6ZVByb2dyYW0oaXJwcm9ncmFtKTtcbiAgY29uc3QgcHJvZ1R5cCA9IHRtcHJvZ3JhbS5hLnR5cGU7XG4gIHZhciByZXR1cm5UeXBlID0gXCJcIjtcbiAgdmFyIHJldHVybkV4cHIgPSBcIlwiO1xuICAvLyBjb25zdCBsYXN0RXhwciA9IHBhcnNlZC5zdG10c1twYXJzZWQuc3RtdHMubGVuZ3RoIC0gMV1cbiAgLy8gY29uc3QgbGFzdEV4cHJUeXAgPSBsYXN0RXhwci5hO1xuICAvLyBjb25zb2xlLmxvZyhcIkxBU1RFWFBSXCIsIGxhc3RFeHByKTtcbiAgaWYocHJvZ1R5cCAhPT0gTk9ORSkge1xuICAgIHJldHVyblR5cGUgPSBcIihyZXN1bHQgaTMyKVwiO1xuICAgIHJldHVybkV4cHIgPSBcIihsb2NhbC5nZXQgJCRsYXN0KVwiXG4gIH0gXG4gIGxldCBnbG9iYWxzQmVmb3JlID0gY29uZmlnLmVudi5nbG9iYWxzO1xuICAvLyBjb25zdCBjb21waWxlZCA9IGNvbXBpbGVyLmNvbXBpbGUodHByb2dyYW0sIGNvbmZpZy5lbnYpO1xuICBjb25zdCBjb21waWxlZCA9IGNvbXBpbGUob3B0SXIsIGdsb2JhbEVudik7XG5cbiAgY29uc3QgdnRhYmxlID0gYCh0YWJsZSAke2dsb2JhbEVudi52dGFibGVNZXRob2RzLmxlbmd0aH0gZnVuY3JlZilcbiAgICAoZWxlbSAoaTMyLmNvbnN0IDApICR7Z2xvYmFsRW52LnZ0YWJsZU1ldGhvZHMubWFwKG1ldGhvZCA9PiBgJCR7bWV0aG9kWzBdfWApLmpvaW4oXCIgXCIpfSlgO1xuICBjb25zdCB0eXBlU2V0ID0gbmV3IFNldDxudW1iZXI+KCk7XG4gIGdsb2JhbEVudi52dGFibGVNZXRob2RzLmZvckVhY2goKFtfLCBwYXJhbU51bV0pPT50eXBlU2V0LmFkZChwYXJhbU51bSkpO1xuICBsZXQgdHlwZXMgPSBcIlwiO1xuICB0eXBlU2V0LmZvckVhY2gocGFyYW1OdW0gPT4ge1xuICAgIGxldCBwYXJhbVR5cGUgPSBcIlwiO1xuICAgIGlmIChwYXJhbU51bSA+IDApIHtcbiAgICAgIHBhcmFtVHlwZSA9IGAocGFyYW0ke1wiIGkzMlwiLnJlcGVhdChwYXJhbU51bSl9KWBcbiAgICB9XG4gICAgdHlwZXMgKz0gYCh0eXBlICR7bWFrZVdhc21GdW5UeXBlKHBhcmFtTnVtKX0gKGZ1bmMgJHtwYXJhbVR5cGV9IChyZXN1bHQgaTMyKSkpXFxuYDtcbiAgfSlcbiAgY29uc3QgZ2xvYmFsSW1wb3J0cyA9IFsuLi5nbG9iYWxzQmVmb3JlLmtleXMoKV0ubWFwKG5hbWUgPT5cbiAgICBgKGltcG9ydCBcImVudlwiIFwiJHtuYW1lfVwiIChnbG9iYWwgJCR7bmFtZX0gKG11dCBpMzIpKSlgXG4gICkuam9pbihcIlxcblwiKTtcbiAgY29uc3QgZ2xvYmFsRGVjbHMgPSBjb21waWxlZC5nbG9iYWxzLm1hcChuYW1lID0+XG4gICAgYChnbG9iYWwgJCR7bmFtZX0gKGV4cG9ydCBcIiR7bmFtZX1cIikgKG11dCBpMzIpIChpMzIuY29uc3QgMCkpYFxuICApLmpvaW4oXCJcXG5cIik7XG5cbiAgY29uc3QgaW1wb3J0T2JqZWN0ID0gY29uZmlnLmltcG9ydE9iamVjdDtcbiAgaWYoIWltcG9ydE9iamVjdC5qcykge1xuICAgIGNvbnN0IG1lbW9yeSA9IG5ldyBXZWJBc3NlbWJseS5NZW1vcnkoe2luaXRpYWw6MjAwMCwgbWF4aW11bToyMDAwfSk7XG4gICAgaW1wb3J0T2JqZWN0LmpzID0geyBtZW1vcnk6IG1lbW9yeSB9O1xuICB9XG5cbiAgY29uc3Qgd2FzbVNvdXJjZSA9IGAobW9kdWxlXG4gICAgKGltcG9ydCBcImpzXCIgXCJtZW1vcnlcIiAobWVtb3J5IDEpKVxuICAgICR7d2FzbUVycm9ySW1wb3J0c31cbiAgICAoZnVuYyAkcHJpbnRfbnVtIChpbXBvcnQgXCJpbXBvcnRzXCIgXCJwcmludF9udW1cIikgKHBhcmFtIGkzMikgKHJlc3VsdCBpMzIpKVxuICAgIChmdW5jICRwcmludF9ib29sIChpbXBvcnQgXCJpbXBvcnRzXCIgXCJwcmludF9ib29sXCIpIChwYXJhbSBpMzIpIChyZXN1bHQgaTMyKSlcbiAgICAoZnVuYyAkcHJpbnRfbm9uZSAoaW1wb3J0IFwiaW1wb3J0c1wiIFwicHJpbnRfbm9uZVwiKSAocGFyYW0gaTMyKSAocmVzdWx0IGkzMikpXG4gICAgKGZ1bmMgJGFicyAoaW1wb3J0IFwiaW1wb3J0c1wiIFwiYWJzXCIpIChwYXJhbSBpMzIpIChyZXN1bHQgaTMyKSlcbiAgICAoZnVuYyAkbWluIChpbXBvcnQgXCJpbXBvcnRzXCIgXCJtaW5cIikgKHBhcmFtIGkzMikgKHBhcmFtIGkzMikgKHJlc3VsdCBpMzIpKVxuICAgIChmdW5jICRtYXggKGltcG9ydCBcImltcG9ydHNcIiBcIm1heFwiKSAocGFyYW0gaTMyKSAocGFyYW0gaTMyKSAocmVzdWx0IGkzMikpXG4gICAgKGZ1bmMgJHBvdyAoaW1wb3J0IFwiaW1wb3J0c1wiIFwicG93XCIpIChwYXJhbSBpMzIpIChwYXJhbSBpMzIpIChyZXN1bHQgaTMyKSlcbiAgICAoZnVuYyAkYWxsb2MgKGltcG9ydCBcImxpYm1lbW9yeVwiIFwiYWxsb2NcIikgKHBhcmFtIGkzMikgKHJlc3VsdCBpMzIpKVxuICAgIChmdW5jICRsb2FkIChpbXBvcnQgXCJsaWJtZW1vcnlcIiBcImxvYWRcIikgKHBhcmFtIGkzMikgKHBhcmFtIGkzMikgKHJlc3VsdCBpMzIpKVxuICAgIChmdW5jICRzdG9yZSAoaW1wb3J0IFwibGlibWVtb3J5XCIgXCJzdG9yZVwiKSAocGFyYW0gaTMyKSAocGFyYW0gaTMyKSAocGFyYW0gaTMyKSlcbiAgICAoZnVuYyAkJGFkZCAoaW1wb3J0IFwiaW1wb3J0c1wiIFwiJGFkZFwiKSAocGFyYW0gaTMyKSAocGFyYW0gaTMyKSAocmVzdWx0IGkzMikpXG4gICAgKGZ1bmMgJCRzdWIgKGltcG9ydCBcImltcG9ydHNcIiBcIiRzdWJcIikgKHBhcmFtIGkzMikgKHBhcmFtIGkzMikgKHJlc3VsdCBpMzIpKVxuICAgIChmdW5jICQkbXVsIChpbXBvcnQgXCJpbXBvcnRzXCIgXCIkbXVsXCIpIChwYXJhbSBpMzIpIChwYXJhbSBpMzIpIChyZXN1bHQgaTMyKSlcbiAgICAoZnVuYyAkJGRpdiAoaW1wb3J0IFwiaW1wb3J0c1wiIFwiJGRpdlwiKSAocGFyYW0gaTMyKSAocGFyYW0gaTMyKSAocmVzdWx0IGkzMikpXG4gICAgKGZ1bmMgJCRtb2QgKGltcG9ydCBcImltcG9ydHNcIiBcIiRtb2RcIikgKHBhcmFtIGkzMikgKHBhcmFtIGkzMikgKHJlc3VsdCBpMzIpKVxuICAgIChmdW5jICQkZXEgKGltcG9ydCBcImltcG9ydHNcIiBcIiRlcVwiKSAocGFyYW0gaTMyKSAocGFyYW0gaTMyKSAocmVzdWx0IGkzMikpXG4gICAgKGZ1bmMgJCRuZXEgKGltcG9ydCBcImltcG9ydHNcIiBcIiRuZXFcIikgKHBhcmFtIGkzMikgKHBhcmFtIGkzMikgKHJlc3VsdCBpMzIpKVxuICAgIChmdW5jICQkbHRlIChpbXBvcnQgXCJpbXBvcnRzXCIgXCIkbHRlXCIpIChwYXJhbSBpMzIpIChwYXJhbSBpMzIpIChyZXN1bHQgaTMyKSlcbiAgICAoZnVuYyAkJGd0ZSAoaW1wb3J0IFwiaW1wb3J0c1wiIFwiJGd0ZVwiKSAocGFyYW0gaTMyKSAocGFyYW0gaTMyKSAocmVzdWx0IGkzMikpXG4gICAgKGZ1bmMgJCRsdCAoaW1wb3J0IFwiaW1wb3J0c1wiIFwiJGx0XCIpIChwYXJhbSBpMzIpIChwYXJhbSBpMzIpIChyZXN1bHQgaTMyKSlcbiAgICAoZnVuYyAkJGd0IChpbXBvcnQgXCJpbXBvcnRzXCIgXCIkZ3RcIikgKHBhcmFtIGkzMikgKHBhcmFtIGkzMikgKHJlc3VsdCBpMzIpKVxuICAgICR7dHlwZXN9XG4gICAgJHtnbG9iYWxJbXBvcnRzfVxuICAgICR7Z2xvYmFsRGVjbHN9XG4gICAgJHt2dGFibGV9XG4gICAgJHtjb25maWcuZnVuY3Rpb25zfVxuICAgICR7Y29tcGlsZWQuZnVuY3Rpb25zfVxuICAgIChmdW5jIChleHBvcnQgXCJleHBvcnRlZF9mdW5jXCIpICR7cmV0dXJuVHlwZX1cbiAgICAgICR7Y29tcGlsZWQubWFpblNvdXJjZX1cbiAgICAgICR7cmV0dXJuRXhwcn1cbiAgICApXG4gIClgO1xuICBjb25zdCBbcmVzdWx0LCBpbnN0YW5jZV0gPSBhd2FpdCBydW5XYXQod2FzbVNvdXJjZSwgaW1wb3J0T2JqZWN0KTtcblxuICByZXR1cm4gW1B5VmFsdWUocHJvZ1R5cCwgcmVzdWx0KSwgY29tcGlsZWQubmV3RW52LCB0ZW52LCBjb21waWxlZC5mdW5jdGlvbnMsIGluc3RhbmNlXTtcbn1cbiIsImltcG9ydCB7IFRyZWVDdXJzb3IgfSBmcm9tIFwiQGxlemVyL2NvbW1vblwiIDtcblxuZXhwb3J0IGZ1bmN0aW9uIHN0cmluZ2lmeVRyZWUodDogVHJlZUN1cnNvciwgc291cmNlOiBzdHJpbmcsIGQ6IG51bWJlcik6IHN0cmluZyB7XG4gICAgdmFyIHN0ciA9IFwiXCI7XG4gICAgdmFyIHNwYWNlcyA9IFwiIFwiLnJlcGVhdChkKjIpO1xuICAgIHN0ciArPSBzcGFjZXMgKyB0LnR5cGUubmFtZTtcbiAgICBpZiAoW1wiTnVtYmVyXCIsIFwiQ2FsbEV4cHJlc3Npb25cIiwgXCJCaW5hcnlFeHByZXNzaW9uXCIsIFwiVW5hcnlFeHByZXNzaW9uXCIsIFwiQXJpdGhPcFwiLCBcIlZhcmlhYmxlTmFtZVwiXS5pbmNsdWRlcyh0LnR5cGUubmFtZSkpIHsgXG4gICAgICBzdHIgKz0gXCIgLS0+IFwiICsgc291cmNlLnN1YnN0cmluZyh0LmZyb20sIHQudG8pXG4gICAgfVxuICAgIHN0ciArPSBcIlxcblwiO1xuICAgIGlmICh0LmZpcnN0Q2hpbGQoKSkge1xuICAgICAgZG8ge1xuICAgICAgICBzdHIgKz0gc3RyaW5naWZ5VHJlZSh0LCBzb3VyY2UsIGQrMSk7XG4gICAgICB9IHdoaWxlKHQubmV4dFNpYmxpbmcoKSk7XG4gICAgICB0LnBhcmVudCgpO1xuICAgIH1cbiAgICByZXR1cm4gc3RyO1xufSIsImltcG9ydCB7IEFubm90YXRpb24sIExvY2F0aW9uLCBzdHJpbmdpZnlPcCwgU3RtdCwgRXhwciwgVHlwZSwgVW5pT3AsIEJpbk9wLCBMaXRlcmFsLCBQcm9ncmFtLCBGdW5EZWYsIFZhckluaXQsIENsYXNzLCBDYWxsYWJsZSwgVHlwZVZhciwgUGFyYW1ldGVyIH0gZnJvbSAnLi9hc3QnO1xuaW1wb3J0IHsgTlVNLCBCT09MLCBOT05FLCBDTEFTUywgQ0FMTEFCTEUsIFRZUEVWQVIgfSBmcm9tICcuL3V0aWxzJztcbmltcG9ydCB7IGVtcHR5RW52IH0gZnJvbSAnLi9jb21waWxlcic7XG5pbXBvcnQgeyBmdWxsU3JjTGluZSwgZHJhd1NxdWlnZ2x5IH0gZnJvbSAnLi9lcnJvcnMnO1xuXG4vLyBJIOKdpO+4jyBUeXBlU2NyaXB0OiBodHRwczovL2dpdGh1Yi5jb20vbWljcm9zb2Z0L1R5cGVTY3JpcHQvaXNzdWVzLzEzOTY1XG5cblxuXG5leHBvcnQgY2xhc3MgVHlwZUNoZWNrRXJyb3IgZXh0ZW5kcyBFcnJvciB7XG4gIF9fcHJvdG9fXzogRXJyb3I7XG4gIGE/OiBBbm5vdGF0aW9uIHwgdW5kZWZpbmVkO1xuICBlcnJNc2c6IHN0cmluZztcblxuICBjb25zdHJ1Y3RvcihTUkM/OiBzdHJpbmcsIG1lc3NhZ2U/OiBzdHJpbmcsIGE/OiBBbm5vdGF0aW9uKSB7XG4gICAgY29uc3QgZnJvbUxvYyA9IGE/LmZyb21Mb2M7XG4gICAgY29uc3QgZW5kTG9jID0gYT8uZW5kTG9jO1xuICAgIGNvbnN0IGVvbExvYyA9IGE/LmVvbExvYztcbiAgICBjb25zdCB0cnVlUHJvdG8gPSBuZXcudGFyZ2V0LnByb3RvdHlwZTtcbiAgICBjb25zdCBsb2MgPSAoYSkgPyBgIG9uIGxpbmUgJHtmcm9tTG9jLnJvd30gYXQgY29sICR7ZnJvbUxvYy5jb2x9YCA6ICcnO1xuICAgIGNvbnN0IHNyYyA9IChhKSA/IGZ1bGxTcmNMaW5lKFNSQywgZnJvbUxvYy5zcmNJZHgsIGZyb21Mb2MuY29sLCBlb2xMb2Muc3JjSWR4KSA6ICcnO1xuICAgIC8vIFRPRE86IGhvdyB0byBkcmF3IHNxdWlnZ2xpZXMgaWYgdGhlIGVycm9yIHNwYW5zIG11bHRpcGxlIGxpbmVzP1xuICAgIGNvbnN0IHNxdWlnZ2x5ID0gKGEpID8gZHJhd1NxdWlnZ2x5KGZyb21Mb2Mucm93LCBlbmRMb2Mucm93LCBmcm9tTG9jLmNvbCwgZW5kTG9jLmNvbCkgOiAnJztcbiAgICBjb25zdCBtc2cgPSBgXFxuXFxuJHtzcmN9XFxuJHtzcXVpZ2dseX1gO1xuICAgIGNvbnN0IHJlcyA9IFwiVFlQRSBFUlJPUjogXCIgKyBtZXNzYWdlICsgbG9jICsgbXNnO1xuICAgIHN1cGVyKHJlcyk7XG4gICAgdGhpcy5hID0gKGEpID8/IHVuZGVmaW5lZDtcbiAgICB0aGlzLmVyck1zZyA9IHJlcztcblxuXG4gICAgLy8gQWx0ZXJuYXRpdmVseSB1c2UgT2JqZWN0LnNldFByb3RvdHlwZU9mIGlmIHlvdSBoYXZlIGFuIEVTNiBlbnZpcm9ubWVudC5cbiAgICB0aGlzLl9fcHJvdG9fXyA9IHRydWVQcm90bztcbiAgfVxuXG4gIHB1YmxpYyBnZXRBKCk6IEFubm90YXRpb24gfCB1bmRlZmluZWQge1xuICAgIHJldHVybiB0aGlzLmE7XG4gIH1cblxuICBwdWJsaWMgZ2V0RXJyTXNnKCk6IHN0cmluZyB7XG4gICAgcmV0dXJuIHRoaXMuZXJyTXNnO1xuICB9XG5cbn1cblxuZXhwb3J0IHR5cGUgR2xvYmFsVHlwZUVudiA9IHtcbiAgZ2xvYmFsczogTWFwPHN0cmluZywgVHlwZT4sXG4gIGZ1bmN0aW9uczogTWFwPHN0cmluZywgW0FycmF5PFR5cGU+LCBUeXBlXT4sXG4gIGNsYXNzZXM6IE1hcDxzdHJpbmcsIFtNYXA8c3RyaW5nLCBUeXBlPiwgTWFwPHN0cmluZywgW0FycmF5PFR5cGU+LCBUeXBlXT4sIEFycmF5PHN0cmluZz5dPixcbiAgdHlwZXZhcnM6IE1hcDxzdHJpbmcsIFtzdHJpbmddPlxufVxuXG5leHBvcnQgdHlwZSBMb2NhbFR5cGVFbnYgPSB7XG4gIHZhcnM6IE1hcDxzdHJpbmcsIFR5cGU+LFxuICBleHBlY3RlZFJldDogVHlwZSxcbiAgYWN0dWFsUmV0OiBUeXBlLFxuICB0b3BMZXZlbDogQm9vbGVhblxufVxuXG5jb25zdCBjb3B5TG9jYWxzID0gKGxvY2FsczogTG9jYWxUeXBlRW52KTogTG9jYWxUeXBlRW52ID0+IHtcbiAgcmV0dXJuIHtcbiAgICAuLi5sb2NhbHMsXG4gICAgdmFyczogbmV3IE1hcChsb2NhbHMudmFycylcbiAgfVxufVxuY29uc3QgY29weUdsb2JhbHMgPSAoZW52OiBHbG9iYWxUeXBlRW52KTogR2xvYmFsVHlwZUVudiA9PiB7XG4gIHJldHVybiB7XG4gICAgZ2xvYmFsczogbmV3IE1hcChlbnYuZ2xvYmFscyksXG4gICAgZnVuY3Rpb25zOiBuZXcgTWFwKGVudi5mdW5jdGlvbnMpLFxuICAgIGNsYXNzZXM6IG5ldyBNYXAoZW52LmNsYXNzZXMpLFxuICAgIHR5cGV2YXJzOiBuZXcgTWFwKGVudi50eXBldmFycylcbiAgfTtcbn1cblxuZXhwb3J0IHR5cGUgTm9ubG9jYWxUeXBlRW52ID0gTG9jYWxUeXBlRW52W1widmFyc1wiXVxuXG5jb25zdCBkZWZhdWx0R2xvYmFsRnVuY3Rpb25zID0gbmV3IE1hcCgpO1xuZGVmYXVsdEdsb2JhbEZ1bmN0aW9ucy5zZXQoXCJhYnNcIiwgW1tOVU1dLCBOVU1dKTtcbmRlZmF1bHRHbG9iYWxGdW5jdGlvbnMuc2V0KFwibWF4XCIsIFtbTlVNLCBOVU1dLCBOVU1dKTtcbmRlZmF1bHRHbG9iYWxGdW5jdGlvbnMuc2V0KFwibWluXCIsIFtbTlVNLCBOVU1dLCBOVU1dKTtcbmRlZmF1bHRHbG9iYWxGdW5jdGlvbnMuc2V0KFwicG93XCIsIFtbTlVNLCBOVU1dLCBOVU1dKTtcbmRlZmF1bHRHbG9iYWxGdW5jdGlvbnMuc2V0KFwicHJpbnRcIiwgW1tDTEFTUyhcIm9iamVjdFwiKV0sIE5VTV0pO1xuXG5leHBvcnQgY29uc3QgZGVmYXVsdFR5cGVFbnYgPSB7XG4gIGdsb2JhbHM6IG5ldyBNYXAoKSxcbiAgZnVuY3Rpb25zOiBkZWZhdWx0R2xvYmFsRnVuY3Rpb25zLFxuICBjbGFzc2VzOiBuZXcgTWFwKCksXG4gIHR5cGV2YXJzOiBuZXcgTWFwKClcbn07XG5cbmV4cG9ydCBmdW5jdGlvbiBlbXB0eUdsb2JhbFR5cGVFbnYoKTogR2xvYmFsVHlwZUVudiB7XG4gIHJldHVybiB7XG4gICAgZ2xvYmFsczogbmV3IE1hcCgpLFxuICAgIGZ1bmN0aW9uczogbmV3IE1hcCgpLFxuICAgIGNsYXNzZXM6IG5ldyBNYXAoKSxcbiAgICB0eXBldmFyczogbmV3IE1hcCgpXG4gIH07XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBlbXB0eUxvY2FsVHlwZUVudigpOiBMb2NhbFR5cGVFbnYge1xuICByZXR1cm4ge1xuICAgIHZhcnM6IG5ldyBNYXAoKSxcbiAgICBleHBlY3RlZFJldDogTk9ORSxcbiAgICBhY3R1YWxSZXQ6IE5PTkUsXG4gICAgdG9wTGV2ZWw6IHRydWVcbiAgfTtcbn1cblxuLy8gY29tYmluZSB0aGUgZWxlbWVudHMgb2YgdHdvIGFycmF5cyBpbnRvIGFuIGFycmF5IG9mIHR1cGxlcy5cbi8vIERBTkdFUjogdGhyb3dzIGFuIGVycm9yIGlmIGFyZ3VtZW50IGFycmF5cyBkb24ndCBoYXZlIHRoZSBzYW1lIGxlbmd0aC5cbmZ1bmN0aW9uIHppcDxBLCBCPihsMTogQXJyYXk8QT4sIGwyOiBBcnJheTxCPikgOiBBcnJheTxbQSwgQl0+IHtcbiAgaWYobDEubGVuZ3RoICE9PSBsMi5sZW5ndGgpIHtcbiAgICB0aHJvdyBuZXcgVHlwZUNoZWNrRXJyb3IoYFRyaWVkIHRvIHppcCB0d28gYXJyYXlzIG9mIGRpZmZlcmVudCBsZW5ndGhgKTtcbiAgfVxuICByZXR1cm4gbDEubWFwKChlbCwgaSkgPT4gW2VsLCBsMltpXV0pOyBcbn1cblxuZXhwb3J0IHR5cGUgVHlwZUVycm9yID0ge1xuICBtZXNzYWdlOiBzdHJpbmdcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGVxdWFsQ2FsbGFibGUodDE6IENhbGxhYmxlLCB0MjogQ2FsbGFibGUpOiBib29sZWFuIHtcbiAgcmV0dXJuIHQxLnBhcmFtcy5sZW5ndGggPT09IHQyLnBhcmFtcy5sZW5ndGggJiZcbiAgICB0MS5wYXJhbXMuZXZlcnkoKHBhcmFtLCBpKSA9PiBlcXVhbFR5cGUocGFyYW0sIHQyLnBhcmFtc1tpXSkpICYmIGVxdWFsVHlwZSh0MS5yZXQsIHQyLnJldCk7XG59XG5cbi8vIENoZWNrIGlmIGEgbGlzdCBvZiB0eXBlLXBhcmFtZXRlcnMgYXJlIGVxdWFsLlxuZXhwb3J0IGZ1bmN0aW9uIGVxdWFsVHlwZVBhcmFtcyhwYXJhbXMxOiBUeXBlW10sIHBhcmFtczI6IFR5cGVbXSkgOiBib29sZWFuIHtcbiAgaWYocGFyYW1zMS5sZW5ndGggIT09IHBhcmFtczIubGVuZ3RoKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG5cbiAgcmV0dXJuIHppcChwYXJhbXMxLCBwYXJhbXMyKS5yZWR1Y2UoKGlzRXF1YWwsIFtwMSwgcDJdKSA9PiB7XG4gICAgcmV0dXJuIGlzRXF1YWwgJiYgZXF1YWxUeXBlKHAxLCBwMik7XG4gIH0sIHRydWUpO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gZXF1YWxUeXBlKHQxOiBUeXBlLCB0MjogVHlwZSkge1xuICByZXR1cm4gKFxuICAgIHQxID09PSB0MiB8fFxuICAgICh0MS50YWcgPT09IFwiY2xhc3NcIiAmJiB0Mi50YWcgPT09IFwiY2xhc3NcIiAmJiB0MS5uYW1lID09PSB0Mi5uYW1lKSB8fFxuICAgICh0MS50YWcgPT09IFwiY2FsbGFibGVcIiAmJiB0Mi50YWcgPT09IFwiY2FsbGFibGVcIiAmJiBlcXVhbENhbGxhYmxlKHQxLCB0MikpIHx8XG4gICAgKHQxLnRhZyA9PT0gXCJ0eXBldmFyXCIgJiYgdDIudGFnID09PSBcInR5cGV2YXJcIiAmJiB0MS5uYW1lID09PSB0Mi5uYW1lKVxuICApO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gaXNOb25lT3JDbGFzc09yQ2FsbGFibGUodDogVHlwZSkge1xuICByZXR1cm4gdC50YWcgPT09IFwibm9uZVwiIHx8IHQudGFnID09PSBcImNsYXNzXCIgfHwgdC50YWcgPT09IFwiY2FsbGFibGVcIjtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGlzU3VidHlwZShlbnY6IEdsb2JhbFR5cGVFbnYsIHQxOiBUeXBlLCB0MjogVHlwZSk6IGJvb2xlYW4ge1xuICByZXR1cm4gZXF1YWxUeXBlKHQxLCB0MikgfHwgdDEudGFnID09PSBcIm5vbmVcIiAmJiAodDIudGFnID09PSBcImNsYXNzXCIgfHwgdDIudGFnID09PSBcImNhbGxhYmxlXCIpXG59XG5cblxuZXhwb3J0IGZ1bmN0aW9uIGlzQXNzaWduYWJsZShlbnY6IEdsb2JhbFR5cGVFbnYsIHQxOiBUeXBlLCB0MjogVHlwZSk6IGJvb2xlYW4ge1xuICByZXR1cm4gaXNTdWJ0eXBlKGVudiwgdDEsIHQyKTtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGpvaW4oZW52OiBHbG9iYWxUeXBlRW52LCB0MTogVHlwZSwgdDI6IFR5cGUpOiBUeXBlIHtcbiAgcmV0dXJuIE5PTkVcbn1cblxuLy8gVGVzdCBpZiBhIHR5cGUgaXMgdmFsaWQgYW5kIGRvZXMgbm90IGhhdmUgYW55IHVuZGVmaW5lZC9ub24tZXhpc3RlbnRcbi8vIGNsYXNzZXMgYW5kIHRoYXQgYWxsIGluc3RhbnRpYXRlZCB0eXBlLXBhcmFtZXRlcnMgYXJlIHZhbGlkLlxuZXhwb3J0IGZ1bmN0aW9uIGlzVmFsaWRUeXBlKGVudjogR2xvYmFsVHlwZUVudiwgdDogVHlwZSkgOiBib29sZWFuIHtcbiAgLy8gcHJpbWl0aXZlIHR5cGVzIGFyZSB2YWxpZCB0eXBlcy5cbiAgaWYodC50YWcgPT09IFwibnVtYmVyXCIgfHwgdC50YWcgPT09IFwiYm9vbFwiIHx8IHQudGFnID09PSBcIm5vbmVcIikge1xuICAgIHJldHVybiB0cnVlO1xuICB9XG5cbiAgLy8gVE9ETzogaGF2ZW4ndCB0YWtlbiB0aGUgdGltZSB0byB1bmRlcnN0YW5kIHdoYXQgZWl0aGVyIGlzLCBcbiAgLy8gYnV0IGNvbnNpZGVyaW5nIGl0IGFsd2F5cyB2YWxpZCBmb3Igbm93LlxuICBpZih0LnRhZyA9PT0gXCJlaXRoZXJcIikge1xuICAgIHJldHVybiB0cnVlO1xuICB9XG5cbiAgLy8gVE9ETzogdHlwZS12YXJpYWJsZXMgYWx3YXlzIHZhbGlkIHR5cGVzIGluIHRoaXMgY29udGV4dCA/XG4gIGlmKHQudGFnID09PSBcInR5cGV2YXJcIikge1xuICAgIHJldHVybiB0cnVlOyBcbiAgfVxuXG4gIGlmKHQudGFnID09PSBcImNhbGxhYmxlXCIpIHtcbiAgICAvLyBUT0RPOiBhY3R1YWxseSBjaGVjayBpZiBjYWxsYWJsZSBpcyB2YWxpZFxuICAgIHJldHVybiB0cnVlO1xuICB9XG5cbiAgLy8gVE9ETzogaGFuZGxlIGFsbCBvdGhlciBuZXdlciBub24tY2xhc3MgdHlwZXMgaGVyZVxuXG4gIC8vIEF0IHRoaXMgcG9pbnQgd2Uga25vdyB0IGlzIGEgQ0xBU1NcbiAgaWYoIWVudi5jbGFzc2VzLmhhcyh0Lm5hbWUpKSB7XG4gICAgcmV0dXJuIGZhbHNlOyAgXG4gIH1cbiAgXG4gIGxldCBbX2ZpZWxkc1R5LCBfbWV0aG9kc1R5LCB0eXBlcGFyYW1zXSA9IGVudi5jbGFzc2VzLmdldCh0Lm5hbWUpO1xuXG4gIGlmKHQucGFyYW1zLmxlbmd0aCAhPT0gdHlwZXBhcmFtcy5sZW5ndGgpIHtcbiAgICByZXR1cm4gZmFsc2U7IFxuICB9XG5cbiAgcmV0dXJuIHppcCh0eXBlcGFyYW1zLCB0LnBhcmFtcykucmVkdWNlKChpc1ZhbGlkLCBbdHlwZXZhciwgdHlwZXBhcmFtXSkgPT4ge1xuICAgIHJldHVybiBpc1ZhbGlkICYmIGlzVmFsaWRUeXBlKGVudiwgdHlwZXBhcmFtKTtcbiAgfSwgdHJ1ZSk7XG59XG5cbi8vIFBvcHVsYXRlIHRoZSBpbnN0YW50aWF0ZWQgdHlwZS1wYXJhbWV0ZXJzIG9mIHRoZSBjbGFzcyB0eXBlIG9ialR5IGluXG4vLyBmaWVsZCB0eXBlIGZpZWxkVHkuIFRoaXMgcmVwbGFjZXMgdHlwZXZhcnMgaW4gZmllbGRUeSB3aXRoIHRoZWlyIGNvbmNyZXRlXG4vLyBpbnN0YW50aWF0aW9ucyBmcm9tIG9ialR5LiBVbmluc3RhbnRpYXRlZCB0eXBlLXBhcmFtZXRlcnMgYXJlIGxlZnQgYXMgdHlwZXZhcnMuXG5leHBvcnQgZnVuY3Rpb24gc3BlY2lhbGl6ZUZpZWxkVHlwZShlbnY6IEdsb2JhbFR5cGVFbnYsIG9ialR5OiBUeXBlLCBmaWVsZFR5OiBUeXBlKSA6IFR5cGUge1xuICBpZihvYmpUeS50YWcgIT09IFwiY2xhc3NcIikge1xuICAgIC8vIFRPRE86IHNob3VsZCB3ZSB0aHJvdyBhbiBlcnJvciBoZXJlID9cbiAgICAvLyBEb24ndCB0aGluayB0aGlzIHNob3VsZCBldmVyIGhhcHBlbiB1bmxlc3NcbiAgICAvLyBzb21ldGhpbmcgaXMgcmVhbGx5IHdyb25nLlxuICAgIHJldHVybiBmaWVsZFR5O1xuICB9XG5cbiAgaWYob2JqVHkucGFyYW1zLmxlbmd0aCA9PT0gMCkge1xuICAgIC8vIGNsYXNzZXMgd2l0aG91dCB0eXBlIHBhcmFtZXRlcnNcbiAgICAvLyBkbyBub3QgbmVlZCBhbmQgc3BlY2lhbGl6YXRpb24uXG4gICAgcmV0dXJuIGZpZWxkVHk7XG4gIH1cblxuICAvLyBnZXQgYSBsaXN0IG9mIHR5cGUtcGFyYW1ldGVycyBvZiB0aGUgY2xhc3MuXG4gIGxldCBbX2ZpZWxkcywgX21ldGhvZHMsIHR5cGVwYXJhbXNdID0gZW52LmNsYXNzZXMuZ2V0KG9ialR5Lm5hbWUpO1xuXG4gIC8vIGNyZWF0ZSBhIG1hcHBpbmcgZnJvbSB0aGUgdHlwZS1wYXJhbWV0ZXIgbmFtZSB0byB0aGUgY29ycmVzcG9uZGluZyBpbnN0YW50aWF0ZWQgdHlwZS5cbiAgbGV0IG1hcCA9IG5ldyBNYXAoemlwKHR5cGVwYXJhbXMsIG9ialR5LnBhcmFtcykpOyAvLy5maWx0ZXIoKFtfdHlwZXZhciwgdHlwZXBhcmFtXSkgPT4gdHlwZXBhcmFtLnRhZyAhPT0gXCJ0eXBldmFyXCIpKTtcbiAgcmV0dXJuIHNwZWNpYWxpemVUeXBlKG1hcCwgZmllbGRUeSk7XG59XG5cbi8vIFBvcHVsYXRlIHRoZSBpbnN0YW50aWF0ZWQgdHlwZS1wYXJhbWV0ZXJzIG9mIHRoZSBjbGFzcyB0eXBlIG9ialR5IGluXG4vLyB0aGUgbWV0aG9kIHR5cGUgZ2l2ZW4gYnkgYXJnVHlwZXMgYW5kIHJldFR5cGUuXG5leHBvcnQgZnVuY3Rpb24gc3BlY2lhbGl6ZU1ldGhvZFR5cGUoZW52OiBHbG9iYWxUeXBlRW52LCBvYmpUeTogVHlwZSwgW2FyZ1R5cGVzLCByZXRUeXBlXTogW1R5cGVbXSwgVHlwZV0pIDogW1R5cGVbXSwgVHlwZV0ge1xuICBpZihvYmpUeS50YWcgIT09IFwiY2xhc3NcIikge1xuICAgIC8vIFRPRE86IHNob3VsZCB3ZSB0aHJvdyBhbiBlcnJvciBoZXJlID9cbiAgICAvLyBEb24ndCB0aGluayB0aGlzIHNob3VsZCBldmVyIGhhcHBlbiB1bmxlc3NcbiAgICAvLyBzb21ldGhpbmcgaXMgcmVhbGx5IHdyb25nLlxuICAgIHJldHVybiBbYXJnVHlwZXMsIHJldFR5cGVdO1xuICB9XG5cbiAgaWYob2JqVHkucGFyYW1zLmxlbmd0aCA9PT0gMCkge1xuICAgIC8vIGNsYXNzZXMgd2l0aG91dCB0eXBlIHBhcmFtZXRlcnNcbiAgICAvLyBkbyBub3QgbmVlZCBhbmQgc3BlY2lhbGl6YXRpb24uXG4gICAgcmV0dXJuIFthcmdUeXBlcywgcmV0VHlwZV07XG4gIH1cblxuICBsZXQgW19maWVsZHMsIF9tZXRob2RzLCB0eXBlcGFyYW1zXSA9IGVudi5jbGFzc2VzLmdldChvYmpUeS5uYW1lKTtcbiAgbGV0IG1hcCA9IG5ldyBNYXAoemlwKHR5cGVwYXJhbXMsIG9ialR5LnBhcmFtcykpOyAgLy8uZmlsdGVyKChbX3R5cGV2YXIsIHR5cGVwYXJhbV0pID0+IHR5cGVwYXJhbS50YWcgIT09IFwidHlwZXZhclwiKSk7XG5cbiAgbGV0IHNwZWNpYWxpemVkUmV0VHlwZSA9IHNwZWNpYWxpemVUeXBlKG1hcCwgcmV0VHlwZSk7XG4gIGxldCBzcGVjaWFsaXplZEFyZ1R5cGVzID0gYXJnVHlwZXMubWFwKGFyZ1R5cGUgPT4gc3BlY2lhbGl6ZVR5cGUobWFwLCBhcmdUeXBlKSk7XG5cbiAgcmV0dXJuIFtzcGVjaWFsaXplZEFyZ1R5cGVzLCBzcGVjaWFsaXplZFJldFR5cGVdO1xufVxuXG4vLyBSZXBsYWNlIHR5cGV2YXJzIGJhc2VkIG9uIHRoZSBlbnZpcm9ubWVudCBtYXBwaW5nIHRoZSB0eXBldmFyc1xuLy8gdG8gdGhlaXIgY3VycmVudCBpbnN0YW50aWF0ZWQgdHlwZXMuXG5leHBvcnQgZnVuY3Rpb24gc3BlY2lhbGl6ZVR5cGUoZW52OiBNYXA8c3RyaW5nLCBUeXBlPiwgdDogVHlwZSkgOiBUeXBlIHtcbiAgLy8gcHJpbWl0aXZlIHR5cGVzIGNhbm5vdCBiZSBzcGVjaWFsaXplZCBhbnkgZnVydGhlci5cbiAgaWYodC50YWcgPT09IFwiZWl0aGVyXCIgfHwgdC50YWcgPT09IFwibm9uZVwiIHx8IHQudGFnID09PSBcImJvb2xcIiB8fCB0LnRhZyA9PT0gXCJudW1iZXJcIikge1xuICAgIHJldHVybiB0O1xuICB9IFxuXG4gIGlmKHQudGFnID09PSBcInR5cGV2YXJcIikge1xuICAgIGlmKCFlbnYuaGFzKHQubmFtZSkpIHtcbiAgICAgIC8vIFVuaW5zdGFudGlhdGVkIHR5cGV2YXJzIGFyZSBsZWZ0IGFzIGlzLlxuICAgICAgcmV0dXJuIHQ7XG4gICAgfVxuICAgIHJldHVybiBlbnYuZ2V0KHQubmFtZSk7XG4gIH1cblxuICBpZih0LnRhZyA9PT0gXCJjYWxsYWJsZVwiKSB7XG4gICAgLy8gVE9ETzogQWN0dWFsbHkgc3BlY2lhbGl6ZSB0aGUgY2FsbGFibGVcbiAgICByZXR1cm4gdDtcbiAgfVxuXG4gIC8vIGF0IHRoaXMgcG9pbnQgdCBoYXMgdG8gYmUgYSBjbGFzcyB0eXBlXG4gIGxldCBzcGVjaWFsaXplZFBhcmFtcyA9IHQucGFyYW1zLm1hcChwID0+IHNwZWNpYWxpemVUeXBlKGVudiwgcCkpO1xuICByZXR1cm4gQ0xBU1ModC5uYW1lLCBzcGVjaWFsaXplZFBhcmFtcyk7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBhdWdtZW50VEVudihlbnY6IEdsb2JhbFR5cGVFbnYsIHByb2dyYW06IFByb2dyYW08QW5ub3RhdGlvbj4pOiBHbG9iYWxUeXBlRW52IHtcbiAgY29uc3QgbmV3R2xvYnMgPSBuZXcgTWFwKGVudi5nbG9iYWxzKTtcbiAgY29uc3QgbmV3RnVucyA9IG5ldyBNYXAoZW52LmZ1bmN0aW9ucyk7XG4gIGNvbnN0IG5ld0NsYXNzZXMgPSBuZXcgTWFwKGVudi5jbGFzc2VzKTtcbiAgY29uc3QgbmV3VHlwZXZhcnMgPSBuZXcgTWFwKGVudi50eXBldmFycyk7XG5cbiAgcHJvZ3JhbS5pbml0cy5mb3JFYWNoKGluaXQgPT4gbmV3R2xvYnMuc2V0KGluaXQubmFtZSwgaW5pdC50eXBlKSk7XG4gIHByb2dyYW0uZnVucy5mb3JFYWNoKGZ1biA9PiBuZXdHbG9icy5zZXQoZnVuLm5hbWUsIENBTExBQkxFKGZ1bi5wYXJhbWV0ZXJzLm1hcChwID0+IHAudHlwZSksIGZ1bi5yZXQpKSk7XG4gIHByb2dyYW0uY2xhc3Nlcy5mb3JFYWNoKGNscyA9PiB7XG4gICAgY29uc3QgZmllbGRzID0gbmV3IE1hcCgpO1xuICAgIGNvbnN0IG1ldGhvZHMgPSBuZXcgTWFwKCk7XG4gICAgY2xzLmZpZWxkcy5mb3JFYWNoKGZpZWxkID0+IGZpZWxkcy5zZXQoZmllbGQubmFtZSwgZmllbGQudHlwZSkpO1xuICAgIGNscy5tZXRob2RzLmZvckVhY2gobWV0aG9kID0+IG1ldGhvZHMuc2V0KG1ldGhvZC5uYW1lLCBbbWV0aG9kLnBhcmFtZXRlcnMubWFwKHAgPT4gcC50eXBlKSwgbWV0aG9kLnJldF0pKTtcbiAgICBjb25zdCB0eXBlUGFyYW1zID0gY2xzLnR5cGVQYXJhbXM7XG4gICAgbmV3Q2xhc3Nlcy5zZXQoY2xzLm5hbWUsIFtmaWVsZHMsIG1ldGhvZHMsIFsuLi50eXBlUGFyYW1zXV0pO1xuICB9KTtcblxuICBwcm9ncmFtLnR5cGVWYXJJbml0cy5mb3JFYWNoKHR2ID0+IHtcbiAgICBpZihuZXdHbG9icy5oYXModHYubmFtZSkgfHwgbmV3VHlwZXZhcnMuaGFzKHR2Lm5hbWUpIHx8IG5ld0NsYXNzZXMuaGFzKHR2Lm5hbWUpKSB7XG4gICAgICB0aHJvdyBuZXcgVHlwZUNoZWNrRXJyb3IoYER1cGxpY2F0ZSBpZGVudGlmaWVyICcke3R2Lm5hbWV9JyBmb3IgdHlwZS12YXJpYWJsZWApO1xuICAgIH1cbiAgICBuZXdUeXBldmFycy5zZXQodHYubmFtZSwgW3R2LmNhbm9uaWNhbE5hbWVdKTtcbiAgfSk7XG4gIHJldHVybiB7IGdsb2JhbHM6IG5ld0dsb2JzLCBmdW5jdGlvbnM6IG5ld0Z1bnMsIGNsYXNzZXM6IG5ld0NsYXNzZXMsIHR5cGV2YXJzOiBuZXdUeXBldmFycyB9O1xufVxuXG5leHBvcnQgZnVuY3Rpb24gdGMoZW52OiBHbG9iYWxUeXBlRW52LCBwcm9ncmFtOiBQcm9ncmFtPEFubm90YXRpb24+KTogW1Byb2dyYW08QW5ub3RhdGlvbj4sIEdsb2JhbFR5cGVFbnZdIHtcbiAgY29uc3QgU1JDID0gcHJvZ3JhbS5hLnNyYztcbiAgY29uc3QgbG9jYWxzID0gZW1wdHlMb2NhbFR5cGVFbnYoKTtcbiAgY29uc3QgbmV3RW52ID0gYXVnbWVudFRFbnYoZW52LCBwcm9ncmFtKTtcbiAgY29uc3QgdFR5cGVWYXJzID0gcHJvZ3JhbS50eXBlVmFySW5pdHMubWFwKHR2ID0+IHRjVHlwZVZhcnMobmV3RW52LCB0diwgU1JDKSk7XG4gIGNvbnN0IHRJbml0cyA9IHByb2dyYW0uaW5pdHMubWFwKGluaXQgPT4gdGNJbml0KG5ld0VudiwgaW5pdCwgU1JDKSk7XG4gIGNvbnN0IHREZWZzID0gcHJvZ3JhbS5mdW5zLm1hcChmdW4gPT4gdGNEZWYobmV3RW52LCBmdW4sIG5ldyBNYXAoKSwgU1JDKSk7XG4gIGNvbnN0IHRDbGFzc2VzID0gcHJvZ3JhbS5jbGFzc2VzLm1hcChjbHMgPT4ge1xuICAgIGlmKGNscy50eXBlUGFyYW1zLmxlbmd0aCA9PT0gMCkge1xuICAgICAgcmV0dXJuIHRjQ2xhc3MobmV3RW52LCBjbHMsIFNSQyk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGxldCByQ2xzID0gcmVzb2x2ZUNsYXNzVHlwZVBhcmFtcyhuZXdFbnYsIGNscylcbiAgICAgIHJldHVybiB0Y0dlbmVyaWNDbGFzcyhuZXdFbnYsIHJDbHMsIFNSQyk7XG4gICAgfVxuICB9KTtcblxuICAvLyBwcm9ncmFtLmluaXRzLmZvckVhY2goaW5pdCA9PiBlbnYuZ2xvYmFscy5zZXQoaW5pdC5uYW1lLCB0Y0luaXQoaW5pdCkpKTtcbiAgLy8gcHJvZ3JhbS5mdW5zLmZvckVhY2goZnVuID0+IGVudi5mdW5jdGlvbnMuc2V0KGZ1bi5uYW1lLCBbZnVuLnBhcmFtZXRlcnMubWFwKHAgPT4gcC50eXBlKSwgZnVuLnJldF0pKTtcbiAgLy8gcHJvZ3JhbS5mdW5zLmZvckVhY2goZnVuID0+IHRjRGVmKGVudiwgZnVuKSk7XG4gIC8vIFN0cmF0ZWd5IGhlcmUgaXMgdG8gYWxsb3cgdGNCbG9jayB0byBwb3B1bGF0ZSB0aGUgbG9jYWxzLCB0aGVuIGNvcHkgdG8gdGhlXG4gIC8vIGdsb2JhbCBlbnYgYWZ0ZXJ3YXJkcyAodGNCbG9jayBjaGFuZ2VzIGxvY2FscylcbiAgY29uc3QgdEJvZHkgPSB0Y0Jsb2NrKG5ld0VudiwgbG9jYWxzLCBwcm9ncmFtLnN0bXRzLCBTUkMpO1xuICB2YXIgbGFzdFR5cDogVHlwZSA9IE5PTkU7XG4gIGlmICh0Qm9keS5sZW5ndGgpIHtcbiAgICBsYXN0VHlwID0gdEJvZHlbdEJvZHkubGVuZ3RoIC0gMV0uYS50eXBlO1xuICB9XG4gIC8vIFRPRE8oam9lKTogY2hlY2sgZm9yIGFzc2lnbm1lbnQgaW4gZXhpc3RpbmcgZW52IHZzLiBuZXcgZGVjbGFyYXRpb25cbiAgLy8gYW5kIGxvb2sgZm9yIGFzc2lnbm1lbnQgY29uc2lzdGVuY3lcbiAgZm9yIChsZXQgbmFtZSBvZiBsb2NhbHMudmFycy5rZXlzKCkpIHtcbiAgICBuZXdFbnYuZ2xvYmFscy5zZXQobmFtZSwgbG9jYWxzLnZhcnMuZ2V0KG5hbWUpKTtcbiAgfVxuXG4gIGNvbnN0IGFwcm9ncmFtID0geyBhOiB7IC4uLnByb2dyYW0uYSwgdHlwZTogbGFzdFR5cCB9LCBpbml0czogdEluaXRzLCBmdW5zOiB0RGVmcywgY2xhc3NlczogdENsYXNzZXMsIHN0bXRzOiB0Qm9keSwgdHlwZVZhckluaXRzOiB0VHlwZVZhcnMgfTtcbiAgcmV0dXJuIFthcHJvZ3JhbSwgbmV3RW52XTtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIHRjSW5pdChlbnY6IEdsb2JhbFR5cGVFbnYsIGluaXQ6IFZhckluaXQ8QW5ub3RhdGlvbj4sIFNSQzogc3RyaW5nKTogVmFySW5pdDxBbm5vdGF0aW9uPiB7XG4gIGlmKCFpc1ZhbGlkVHlwZShlbnYsIGluaXQudHlwZSkpIHtcbiAgICB0aHJvdyBuZXcgVHlwZUNoZWNrRXJyb3IoU1JDLCBgSW52YWxpZCB0eXBlIGFubm90YXRpb24gJyR7SlNPTi5zdHJpbmdpZnkoaW5pdC50eXBlKX0nIGZvciAnJHtpbml0Lm5hbWV9J2ApO1xuICB9XG5cbiAgaWYoaW5pdC50eXBlLnRhZyA9PT0gXCJ0eXBldmFyXCIpIHtcbiAgICBpZihpbml0LnZhbHVlLnRhZyAhPT0gXCJ6ZXJvXCIpIHtcbiAgICAgIHRocm93IG5ldyBUeXBlQ2hlY2tFcnJvcihTUkMsIGBHZW5lcmljIHZhcmlhYmxlcyBtdXN0IGJlIGluaXRpYWxpemVkIHdpdGggX19aRVJPX19gKTtcbiAgICB9XG5cbiAgICByZXR1cm4geyAuLi5pbml0LCBhOiB7IC4uLmluaXQuYSwgdHlwZTogTk9ORSB9IH07XG4gIH1cblxuICBjb25zdCB2YWxUeXAgPSB0Y0xpdGVyYWwoaW5pdC52YWx1ZSk7XG4gIGlmIChpc0Fzc2lnbmFibGUoZW52LCB2YWxUeXAsIGluaXQudHlwZSkpIHtcbiAgICByZXR1cm4geyAuLi5pbml0LCBhOiB7IC4uLmluaXQuYSwgdHlwZTogTk9ORSB9IH07XG4gIH0gZWxzZSB7XG4gICAgdGhyb3cgbmV3IFR5cGVDaGVja0Vycm9yKFNSQywgYEV4cGVjdGVkIHR5cGUgJHtKU09OLnN0cmluZ2lmeShpbml0LnR5cGUudGFnKX07IGdvdCB0eXBlICR7SlNPTi5zdHJpbmdpZnkodmFsVHlwLnRhZyl9YCwgaW5pdC52YWx1ZS5hKTtcbiAgfVxufVxuXG5leHBvcnQgZnVuY3Rpb24gdGNEZWYoZW52IDogR2xvYmFsVHlwZUVudiwgZnVuIDogRnVuRGVmPEFubm90YXRpb24+LCBub25sb2NhbEVudjogTm9ubG9jYWxUeXBlRW52LCBTUkM6IHN0cmluZykgOiBGdW5EZWY8QW5ub3RhdGlvbj4ge1xuICB2YXIgbG9jYWxzID0gZW1wdHlMb2NhbFR5cGVFbnYoKTtcbiAgbG9jYWxzLnZhcnMuc2V0KGZ1bi5uYW1lLCBDQUxMQUJMRShmdW4ucGFyYW1ldGVycy5tYXAoeCA9PiB4LnR5cGUpLCBmdW4ucmV0KSk7XG4gIGxvY2Fscy5leHBlY3RlZFJldCA9IGZ1bi5yZXQ7XG4gIGxvY2Fscy50b3BMZXZlbCA9IGZhbHNlO1xuXG4gIGZ1bi5wYXJhbWV0ZXJzLmZvckVhY2gocCA9PiB7XG4gICAgaWYoIWlzVmFsaWRUeXBlKGVudiwgcC50eXBlKSkge1xuICAgICAgdGhyb3cgbmV3IFR5cGVDaGVja0Vycm9yKFNSQywgYEludmFsaWQgdHlwZSBhbm5vdGF0aW9uICcke0pTT04uc3RyaW5naWZ5KHAudHlwZSl9JyBmb3IgcGFyYW1ldGVyICcke3AubmFtZX0nIGluIGZ1bmN0aW9uICcke2Z1bi5uYW1lfSdgKTtcbiAgICB9XG4gICAgbG9jYWxzLnZhcnMuc2V0KHAubmFtZSwgcC50eXBlKVxuICB9KTtcbiAgdmFyIG5vbmxvY2FscyA9IGZ1bi5ub25sb2NhbHMubWFwKGluaXQgPT4gKHsgbmFtZTogaW5pdC5uYW1lLCBhOiB7IC4uLmluaXQuYSwgdHlwZTogbm9ubG9jYWxFbnYuZ2V0KGluaXQubmFtZSkgfX0pKTtcbiAgZnVuLnBhcmFtZXRlcnMuZm9yRWFjaChwID0+IGxvY2Fscy52YXJzLnNldChwLm5hbWUsIHAudHlwZSkpO1xuICBmdW4uaW5pdHMuZm9yRWFjaChpbml0ID0+IGxvY2Fscy52YXJzLnNldChpbml0Lm5hbWUsIHRjSW5pdChlbnYsIGluaXQsIFNSQykudHlwZSkpO1xuICBub25sb2NhbHMuZm9yRWFjaChpbml0ID0+IGxvY2Fscy52YXJzLnNldChpbml0Lm5hbWUsIGluaXQuYS50eXBlKSk7XG4gIHZhciBlbnZDb3B5ID0gY29weUdsb2JhbHMoZW52KTtcbiAgZnVuLmNoaWxkcmVuLmZvckVhY2goZiA9PiBlbnZDb3B5LmZ1bmN0aW9ucy5zZXQoZi5uYW1lLCBbZi5wYXJhbWV0ZXJzLm1hcCh4ID0+IHgudHlwZSksIGYucmV0XSkpO1xuICB2YXIgY2hpbGRyZW4gPSBmdW4uY2hpbGRyZW4ubWFwKGYgPT4gdGNEZWYoZW52Q29weSwgZiwgbG9jYWxzLnZhcnMsIFNSQykpO1xuICBmdW4uY2hpbGRyZW4uZm9yRWFjaChjaGlsZCA9PiBsb2NhbHMudmFycy5zZXQoY2hpbGQubmFtZSwgQ0FMTEFCTEUoY2hpbGQucGFyYW1ldGVycy5tYXAoeCA9PiB4LnR5cGUpLCBjaGlsZC5yZXQpKSk7XG4gIFxuICBjb25zdCB0Qm9keSA9IHRjQmxvY2soZW52Q29weSwgbG9jYWxzLCBmdW4uYm9keSwgU1JDKTtcbiAgaWYgKCFpc0Fzc2lnbmFibGUoZW52Q29weSwgbG9jYWxzLmFjdHVhbFJldCwgbG9jYWxzLmV4cGVjdGVkUmV0KSlcbiAgICAvLyBUT0RPOiB3aGF0IGxvY2F0aW9ucyB0byBiZSByZXBvcnRlZCBoZXJlP1xuICAgIHRocm93IG5ldyBUeXBlQ2hlY2tFcnJvcihgZXhwZWN0ZWQgcmV0dXJuIHR5cGUgb2YgYmxvY2s6ICR7SlNPTi5zdHJpbmdpZnkobG9jYWxzLmV4cGVjdGVkUmV0KX0gZG9lcyBub3QgbWF0Y2ggYWN0dWFsIHJldHVybiB0eXBlOiAke0pTT04uc3RyaW5naWZ5KGxvY2Fscy5hY3R1YWxSZXQpfWApXG4gIHJldHVybiB7Li4uZnVuLCBhOiB7IC4uLmZ1bi5hLCB0eXBlOiBOT05FIH0sIGJvZHk6IHRCb2R5LCBub25sb2NhbHMsIGNoaWxkcmVufTtcbn1cblxuLy8gR2VuZXJpYyBjbGFzc2VzIGFyZSB0eXBlLWNoZWNrZWQgYnkgdHJlYXRpbmcgYWxsIHR5cGV2YXJzIGFzIGNvbXBsZXRlbHkgdW5jb25zdHJhaW5lZFxuLy8gdHlwZXMgdGhhdCB3ZSBkbyBub3Qga25vdyBhbnl0aGluZyBhYm91dC5cbmV4cG9ydCBmdW5jdGlvbiB0Y0dlbmVyaWNDbGFzcyhlbnY6IEdsb2JhbFR5cGVFbnYsIGNsczogQ2xhc3M8QW5ub3RhdGlvbj4sIFNSQzogc3RyaW5nKSA6IENsYXNzPEFubm90YXRpb24+IHtcbiAgLy8gZW5zdXJlIGFsbCB0eXBlIHBhcmFtZXRlcnMgYXJlIGRlZmluZWQgYXMgdHlwZSB2YXJpYWJsZXNcbiAgY2xzLnR5cGVQYXJhbXMuZm9yRWFjaChwYXJhbSA9PiB7XG4gICAgaWYoIWVudi50eXBldmFycy5oYXMocGFyYW0pKSB7XG4gICAgICB0aHJvdyBuZXcgVHlwZUNoZWNrRXJyb3IoU1JDLCBgdW5kZWZpbmVkIHR5cGUgdmFyaWFibGUgJHtwYXJhbX0gdXNlZCBpbiBkZWZpbml0aW9uIG9mIGNsYXNzICR7Y2xzLm5hbWV9YCk7XG4gICAgfVxuICB9KTtcblxuICByZXR1cm4gdGNDbGFzcyhlbnYsIGNscywgU1JDKTtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIHJlc29sdmVDbGFzc1R5cGVQYXJhbXMoZW52OiBHbG9iYWxUeXBlRW52LCBjbHM6IENsYXNzPEFubm90YXRpb24+KSA6IENsYXNzPEFubm90YXRpb24+IHsgXG4gIGxldCBbZmllbGRzVHksIG1ldGhvZHNUeSwgdHlwZXBhcmFtc10gPSBlbnYuY2xhc3Nlcy5nZXQoY2xzLm5hbWUpO1xuXG4gIGxldCBuZXdGaWVsZHNUeSA9IG5ldyBNYXAoQXJyYXkuZnJvbShmaWVsZHNUeS5lbnRyaWVzKCkpLm1hcCgoW25hbWUsIHR5cGVdKSA9PiB7XG4gICAgbGV0IFtfLCBuZXdUeXBlXSA9IHJlc29sdmVUeXBlVHlwZVBhcmFtcyhjbHMudHlwZVBhcmFtcywgdHlwZSk7XG4gICAgcmV0dXJuIFtuYW1lLCBuZXdUeXBlXTtcbiAgfSkpO1xuXG4gIGxldCBuZXdNZXRob2RzVHk6IE1hcDxzdHJpbmcsIFtUeXBlW10sIFR5cGVdPiA9IG5ldyBNYXAoQXJyYXkuZnJvbShtZXRob2RzVHkuZW50cmllcygpKS5tYXAoKFtuYW1lLCBbcGFyYW1zLCByZXRdXSkgPT4ge1xuICAgIGxldCBbXywgbmV3UmV0XSA9IHJlc29sdmVUeXBlVHlwZVBhcmFtcyhjbHMudHlwZVBhcmFtcywgcmV0KTsgXG4gICAgbGV0IG5ld1BhcmFtcyA9IHBhcmFtcy5tYXAocCA9PiB7XG4gICAgICBsZXQgW18sIG5ld1BdID0gcmVzb2x2ZVR5cGVUeXBlUGFyYW1zKGNscy50eXBlUGFyYW1zLCBwKTtcbiAgICAgIHJldHVybiBuZXdQO1xuICAgIH0pO1xuXG4gICAgcmV0dXJuIFtuYW1lLCBbbmV3UGFyYW1zLCBuZXdSZXRdXTtcbiAgfSkpO1xuXG4gIGVudi5jbGFzc2VzLnNldChjbHMubmFtZSwgW25ld0ZpZWxkc1R5LCBuZXdNZXRob2RzVHksIHR5cGVwYXJhbXNdKTtcblxuICBsZXQgbmV3RmllbGRzID0gY2xzLmZpZWxkcy5tYXAoZmllbGQgPT4gcmVzb2x2ZVZhckluaXRUeXBlUGFyYW1zKGNscy50eXBlUGFyYW1zLCBmaWVsZCkpO1xuICBsZXQgbmV3TWV0aG9kcyA9IGNscy5tZXRob2RzLm1hcChtZXRob2QgPT4gcmVzb2x2ZUZ1bkRlZlR5cGVQYXJhbXMoY2xzLnR5cGVQYXJhbXMsIG1ldGhvZCkpO1xuXG4gIHJldHVybiB7Li4uY2xzLCBmaWVsZHM6IG5ld0ZpZWxkcywgbWV0aG9kczogbmV3TWV0aG9kc307XG59XG5cbmV4cG9ydCBmdW5jdGlvbiByZXNvbHZlVmFySW5pdFR5cGVQYXJhbXMoZW52OiBzdHJpbmdbXSwgaW5pdDogVmFySW5pdDxBbm5vdGF0aW9uPikgOiBWYXJJbml0PEFubm90YXRpb24+IHtcbiAgbGV0IFtfLCBuZXdUeXBlXSA9IHJlc29sdmVUeXBlVHlwZVBhcmFtcyhlbnYsIGluaXQudHlwZSk7XG4gIHJldHVybiB7Li4uaW5pdCwgdHlwZTogbmV3VHlwZX07XG59XG5cbmV4cG9ydCBmdW5jdGlvbiByZXNvbHZlRnVuRGVmVHlwZVBhcmFtcyhlbnY6IHN0cmluZ1tdLCBmdW46IEZ1bkRlZjxBbm5vdGF0aW9uPikgOiBGdW5EZWY8QW5ub3RhdGlvbj4ge1xuICBsZXQgbmV3UGFyYW1ldGVycyA9IGZ1bi5wYXJhbWV0ZXJzLm1hcChwID0+IHJlc29sdmVQYXJhbWV0ZXJUeXBlUGFyYW1zKGVudiwgcCkpO1xuICBsZXQgW18sIG5ld1JldF0gPSByZXNvbHZlVHlwZVR5cGVQYXJhbXMoZW52LCBmdW4ucmV0KTtcbiAgbGV0IG5ld0luaXRzID0gZnVuLmluaXRzLm1hcChpID0+IHJlc29sdmVWYXJJbml0VHlwZVBhcmFtcyhlbnYsIGkpKTtcblxuICByZXR1cm4gey4uLmZ1biwgcmV0OiBuZXdSZXQsIHBhcmFtZXRlcnM6IG5ld1BhcmFtZXRlcnMsIGluaXRzOiBuZXdJbml0c307XG59XG5cbmV4cG9ydCBmdW5jdGlvbiByZXNvbHZlUGFyYW1ldGVyVHlwZVBhcmFtcyhlbnY6IHN0cmluZ1tdLCBwYXJhbTogUGFyYW1ldGVyPEFubm90YXRpb24+KSA6IFBhcmFtZXRlcjxBbm5vdGF0aW9uPiB7XG4gIGxldCBbXywgbmV3VHlwZV0gPSByZXNvbHZlVHlwZVR5cGVQYXJhbXMoZW52LCBwYXJhbS50eXBlKTtcbiAgcmV0dXJuIHsuLi5wYXJhbSwgdHlwZTogbmV3VHlwZX1cbn1cblxuZXhwb3J0IGZ1bmN0aW9uIHJlc29sdmVUeXBlVHlwZVBhcmFtcyhlbnY6IHN0cmluZ1tdLCB0eXBlOiBUeXBlKSA6IFtib29sZWFuLCBUeXBlXSB7XG4gIGlmKHR5cGUudGFnICE9PSBcImNsYXNzXCIpIHtcbiAgICByZXR1cm4gW2ZhbHNlLCB0eXBlXTtcbiAgfVxuXG4gIGlmKGVudi5pbmRleE9mKHR5cGUubmFtZSkgIT09IC0xKSB7XG4gICAgcmV0dXJuIFt0cnVlLCBUWVBFVkFSKHR5cGUubmFtZSldXG4gIH1cblxuICBsZXQgbmV3UGFyYW1zOiBUeXBlW109IHR5cGUucGFyYW1zLm1hcCgocCkgPT4ge1xuICAgIGxldCBbXywgbmV3VHlwZV0gPSByZXNvbHZlVHlwZVR5cGVQYXJhbXMoZW52LCBwKTtcbiAgICByZXR1cm4gbmV3VHlwZTtcbiAgfSk7XG5cbiAgcmV0dXJuIFt0cnVlLCB7Li4udHlwZSwgcGFyYW1zOiBuZXdQYXJhbXN9XTtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIHRjVHlwZVZhcnMoZW52OiBHbG9iYWxUeXBlRW52LCB0djogVHlwZVZhcjxBbm5vdGF0aW9uPiwgU1JDOiBzdHJpbmcpIDogVHlwZVZhcjxBbm5vdGF0aW9uPiB7XG4gIHJldHVybiB7Li4udHYsIGE6IHsuLi50di5hLCB0eXBlOiBOT05FfX07XG59XG5cbmV4cG9ydCBmdW5jdGlvbiB0Y0NsYXNzKGVudjogR2xvYmFsVHlwZUVudiwgY2xzOiBDbGFzczxBbm5vdGF0aW9uPiwgU1JDOiBzdHJpbmcpOiBDbGFzczxBbm5vdGF0aW9uPiB7XG4gIGNvbnN0IHRGaWVsZHMgPSBjbHMuZmllbGRzLm1hcChmaWVsZCA9PiB0Y0luaXQoZW52LCBmaWVsZCwgU1JDKSk7XG4gIGNvbnN0IHRNZXRob2RzID0gY2xzLm1ldGhvZHMubWFwKG1ldGhvZCA9PiB0Y0RlZihlbnYsIG1ldGhvZCwgbmV3IE1hcCgpLCBTUkMpKTtcbiAgY29uc3QgaW5pdCA9IGNscy5tZXRob2RzLmZpbmQobWV0aG9kID0+IG1ldGhvZC5uYW1lID09PSBcIl9faW5pdF9fXCIpIC8vIHdlJ2xsIGFsd2F5cyBmaW5kIF9faW5pdF9fXG4gIGNvbnN0IHRQYXJhbXMgPSBjbHMudHlwZVBhcmFtcy5tYXAoVFlQRVZBUik7XG4gIGlmIChpbml0LnBhcmFtZXRlcnMubGVuZ3RoICE9PSAxIHx8XG4gICAgaW5pdC5wYXJhbWV0ZXJzWzBdLm5hbWUgIT09IFwic2VsZlwiIHx8XG4gICAgIWVxdWFsVHlwZShpbml0LnBhcmFtZXRlcnNbMF0udHlwZSwgQ0xBU1MoY2xzLm5hbWUsIHRQYXJhbXMpKSB8fFxuICAgIGluaXQucmV0ICE9PSBOT05FKSB7XG4gICAgY29uc3QgcmVhc29uID0gKGluaXQucGFyYW1ldGVycy5sZW5ndGggIT09IDEpID8gYCR7aW5pdC5wYXJhbWV0ZXJzLmxlbmd0aH0gcGFyYW1ldGVyc2AgOlxuICAgICAgKGluaXQucGFyYW1ldGVyc1swXS5uYW1lICE9PSBcInNlbGZcIikgPyBgcGFyYW1ldGVyIG5hbWUgJHtpbml0LnBhcmFtZXRlcnNbMF0ubmFtZX1gIDpcbiAgICAgICAgKCFlcXVhbFR5cGUoaW5pdC5wYXJhbWV0ZXJzWzBdLnR5cGUsIENMQVNTKGNscy5uYW1lKSkpID8gYHBhcmFtZXRlciB0eXBlICR7SlNPTi5zdHJpbmdpZnkoaW5pdC5wYXJhbWV0ZXJzWzBdLnR5cGUudGFnKX1gIDpcbiAgICAgICAgICAoaW5pdC5yZXQgIT09IE5PTkUpID8gYHJldHVybiB0eXBlICR7SlNPTi5zdHJpbmdpZnkoaW5pdC5yZXQudGFnKX1gIDogXCJ1bmtub3duIHJlYXNvblwiO1xuXG4gICAgdGhyb3cgbmV3IFR5cGVDaGVja0Vycm9yKFNSQywgYF9faW5pdF9fIHRha2VzIDEgcGFyYW1ldGVyIFxcYHNlbGZcXGAgb2YgdGhlIHNhbWUgdHlwZSBvZiB0aGUgY2xhc3MgXFxgJHtjbHMubmFtZX1cXGAgd2l0aCByZXR1cm4gdHlwZSBvZiBcXGBOb25lXFxgLCBnb3QgJHtyZWFzb259YCwgaW5pdC5hKTtcbiAgfVxuICByZXR1cm4geyBhOiB7IC4uLmNscy5hLCB0eXBlOiBOT05FIH0sIG5hbWU6IGNscy5uYW1lLCBmaWVsZHM6IHRGaWVsZHMsIG1ldGhvZHM6IHRNZXRob2RzLCB0eXBlUGFyYW1zOiBjbHMudHlwZVBhcmFtcyB9O1xufVxuXG5leHBvcnQgZnVuY3Rpb24gdGNCbG9jayhlbnY6IEdsb2JhbFR5cGVFbnYsIGxvY2FsczogTG9jYWxUeXBlRW52LCBzdG10czogQXJyYXk8U3RtdDxBbm5vdGF0aW9uPj4sIFNSQzogc3RyaW5nKTogQXJyYXk8U3RtdDxBbm5vdGF0aW9uPj4ge1xuICB2YXIgdFN0bXRzID0gc3RtdHMubWFwKHN0bXQgPT4gdGNTdG10KGVudiwgbG9jYWxzLCBzdG10LCBTUkMpKTtcbiAgcmV0dXJuIHRTdG10cztcbn1cblxuXG5leHBvcnQgZnVuY3Rpb24gdGNTdG10KGVudjogR2xvYmFsVHlwZUVudiwgbG9jYWxzOiBMb2NhbFR5cGVFbnYsIHN0bXQ6IFN0bXQ8QW5ub3RhdGlvbj4sIFNSQzogc3RyaW5nKTogU3RtdDxBbm5vdGF0aW9uPiB7XG4gIHN3aXRjaCAoc3RtdC50YWcpIHtcbiAgICBjYXNlIFwiYXNzaWduXCI6XG4gICAgICBjb25zdCB0VmFsRXhwciA9IHRjRXhwcihlbnYsIGxvY2Fscywgc3RtdC52YWx1ZSwgU1JDKTtcbiAgICAgIHZhciBuYW1lVHlwO1xuICAgICAgaWYgKGxvY2Fscy52YXJzLmhhcyhzdG10Lm5hbWUpKSB7XG4gICAgICAgIG5hbWVUeXAgPSBsb2NhbHMudmFycy5nZXQoc3RtdC5uYW1lKTtcbiAgICAgIH0gZWxzZSBpZiAoZW52Lmdsb2JhbHMuaGFzKHN0bXQubmFtZSkpIHtcbiAgICAgICAgbmFtZVR5cCA9IGVudi5nbG9iYWxzLmdldChzdG10Lm5hbWUpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGhyb3cgbmV3IFR5cGVDaGVja0Vycm9yKFNSQywgXCJVbmJvdW5kIGlkOiBcIiArIHN0bXQubmFtZSk7XG4gICAgICB9XG5cbiAgICAgIC8vIFRPRE86IHRoaXMgaXMgYW4gdWdseSB0ZW1wb3JhcnkgaGFjayBmb3IgZ2VuZXJpYyBjb25zdHJ1Y3RvclxuICAgICAgLy8gY2FsbHMgdW50aWwgZXhwbGljaXQgYW5ub3RhdGlvbnMgYXJlIHN1cHBvcnRlZC5cbiAgICAgIC8vIFVudGlsIHRoZW4gY29uc3RydWN0b3JzIGZvciBnZW5lcmljIGNsYXNzZXMgYXJlIHByb3Blcmx5IGNoZWNrZWQgb25seVxuICAgICAgLy8gd2hlbiBkaXJlY3RseSBhc3NpZ25lZCB0byB2YXJpYWJsZXMgYW5kIHdpbGwgZmFpbCBpbiB1bmV4cGVjdGVkIHdheXMgb3RoZXJ3aXNlLlxuICAgICAgaWYobmFtZVR5cC50YWcgPT09ICdjbGFzcycgJiYgbmFtZVR5cC5wYXJhbXMubGVuZ3RoICE9PSAwICYmIHRWYWxFeHByLmEudHlwZS50YWcgPT09ICdjbGFzcycgJiYgdFZhbEV4cHIuYS50eXBlLm5hbWUgPT09IG5hbWVUeXAubmFtZSAmJiB0VmFsRXhwci50YWcgPT09ICdjb25zdHJ1Y3QnKSB7XG4gICAgICAgIC8vIGl0IHdvdWxkIGhhdmUgYmVlbiBpbXBvc3NpYmxlIGZvciB0aGUgaW5uZXIgdHlwZS1jaGVja2luZ1xuICAgICAgICAvLyBjb2RlIHRvIHByb3Blcmx5IGluZmVyIGFuZCBmaWxsIGluIHRoZSB0eXBlIHBhcmFtZXRlcnMgZm9yXG4gICAgICAgIC8vIHRoZSBjb25zdHJ1Y3RvciBjYWxsLiBTbyB3ZSBjb3B5IGl0IGZyb20gdGhlIHR5cGUgb2YgdGhlIHZhcmlhYmxlXG4gICAgICAgIC8vIHdlIGFyZSBhc3NpZ25pbmcgdG8uXG4gICAgICAgIHRWYWxFeHByLmEudHlwZS5wYXJhbXMgPSBbLi4ubmFtZVR5cC5wYXJhbXNdOyBcbiAgICAgIH1cblxuICAgICAgaWYgKCFpc0Fzc2lnbmFibGUoZW52LCB0VmFsRXhwci5hLnR5cGUsIG5hbWVUeXApKVxuICAgICAgICB0aHJvdyBuZXcgVHlwZUNoZWNrRXJyb3IoU1JDLCBgQXNzaWdubWVudCB2YWx1ZSBzaG91bGQgaGF2ZSBhc3NpZ25hYmxlIHR5cGUgdG8gdHlwZSAke0pTT04uc3RyaW5naWZ5KG5hbWVUeXAudGFnKX0sIGdvdCAke0pTT04uc3RyaW5naWZ5KHRWYWxFeHByLmEudHlwZS50YWcpfWAsXG4gICAgICAgIHRWYWxFeHByLmEpO1xuICAgICAgcmV0dXJuIHsgYTogeyAuLi5zdG10LmEsIHR5cGU6IE5PTkUgfSwgdGFnOiBzdG10LnRhZywgbmFtZTogc3RtdC5uYW1lLCB2YWx1ZTogdFZhbEV4cHIgfTtcbiAgICBjYXNlIFwiZXhwclwiOlxuICAgICAgY29uc3QgdEV4cHIgPSB0Y0V4cHIoZW52LCBsb2NhbHMsIHN0bXQuZXhwciwgU1JDKTtcbiAgICAgIHJldHVybiB7IGE6IHRFeHByLmEsIHRhZzogc3RtdC50YWcsIGV4cHI6IHRFeHByIH07XG4gICAgY2FzZSBcImlmXCI6XG4gICAgICB2YXIgdENvbmQgPSB0Y0V4cHIoZW52LCBsb2NhbHMsIHN0bXQuY29uZCwgU1JDKTtcbiAgICAgIGNvbnN0IHRUaG4gPSB0Y0Jsb2NrKGVudiwgbG9jYWxzLCBzdG10LnRobiwgU1JDKTtcbiAgICAgIGNvbnN0IHRoblR5cCA9IGxvY2Fscy5hY3R1YWxSZXQ7XG4gICAgICBsb2NhbHMuYWN0dWFsUmV0ID0gTk9ORTtcbiAgICAgIGNvbnN0IHRFbHMgPSB0Y0Jsb2NrKGVudiwgbG9jYWxzLCBzdG10LmVscywgU1JDKTtcbiAgICAgIGNvbnN0IGVsc1R5cCA9IGxvY2Fscy5hY3R1YWxSZXQ7XG4gICAgICBpZiAodENvbmQuYS50eXBlICE9PSBCT09MKVxuICAgICAgICB0aHJvdyBuZXcgVHlwZUNoZWNrRXJyb3IoU1JDLCBgQ29uZGl0aW9uIEV4cHJlc3Npb24gTXVzdCBiZSBoYXZlIHR5cGUgXCJib29sXCIsIGdvdCAke0pTT04uc3RyaW5naWZ5KHRDb25kLmEudHlwZS50YWcpfWAsIHRDb25kLmEpO1xuICAgICAgaWYgKHRoblR5cCAhPT0gZWxzVHlwKVxuICAgICAgICBsb2NhbHMuYWN0dWFsUmV0ID0geyB0YWc6IFwiZWl0aGVyXCIsIGxlZnQ6IHRoblR5cCwgcmlnaHQ6IGVsc1R5cCB9XG4gICAgICByZXR1cm4geyBhOiB7IC4uLnN0bXQuYSwgdHlwZTogdGhuVHlwIH0sIHRhZzogc3RtdC50YWcsIGNvbmQ6IHRDb25kLCB0aG46IHRUaG4sIGVsczogdEVscyB9O1xuICAgIGNhc2UgXCJyZXR1cm5cIjpcbiAgICAgIGlmIChsb2NhbHMudG9wTGV2ZWwpXG4gICAgICAvLyBUT0RPOiBlcnJvciByZXBvcnRpbmcgZm9yIGNoZWNraW5nIHJldHVybnNcbiAgICAgICAgdGhyb3cgbmV3IFR5cGVDaGVja0Vycm9yKFNSQywgXCJjYW5ub3QgcmV0dXJuIG91dHNpZGUgb2YgZnVuY3Rpb25zXCIpO1xuICAgICAgY29uc3QgdFJldCA9IHRjRXhwcihlbnYsIGxvY2Fscywgc3RtdC52YWx1ZSwgU1JDKTtcbiAgICAgIGlmICghaXNBc3NpZ25hYmxlKGVudiwgdFJldC5hLnR5cGUsIGxvY2Fscy5leHBlY3RlZFJldCkpXG4gICAgICAgIHRocm93IG5ldyBUeXBlQ2hlY2tFcnJvcihTUkMsIFwiZXhwZWN0ZWQgcmV0dXJuIHR5cGUgYFwiICsgKGxvY2Fscy5leHBlY3RlZFJldCBhcyBhbnkpLnRhZyArIFwiYDsgZ290IHR5cGUgYFwiICsgKHRSZXQuYS50eXBlIGFzIGFueSkudGFnICsgXCJgXCIsXG4gICAgICAgICAgc3RtdC5hKTsgLy8gcmV0dXJuaW5nIHRoZSBsb2Mgb2YgdGhlIGVudGlyZSByZXR1cm4gc3RhdGVtZW50IGhlcmUgYmVjYXVzZSB0aGUgcmV0RXhwciBtaWdodCBiZSBlbXB0eVxuICAgICAgbG9jYWxzLmFjdHVhbFJldCA9IHRSZXQuYS50eXBlO1xuICAgICAgcmV0dXJuIHsgYTogdFJldC5hLCB0YWc6IHN0bXQudGFnLCB2YWx1ZTogdFJldCB9O1xuICAgIGNhc2UgXCJ3aGlsZVwiOlxuICAgICAgdmFyIHRDb25kID0gdGNFeHByKGVudiwgbG9jYWxzLCBzdG10LmNvbmQsIFNSQyk7XG4gICAgICBjb25zdCB0Qm9keSA9IHRjQmxvY2soZW52LCBsb2NhbHMsIHN0bXQuYm9keSwgU1JDKTtcbiAgICAgIGlmICghZXF1YWxUeXBlKHRDb25kLmEudHlwZSwgQk9PTCkpXG4gICAgICAgIHRocm93IG5ldyBUeXBlQ2hlY2tFcnJvcihTUkMsIGBDb25kaXRpb24gRXhwcmVzc2lvbiBNdXN0IGJlIGEgYm9vbCwgZ290ICR7SlNPTi5zdHJpbmdpZnkodENvbmQuYS50eXBlLnRhZyl9YCwgdENvbmQuYSk7XG4gICAgICByZXR1cm4geyBhOiB7IC4uLnN0bXQuYSwgdHlwZTogTk9ORSB9LCB0YWc6IHN0bXQudGFnLCBjb25kOiB0Q29uZCwgYm9keTogdEJvZHkgfTtcbiAgICBjYXNlIFwicGFzc1wiOlxuICAgICAgcmV0dXJuIHsgYTogeyAuLi5zdG10LmEsIHR5cGU6IE5PTkUgfSwgdGFnOiBzdG10LnRhZyB9O1xuICAgIGNhc2UgXCJicmVha1wiOlxuICAgIGNhc2UgXCJjb250aW51ZVwiOlxuICAgICAgcmV0dXJuIHthOiB7IC4uLnN0bXQuYSwgdHlwZTogTk9ORSB9LCB0YWc6IHN0bXQudGFnfTtcbiAgICBjYXNlIFwiZm9yXCI6XG4gICAgICB2YXIgdEl0ZXJhdG9yID0gdGNJdGVyYXRvcihlbnYsIGxvY2Fscywgc3RtdC5pdGVyYXRvcilcbiAgICAgIHZhciB0VmFsT2JqZWN0ID0gdGNFeHByKGVudiwgbG9jYWxzLCBzdG10LnZhbHVlcywgU1JDKTtcbiAgICAgIGlmICh0VmFsT2JqZWN0LmEudHlwZS50YWcgIT09IFwiY2xhc3NcIikgXG4gICAgICAgIHRocm93IG5ldyBUeXBlQ2hlY2tFcnJvcihcInZhbHVlcyByZXF1aXJlIGFuIG9iamVjdFwiKTtcbiAgICAgIGlmICghZW52LmNsYXNzZXMuaGFzKHRWYWxPYmplY3QuYS50eXBlLm5hbWUpKSBcbiAgICAgICAgdGhyb3cgbmV3IFR5cGVDaGVja0Vycm9yKFwidmFsdWVzIG9uIGFuIHVua25vd24gY2xhc3NcIik7XG4gICAgICBjb25zdCBbX18sIG1ldGhvZHNdID0gZW52LmNsYXNzZXMuZ2V0KHRWYWxPYmplY3QuYS50eXBlLm5hbWUpO1xuICAgICAgaWYoIShtZXRob2RzLmhhcyhcImhhc25leHRcIikpIHx8IG1ldGhvZHMuZ2V0KFwiaGFzbmV4dFwiKVsxXS50YWcgIT0gQk9PTC50YWcpXG4gICAgICAgIHRocm93IG5ldyBUeXBlQ2hlY2tFcnJvcihTUkMsIFwiaXRlcmFibGUgY2xhc3MgbXVzdCBoYXZlIGhhc25leHQgbWV0aG9kIHdpdGggYm9vbGVhbiByZXR1cm4gdHlwZVwiKTtcbiAgICAgIGlmKCEobWV0aG9kcy5oYXMoXCJuZXh0XCIpKSkgeyB0aHJvdyBuZXcgVHlwZUNoZWNrRXJyb3IoU1JDLCBcIk5vIG5leHQgbWV0aG9kXCIpOyB9XG4gICAgICBjb25zdCBtZXRob2RUeXBlID0gc3BlY2lhbGl6ZU1ldGhvZFR5cGUoZW52LCB0VmFsT2JqZWN0LmEudHlwZSwgbWV0aG9kcy5nZXQoXCJuZXh0XCIpKTtcbiAgICAgIGlmKCFlcXVhbFR5cGUobWV0aG9kVHlwZVsxXSx0SXRlcmF0b3IpKSB7XG4gICAgICAgIHRocm93IG5ldyBUeXBlQ2hlY2tFcnJvcihTUkMsIFwiaXRlcmFibGUgY2xhc3MgbXVzdCBoYXZlIG5leHQgbWV0aG9kIHdpdGggc2FtZSByZXR1cm4gdHlwZSBhcyBpdGVyYXRvclwiKTtcbiAgICAgIH1cbiAgICAgIGlmKCEobWV0aG9kcy5oYXMoXCJyZXNldFwiKSkgfHwgbWV0aG9kcy5nZXQoXCJyZXNldFwiKVsxXS50YWcgIT0gTk9ORS50YWcpXG4gICAgICAgIHRocm93IG5ldyBUeXBlQ2hlY2tFcnJvcihTUkMsIFwiaXRlcmFibGUgY2xhc3MgbXVzdCBoYXZlIHJlc2V0IG1ldGhvZCB3aXRoIG5vbmUgcmV0dXJuIHR5cGVcIik7XG4gICAgICBjb25zdCB0Zm9yQm9keSA9IHRjQmxvY2soZW52LCBsb2NhbHMsIHN0bXQuYm9keSwgU1JDKTtcbiAgICAgIHJldHVybiB7YTogey4uLnN0bXQuYSwgdHlwZTogdEl0ZXJhdG9yfSwgdGFnOiBzdG10LnRhZywgaXRlcmF0b3I6c3RtdC5pdGVyYXRvciwgdmFsdWVzOiB0VmFsT2JqZWN0LCBib2R5OiB0Zm9yQm9keSB9XG4gICAgY2FzZSBcImZpZWxkLWFzc2lnblwiOlxuICAgICAgdmFyIHRPYmogPSB0Y0V4cHIoZW52LCBsb2NhbHMsIHN0bXQub2JqLCBTUkMpO1xuICAgICAgY29uc3QgdFZhbCA9IHRjRXhwcihlbnYsIGxvY2Fscywgc3RtdC52YWx1ZSwgU1JDKTtcbiAgICAgIGlmICh0T2JqLmEudHlwZS50YWcgIT09IFwiY2xhc3NcIilcbiAgICAgICAgdGhyb3cgbmV3IFR5cGVDaGVja0Vycm9yKFNSQywgYGZpZWxkIGFzc2lnbm1lbnRzIHJlcXVpcmUgYW4gb2JqZWN0LCBnb3QgJHtKU09OLnN0cmluZ2lmeSh0T2JqLmEudHlwZS50YWcpfWAsIHRPYmouYSk7XG4gICAgICBpZiAoIWVudi5jbGFzc2VzLmhhcyh0T2JqLmEudHlwZS5uYW1lKSlcbiAgICAgICAgdGhyb3cgbmV3IFR5cGVDaGVja0Vycm9yKFNSQywgYGZpZWxkIGFzc2lnbm1lbnQgb24gYW4gdW5rbm93biBjbGFzcyBcXGAke3RPYmouYS50eXBlLm5hbWV9XFxgYCwgdE9iai5hKTtcbiAgICAgIGNvbnN0IFtmaWVsZHMsIF9dID0gZW52LmNsYXNzZXMuZ2V0KHRPYmouYS50eXBlLm5hbWUpO1xuICAgICAgaWYgKCFmaWVsZHMuaGFzKHN0bXQuZmllbGQpKVxuICAgICAgICB0aHJvdyBuZXcgVHlwZUNoZWNrRXJyb3IoU1JDLCBgY291bGQgbm90IGZpbmQgZmllbGQgXFxgJHtzdG10LmZpZWxkfVxcYCBpbiBjbGFzcyBcXGAke3RPYmouYS50eXBlLm5hbWV9XFxgYCwgc3RtdC5hKTtcblxuICAgICAgbGV0IGZpZWxkVHkgPSBzcGVjaWFsaXplRmllbGRUeXBlKGVudiwgdE9iai5hLnR5cGUsIGZpZWxkcy5nZXQoc3RtdC5maWVsZCkpO1xuXG4gICAgICAvLyBUT0RPOiB0aGlzIGlzIGFuIHVnbHkgdGVtcG9yYXJ5IGhhY2sgZm9yIGdlbmVyaWMgY29uc3RydWN0b3JcbiAgICAgIC8vIGNhbGxzIHVudGlsIGV4cGxpY2l0IGFubm90YXRpb25zIGFyZSBzdXBwb3J0ZWQuXG4gICAgICAvLyBVbnRpbCB0aGVuIGNvbnN0cnVjdG9ycyBmb3IgZ2VuZXJpYyBjbGFzc2VzIGFyZSBwcm9wZXJseSBjaGVja2VkIG9ubHlcbiAgICAgIC8vIHdoZW4gZGlyZWN0bHkgYXNzaWduZWQgdG8gZmllbGRzIGFuZCB3aWxsIGZhaWwgaW4gdW5leHBlY3RlZCB3YXlzIG90aGVyd2lzZS5cbiAgICAgIGlmKGZpZWxkVHkudGFnID09PSBcImNsYXNzXCIgJiYgZmllbGRUeS5wYXJhbXMubGVuZ3RoICE9PSAwICYmIHRWYWwuYS50eXBlLnRhZyA9PT0gJ2NsYXNzJyAmJiB0VmFsLmEudHlwZS5uYW1lID09PSBmaWVsZFR5Lm5hbWUgJiYgdFZhbC50YWcgPT09ICdjb25zdHJ1Y3QnKSB7XG4gICAgICAgIC8vIGl0IHdvdWxkIGhhdmUgYmVlbiBpbXBvc3NpYmxlIGZvciB0aGUgaW5uZXIgdHlwZS1jaGVja2luZ1xuICAgICAgICAvLyBjb2RlIHRvIHByb3Blcmx5IGluZmVyIGFuZCBmaWxsIGluIHRoZSB0eXBlIHBhcmFtZXRlcnMgZm9yXG4gICAgICAgIC8vIHRoZSBjb25zdHJ1Y3RvciBjYWxsLiBTbyB3ZSBjb3B5IGl0IGZyb20gdGhlIHR5cGUgb2YgdGhlIGZpZWxkXG4gICAgICAgIC8vIHdlIGFyZSBhc3NpZ25pbmcgdG8uXG4gICAgICAgIHRWYWwuYS50eXBlLnBhcmFtcyA9IFsuLi5maWVsZFR5LnBhcmFtc107IFxuICAgICAgfVxuXG4gICAgICBpZiAoIWlzQXNzaWduYWJsZShlbnYsIHRWYWwuYS50eXBlLCBmaWVsZFR5KSlcbiAgICAgICAgdGhyb3cgbmV3IFR5cGVDaGVja0Vycm9yKFNSQywgYGZpZWxkIFxcYCR7c3RtdC5maWVsZH1cXGAgZXhwZWN0ZWQgdHlwZTogJHtKU09OLnN0cmluZ2lmeShmaWVsZHMuZ2V0KHN0bXQuZmllbGQpLnRhZyl9LCBnb3QgdmFsdWUgb2YgdHlwZSAke0pTT04uc3RyaW5naWZ5KHRWYWwuYS50eXBlLnRhZyl9YCxcbiAgICAgICAgICB0VmFsLmEpO1xuICAgICAgcmV0dXJuIHsgLi4uc3RtdCwgYTogeyAuLi5zdG10LmEsIHR5cGU6IE5PTkUgfSwgb2JqOiB0T2JqLCB2YWx1ZTogdFZhbCB9O1xuICB9XG59XG5cbmV4cG9ydCBmdW5jdGlvbiB0Y0V4cHIoZW52OiBHbG9iYWxUeXBlRW52LCBsb2NhbHM6IExvY2FsVHlwZUVudiwgZXhwcjogRXhwcjxBbm5vdGF0aW9uPiwgU1JDOiBzdHJpbmcpOiBFeHByPEFubm90YXRpb24+IHtcbiAgc3dpdGNoIChleHByLnRhZykge1xuICAgIGNhc2UgXCJsaXRlcmFsXCI6XG4gICAgICByZXR1cm4geyAuLi5leHByLCBhOiB7IC4uLmV4cHIuYSwgdHlwZTogdGNMaXRlcmFsKGV4cHIudmFsdWUpIH0gfTtcbiAgICBjYXNlIFwiYmlub3BcIjpcbiAgICAgIGNvbnN0IHRMZWZ0ID0gdGNFeHByKGVudiwgbG9jYWxzLCBleHByLmxlZnQsIFNSQyk7XG4gICAgICBjb25zdCB0UmlnaHQgPSB0Y0V4cHIoZW52LCBsb2NhbHMsIGV4cHIucmlnaHQsIFNSQyk7XG4gICAgICBjb25zdCB0QmluID0geyAuLi5leHByLCBsZWZ0OiB0TGVmdCwgcmlnaHQ6IHRSaWdodCB9O1xuICAgICAgc3dpdGNoIChleHByLm9wKSB7XG4gICAgICAgIGNhc2UgQmluT3AuUGx1czpcbiAgICAgICAgY2FzZSBCaW5PcC5NaW51czpcbiAgICAgICAgY2FzZSBCaW5PcC5NdWw6XG4gICAgICAgIGNhc2UgQmluT3AuSURpdjpcbiAgICAgICAgY2FzZSBCaW5PcC5Nb2Q6XG4gICAgICAgICAgaWYgKGVxdWFsVHlwZSh0TGVmdC5hLnR5cGUsIE5VTSkgJiYgZXF1YWxUeXBlKHRSaWdodC5hLnR5cGUsIE5VTSkpIHsgcmV0dXJuIHsgLi4udEJpbiwgYTogeyAuLi5leHByLmEsIHR5cGU6IE5VTSB9IH0gfVxuICAgICAgICAgIGVsc2UgeyB0aHJvdyBuZXcgVHlwZUNoZWNrRXJyb3IoU1JDLCBgQmluYXJ5IG9wZXJhdG9yIFxcYCR7c3RyaW5naWZ5T3AoZXhwci5vcCl9XFxgIGV4cGVjdHMgdHlwZSBcIm51bWJlclwiIG9uIGJvdGggc2lkZXMsIGdvdCAke0pTT04uc3RyaW5naWZ5KHRMZWZ0LmEudHlwZS50YWcpfSBhbmQgJHtKU09OLnN0cmluZ2lmeSh0UmlnaHQuYS50eXBlLnRhZyl9YCxcbiAgICAgICAgICAgIGV4cHIuYSk7IH1cbiAgICAgICAgY2FzZSBCaW5PcC5FcTpcbiAgICAgICAgY2FzZSBCaW5PcC5OZXE6XG4gICAgICAgICAgaWYgKHRMZWZ0LmEudHlwZS50YWcgPT09IFwiY2xhc3NcIiB8fCB0UmlnaHQuYS50eXBlLnRhZyA9PT0gXCJjbGFzc1wiKSB0aHJvdyBuZXcgVHlwZUNoZWNrRXJyb3IoU1JDLCBcImNhbm5vdCBhcHBseSBvcGVyYXRvciAnPT0nIG9uIGNsYXNzIHR5cGVzXCIpXG4gICAgICAgICAgaWYodExlZnQuYS50eXBlLnRhZyA9PT0gXCJ0eXBldmFyXCIgfHwgdFJpZ2h0LmEudHlwZS50YWcgPT09IFwidHlwZXZhclwiKSB0aHJvdyBuZXcgVHlwZUNoZWNrRXJyb3IoU1JDLCBcImNhbm5vdCBhcHBseSBvcGVyYXRvciAnPT0nIG9uIHVuY29uc3RyYWluZWQgdHlwZSBwYXJhbWV0ZXJzXCIpXG4gICAgICAgICAgaWYgKGVxdWFsVHlwZSh0TGVmdC5hLnR5cGUsIHRSaWdodC5hLnR5cGUpKSB7IHJldHVybiB7IC4uLnRCaW4sIGE6IHsgLi4uZXhwci5hLCB0eXBlOiBCT09MIH0gfTsgfVxuICAgICAgICAgIGVsc2UgeyB0aHJvdyBuZXcgVHlwZUNoZWNrRXJyb3IoU1JDLCBgQmluYXJ5IG9wZXJhdG9yIFxcYCR7c3RyaW5naWZ5T3AoZXhwci5vcCl9XFxgIGV4cGVjdHMgdGhlIHNhbWUgdHlwZSBvbiBib3RoIHNpZGVzLCBnb3QgJHtKU09OLnN0cmluZ2lmeSh0TGVmdC5hLnR5cGUudGFnKX0gYW5kICR7SlNPTi5zdHJpbmdpZnkodFJpZ2h0LmEudHlwZS50YWcpfWAsXG4gICAgICAgICAgICBleHByLmEpOyB9XG4gICAgICAgIGNhc2UgQmluT3AuTHRlOlxuICAgICAgICBjYXNlIEJpbk9wLkd0ZTpcbiAgICAgICAgY2FzZSBCaW5PcC5MdDpcbiAgICAgICAgY2FzZSBCaW5PcC5HdDpcbiAgICAgICAgICBpZiAoZXF1YWxUeXBlKHRMZWZ0LmEudHlwZSwgTlVNKSAmJiBlcXVhbFR5cGUodFJpZ2h0LmEudHlwZSwgTlVNKSkgeyByZXR1cm4geyAuLi50QmluLCBhOiB7IC4uLmV4cHIuYSwgdHlwZTogQk9PTCB9IH07IH1cbiAgICAgICAgICBlbHNlIHsgdGhyb3cgbmV3IFR5cGVDaGVja0Vycm9yKFNSQywgYEJpbmFyeSBvcGVyYXRvciBcXGAke3N0cmluZ2lmeU9wKGV4cHIub3ApfVxcYCBleHBlY3RzIHR5cGUgXCJudW1iZXJcIiBvbiBib3RoIHNpZGVzLCBnb3QgJHtKU09OLnN0cmluZ2lmeSh0TGVmdC5hLnR5cGUudGFnKX0gYW5kICR7SlNPTi5zdHJpbmdpZnkodFJpZ2h0LmEudHlwZS50YWcpfWAsXG4gICAgICAgICAgZXhwci5hKTsgfVxuICAgICAgICBjYXNlIEJpbk9wLkFuZDpcbiAgICAgICAgY2FzZSBCaW5PcC5PcjpcbiAgICAgICAgICBpZiAoZXF1YWxUeXBlKHRMZWZ0LmEudHlwZSwgQk9PTCkgJiYgZXF1YWxUeXBlKHRSaWdodC5hLnR5cGUsIEJPT0wpKSB7IHJldHVybiB7IC4uLnRCaW4sIGE6IHsgLi4uZXhwci5hLCB0eXBlOiBCT09MIH0gfTsgfVxuICAgICAgICAgIGVsc2UgeyB0aHJvdyBuZXcgVHlwZUNoZWNrRXJyb3IoU1JDLCBgQmluYXJ5IG9wZXJhdG9yIFxcYCR7c3RyaW5naWZ5T3AoZXhwci5vcCl9XFxgIGV4cGVjdHMgdHlwZSBcImJvb2xcIiBvbiBib3RoIHNpZGVzLCBnb3QgJHtKU09OLnN0cmluZ2lmeSh0TGVmdC5hLnR5cGUudGFnKX0gYW5kICR7SlNPTi5zdHJpbmdpZnkodFJpZ2h0LmEudHlwZS50YWcpfWAsXG4gICAgICAgICAgZXhwci5hKTsgfVxuICAgICAgICBjYXNlIEJpbk9wLklzOlxuICAgICAgICAgIGlmKCFpc05vbmVPckNsYXNzT3JDYWxsYWJsZSh0TGVmdC5hLnR5cGUpIHx8ICFpc05vbmVPckNsYXNzT3JDYWxsYWJsZSh0UmlnaHQuYS50eXBlKSlcbiAgICAgICAgICAgIHRocm93IG5ldyBUeXBlQ2hlY2tFcnJvcihTUkMsIGBCaW5hcnkgb3BlcmF0b3IgXFxgJHtzdHJpbmdpZnlPcChleHByLm9wKX1cXGAgZXhwZWN0cyB0eXBlIFwiY2xhc3NcIiwgXCJub25lXCIsIG9yIFwiY2FsbGFibGVcIiBvbiBib3RoIHNpZGVzLCBnb3QgJHtKU09OLnN0cmluZ2lmeSh0TGVmdC5hLnR5cGUudGFnKX0gYW5kICR7SlNPTi5zdHJpbmdpZnkodFJpZ2h0LmEudHlwZS50YWcpfWAsXG4gICAgICAgICAgICBleHByLmEpO1xuICAgICAgICAgIHJldHVybiB7IC4uLnRCaW4sIGE6IHsgLi4uZXhwci5hLCB0eXBlOiBCT09MIH0gfTtcbiAgICAgIH1cbiAgICBjYXNlIFwidW5pb3BcIjpcbiAgICAgIGNvbnN0IHRFeHByID0gdGNFeHByKGVudiwgbG9jYWxzLCBleHByLmV4cHIsIFNSQyk7XG4gICAgICBjb25zdCB0VW5pID0geyAuLi5leHByLCBhOiB0RXhwci5hLCBleHByOiB0RXhwciB9XG4gICAgICBzd2l0Y2ggKGV4cHIub3ApIHtcbiAgICAgICAgY2FzZSBVbmlPcC5OZWc6XG4gICAgICAgICAgaWYgKGVxdWFsVHlwZSh0RXhwci5hLnR5cGUsIE5VTSkpIHsgcmV0dXJuIHRVbmkgfVxuICAgICAgICAgIGVsc2UgeyB0aHJvdyBuZXcgVHlwZUNoZWNrRXJyb3IoU1JDLCBgVW5hcnkgb3BlcmF0b3IgXFxgJHtzdHJpbmdpZnlPcChleHByLm9wKX1cXGAgZXhwZWN0cyB0eXBlIFwibnVtYmVyXCIsIGdvdCAke0pTT04uc3RyaW5naWZ5KHRFeHByLmEudHlwZS50YWcpfWAsXG4gICAgICAgICAgZXhwci5hKTsgfVxuICAgICAgICBjYXNlIFVuaU9wLk5vdDpcbiAgICAgICAgICBpZiAoZXF1YWxUeXBlKHRFeHByLmEudHlwZSwgQk9PTCkpIHsgcmV0dXJuIHRVbmkgfVxuICAgICAgICAgIGVsc2UgeyB0aHJvdyBuZXcgVHlwZUNoZWNrRXJyb3IoU1JDLCBgVW5hcnkgb3BlcmF0b3IgXFxgJHtzdHJpbmdpZnlPcChleHByLm9wKX1cXGAgZXhwZWN0cyB0eXBlIFwiYm9vbFwiLCBnb3QgJHtKU09OLnN0cmluZ2lmeSh0RXhwci5hLnR5cGUudGFnKX1gLFxuICAgICAgICAgIGV4cHIuYSk7IH1cbiAgICAgIH1cbiAgICBjYXNlIFwiaWRcIjpcbiAgICAgIGlmIChsb2NhbHMudmFycy5oYXMoZXhwci5uYW1lKSkge1xuICAgICAgICByZXR1cm4geyAuLi5leHByLCBhOiB7IC4uLmV4cHIuYSwgdHlwZTogbG9jYWxzLnZhcnMuZ2V0KGV4cHIubmFtZSkgfSB9O1xuICAgICAgfSBlbHNlIGlmIChlbnYuZ2xvYmFscy5oYXMoZXhwci5uYW1lKSkge1xuICAgICAgICByZXR1cm4geyAuLi5leHByLCBhOiB7IC4uLmV4cHIuYSwgdHlwZTogZW52Lmdsb2JhbHMuZ2V0KGV4cHIubmFtZSkgfSB9O1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGhyb3cgbmV3IFR5cGVDaGVja0Vycm9yKFNSQywgXCJVbmJvdW5kIGlkOiBcIiArIGV4cHIubmFtZSwgZXhwci5hKTtcbiAgICAgIH1cbiAgICBjYXNlIFwibGFtYmRhXCI6XG4gICAgICBpZiAoZXhwci5wYXJhbXMubGVuZ3RoICE9PSBleHByLnR5cGUucGFyYW1zLmxlbmd0aCkge1xuICAgICAgICB0aHJvdyBuZXcgVHlwZUNoZWNrRXJyb3IoXCJNaXNtYXRjaCBpbiBudW1iZXIgb2YgcGFyYW1ldGVyczogXCIgKyBleHByLnR5cGUucGFyYW1zLmxlbmd0aCArIFwiICE9IFwiICsgZXhwci5wYXJhbXMubGVuZ3RoKTtcbiAgICAgIH1cbiAgICAgIGNvbnN0IGxhbWJkYUxvY2FscyA9IGNvcHlMb2NhbHMobG9jYWxzKTtcbiAgICAgIGV4cHIucGFyYW1zLmZvckVhY2goKHBhcmFtLCBpKSA9PiB7XG4gICAgICAgIGxhbWJkYUxvY2Fscy52YXJzLnNldChwYXJhbSwgZXhwci50eXBlLnBhcmFtc1tpXSk7XG4gICAgICB9KVxuICAgICAgbGV0IHJldCA9IHRjRXhwcihlbnYsIGxhbWJkYUxvY2FscywgZXhwci5leHByLCBTUkMpO1xuICAgICAgaWYgKCFpc0Fzc2lnbmFibGUoZW52LCByZXQuYS50eXBlLCBleHByLnR5cGUucmV0KSkge1xuICAgICAgICB0aHJvdyBuZXcgVHlwZUNoZWNrRXJyb3IoXCJFeHBlY3RlZCB0eXBlIFwiICsgSlNPTi5zdHJpbmdpZnkoZXhwci50eXBlLnJldCkgKyBcIiBpbiBsYW1iZGEsIGdvdCB0eXBlIFwiICsgSlNPTi5zdHJpbmdpZnkocmV0LmEudHlwZS50YWcpKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiB7YTogeyAuLi5leHByLmEsIHR5cGU6IGV4cHIudHlwZSB9LCB0YWc6IFwibGFtYmRhXCIsIHBhcmFtczogZXhwci5wYXJhbXMsIHR5cGU6IGV4cHIudHlwZSwgZXhwcjogcmV0fVxuICAgIGNhc2UgXCJidWlsdGluMVwiOlxuICAgICAgLy8gVE9ETzogdHlwZSBjaGVjayBgbGVuYCBhZnRlciBsaXN0cyBhcmUgaW1wbGVtZW50ZWRcbiAgICAgIGlmIChleHByLm5hbWUgPT09IFwicHJpbnRcIikge1xuICAgICAgICBjb25zdCB0QXJnID0gdGNFeHByKGVudiwgbG9jYWxzLCBleHByLmFyZywgU1JDKTtcbiAgICAgICAgXG4gICAgICAgIC8vIFtsaXNhXSBjb21tZW50ZWQgb3V0IGZvciBub3cgYmVjYXVzZSBpdCdzIGZhaWxpbmcgc29tZSBoaWRkZW4gdGVzdFxuICAgICAgICAvLyBpZiAodEFyZy5hLnR5cGUudGFnICE9PSBcIm51bWJlclwiICYmIHRBcmcuYS50eXBlLnRhZyAhPT0gXCJib29sXCIpIHtcbiAgICAgICAgLy8gICB0aHJvdyBuZXcgVHlwZUNoZWNrRXJyb3IoU1JDLCBgcHJpbnQoKSBleHBlY3RzIHR5cGVzIFwiaW50XCIgb3IgXCJib29sXCIgYXMgdGhlIGFyZ3VtZW50LCBnb3QgJHtKU09OLnN0cmluZ2lmeSh0QXJnLmEudHlwZS50YWcpfWAsIHRBcmcuYSwgdEFyZy5hLmVuZExvYyk7XG4gICAgICAgIC8vIH1cbiAgICAgICAgcmV0dXJuIHsgLi4uZXhwciwgYTogdEFyZy5hLCBhcmc6IHRBcmcgfTtcbiAgICAgIH0gZWxzZSBpZiAoZW52LmZ1bmN0aW9ucy5oYXMoZXhwci5uYW1lKSkge1xuICAgICAgICBjb25zdCBbW2V4cGVjdGVkQXJnVHlwXSwgcmV0VHlwXSA9IGVudi5mdW5jdGlvbnMuZ2V0KGV4cHIubmFtZSk7XG4gICAgICAgIGNvbnN0IHRBcmcgPSB0Y0V4cHIoZW52LCBsb2NhbHMsIGV4cHIuYXJnLCBTUkMpO1xuXG4gICAgICAgIGlmIChpc0Fzc2lnbmFibGUoZW52LCB0QXJnLmEudHlwZSwgZXhwZWN0ZWRBcmdUeXApKSB7XG4gICAgICAgICAgcmV0dXJuIHsgLi4uZXhwciwgYTogeyAuLi5leHByLmEsIHR5cGU6IHJldFR5cCB9LCBhcmc6IHRBcmcgfTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB0aHJvdyBuZXcgVHlwZUNoZWNrRXJyb3IoU1JDLCBgRnVuY3Rpb24gY2FsbCBleHBlY3RzIGFuIGFyZ3VtZW50IG9mIHR5cGUgJHtKU09OLnN0cmluZ2lmeShleHBlY3RlZEFyZ1R5cC50YWcpfSwgZ290ICR7SlNPTi5zdHJpbmdpZnkodEFyZy5hLnR5cGUudGFnKX1gLFxuICAgICAgICAgICAgZXhwci5hKTtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGhyb3cgbmV3IFR5cGVDaGVja0Vycm9yKFNSQywgXCJVbmRlZmluZWQgZnVuY3Rpb246IFwiICsgZXhwci5uYW1lLCBleHByLmEpO1xuICAgICAgfVxuICAgIGNhc2UgXCJidWlsdGluMlwiOlxuICAgICAgaWYgKGVudi5mdW5jdGlvbnMuaGFzKGV4cHIubmFtZSkpIHtcbiAgICAgICAgY29uc3QgW1tsZWZ0VHlwLCByaWdodFR5cF0sIHJldFR5cF0gPSBlbnYuZnVuY3Rpb25zLmdldChleHByLm5hbWUpO1xuICAgICAgICBjb25zdCB0TGVmdEFyZyA9IHRjRXhwcihlbnYsIGxvY2FscywgZXhwci5sZWZ0LCBTUkMpO1xuICAgICAgICBjb25zdCB0UmlnaHRBcmcgPSB0Y0V4cHIoZW52LCBsb2NhbHMsIGV4cHIucmlnaHQsIFNSQyk7XG4gICAgICAgIGlmIChpc0Fzc2lnbmFibGUoZW52LCBsZWZ0VHlwLCB0TGVmdEFyZy5hLnR5cGUpICYmIGlzQXNzaWduYWJsZShlbnYsIHJpZ2h0VHlwLCB0UmlnaHRBcmcuYS50eXBlKSkge1xuICAgICAgICAgIHJldHVybiB7IC4uLmV4cHIsIGE6IHsgLi4uZXhwci5hLCB0eXBlOiByZXRUeXAgfSwgbGVmdDogdExlZnRBcmcsIHJpZ2h0OiB0UmlnaHRBcmcgfTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB0aHJvdyBuZXcgVHlwZUNoZWNrRXJyb3IoU1JDLCBgRnVuY3Rpb24gY2FsbCBleHBlY3RzIGFyZ3VtZW50cyBvZiB0eXBlcyAke0pTT04uc3RyaW5naWZ5KGxlZnRUeXAudGFnKX0gYW5kICR7SlNPTi5zdHJpbmdpZnkocmlnaHRUeXAudGFnKX0sIGdvdCAke0pTT04uc3RyaW5naWZ5KHRMZWZ0QXJnLmEudHlwZS50YWcpfSBhbmQgJHtKU09OLnN0cmluZ2lmeSh0UmlnaHRBcmcuYS50eXBlLnRhZyl9YCxcbiAgICAgICAgICAgIGV4cHIuYSk7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRocm93IG5ldyBUeXBlQ2hlY2tFcnJvcihTUkMsIFwiVW5kZWZpbmVkIGZ1bmN0aW9uOiBcIiArIGV4cHIubmFtZSwgZXhwci5hKTtcbiAgICAgIH1cbiAgICBjYXNlIFwiY2FsbFwiOlxuICAgICAgaWYgKGV4cHIuZm4udGFnID09PSBcImlkXCIgJiYgZW52LmNsYXNzZXMuaGFzKGV4cHIuZm4ubmFtZSkpIHtcbiAgICAgICAgLy8gc3VycHJpc2Ugc3VycHJpc2UgdGhpcyBpcyBhY3R1YWxseSBhIGNvbnN0cnVjdG9yXG4gICAgICAgIGNvbnN0IHRDb25zdHJ1Y3Q6IEV4cHI8QW5ub3RhdGlvbj4gPSB7IGE6IHsgLi4uZXhwci5hLCB0eXBlOiBDTEFTUyhleHByLmZuLm5hbWUpIH0sIHRhZzogXCJjb25zdHJ1Y3RcIiwgbmFtZTogZXhwci5mbi5uYW1lIH07XG4gICAgICAgIGNvbnN0IFtfLCBtZXRob2RzXSA9IGVudi5jbGFzc2VzLmdldChleHByLmZuLm5hbWUpO1xuICAgICAgICBpZiAobWV0aG9kcy5oYXMoXCJfX2luaXRfX1wiKSkge1xuICAgICAgICAgIGNvbnN0IFtpbml0QXJncywgaW5pdFJldF0gPSBtZXRob2RzLmdldChcIl9faW5pdF9fXCIpO1xuICAgICAgICAgIGlmIChleHByLmFyZ3VtZW50cy5sZW5ndGggIT09IGluaXRBcmdzLmxlbmd0aCAtIDEpXG4gICAgICAgICAgICB0aHJvdyBuZXcgVHlwZUNoZWNrRXJyb3IoU1JDLCBgX19pbml0X18gdGFrZXMgMSBwYXJhbWV0ZXIgXFxgc2VsZlxcYCBvZiB0aGUgc2FtZSB0eXBlIG9mIHRoZSBjbGFzcyBcXGAke2V4cHIuZm4ubmFtZX1cXGAgd2l0aCByZXR1cm4gdHlwZSBvZiBcXGBOb25lXFxgLCBnb3QgJHtleHByLmFyZ3VtZW50cy5sZW5ndGh9IHBhcmFtZXRlcnNgLCBleHByLmEpO1xuICAgICAgICAgIGlmIChpbml0UmV0ICE9PSBOT05FKVxuICAgICAgICAgICAgdGhyb3cgbmV3IFR5cGVDaGVja0Vycm9yKFNSQywgYF9faW5pdF9fIHRha2VzIDEgcGFyYW1ldGVyIFxcYHNlbGZcXGAgb2YgdGhlIHNhbWUgdHlwZSBvZiB0aGUgY2xhc3MgXFxgJHtleHByLmZuLm5hbWV9XFxgIHdpdGggcmV0dXJuIHR5cGUgb2YgXFxgTm9uZVxcYCwgZ290cmV0dXJuIHR5cGUgJHtKU09OLnN0cmluZ2lmeShpbml0UmV0LnRhZyl9YCwgZXhwci5hKTtcbiAgICAgICAgICByZXR1cm4gdENvbnN0cnVjdDtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICByZXR1cm4gdENvbnN0cnVjdDtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgY29uc3QgbmV3Rm4gPSB0Y0V4cHIoZW52LCBsb2NhbHMsIGV4cHIuZm4sIFNSQyk7XG4gICAgICAgIGlmKG5ld0ZuLmEudHlwZS50YWcgIT09IFwiY2FsbGFibGVcIikge1xuICAgICAgICAgIHRocm93IG5ldyBUeXBlQ2hlY2tFcnJvcihcIkNhbm5vdCBjYWxsIG5vbi1jYWxsYWJsZSBleHByZXNzaW9uXCIpO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHRBcmdzID0gZXhwci5hcmd1bWVudHMubWFwKGFyZyA9PiB0Y0V4cHIoZW52LCBsb2NhbHMsIGFyZywgU1JDKSk7XG4gICAgICAgIFxuICAgICAgICBpZihuZXdGbi5hLnR5cGUucGFyYW1zLmxlbmd0aCA9PT0gZXhwci5hcmd1bWVudHMubGVuZ3RoICYmXG4gICAgICAgICAgbmV3Rm4uYS50eXBlLnBhcmFtcy5ldmVyeSgocGFyYW0sIGkpID0+IGlzQXNzaWduYWJsZShlbnYsIHRBcmdzW2ldLmEudHlwZSwgcGFyYW0pKSkge1xuICAgICAgICAgIHJldHVybiB7Li4uZXhwciwgYTogey4uLmV4cHIuYSwgdHlwZTogbmV3Rm4uYS50eXBlLnJldH0sIGFyZ3VtZW50czogdEFyZ3MsIGZuOiBuZXdGbn07XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgY29uc3QgdEFyZ3NTdHIgPSB0QXJncy5tYXAodEFyZyA9PiBKU09OLnN0cmluZ2lmeSh0QXJnLmEudHlwZS50YWcpKS5qb2luKFwiLCBcIik7XG4gICAgICAgICAgY29uc3QgYXJnVHlwZXNTdHIgPSBuZXdGbi5hLnR5cGUucGFyYW1zLm1hcChhcmdUeXBlID0+IEpTT04uc3RyaW5naWZ5KGFyZ1R5cGUudGFnKSkuam9pbihcIiwgXCIpO1xuICAgICAgICAgIHRocm93IG5ldyBUeXBlQ2hlY2tFcnJvcihTUkMsIGBGdW5jdGlvbiBjYWxsIGV4cGVjdHMgYXJndW1lbnRzIG9mIHR5cGVzIFske2FyZ1R5cGVzU3RyfV0sIGdvdCBbJHt0QXJnc1N0cn1dYCwgZXhwci5hKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIGNhc2UgXCJsb29rdXBcIjpcbiAgICAgIHZhciB0T2JqID0gdGNFeHByKGVudiwgbG9jYWxzLCBleHByLm9iaiwgU1JDKTtcbiAgICAgIGlmICh0T2JqLmEudHlwZS50YWcgPT09IFwiY2xhc3NcIikge1xuICAgICAgICBpZiAoZW52LmNsYXNzZXMuaGFzKHRPYmouYS50eXBlLm5hbWUpKSB7XG4gICAgICAgICAgY29uc3QgW2ZpZWxkcywgX10gPSBlbnYuY2xhc3Nlcy5nZXQodE9iai5hLnR5cGUubmFtZSk7XG4gICAgICAgICAgaWYgKGZpZWxkcy5oYXMoZXhwci5maWVsZCkpIHtcbiAgICAgICAgICAgIHJldHVybiB7IC4uLmV4cHIsIGE6IHsgLi4uZXhwci5hLCB0eXBlOiBzcGVjaWFsaXplRmllbGRUeXBlKGVudiwgdE9iai5hLnR5cGUsIGZpZWxkcy5nZXQoZXhwci5maWVsZCkpIH0sIG9iajogdE9iaiB9O1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgVHlwZUNoZWNrRXJyb3IoU1JDLCBgY291bGQgbm90IGZpbmQgZmllbGQgJHtleHByLmZpZWxkfSBpbiBjbGFzcyAke3RPYmouYS50eXBlLm5hbWV9YCwgZXhwci5hKTtcbiAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgdGhyb3cgbmV3IFR5cGVDaGVja0Vycm9yKFNSQywgYGZpZWxkIGxvb2t1cCBvbiBhbiB1bmtub3duIGNsYXNzICR7dE9iai5hLnR5cGUubmFtZX1gLCBleHByLmEpO1xuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aHJvdyBuZXcgVHlwZUNoZWNrRXJyb3IoU1JDLCBgZmllbGQgbG9va3VwcyByZXF1aXJlIGFuIG9iamVjdCBvZiB0eXBlIFwiY2xhc3NcIiwgZ290ICR7SlNPTi5zdHJpbmdpZnkodE9iai5hLnR5cGUudGFnKX1gLCBleHByLmEpO1xuICAgICAgfVxuICAgIGNhc2UgXCJtZXRob2QtY2FsbFwiOlxuICAgICAgdmFyIHRPYmogPSB0Y0V4cHIoZW52LCBsb2NhbHMsIGV4cHIub2JqLCBTUkMpO1xuICAgICAgdmFyIHRBcmdzID0gZXhwci5hcmd1bWVudHMubWFwKGFyZyA9PiB0Y0V4cHIoZW52LCBsb2NhbHMsIGFyZywgU1JDKSk7XG4gICAgICBpZiAodE9iai5hLnR5cGUudGFnID09PSBcImNsYXNzXCIpIHtcbiAgICAgICAgaWYgKGVudi5jbGFzc2VzLmhhcyh0T2JqLmEudHlwZS5uYW1lKSkge1xuICAgICAgICAgIGNvbnN0IFtfLCBtZXRob2RzXSA9IGVudi5jbGFzc2VzLmdldCh0T2JqLmEudHlwZS5uYW1lKTtcbiAgICAgICAgICBpZiAobWV0aG9kcy5oYXMoZXhwci5tZXRob2QpKSB7XG4gICAgICAgICAgICBjb25zdCBbbWV0aG9kQXJncywgbWV0aG9kUmV0XSA9IHNwZWNpYWxpemVNZXRob2RUeXBlKGVudiwgdE9iai5hLnR5cGUsIG1ldGhvZHMuZ2V0KGV4cHIubWV0aG9kKSk7XG4gICAgICAgICAgICBjb25zdCByZWFsQXJncyA9IFt0T2JqXS5jb25jYXQodEFyZ3MpO1xuICAgICAgICAgICAgaWYgKG1ldGhvZEFyZ3MubGVuZ3RoID09PSByZWFsQXJncy5sZW5ndGggJiZcbiAgICAgICAgICAgICAgbWV0aG9kQXJncy5ldmVyeSgoYXJnVHlwLCBpKSA9PiBpc0Fzc2lnbmFibGUoZW52LCByZWFsQXJnc1tpXS5hLnR5cGUsIGFyZ1R5cCkpKSB7XG4gICAgICAgICAgICAgIHJldHVybiB7IC4uLmV4cHIsIGE6IHsgLi4uZXhwci5hLCB0eXBlOiBtZXRob2RSZXQgfSwgb2JqOiB0T2JqLCBhcmd1bWVudHM6IHRBcmdzIH07XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICBjb25zdCBhcmdUeXBlc1N0ciA9IG1ldGhvZEFyZ3MubWFwKGFyZ1R5cGUgPT4gSlNPTi5zdHJpbmdpZnkoYXJnVHlwZS50YWcpKS5qb2luKFwiLCBcIik7XG4gICAgICAgICAgICAgIGNvbnN0IHRBcmdzU3RyID0gcmVhbEFyZ3MubWFwKHRBcmcgPT4gSlNPTi5zdHJpbmdpZnkodEFyZy5hLnR5cGUudGFnKSkuam9pbihcIiwgXCIpO1xuICAgICAgICAgICAgICB0aHJvdyBuZXcgVHlwZUNoZWNrRXJyb3IoU1JDLCBgTWV0aG9kIGNhbGwgJHtleHByLm1ldGhvZH0gZXhwZWN0cyBhcmd1bWVudHMgb2YgdHlwZXMgWyR7YXJnVHlwZXNTdHJ9XSwgZ290IFske3RBcmdzU3RyfV1gLFxuICAgICAgICAgICAgICBleHByLmEpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgVHlwZUNoZWNrRXJyb3IoU1JDLCBgY291bGQgbm90IGZvdW5kIG1ldGhvZCAke2V4cHIubWV0aG9kfSBpbiBjbGFzcyAke3RPYmouYS50eXBlLm5hbWV9YCxcbiAgICAgICAgICAgIGV4cHIuYSk7XG4gICAgICAgICAgfVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHRocm93IG5ldyBUeXBlQ2hlY2tFcnJvcihTUkMsIGBtZXRob2QgY2FsbCBvbiBhbiB1bmtub3duIGNsYXNzICR7dE9iai5hLnR5cGUubmFtZX1gLCBleHByLmEpO1xuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aHJvdyBuZXcgVHlwZUNoZWNrRXJyb3IoU1JDLCBgbWV0aG9kIGNhbGxzIHJlcXVpcmUgYW4gb2JqZWN0IG9mIHR5cGUgXCJjbGFzc1wiLCBnb3QgJHtKU09OLnN0cmluZ2lmeSh0T2JqLmEudHlwZS50YWcpfWAsIGV4cHIuYSk7XG4gICAgICB9XG4gICAgICBjYXNlIFwibGlzdC1jb21wXCI6XG4gICAgICAgIC8vIGNoZWNrIGlmIGl0ZXJhYmxlIGlzIGluc3RhbmNlIG9mIGNsYXNzXG4gICAgICAgIGNvbnN0IGl0ZXJhYmxlID0gdGNFeHByKGVudiwgbG9jYWxzLCBleHByLml0ZXJhYmxlLFNSQyk7XG4gICAgICAgIGlmIChpdGVyYWJsZS5hLnR5cGUudGFnID09PSBcImNsYXNzXCIpe1xuICAgICAgICAgIGNvbnN0IGNsYXNzRGF0YSA9IGVudi5jbGFzc2VzLmdldChpdGVyYWJsZS5hLnR5cGUubmFtZSk7XG4gICAgICAgICAgLy8gY2hlY2sgaWYgbmV4dCBhbmQgaGFzTmV4dCBtZXRob2RzIGFyZSB0aGVyZVxuICAgICAgICAgIGlmICghY2xhc3NEYXRhWzFdLmhhcyhcIm5leHRcIikgfHwgIWNsYXNzRGF0YVsxXS5oYXMoXCJoYXNOZXh0XCIpKVxuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiVFlQRSBFUlJPUjogQ2xhc3Mgb2YgdGhlIGluc3RhbmNlIG11c3QgaGF2ZSBuZXh0KCkgYW5kIGhhc05leHQoKSBtZXRob2RzXCIpO1xuICAgICAgICAgIC8vIG5lZWQgdG8gY3JlYXRlIGEgbG9jYWwgZW52IGZvciBlbGVtIHRvIGJlIGluc2lkZSBjb21wcmVoZW5zaW9uIG9ubHlcbiAgICAgICAgICB2YXIgbG9jID0gbG9jYWxzO1xuICAgICAgICAgIGlmIChleHByLmVsZW0udGFnID09PSBcImlkXCIpe1xuICAgICAgICAgICAgbG9jLnZhcnMuc2V0KGV4cHIuZWxlbS5uYW1lLCBOVU0pO1xuICAgICAgICAgICAgY29uc3QgZWxlbSA9IHsuLi5leHByLmVsZW0sIGE6IHsuLi5leHByLCB0eXBlOiBOVU19fTtcbiAgICAgICAgICAgIGNvbnN0IGxlZnQgPSB0Y0V4cHIoZW52LCBsb2MsIGV4cHIubGVmdCxTUkMpO1xuICAgICAgICAgICAgdmFyIGNvbmQ7XG4gICAgICAgICAgICBpZiAoZXhwci5jb25kKVxuICAgICAgICAgICAgICBjb25kID0gdGNFeHByKGVudiwgbG9jLCBleHByLmNvbmQsU1JDKTtcbiAgICAgICAgICAgIGlmIChjb25kICYmIGNvbmQuYS50eXBlLnRhZyAhPT0gXCJib29sXCIpXG4gICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIlRZUEUgRVJST1I6IGNvbXByZWhlbnNpb24gaWYgY29uZGl0aW9uIG11c3QgcmV0dXJuIGJvb2xcIilcbiAgICAgICAgICAgIHJldHVybiB7Li4uZXhwciwgbGVmdCwgZWxlbSwgY29uZCwgaXRlcmFibGUsIGE6IHsuLi5leHByLCB0eXBlOiBDTEFTUyhpdGVyYWJsZS5hLnR5cGUubmFtZSl9fTtcbiAgICAgICAgICB9XG4gICAgICAgICAgZWxzZVxuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiVFlQRSBFUlJPUjogZWxlbSBoYXMgdG8gYmUgYW4gaWRcIik7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZVxuICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIlRZUEUgRVJST1I6IEl0ZXJhYmxlIG11c3QgYmUgYW4gaW5zdGFuY2Ugb2YgYSBjbGFzc1wiKTsgIFxuICAgIGNhc2UgXCJpZi1leHByXCI6XG4gICAgICB2YXIgdFRobiA9IHRjRXhwcihlbnYsIGxvY2FscywgZXhwci50aG4sIFNSQyk7XG4gICAgICB2YXIgdENvbmQgPSB0Y0V4cHIoZW52LCBsb2NhbHMsIGV4cHIuY29uZCwgU1JDKTtcbiAgICAgIHZhciB0RWxzID0gdGNFeHByKGVudiwgbG9jYWxzLCBleHByLmVscywgU1JDKTtcbiAgICAgIGlmKCFlcXVhbFR5cGUodENvbmQuYS50eXBlLCBCT09MKSkgdGhyb3cgbmV3IFR5cGVDaGVja0Vycm9yKFNSQywgXCJDb25kaXRpb24gRXhwcmVzc2lvbiBNdXN0IGJlIGEgYm9vbFwiLCBleHByLmEpO1xuICAgICAgLy9UT0RPIChNaWNoYWVsIE1hZGR5LCBDbG9zdXJlcyk6IE1pZ2h0IG5vdCB3b3JrIGZvciBpbmhlcml0ZW5jZS4uLlxuICAgICAgaWYoIWVxdWFsVHlwZSh0VGhuLmEudHlwZSwgdEVscy5hLnR5cGUpKSB0aHJvdyBuZXcgVHlwZUNoZWNrRXJyb3IoU1JDLCBgaWYtZXhwciB0eXBlIG1pc21hdGNoOiAke0pTT04uc3RyaW5naWZ5KHRUaG4uYSl9IGlzIG5vdCB0aGUgc2FtZSBhcyAke0pTT04uc3RyaW5naWZ5KHRFbHMuYSl9YCwgZXhwci5hKTtcbiAgICAgIC8vSW5zdGVhZCB0aGUgdHlwZSBjb3VsZCBiZSBlaXRoZXIgdGhlIHR5cGUgb2YgdGhuIG9yIGVscywgYW5kIG5vdCBlcnJvciBpZiB0aGV5IGFyZSBub3QgdGhlIHNhbWUgdHlwZS5cbiAgICAgIC8vIHZhciBuZXdUeXBlID0gam9pbihlbnYsIHRUaG4uYSwgdEVscy5hKVxuICAgICAgcmV0dXJuIHsuLi5leHByLCBhOiB0VGhuLmEsIGNvbmQ6IHRDb25kLCB0aG46IHRUaG4sIGVsczogdEVsc307XG4gICAgZGVmYXVsdDogdGhyb3cgbmV3IFR5cGVDaGVja0Vycm9yKFNSQywgYHVuaW1wbGVtZW50ZWQgdHlwZSBjaGVja2luZyBmb3IgZXhwcjogJHtleHByfWAsIGV4cHIuYSk7XG4gIH1cbn1cblxuZXhwb3J0IGZ1bmN0aW9uIHRjTGl0ZXJhbChsaXRlcmFsIDogTGl0ZXJhbDxBbm5vdGF0aW9uPikge1xuICAgIHN3aXRjaChsaXRlcmFsLnRhZykge1xuICAgICAgICBjYXNlIFwiYm9vbFwiOiByZXR1cm4gQk9PTDtcbiAgICAgICAgY2FzZSBcIm51bVwiOiByZXR1cm4gTlVNO1xuICAgICAgICBjYXNlIFwibm9uZVwiOiByZXR1cm4gTk9ORTtcbiAgICB9XG59XG5cbi8vIGZ1bmN0aW9uIHRvIHJldHVybiB0aGUgdHlwZSBvZiBpdGVyYXRvciBpbiBmb3ItbG9vcC4gRmluZHMgdGhlIHN0cmluZyBpbiBnbG9iYWxzL2xvY2FscyBhbmQgcmV0dXJucyBpdHMgdHlwZVxuLy8gV2lsbCBiZSBleHRlbmRlZCB0byBpbmNsdWRlIHR1cGxlcyBldGMgaW4gbGF0ZXIgY29tbWl0c1xuZXhwb3J0IGZ1bmN0aW9uIHRjSXRlcmF0b3IoZW52IDogR2xvYmFsVHlwZUVudiwgbG9jYWxzIDogTG9jYWxUeXBlRW52LCBpdGVyYXRvcjogc3RyaW5nKTogVHlwZXtcbiAgaWYgKGxvY2Fscy52YXJzLmhhcyhpdGVyYXRvcikpXG4gICByZXR1cm4gbG9jYWxzLnZhcnMuZ2V0KGl0ZXJhdG9yKSBcbiAgZWxzZSBpZiAoZW52Lmdsb2JhbHMuaGFzKGl0ZXJhdG9yKSlcbiAgICAgcmV0dXJuIGVudi5nbG9iYWxzLmdldChpdGVyYXRvcilcbiAgIHRocm93IG5ldyBUeXBlQ2hlY2tFcnJvcihgVW5kZWZpbmVkIGl0ZXJhdG9yYClcbn1cbiIsImltcG9ydCB7IFZhbHVlLCBUeXBlLCBBbm5vdGF0aW9uLCBMaXRlcmFsIH0gZnJvbSBcIi4vYXN0XCI7XG5cbmV4cG9ydCBjb25zdCBiaWdNYXRoID0ge1xuICAvLyBodHRwczovL3N0YWNrb3ZlcmZsb3cuY29tL2EvNjQ5NTMyODBcbiAgYWJzKHg6IGJpZ2ludCkge1xuICAgIHJldHVybiB4IDwgQmlnSW50KDApID8gLXggOiB4XG4gIH0sXG4gIHNpZ24oeDogYmlnaW50KSB7XG4gICAgaWYgKHggPT09IEJpZ0ludCgwKSkgcmV0dXJuIEJpZ0ludCgwKVxuICAgIHJldHVybiB4IDwgQmlnSW50KDApID8gQmlnSW50KC0xKSA6IEJpZ0ludCgxKVxuICB9LFxuICBwb3coYmFzZTogYmlnaW50LCBleHBvbmVudDogYmlnaW50KSB7XG4gICAgcmV0dXJuIGJhc2UgKiogZXhwb25lbnRcbiAgfSxcbiAgbWluKHZhbHVlOiBiaWdpbnQsIC4uLnZhbHVlczogYmlnaW50W10pIHtcbiAgICBmb3IgKGNvbnN0IHYgb2YgdmFsdWVzKVxuICAgICAgaWYgKHYgPCB2YWx1ZSkgdmFsdWUgPSB2XG4gICAgcmV0dXJuIHZhbHVlXG4gIH0sXG4gIG1heCh2YWx1ZTogYmlnaW50LCAuLi52YWx1ZXM6IGJpZ2ludFtdKSB7XG4gICAgZm9yIChjb25zdCB2IG9mIHZhbHVlcylcbiAgICAgIGlmICh2ID4gdmFsdWUpIHZhbHVlID0gdlxuICAgIHJldHVybiB2YWx1ZVxuICB9LFxuICBhZGQodmFsdWUxOiBiaWdpbnQsIHZhbHVlMjogYmlnaW50KSB7XG4gICAgcmV0dXJuIHZhbHVlMSArIHZhbHVlMlxuICB9LFxuICBzdWIodmFsdWUxOiBiaWdpbnQsIHZhbHVlMjogYmlnaW50KSB7XG4gICAgcmV0dXJuIHZhbHVlMSAtIHZhbHVlMlxuICB9LFxuICBtdWwodmFsdWUxOiBiaWdpbnQsIHZhbHVlMjogYmlnaW50KSB7XG4gICAgcmV0dXJuIHZhbHVlMSAqIHZhbHVlMlxuICB9LFxuICBkaXYodmFsdWUxOiBiaWdpbnQsIHZhbHVlMjogYmlnaW50KSB7XG4gICAgcmV0dXJuIHZhbHVlMSAvIHZhbHVlMlxuICB9LFxuICBtb2QodmFsdWUxOiBiaWdpbnQsIHZhbHVlMjogYmlnaW50KSB7XG4gICAgcmV0dXJuIHZhbHVlMSAlIHZhbHVlMlxuICB9LFxuICBlcSh2YWx1ZTE6IGJpZ2ludCwgdmFsdWUyOiBiaWdpbnQpIHtcbiAgICByZXR1cm4gdmFsdWUxID09PSB2YWx1ZTJcbiAgfSxcbiAgbmVxKHZhbHVlMTogYmlnaW50LCB2YWx1ZTI6IGJpZ2ludCkge1xuICAgIHJldHVybiB2YWx1ZTEgIT09IHZhbHVlMlxuICB9LFxuICBsdGUodmFsdWUxOiBiaWdpbnQsIHZhbHVlMjogYmlnaW50KSB7XG4gICAgcmV0dXJuIHZhbHVlMSA8PSB2YWx1ZTJcbiAgfSxcbiAgZ3RlKHZhbHVlMTogYmlnaW50LCB2YWx1ZTI6IGJpZ2ludCkge1xuICAgIHJldHVybiB2YWx1ZTEgPj0gdmFsdWUyXG4gIH0sXG4gIGx0KHZhbHVlMTogYmlnaW50LCB2YWx1ZTI6IGJpZ2ludCkge1xuICAgIHJldHVybiB2YWx1ZTEgPCB2YWx1ZTJcbiAgfSxcbiAgZ3QodmFsdWUxOiBiaWdpbnQsIHZhbHVlMjogYmlnaW50KSB7XG4gICAgcmV0dXJuIHZhbHVlMSA+IHZhbHVlMlxuICB9LFxufVxuXG5leHBvcnQgZnVuY3Rpb24gYmlub3BfYmlnbnVtKGFyZ3M6IG51bWJlcltdLCBidWlsdGluOiBGdW5jdGlvbiwgbGlibWVtOiBXZWJBc3NlbWJseS5FeHBvcnRzKTogbnVtYmVyIHtcbiAgdmFyIHJzbHQgOiBiaWdpbnQgPSBCaWdJbnQoMCk7XG4gIGNvbnN0IGxvYWQgPSBsaWJtZW0ubG9hZDtcbiAgXG4gIGlmKGFyZ3MubGVuZ3RoID09PSAyKVxuICAgIHJzbHQgPSBidWlsdGluKGxvYWRfYmlnbnVtKGFyZ3NbMF0sIGxvYWQpLCBsb2FkX2JpZ251bShhcmdzWzFdLCBsb2FkKSk7XG4gIGVsc2VcbiAgICB0aHJvdyBuZXcgRXJyb3IoXCJSdW50aW1lIEVycm9yOiB0b28gbWFueSBhcmd1bWVudHMgZm9yIGJ1aWx0aW4gZnVuY3Rpb25zXCIpO1xuICByZXR1cm4gc2F2ZV9iaWdudW0ocnNsdCwgbGlibWVtKTtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGJpbm9wX2NvbXBfYmlnbnVtKGFyZ3M6IG51bWJlcltdLCBidWlsdGluOiBGdW5jdGlvbiwgbGlibWVtOiBXZWJBc3NlbWJseS5FeHBvcnRzKTogbnVtYmVyIHtcbiAgdmFyIHJzbHQgOiBiaWdpbnQgPSBCaWdJbnQoMCk7XG4gIGNvbnN0IGxvYWQgPSBsaWJtZW0ubG9hZDtcbiAgXG4gIGlmKGFyZ3MubGVuZ3RoID09PSAyKVxuICAgIHJzbHQgPSBidWlsdGluKGxvYWRfYmlnbnVtKGFyZ3NbMF0sIGxvYWQpLCBsb2FkX2JpZ251bShhcmdzWzFdLCBsb2FkKSk7XG4gIGVsc2VcbiAgICB0aHJvdyBuZXcgRXJyb3IoXCJSdW50aW1lIEVycm9yOiB0b28gbWFueSBhcmd1bWVudHMgZm9yIGJ1aWx0aW4gZnVuY3Rpb25zXCIpO1xuICByZXR1cm4gTnVtYmVyKHJzbHQpO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gbG9hZF9iaWdudW0oYWRkcjogbnVtYmVyLCBsb2FkZXI6IFdlYkFzc2VtYmx5LkV4cG9ydFZhbHVlKTogYmlnaW50IHtcbiAgY29uc3QgbG9hZCA9IGxvYWRlciBhcyBDYWxsYWJsZUZ1bmN0aW9uO1xuICBpZiAoYWRkciA9PT0gMCkgXG4gICAgcmV0dXJuIEJpZ0ludCgwKTtcbiAgY29uc3QgbnVtbGVuZ3RoID0gbG9hZChhZGRyLCAwKTtcbiAgdmFyIGJpZ251bSA6IGJpZ2ludCA9IEJpZ0ludCgwKTtcbiAgZm9yIChsZXQgaSA9IE1hdGguYWJzKG51bWxlbmd0aCk7IGkgPiAwOyBpLS0pIHtcbiAgICBiaWdudW0gPDw9IEJpZ0ludCgzMSk7XG4gICAgYmlnbnVtICs9IEJpZ0ludChsb2FkKGFkZHIsIGkpICYgMHg3ZmZmZmZmZik7IC8vIG1hc2sgbnVtYmVyIHRvIDJeMzFcbiAgfVxuICBpZiAobnVtbGVuZ3RoIDwgMClcbiAgICBiaWdudW0gKj0gQmlnSW50KC0xKTtcbiAgcmV0dXJuIGJpZ251bTtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGFsbG9jX2JpZ251bShudW1sZW5ndGg6IG51bWJlciwgYWxsb2NhdG9yOiBXZWJBc3NlbWJseS5FeHBvcnRWYWx1ZSk6IG51bWJlciB7XG4gIGNvbnN0IGFsbG9jID0gYWxsb2NhdG9yIGFzIENhbGxhYmxlRnVuY3Rpb247XG4gIC8vIGFsbG9jYXRlIG9uZSBleHRyYSBzcGFjZSBmb3IgbWV0YWRhdGEgKGxlbmd0aClcbiAgcmV0dXJuIGFsbG9jKE1hdGguYWJzKG51bWxlbmd0aCkrMSk7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBzdG9yZV9iaWdudW0oYWRkcjogbnVtYmVyLCBudW1sZW5ndGg6IG51bWJlciwgZGlnaXRzOiBudW1iZXJbXSwgc3RvcmVyOiBXZWJBc3NlbWJseS5FeHBvcnRWYWx1ZSkge1xuICBjb25zdCBzdG9yZSA9IHN0b3JlciBhcyBDYWxsYWJsZUZ1bmN0aW9uO1xuICBzdG9yZShhZGRyLCAwLCBudW1sZW5ndGgpO1xuICBkaWdpdHMuZm9yRWFjaCgoZCwgaSkgPT4ge1xuICAgIHN0b3JlKGFkZHIsIGkrMSwgZCk7XG4gIH0pO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gc2F2ZV9iaWdudW0oYmlnbnVtOiBiaWdpbnQsIGxpYm1lbTogV2ViQXNzZW1ibHkuRXhwb3J0cyk6IG51bWJlciB7XG4gIGNvbnN0IGFsbG9jID0gbGlibWVtLmFsbG9jO1xuICBjb25zdCBzdG9yZSA9IGxpYm1lbS5zdG9yZTtcbiAgY29uc3QgbmVnID0gYmlnbnVtIDwgMDtcbiAgaWYgKG5lZylcbiAgICBiaWdudW0gKj0gQmlnSW50KC0xKTtcbiAgY29uc3QgZGlnaXRzIDpudW1iZXJbXSA9IFtdO1xuICB3aGlsZSAoYmlnbnVtID4gMCkge1xuICAgIGRpZ2l0cy5wdXNoKE51bWJlcihiaWdudW0gJiBCaWdJbnQoMHg3ZmZmZmZmZikpKTsgLy8gbWFzayBudW1iZXIgdG8gMl4zMVxuICAgIGJpZ251bSA9IGJpZ251bSA+PiBCaWdJbnQoMzEpO1xuICB9XG4gIGNvbnN0IG51bWxlbmd0aCA9IG5lZz8gZGlnaXRzLmxlbmd0aCAqIC0xOiBkaWdpdHMubGVuZ3RoO1xuICBpZiAobnVtbGVuZ3RoID09PSAwKSBcbiAgICByZXR1cm4gMDtcbiAgY29uc3QgYWRkciA9IGFsbG9jX2JpZ251bShudW1sZW5ndGgsIGFsbG9jKTtcbiAgc3RvcmVfYmlnbnVtKGFkZHIsIG51bWxlbmd0aCwgZGlnaXRzLCBzdG9yZSk7XG4gIHJldHVybiBhZGRyO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gYnVpbHRpbl9iaWdudW0oYXJnczogbnVtYmVyW10sIGJ1aWx0aW46IEZ1bmN0aW9uLCBsaWJtZW06IFdlYkFzc2VtYmx5LkV4cG9ydHMpOiBudW1iZXIge1xuICB2YXIgcnNsdCA6IGJpZ2ludCA9IEJpZ0ludCgwKTtcbiAgY29uc3QgbG9hZCA9IGxpYm1lbS5sb2FkO1xuICBpZihhcmdzLmxlbmd0aCA9PT0gMSlcbiAgICByc2x0ID0gYnVpbHRpbihsb2FkX2JpZ251bShhcmdzWzBdLCBsb2FkKSk7XG4gIGVsc2UgaWYoYXJncy5sZW5ndGggPT09IDIpXG4gICAgcnNsdCA9IGJ1aWx0aW4obG9hZF9iaWdudW0oYXJnc1swXSwgbG9hZCksIGxvYWRfYmlnbnVtKGFyZ3NbMV0sIGxvYWQpKTtcbiAgZWxzZVxuICAgIHRocm93IG5ldyBFcnJvcihcIlJ1bnRpbWUgRXJyb3I6IHRvbyBtYW55IGFyZ3VtZW50cyBmb3IgYnVpbHRpbiBmdW5jdGlvbnNcIik7XG4gIHJldHVybiBzYXZlX2JpZ251bShyc2x0LCBsaWJtZW0pO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gUHlWYWx1ZSh0eXA6IFR5cGUsIHJlc3VsdDogbnVtYmVyKTogVmFsdWU8QW5ub3RhdGlvbj4ge1xuICBzd2l0Y2ggKHR5cC50YWcpIHtcbiAgICBjYXNlIFwibnVtYmVyXCI6XG4gICAgICByZXR1cm4gUHlJbnQocmVzdWx0KTtcbiAgICBjYXNlIFwiYm9vbFwiOlxuICAgICAgcmV0dXJuIFB5Qm9vbChCb29sZWFuKHJlc3VsdCkpO1xuICAgIGNhc2UgXCJjbGFzc1wiOlxuICAgICAgcmV0dXJuIFB5T2JqKHR5cC5uYW1lLCByZXN1bHQpO1xuICAgIGNhc2UgXCJub25lXCI6XG4gICAgICByZXR1cm4gUHlOb25lKCk7XG4gIH1cbn1cblxuZXhwb3J0IGZ1bmN0aW9uIFB5SW50KG46IG51bWJlcik6IFZhbHVlPEFubm90YXRpb24+IHtcbiAgcmV0dXJuIHsgdGFnOiBcIm51bVwiLCB2YWx1ZTogbiB9O1xufVxuXG5leHBvcnQgZnVuY3Rpb24gUHlCb29sKGI6IGJvb2xlYW4pOiBWYWx1ZTxBbm5vdGF0aW9uPiB7XG4gIHJldHVybiB7IHRhZzogXCJib29sXCIsIHZhbHVlOiBiIH07XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBQeU9iaihuYW1lOiBzdHJpbmcsIGFkZHJlc3M6IG51bWJlcik6IFZhbHVlPEFubm90YXRpb24+IHtcbiAgaWYgKGFkZHJlc3MgPT09IDApIHJldHVybiBQeU5vbmUoKTtcbiAgZWxzZSByZXR1cm4geyB0YWc6IFwib2JqZWN0XCIsIG5hbWUsIGFkZHJlc3MgfTtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIFB5Tm9uZSgpOiBWYWx1ZTxBbm5vdGF0aW9uPiB7XG4gIHJldHVybiB7IHRhZzogXCJub25lXCIgfTtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIFB5WmVybygpOiBMaXRlcmFsPEFubm90YXRpb24+IHtcbiAgcmV0dXJuIHsgdGFnOiBcInplcm9cIiB9O1xufVxuXG5leHBvcnQgY29uc3QgTlVNIDogVHlwZSA9IHt0YWc6IFwibnVtYmVyXCJ9O1xuZXhwb3J0IGNvbnN0IEJPT0wgOiBUeXBlID0ge3RhZzogXCJib29sXCJ9O1xuZXhwb3J0IGNvbnN0IE5PTkUgOiBUeXBlID0ge3RhZzogXCJub25lXCJ9O1xuZXhwb3J0IGZ1bmN0aW9uIENMQVNTKG5hbWUgOiBzdHJpbmcsIHBhcmFtczogQXJyYXk8VHlwZT4gPSBbXSkgOiBUeXBlIHtyZXR1cm4ge3RhZzogXCJjbGFzc1wiLCBuYW1lLCBwYXJhbXN9fTtcbmV4cG9ydCBmdW5jdGlvbiBUWVBFVkFSKG5hbWU6IHN0cmluZykgOiBUeXBlIHtyZXR1cm4ge3RhZzogXCJ0eXBldmFyXCIsIG5hbWV9fTtcbmV4cG9ydCBmdW5jdGlvbiBDQUxMQUJMRShwYXJhbXM6IEFycmF5PFR5cGU+LCByZXQ6IFR5cGUpIDogVHlwZSB7cmV0dXJuIHt0YWc6IFwiY2FsbGFibGVcIiwgcGFyYW1zLCByZXR9fTtcblxuZXhwb3J0IGNvbnN0IEFQUExZIDogc3RyaW5nID0gXCJhcHBseVwiO1xuZXhwb3J0IGZ1bmN0aW9uIGNyZWF0ZU1ldGhvZE5hbWUoY2xzOiBzdHJpbmcsIG1ldGhvZDogc3RyaW5nKTogc3RyaW5ne1xuICByZXR1cm4gYCR7Y2xzfSQke21ldGhvZH1gO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gbWFrZVdhc21GdW5UeXBlKHBhcmFtTnVtOiBudW1iZXIpOiBzdHJpbmcge1xuICByZXR1cm4gYCRjYWxsYWJsZSR7cGFyYW1OdW19cGFyYW1gO1xufVxuIiwiaW1wb3J0IHtCYXNpY1JFUEx9IGZyb20gJy4vcmVwbCc7XG5pbXBvcnQgeyBUeXBlLCBWYWx1ZSwgQW5ub3RhdGlvbiwgQ2xhc3MgfSBmcm9tICcuL2FzdCc7XG5pbXBvcnQgeyBkZWZhdWx0VHlwZUVudiwgVHlwZUNoZWNrRXJyb3IgfSBmcm9tICcuL3R5cGUtY2hlY2snO1xuaW1wb3J0IHsgTlVNLCBCT09MLCBOT05FLCBsb2FkX2JpZ251bSwgYnVpbHRpbl9iaWdudW0sIGJpbm9wX2JpZ251bSwgYmlub3BfY29tcF9iaWdudW0sIGJpZ01hdGggIH0gZnJvbSAnLi91dGlscyc7XG5pbXBvcnQgeyBpbXBvcnRPYmplY3RFcnJvcnMgfSBmcm9tICcuL2Vycm9ycyc7XG5cbmltcG9ydCBDb2RlTWlycm9yIGZyb20gJ2NvZGVtaXJyb3InO1xuaW1wb3J0IFwiY29kZW1pcnJvci9hZGRvbi9lZGl0L2Nsb3NlYnJhY2tldHNcIjtcbmltcG9ydCBcImNvZGVtaXJyb3IvbW9kZS9weXRob24vcHl0aG9uXCI7XG5pbXBvcnQgXCJjb2RlbWlycm9yL2FkZG9uL2hpbnQvc2hvdy1oaW50XCI7XG5pbXBvcnQgXCJjb2RlbWlycm9yL2FkZG9uL2xpbnQvbGludFwiO1xuXG5pbXBvcnQgXCJjb2RlbWlycm9yL2FkZG9uL3Njcm9sbC9zaW1wbGVzY3JvbGxiYXJzXCI7XG5pbXBvcnQgXCIuL3N0eWxlLnNjc3NcIjtcblxuaW1wb3J0IHsgYXV0b2NvbXBsZXRlSGludCB9IGZyb20gXCIuL2F1dG9jb21wbGV0ZVwiO1xuaW1wb3J0IHsgZGVmYXVsdF9rZXl3b3JkcywgZGVmYXVsdF9mdW5jdGlvbnMgfSBmcm9tIFwiLi9jb25zdFwiO1xuXG5mdW5jdGlvbiBzdHJpbmdpZnkodHlwOiBUeXBlLCBhcmc6IGFueSwgbG9hZGVyOiBXZWJBc3NlbWJseS5FeHBvcnRWYWx1ZSkgOiBzdHJpbmcge1xuICBzd2l0Y2godHlwLnRhZykge1xuICAgIGNhc2UgXCJudW1iZXJcIjpcbiAgICAgIHJldHVybiBsb2FkX2JpZ251bShhcmcsIGxvYWRlcikudG9TdHJpbmcoKTtcbiAgICBjYXNlIFwiYm9vbFwiOlxuICAgICAgcmV0dXJuIChhcmcgYXMgYm9vbGVhbikgPyBcIlRydWVcIiA6IFwiRmFsc2VcIjtcbiAgICBjYXNlIFwibm9uZVwiOlxuICAgICAgcmV0dXJuIFwiTm9uZVwiO1xuICAgIGNhc2UgXCJjbGFzc1wiOlxuICAgICAgcmV0dXJuIHR5cC5uYW1lO1xuICB9XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBwcmludF9jbGFzcyhtZW1vcnk6IFdlYkFzc2VtYmx5Lk1lbW9yeSwgcmVwbDogQmFzaWNSRVBMLCBwb2ludGVyOiBudW1iZXIsIGNsYXNzbmFtZTogc3RyaW5nLCBsZXZlbDogbnVtYmVyLCBtZXRfb2JqZWN0OiBNYXA8bnVtYmVyLCBudW1iZXI+LCBvYmplY3RfbnVtYmVyOiBudW1iZXIsIGxvYWRlciA6IFdlYkFzc2VtYmx5LkV4cG9ydFZhbHVlKTogQXJyYXk8c3RyaW5nPiB7XG5cbiAgdmFyIGZpZWxkc19vZmZzZXRfID0gcmVwbC5jdXJyZW50RW52LmNsYXNzZXMuZ2V0KGNsYXNzbmFtZSk7XG4gIHZhciBmaWVsZHNfdHlwZSA9IHJlcGwuY3VycmVudFR5cGVFbnYuY2xhc3Nlcy5nZXQoY2xhc3NuYW1lKVswXTtcbiAgdmFyIG1lbSA9IG5ldyBVaW50MzJBcnJheShtZW1vcnkuYnVmZmVyKTtcbiAgdmFyIGRpc3BsYXk6IEFycmF5PHN0cmluZz4gPSBbXTtcbiAgLy8gQVsxXVswXSByZWZlcnMgdG8gdGhlIG9mZnNldCB2YWx1ZSBvZiBmaWVsZCBBLCBzb3J0ZWQgYnkgdGhlIG9mZnNldCB2YWx1ZSB0byBlbnN1cmUgdGhlIGl0ZXJhdGlvbiBoYXMgYSBjb25zaXN0ZW50IG9yZGVyLiBcbiAgdmFyIGZpZWxkc19vZmZzZXQgPSBBcnJheS5mcm9tKGZpZWxkc19vZmZzZXRfLmVudHJpZXMoKSk7XG4gIGZpZWxkc19vZmZzZXQuc29ydCgoYSwgYikgPT4ge1xuICAgIHJldHVybiBhWzFdWzBdIC0gYlsxXVswXTtcbiAgfSk7XG4gIC8vIHRoZSByZWFzb24gd2h5IHBvaW50ZXIgYmVhY3VzZSBtZW0gaXMgdTMyIGFycmF5KDQgYnl0ZSBhZGRyZXNzaW5nKSBhbmQgdGhlIHBvaW50ZXIgdmFsdWUgcmV0dXJuZWQgYnkgdGhlIHJ1biBtZXRob2QgaXMgaW4gcmF3IGFkZHJlc3MoYnl0ZSBhZHJlc3MpXG4gIC8vIHN1cnByaXNpbmdseShzaW5jZSB0aGVyZSBpcyBhbHNvIGk2NCBpbiB3YXNtKSwgdGhlIG9mZnNldCBzdG9yZWQgaW50IHRoZSBjdXJyZW50ZW52IGlzIGluIDQgYnl0ZSBhZGRyZXNzaW5nLlxuICBjb25zdCBzcGFjZSA9IFwiIFwiO1xuICBpZiAobWV0X29iamVjdC5oYXMocG9pbnRlcikpIHtcbiAgICBkaXNwbGF5LnB1c2goYCR7c3BhY2UucmVwZWF0KGxldmVsKX1kaXNwbGF5ZWQgJHttZXRfb2JqZWN0LmdldChwb2ludGVyKX06JHtjbGFzc25hbWV9IG9iamVjdCBhdCBhZGRyICR7cG9pbnRlcn06IC4uLmApO1xuICAgIHJldHVybiBkaXNwbGF5O1xuICB9XG4gIGRpc3BsYXkucHVzaChcbiAgICBgJHtzcGFjZS5yZXBlYXQobGV2ZWwpfSR7b2JqZWN0X251bWJlcn06JHtjbGFzc25hbWV9IG9iamVjdCBhdCBhZGRyICR7cG9pbnRlcn06IHtgKTtcbiAgbWV0X29iamVjdC5zZXQocG9pbnRlciwgb2JqZWN0X251bWJlcilcbiAgZmllbGRzX29mZnNldC5mb3JFYWNoKHRoaXNmaWVsZCA9PiB7XG4gICAgdmFyIHRoaXNmaWVsZF90eXBlID0gZmllbGRzX3R5cGUuZ2V0KHRoaXNmaWVsZFswXSk7XG4gICAgaWYgKHRoaXNmaWVsZF90eXBlLnRhZyA9PT0gXCJjbGFzc1wiKSB7XG4gICAgICBpZiAobWVtW3BvaW50ZXIgLyA0ICsgdGhpc2ZpZWxkWzFdWzBdXSA9PT0gMCkge1xuICAgICAgICBkaXNwbGF5LnB1c2goYCR7c3BhY2UucmVwZWF0KGxldmVsICsgMil9JHt0aGlzZmllbGRbMF19IDogbm9uZSBgKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGRpc3BsYXkucHVzaChgJHtzcGFjZS5yZXBlYXQobGV2ZWwgKyAyKX0ke3RoaXNmaWVsZFswXX06e2ApXG4gICAgICAgIGRpc3BsYXkucHVzaCguLi5wcmludF9jbGFzcyhtZW1vcnksIHJlcGwsIG1lbVtwb2ludGVyIC8gNCArIHRoaXNmaWVsZFsxXVswXV0sIHRoaXNmaWVsZF90eXBlLm5hbWUsIGxldmVsICsgNSwgbWV0X29iamVjdCwgb2JqZWN0X251bWJlciArIDEsIGxvYWRlcikpO1xuICAgICAgICBkaXNwbGF5LnB1c2goYCR7c3BhY2UucmVwZWF0KGxldmVsICsgMil9fWApXG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIGRpc3BsYXkucHVzaChgJHtzcGFjZS5yZXBlYXQobGV2ZWwgKyAyKX0ke3RoaXNmaWVsZFswXX0gOiAke3N0cmluZ2lmeSh0aGlzZmllbGRfdHlwZSwgbWVtW3BvaW50ZXIgLyA0ICsgdGhpc2ZpZWxkWzFdWzBdXSwgbG9hZGVyKX0gYCk7XG4gICAgfVxuICB9XG4gIClcbiAgZGlzcGxheS5wdXNoKFxuICAgIGAke3NwYWNlLnJlcGVhdChsZXZlbCArIDEpfX1gKTtcbiAgcmV0dXJuIGRpc3BsYXk7XG59XG5cbmZ1bmN0aW9uIHByaW50KHR5cDogVHlwZSwgYXJnIDogbnVtYmVyLCBsb2FkZXI6IFdlYkFzc2VtYmx5LkV4cG9ydFZhbHVlKSA6IGFueSB7XG4gIGNvbnNvbGUubG9nKFwiTG9nZ2luZyBmcm9tIFdBU006IFwiLCBhcmcpO1xuICBjb25zdCBlbHQgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwicHJlXCIpO1xuICBkb2N1bWVudC5nZXRFbGVtZW50QnlJZChcIm91dHB1dFwiKS5hcHBlbmRDaGlsZChlbHQpO1xuICBlbHQuaW5uZXJUZXh0ID0gc3RyaW5naWZ5KHR5cCwgYXJnLCBsb2FkZXIpO1xuICByZXR1cm4gYXJnO1xufVxuXG5mdW5jdGlvbiBhc3NlcnRfbm90X25vbmUoYXJnOiBhbnkpOiBhbnkge1xuICBpZiAoYXJnID09PSAwKVxuICAgIHRocm93IG5ldyBFcnJvcihcIlJVTlRJTUUgRVJST1I6IGNhbm5vdCBwZXJmb3JtIG9wZXJhdGlvbiBvbiBub25lXCIpO1xuICByZXR1cm4gYXJnO1xufVxuXG5mdW5jdGlvbiBnZXRfY29kZV9leGFtcGxlKG5hbWU6IHN0cmluZyk6IHN0cmluZyB7XG4gIGlmIChuYW1lID09PSBcImJhc2ljIGNsYXNzXCIpIHtcbiAgICByZXR1cm4gXCJjbGFzcyBDOlxcblwiICtcbiAgICAgIFwiICAgIGEgOiBpbnQgPSAxXFxuXCIgK1xuICAgICAgXCIgICAgYiA6IGludCA9IDJcXG5cIiArXG4gICAgICBcImMgOiBDID0gTm9uZVxcblwiICtcbiAgICAgIFwiYyA9IEMoKVwiXG4gIH0gZWxzZSBpZiAobmFtZSA9PT0gXCJuZXN0ZWQgY2xhc3NcIikge1xuICAgIHJldHVybiBcImNsYXNzIEUob2JqZWN0KTpcXG5cIiArXG4gICAgICBcIiAgICBhIDogaW50ID0gMVxcblwiICtcbiAgICAgIFwiY2xhc3MgQyhvYmplY3QpOlxcblwiICtcbiAgICAgIFwiICAgIGEgOiBib29sID0gVHJ1ZVxcblwiICtcbiAgICAgIFwiICAgIGUgOiBFID0gTm9uZVxcblwiICtcbiAgICAgIFwiICAgIGRlZiBfX2luaXRfXyhzZWxmOiBDKTpcXG5cIiArXG4gICAgICBcIiAgICAgICAgc2VsZi5lID0gRSgpXFxuXCIgK1xuICAgICAgXCIgICAgZGVmIGQoc2VsZjogQykgLT4gaW50OlxcblwiICtcbiAgICAgIFwiICAgICAgICByZXR1cm4gMVxcblwiICtcbiAgICAgIFwiYyA6IEMgPSBOb25lXFxuXCIgK1xuICAgICAgXCJjID0gQygpXCJcbiAgfSBlbHNlIGlmIChuYW1lID09PSBcImN5Y2xpYyBsaW5rZWRsaXN0IGNsYXNzXCIpIHtcbiAgICByZXR1cm4gYGNsYXNzIEMob2JqZWN0KTpcbiAgbmV4dDpDID0gTm9uZVxuYzE6QyA9IE5vbmVcbmMyOkMgPSBOb25lXG5jMzpDID0gTm9uZVxuYzEgPSBDKClcbmMyID0gQygpXG5jMyA9IEMoKVxuYzEubmV4dCA9IGMyXG5jMi5uZXh0ID0gYzNcbmMzLm5leHQgPSBjMVxuICAgIGBcbiAgfSBlbHNlIGlmIChuYW1lID09PSBcImxpbmtlZGxpc3QgY2xhc3NcIikge1xuICAgIHJldHVybiBgY2xhc3MgQyhvYmplY3QpOlxuICBuZXh0OkMgPSBOb25lXG5jMTpDID0gTm9uZVxuYzI6QyA9IE5vbmVcbmMzOkMgPSBOb25lXG5jMSA9IEMoKVxuYzIgPSBDKClcbmMzID0gQygpXG5jMS5uZXh0ID0gYzJcbmMyLm5leHQgPSBjM1xuICAgIGBcbiAgfVxuXG4gIGVsc2UgaWYgKG5hbWUgPT09IFwidW5pbml0aWFsaXplZCBtZW1iZXIgdmFyaWFibGVcIikge1xuICAgIHJldHVybiBcImNsYXNzIEUob2JqZWN0KTpcXG5cIiArXG4gICAgICBcIiAgICBhIDogaW50ID0gMVxcblwiICtcbiAgICAgIFwiXFxuXCIgK1xuICAgICAgXCJjbGFzcyBDKEUpOlxcblwiICtcbiAgICAgIFwiICAgIGEgOiBpbnQgPSAyXFxuXCIgK1xuICAgICAgXCIgICAgZSA6IEUgPSBOb25lXFxuXCIgK1xuICAgICAgXCIgICAgZGVmIGQoc2VsZjogQykgLT4gaW50OlxcblwiICtcbiAgICAgIFwiICAgICAgICByZXR1cm4gMVxcblwiICtcbiAgICAgIFwiYyA6IEMgPSBOb25lXFxuXCIgK1xuICAgICAgXCJjID0gQygpXCJcbiAgfVxuXG4gIHJldHVybiBcIlwiO1xufVxuLy8gc2V0dXAgY29kZU1pcnJvciBpbnN0YW5jZSBhbmQgZXZlbnRzXG5cbmZ1bmN0aW9uIHdlYlN0YXJ0KCkge1xuICBkb2N1bWVudC5hZGRFdmVudExpc3RlbmVyKFwiRE9NQ29udGVudExvYWRlZFwiLCBhc3luYyBmdW5jdGlvbiAoKSB7XG5cbiAgICAvLyBodHRwczovL2dpdGh1Yi5jb20vbWRuL3dlYmFzc2VtYmx5LWV4YW1wbGVzL2lzc3Vlcy81XG4gICAgdmFyIGNvZGVDb250ZW50OiBzdHJpbmcgfCBBcnJheUJ1ZmZlclxuICAgIGNvbnN0IG1lbW9yeSA9IG5ldyBXZWJBc3NlbWJseS5NZW1vcnkoeyBpbml0aWFsOiAxMCwgbWF4aW11bTogMTAwIH0pO1xuICAgIGNvbnN0IG1lbW9yeU1vZHVsZSA9IGF3YWl0IGZldGNoKCdtZW1vcnkud2FzbScpLnRoZW4ocmVzcG9uc2UgPT5cbiAgICAgIHJlc3BvbnNlLmFycmF5QnVmZmVyKClcbiAgICApLnRoZW4oYnl0ZXMgPT5cbiAgICAgIFdlYkFzc2VtYmx5Lmluc3RhbnRpYXRlKGJ5dGVzLCB7IGpzOiB7IG1lbTogbWVtb3J5IH0gfSlcbiAgICApO1xuICAgIGZ1bmN0aW9uIGluaXRDb2RlTWlycm9yKCkge1xuXG4gICAgICBsZXQgaXNDbGFzc01ldGhvZCA9IGZhbHNlO1xuXG4gICAgICBjb25zdCB1c2VyQ29kZSA9IGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKFwidXNlci1jb2RlXCIpIGFzIEhUTUxUZXh0QXJlYUVsZW1lbnQ7XG4gICAgICBjb25zdCBlZGl0b3JCb3ggPSBDb2RlTWlycm9yLmZyb21UZXh0QXJlYSh1c2VyQ29kZSwge1xuICAgICAgICBtb2RlOiBcInB5dGhvblwiLFxuICAgICAgICB0aGVtZTogXCJkZWZhdWx0XCIsXG4gICAgICAgIGxpbmVOdW1iZXJzOiB0cnVlLFxuICAgICAgICBhdXRvQ2xvc2VCcmFja2V0czogdHJ1ZSxcbiAgICAgICAgbGludDogdHJ1ZSxcbiAgICAgICAgZ3V0dGVyczogW1wiZXJyb3JcIl0sXG4gICAgICAgIGV4dHJhS2V5czoge1xuICAgICAgICAgIFwiQ3RybCtTcGFjZVwiOiBcImF1dG9jb21wbGV0ZVwiLFxuICAgICAgICB9LFxuICAgICAgICBoaW50T3B0aW9uczoge1xuICAgICAgICAgIGFsaWduV2l0aFdvcmQ6IGZhbHNlLFxuICAgICAgICAgIGNvbXBsZXRlU2luZ2xlOiBmYWxzZSxcbiAgICAgICAgfSxcbiAgICAgICAgc2Nyb2xsYmFyU3R5bGU6IFwic2ltcGxlXCIsXG4gICAgICB9KTtcbiAgICAgIGVkaXRvckJveC5vbihcImNoYW5nZVwiLCAoKSA9PiB7XG4gICAgICAgIHVzZXJDb2RlLnZhbHVlID0gZWRpdG9yQm94LmdldFZhbHVlKCk7XG4gICAgICB9KTtcbiAgICAgIGVkaXRvckJveC5vbihcImlucHV0UmVhZFwiLCBmdW5jdGlvbiBvbkNoYW5nZShlZGl0b3IsIGlucHV0KSB7XG4gICAgICAgIGlmIChpbnB1dC50ZXh0WzBdID09PSBcIjtcIiB8fCBpbnB1dC50ZXh0WzBdID09PSBcIiBcIiB8fCBpbnB1dC50ZXh0WzBdID09PSBcIjpcIikge1xuICAgICAgICAgIGlzQ2xhc3NNZXRob2QgPSBmYWxzZTtcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH0gZWxzZSBpZiAoaW5wdXQudGV4dFswXSA9PT0gXCIuXCIgfHwgaXNDbGFzc01ldGhvZCkge1xuICAgICAgICAgIC8vYXV0b2NvbXBsZXRlIGNsYXNzIG1ldGhvZHNcbiAgICAgICAgICBpc0NsYXNzTWV0aG9kID0gdHJ1ZTtcbiAgICAgICAgICBlZGl0b3Iuc2hvd0hpbnQoe1xuICAgICAgICAgICAgaGludDogKCkgPT5cbiAgICAgICAgICAgICAgYXV0b2NvbXBsZXRlSGludChlZGl0b3IsIFtdLCBmdW5jdGlvbiAoZTogYW55LCBjdXI6IGFueSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBlLmdldFRva2VuQXQoY3VyKTtcbiAgICAgICAgICAgICAgfSksXG4gICAgICAgICAgfSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgLy9hdXRvY29tcGxldGUgdmFyaWFibGVzLCBuYW1lcywgdG9wLWxldmVsIGZ1bmN0aW9uc1xuICAgICAgICAgIGVkaXRvci5zaG93SGludCh7XG4gICAgICAgICAgICBoaW50OiAoKSA9PlxuICAgICAgICAgICAgICBhdXRvY29tcGxldGVIaW50KFxuICAgICAgICAgICAgICAgIGVkaXRvcixcbiAgICAgICAgICAgICAgICBkZWZhdWx0X2tleXdvcmRzLmNvbmNhdChkZWZhdWx0X2Z1bmN0aW9ucyksXG4gICAgICAgICAgICAgICAgZnVuY3Rpb24gKGU6IGFueSwgY3VyOiBhbnkpIHtcbiAgICAgICAgICAgICAgICAgIHJldHVybiBlLmdldFRva2VuQXQoY3VyKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICksXG4gICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuXG4gICAgICBlZGl0b3JCb3gub24oXCJrZXlkb3duXCIsIChjbSwgZXZlbnQpID0+IHtcbiAgICAgICAgc3dpdGNoIChldmVudC5jb2RlKSB7XG4gICAgICAgICAgLy9yZXNldCBpc0NsYXNzTWV0aG9kIHZhcmlhYmxlIGJhc2VkIG9uIGVudGVyIG9yIHNwYWNlIG9yIGJhY2tzcGFjZVxuICAgICAgICAgIGNhc2UgXCJFbnRlclwiOlxuICAgICAgICAgICAgaXNDbGFzc01ldGhvZCA9IGZhbHNlO1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgIGNhc2UgXCJTcGFjZVwiOlxuICAgICAgICAgICAgaXNDbGFzc01ldGhvZCA9IGZhbHNlO1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgIGNhc2UgXCJCYWNrc3BhY2VcIjpcbiAgICAgICAgICAgIGlzQ2xhc3NNZXRob2QgPSBmYWxzZTtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgfSk7XG5cbiAgICAgIHJldHVybiBlZGl0b3JCb3g7XG4gICAgfVxuICAgIGNvbnN0IGVkaXRvckJveCA9IGluaXRDb2RlTWlycm9yKCk7XG5cbiAgICBjb25zdCBsb2FkZXIgPSBtZW1vcnlNb2R1bGUuaW5zdGFuY2UuZXhwb3J0cy5sb2FkO1xuICAgIHZhciBpbXBvcnRPYmplY3QgPSB7XG4gICAgICBpbXBvcnRzOiB7XG4gICAgICAgIGFzc2VydF9ub3Rfbm9uZTogKGFyZzogYW55KSA9PiBhc3NlcnRfbm90X25vbmUoYXJnKSxcbiAgICAgICAgcHJpbnRfbnVtOiAoYXJnOiBudW1iZXIpID0+IHByaW50KE5VTSwgYXJnLCBsb2FkZXIpLFxuICAgICAgICBwcmludF9ib29sOiAoYXJnOiBudW1iZXIpID0+IHByaW50KEJPT0wsIGFyZywgbnVsbCksXG4gICAgICAgIHByaW50X25vbmU6IChhcmc6IG51bWJlcikgPT4gcHJpbnQoTk9ORSwgYXJnLCBudWxsKSxcbiAgICAgICAgYWJzOiAgKGFyZzogbnVtYmVyKSA9PiBidWlsdGluX2JpZ251bShbYXJnXSwgYmlnTWF0aC5hYnMsIG1lbW9yeU1vZHVsZS5pbnN0YW5jZS5leHBvcnRzKSxcbiAgICAgICAgbWluOiAoYXJnMTogbnVtYmVyLCBhcmcyOiBudW1iZXIpID0+IGJ1aWx0aW5fYmlnbnVtKFthcmcxLCBhcmcyXSwgYmlnTWF0aC5taW4sIG1lbW9yeU1vZHVsZS5pbnN0YW5jZS5leHBvcnRzKSxcbiAgICAgICAgbWF4OiAoYXJnMTogbnVtYmVyLCBhcmcyOiBudW1iZXIpID0+IGJ1aWx0aW5fYmlnbnVtKFthcmcxLCBhcmcyXSwgYmlnTWF0aC5tYXgsIG1lbW9yeU1vZHVsZS5pbnN0YW5jZS5leHBvcnRzKSxcbiAgICAgICAgcG93OiAoYXJnMTogbnVtYmVyLCBhcmcyOiBudW1iZXIpID0+IGJ1aWx0aW5fYmlnbnVtKFthcmcxLCBhcmcyXSwgYmlnTWF0aC5wb3csIG1lbW9yeU1vZHVsZS5pbnN0YW5jZS5leHBvcnRzKSxcbiAgICAgICAgJGFkZDogKGFyZzE6IG51bWJlciwgYXJnMjogbnVtYmVyKSA9PiBiaW5vcF9iaWdudW0oW2FyZzEsIGFyZzJdLCBiaWdNYXRoLmFkZCwgbWVtb3J5TW9kdWxlLmluc3RhbmNlLmV4cG9ydHMpLFxuICAgICAgICAkc3ViOiAoYXJnMTogbnVtYmVyLCBhcmcyOiBudW1iZXIpID0+IGJpbm9wX2JpZ251bShbYXJnMSwgYXJnMl0sIGJpZ01hdGguc3ViLCBtZW1vcnlNb2R1bGUuaW5zdGFuY2UuZXhwb3J0cyksXG4gICAgICAgICRtdWw6IChhcmcxOiBudW1iZXIsIGFyZzI6IG51bWJlcikgPT4gYmlub3BfYmlnbnVtKFthcmcxLCBhcmcyXSwgYmlnTWF0aC5tdWwsIG1lbW9yeU1vZHVsZS5pbnN0YW5jZS5leHBvcnRzKSxcbiAgICAgICAgJGRpdjogKGFyZzE6IG51bWJlciwgYXJnMjogbnVtYmVyKSA9PiBiaW5vcF9iaWdudW0oW2FyZzEsIGFyZzJdLCBiaWdNYXRoLmRpdiwgbWVtb3J5TW9kdWxlLmluc3RhbmNlLmV4cG9ydHMpLFxuICAgICAgICAkbW9kOiAoYXJnMTogbnVtYmVyLCBhcmcyOiBudW1iZXIpID0+IGJpbm9wX2JpZ251bShbYXJnMSwgYXJnMl0sIGJpZ01hdGgubW9kLCBtZW1vcnlNb2R1bGUuaW5zdGFuY2UuZXhwb3J0cyksXG4gICAgICAgICRlcTogKGFyZzE6IG51bWJlciwgYXJnMjogbnVtYmVyKSA9PiBiaW5vcF9jb21wX2JpZ251bShbYXJnMSwgYXJnMl0sIGJpZ01hdGguZXEsIG1lbW9yeU1vZHVsZS5pbnN0YW5jZS5leHBvcnRzKSxcbiAgICAgICAgJG5lcTogKGFyZzE6IG51bWJlciwgYXJnMjogbnVtYmVyKSA9PiBiaW5vcF9jb21wX2JpZ251bShbYXJnMSwgYXJnMl0sIGJpZ01hdGgubmVxLCBtZW1vcnlNb2R1bGUuaW5zdGFuY2UuZXhwb3J0cyksXG4gICAgICAgICRsdGU6IChhcmcxOiBudW1iZXIsIGFyZzI6IG51bWJlcikgPT4gYmlub3BfY29tcF9iaWdudW0oW2FyZzEsIGFyZzJdLCBiaWdNYXRoLmx0ZSwgbWVtb3J5TW9kdWxlLmluc3RhbmNlLmV4cG9ydHMpLFxuICAgICAgICAkZ3RlOiAoYXJnMTogbnVtYmVyLCBhcmcyOiBudW1iZXIpID0+IGJpbm9wX2NvbXBfYmlnbnVtKFthcmcxLCBhcmcyXSwgYmlnTWF0aC5ndGUsIG1lbW9yeU1vZHVsZS5pbnN0YW5jZS5leHBvcnRzKSxcbiAgICAgICAgJGx0OiAoYXJnMTogbnVtYmVyLCBhcmcyOiBudW1iZXIpID0+IGJpbm9wX2NvbXBfYmlnbnVtKFthcmcxLCBhcmcyXSwgYmlnTWF0aC5sdCwgbWVtb3J5TW9kdWxlLmluc3RhbmNlLmV4cG9ydHMpLFxuICAgICAgICAkZ3Q6IChhcmcxOiBudW1iZXIsIGFyZzI6IG51bWJlcikgPT4gYmlub3BfY29tcF9iaWdudW0oW2FyZzEsIGFyZzJdLCBiaWdNYXRoLmd0LCBtZW1vcnlNb2R1bGUuaW5zdGFuY2UuZXhwb3J0cyksXG4gICAgICB9LFxuICAgICAgZXJyb3JzOiBpbXBvcnRPYmplY3RFcnJvcnMsXG4gICAgICBsaWJtZW1vcnk6IG1lbW9yeU1vZHVsZS5pbnN0YW5jZS5leHBvcnRzLFxuICAgICAgbWVtb3J5X3ZhbHVlczogbWVtb3J5LFxuICAgICAganM6IHsgbWVtb3J5OiBtZW1vcnkgfVxuICAgIH07XG4gICAgdmFyIHJlcGwgPSBuZXcgQmFzaWNSRVBMKGltcG9ydE9iamVjdCk7XG5cbiAgICBmdW5jdGlvbiByZW5kZXJSZXN1bHQocmVzdWx0IDogVmFsdWU8QW5ub3RhdGlvbj4pIDogdm9pZCB7XG4gICAgICBpZihyZXN1bHQgPT09IHVuZGVmaW5lZCkgeyBjb25zb2xlLmxvZyhcInNraXBcIik7IHJldHVybjsgfVxuICAgICAgaWYgKHJlc3VsdC50YWcgPT09IFwibm9uZVwiKSByZXR1cm47XG4gICAgICBjb25zdCBlbHQgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwicHJlXCIpO1xuICAgICAgZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoXCJvdXRwdXRcIikuYXBwZW5kQ2hpbGQoZWx0KTtcbiAgICAgIHN3aXRjaCAocmVzdWx0LnRhZykge1xuICAgICAgICBjYXNlIFwibnVtXCI6XG4gICAgICAgICAgZWx0LmlubmVyVGV4dCA9IFN0cmluZyhyZXN1bHQudmFsdWUpO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIFwiYm9vbFwiOlxuICAgICAgICAgIGVsdC5pbm5lckhUTUwgPSAocmVzdWx0LnZhbHVlKSA/IFwiVHJ1ZVwiIDogXCJGYWxzZVwiO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIFwib2JqZWN0XCI6XG4gICAgICAgICAgLy8gZWx0LmlubmVySFRNTCA9IGAke3Jlc3VsdC5uYW1lfSBvYmplY3QgYXQgJHtyZXN1bHQuYWRkcmVzc31gXG4gICAgICAgICAgZWx0LmlubmVySFRNTCA9IHByaW50X2NsYXNzKG1lbW9yeSwgcmVwbCwgcmVzdWx0LmFkZHJlc3MsIHJlc3VsdC5uYW1lLCAwLCBuZXcgTWFwKCksIDEsIGxvYWRlcikuam9pbihcIlxcblwiKTtcbiAgICAgICAgICBicmVha1xuICAgICAgICBkZWZhdWx0OiB0aHJvdyBuZXcgRXJyb3IoYENvdWxkIG5vdCByZW5kZXIgdmFsdWU6ICR7cmVzdWx0fWApO1xuICAgICAgfVxuICAgIH1cblxuICAgIGZ1bmN0aW9uIHJlbmRlckVycm9yKHJlc3VsdCA6IGFueSkgOiB2b2lkIHtcbiAgICAgIC8vIG9ubHkgYFR5cGVDaGVja0Vycm9yYCBoYXMgYGdldEFgIGFuZCBgZ2V0RXJyTXNnYFxuICAgICAgaWYgKHJlc3VsdCBpbnN0YW5jZW9mIFR5cGVDaGVja0Vycm9yKSB7XG4gICAgICAgIGNvbnNvbGUubG9nKHJlc3VsdC5nZXRBKCkpOyAvLyBjb3VsZCBiZSB1bmRlZmluZWQgaWYgbm8gQW5ub3RhdGlvbiBpbmZvcm1hdGlvbiBpcyBwYXNzZWQgdG8gdGhlIGNvbnN0cnVjdG9yIG9mIFR5cGVDaGVja0Vycm9yXG4gICAgICAgIGNvbnNvbGUubG9nKHJlc3VsdC5nZXRFcnJNc2coKSk7XG4gICAgICB9XG5cbiAgICAgIGNvbnN0IGVsdCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJwcmVcIik7XG4gICAgICBkb2N1bWVudC5nZXRFbGVtZW50QnlJZChcIm91dHB1dFwiKS5hcHBlbmRDaGlsZChlbHQpO1xuICAgICAgZWx0LnNldEF0dHJpYnV0ZShcInN0eWxlXCIsIFwiY29sb3I6IHJlZFwiKTtcbiAgICAgIGVsdC5pbm5lclRleHQgPSBTdHJpbmcocmVzdWx0KTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBzZXR1cFJlcGwoKSB7XG4gICAgICBkb2N1bWVudC5nZXRFbGVtZW50QnlJZChcIm91dHB1dFwiKS5pbm5lckhUTUwgPSBcIlwiO1xuICAgICAgY29uc3QgcmVwbENvZGVFbGVtZW50ID0gZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoXCJuZXh0LWNvZGVcIikgYXMgSFRNTFRleHRBcmVhRWxlbWVudDtcbiAgICAgIHJlcGxDb2RlRWxlbWVudC5hZGRFdmVudExpc3RlbmVyKFwia2V5cHJlc3NcIiwgKGUpID0+IHtcblxuICAgICAgICBpZiAoZS5zaGlmdEtleSAmJiBlLmtleSA9PT0gXCJFbnRlclwiKSB7XG4gICAgICAgIH0gZWxzZSBpZiAoZS5rZXkgPT09IFwiRW50ZXJcIikge1xuICAgICAgICAgIGUucHJldmVudERlZmF1bHQoKTtcbiAgICAgICAgICBjb25zdCBvdXRwdXQgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwiZGl2XCIpO1xuICAgICAgICAgIGNvbnN0IHByb21wdCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJzcGFuXCIpO1xuICAgICAgICAgIHByb21wdC5pbm5lclRleHQgPSBcIsK7XCI7XG4gICAgICAgICAgb3V0cHV0LmFwcGVuZENoaWxkKHByb21wdCk7XG4gICAgICAgICAgY29uc3QgZWx0ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcInRleHRhcmVhXCIpO1xuICAgICAgICAgIC8vIGVsdC50eXBlID0gXCJ0ZXh0XCI7XG4gICAgICAgICAgZWx0LmRpc2FibGVkID0gdHJ1ZTtcbiAgICAgICAgICBlbHQuY2xhc3NOYW1lID0gXCJyZXBsLWNvZGVcIjtcbiAgICAgICAgICBvdXRwdXQuYXBwZW5kQ2hpbGQoZWx0KTtcbiAgICAgICAgICBkb2N1bWVudC5nZXRFbGVtZW50QnlJZChcIm91dHB1dFwiKS5hcHBlbmRDaGlsZChvdXRwdXQpO1xuICAgICAgICAgIGNvbnN0IHNvdXJjZSA9IHJlcGxDb2RlRWxlbWVudC52YWx1ZTtcbiAgICAgICAgICBlbHQudmFsdWUgPSBzb3VyY2U7XG4gICAgICAgICAgcmVwbENvZGVFbGVtZW50LnZhbHVlID0gXCJcIjtcbiAgICAgICAgICByZXBsLnJ1bihzb3VyY2UpLnRoZW4oKHIpID0+IHtcbiAgICAgICAgICAgIHJlbmRlclJlc3VsdChyKTtcbiAgICAgICAgICAgIHByaW50TWVtKCk7XG4gICAgICAgICAgICBjb25zb2xlLmxvZyhcInJ1biBmaW5pc2hlZFwiKVxuICAgICAgICAgIH0pXG4gICAgICAgICAgICAuY2F0Y2goKGUpID0+IHsgcmVuZGVyRXJyb3IoZSk7IGNvbnNvbGUubG9nKFwicnVuIGZhaWxlZFwiLCBlKSB9KTs7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIHJlc2V0UmVwbCgpIHtcbiAgICAgIGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKFwib3V0cHV0XCIpLmlubmVySFRNTCA9IFwiXCI7XG4gICAgfVxuICAgIGZ1bmN0aW9uIHByaW50TWVtKCkge1xuICAgICAgdmFyIG1lbSA9IG5ldyBVaW50MzJBcnJheShtZW1vcnkuYnVmZmVyKTtcbiAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgMjU7IGkrKykge1xuICAgICAgICBjb25zb2xlLmxvZyhtZW1baV0pO1xuICAgICAgfVxuICAgICAgLy8gbWVtLmZvckVhY2goKHgpID0+IGNvbnNvbGUubG9nKHgpKTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBzZXR1cENvZGVFeGFtcGxlKCkge1xuICAgICAgY29uc3Qgc2VsID0gZG9jdW1lbnQucXVlcnlTZWxlY3RvcihcIiNleGFtcGxlU2VsZWN0XCIpIGFzIEhUTUxTZWxlY3RFbGVtZW50O1xuICAgICAgY29uc29sZS5sb2coJ2VkaXRvckJveDogJywgZWRpdG9yQm94KTtcbiAgICAgIHNlbC5hZGRFdmVudExpc3RlbmVyKFwiY2hhbmdlXCIsIChlKSA9PiB7XG4gICAgICAgIGNvbnN0IGNvZGUgPSBnZXRfY29kZV9leGFtcGxlKHNlbC52YWx1ZSk7XG4gICAgICAgIGlmIChjb2RlICE9PSBcIlwiKSB7XG4gICAgICAgICAgLy8gY29uc3QgdXNlcmNvZGUgPSBkb2N1bWVudC5nZXRFbGVtZW50QnlJZChcInVzZXItY29kZVwiKSBhcyBIVE1MVGV4dEFyZWFFbGVtZW50O1xuICAgICAgICAgIGVkaXRvckJveC5zZXRWYWx1ZShjb2RlKTtcbiAgICAgICAgfVxuICAgICAgfSlcbiAgICB9XG4gICAgZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoXCJjbGVhclwiKS5hZGRFdmVudExpc3RlbmVyKFwiY2xpY2tcIiwgZnVuY3Rpb24gKGUpIHtcbiAgICAgIC8vcmVwbCBjb2RlIGRpc2FwcGVyIChvbiB0aGUgcmlnaHQgc2lkZSlcbiAgICAgIHJlc2V0UmVwbCgpXG5cbiAgICAgIC8vcmVzZXQgZW52aXJvbm1lbnRcbiAgICAgIHJlcGwgPSBuZXcgQmFzaWNSRVBMKGltcG9ydE9iamVjdClcblxuICAgICAgLy9jbGVhciBlZGl0b3IgY29kZVxuICAgICAgdmFyIGVsZW1lbnQgPSBkb2N1bWVudC5xdWVyeVNlbGVjdG9yKFwiLkNvZGVNaXJyb3JcIikgYXMgYW55XG4gICAgICB2YXIgZWRpdG9yID0gZWxlbWVudC5Db2RlTWlycm9yXG4gICAgICBlZGl0b3Iuc2V0VmFsdWUoXCJcIilcbiAgICAgIGVkaXRvci5jbGVhckhpc3RvcnkoKVxuXG4gICAgfSlcblxuICAgIGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKFwibG9hZFwiKS5hZGRFdmVudExpc3RlbmVyKFwiY2hhbmdlXCIsIGZ1bmN0aW9uIChlKSB7XG4gICAgICByZXNldFJlcGwoKVxuICAgICAgcmVwbCA9IG5ldyBCYXNpY1JFUEwoaW1wb3J0T2JqZWN0KVxuXG4gICAgICB2YXIgaW5wdXQ6IGFueSA9IGUudGFyZ2V0XG4gICAgICB2YXIgcmVhZGVyID0gbmV3IEZpbGVSZWFkZXIoKVxuXG4gICAgICB2YXIgZWRpdG9yQm94ID0gZG9jdW1lbnQucXVlcnlTZWxlY3RvcihcIi5Db2RlTWlycm9yXCIpIGFzIGFueTtcbiAgICAgIGNvbnN0IGNvZGVOb2RlID0gZWRpdG9yQm94LkNvZGVNaXJyb3I7XG5cbiAgICAgIGNvZGVOb2RlLnNldFZhbHVlKFwiXCIpXG4gICAgICByZWFkZXIub25sb2FkID0gZnVuY3Rpb24gKCkge1xuXG4gICAgICAgIGlmIChjb2RlTm9kZS52YWx1ZSAhPSBcIlwiKSB7XG4gICAgICAgICAgY29kZU5vZGUuc2V0VmFsdWUoXCJcIilcbiAgICAgICAgICBjb2RlTm9kZS5zZXRWYWx1ZShyZWFkZXIucmVzdWx0KVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGNvZGVOb2RlLnNldFZhbHVlKHJlYWRlci5yZXN1bHQpXG4gICAgICAgIH1cblxuICAgICAgfVxuICAgICAgcmVhZGVyLnJlYWRBc1RleHQoaW5wdXQuZmlsZXNbMF0pXG5cbiAgICB9KVxuICAgIC8vIHdpbmRvdy5vbmxvYWQgPSBmdW5jdGlvbihlOiBFdmVudCl7XG4gICAgLy8gICB2YXIgZiA9IGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKFwibG9hZFwiKVxuICAgIC8vICAgdmFyIHJlYWRlciA9IG5ldyBGaWxlUmVhZGVyKCk7XG4gICAgLy8gICB2YXIgcmVhZGVyQ29udGVudFxuICAgIC8vICAgZi5vbmNoYW5nZSA9IGZ1bmN0aW9uKCl7XG4gICAgLy8gICAgIHJlYWRlckNvbnRlbnQgPSByZWFkZXIucmVzdWx0XG4gICAgLy8gICB9XG4gICAgLy8gICB2YXIgY29udGVudFRvTG9hZCA9IHJlYWRlckNvbnRlbnQgYXMgc3RyaW5nXG5cbiAgICAvLyAgIHZhciBjb2RlTm9kZT0gZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoXCJ1c2VyLWNvZGVcIikgYXMgSFRNTFRleHRBcmVhRWxlbWVudFxuICAgIC8vICAgY29kZU5vZGUudmFsdWUgPSBjb250ZW50VG9Mb2FkXG4gICAgLy8gfVxuXG4gICAgZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoXCJzYXZlXCIpLmFkZEV2ZW50TGlzdGVuZXIoXCJjbGlja1wiLCBmdW5jdGlvbiAoZSkge1xuICAgICAgdmFyIEZpbGVTYXZlciA9IHJlcXVpcmUoXCJmaWxlLXNhdmVyXCIpO1xuICAgICAgdmFyIHRpdGxlID0gcHJvbXB0KFwicGxlYXNlIGlucHV0IGZpbGUgbmFtZTogXCIsIFwidW50aXRsZWRcIilcblxuICAgICAgLy9JZiB3ZSBjbGljayBcImNhbmNlbFwiLCB0aGUgdGl0bGUgcmV0dXJuZWQgaXMgbnVsbFxuICAgICAgaWYgKHRpdGxlICE9IG51bGwpIHtcbiAgICAgICAgdmFyIGNvZGVOb2RlID0gZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoXCJ1c2VyLWNvZGVcIikgYXMgSFRNTFRleHRBcmVhRWxlbWVudFxuICAgICAgICB2YXIgY29kZSA9IGNvZGVOb2RlLnZhbHVlXG4gICAgICAgIHZhciBibG9iID0gbmV3IEJsb2IoW2NvZGVdLCB7IHR5cGU6IFwidGV4dC9wbGFpbjtjaGFyc2V0PXV0Zi04XCIgfSk7XG4gICAgICAgIEZpbGVTYXZlci5zYXZlQXMoYmxvYiwgdGl0bGUpXG4gICAgICB9XG4gICAgfSlcblxuICAgIGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKFwicnVuXCIpLmFkZEV2ZW50TGlzdGVuZXIoXCJjbGlja1wiLCBmdW5jdGlvbiAoZSkge1xuICAgICAgcmVwbCA9IG5ldyBCYXNpY1JFUEwoaW1wb3J0T2JqZWN0KTtcbiAgICAgIGNvbnN0IHNvdXJjZSA9IGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKFwidXNlci1jb2RlXCIpIGFzIEhUTUxUZXh0QXJlYUVsZW1lbnQ7XG4gICAgICByZXNldFJlcGwoKTtcbiAgICAgIHJlcGwucnVuKHNvdXJjZS52YWx1ZSkudGhlbigocikgPT4geyByZW5kZXJSZXN1bHQocik7IGNvbnNvbGUubG9nKFwicnVuIGZpbmlzaGVkXCIpIH0pXG4gICAgICAgIC5jYXRjaCgoZSkgPT4geyByZW5kZXJFcnJvcihlKTsgY29uc29sZS5sb2coXCJydW4gZmFpbGVkXCIsIGUpIH0pOztcbiAgICB9KTtcbiAgICBzZXR1cFJlcGwoKTtcbiAgICBzZXR1cENvZGVFeGFtcGxlKCk7XG4gIH0pO1xufVxuXG53ZWJTdGFydCgpO1xuIiwibW9kdWxlLmV4cG9ydHMgPSB3YWJ0OyIsIid1c2Ugc3RyaWN0JztcblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsICdfX2VzTW9kdWxlJywgeyB2YWx1ZTogdHJ1ZSB9KTtcblxuLy8gRklYTUUgcHJvZmlsZSBhZGRpbmcgYSBwZXItVHJlZSBUcmVlTm9kZSBjYWNoZSwgdmFsaWRhdGluZyBpdCBieVxuLy8gcGFyZW50IHBvaW50ZXJcbi8vLyBUaGUgZGVmYXVsdCBtYXhpbXVtIGxlbmd0aCBvZiBhIGBUcmVlQnVmZmVyYCBub2RlICgxMDI0KS5cbmNvbnN0IERlZmF1bHRCdWZmZXJMZW5ndGggPSAxMDI0O1xubGV0IG5leHRQcm9wSUQgPSAwO1xuY2xhc3MgUmFuZ2Uge1xuICAgIGNvbnN0cnVjdG9yKGZyb20sIHRvKSB7XG4gICAgICAgIHRoaXMuZnJvbSA9IGZyb207XG4gICAgICAgIHRoaXMudG8gPSB0bztcbiAgICB9XG59XG4vLy8gRWFjaCBbbm9kZSB0eXBlXSgjY29tbW9uLk5vZGVUeXBlKSBvciBbaW5kaXZpZHVhbCB0cmVlXSgjY29tbW9uLlRyZWUpXG4vLy8gY2FuIGhhdmUgbWV0YWRhdGEgYXNzb2NpYXRlZCB3aXRoIGl0IGluIHByb3BzLiBJbnN0YW5jZXMgb2YgdGhpc1xuLy8vIGNsYXNzIHJlcHJlc2VudCBwcm9wIG5hbWVzLlxuY2xhc3MgTm9kZVByb3Age1xuICAgIC8vLyBDcmVhdGUgYSBuZXcgbm9kZSBwcm9wIHR5cGUuXG4gICAgY29uc3RydWN0b3IoY29uZmlnID0ge30pIHtcbiAgICAgICAgdGhpcy5pZCA9IG5leHRQcm9wSUQrKztcbiAgICAgICAgdGhpcy5wZXJOb2RlID0gISFjb25maWcucGVyTm9kZTtcbiAgICAgICAgdGhpcy5kZXNlcmlhbGl6ZSA9IGNvbmZpZy5kZXNlcmlhbGl6ZSB8fCAoKCkgPT4ge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiVGhpcyBub2RlIHR5cGUgZG9lc24ndCBkZWZpbmUgYSBkZXNlcmlhbGl6ZSBmdW5jdGlvblwiKTtcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIC8vLyBUaGlzIGlzIG1lYW50IHRvIGJlIHVzZWQgd2l0aFxuICAgIC8vLyBbYE5vZGVTZXQuZXh0ZW5kYF0oI2NvbW1vbi5Ob2RlU2V0LmV4dGVuZCkgb3JcbiAgICAvLy8gW2BMUlBhcnNlci5jb25maWd1cmVgXSgjbHIuUGFyc2VyQ29uZmlnLnByb3BzKSB0byBjb21wdXRlXG4gICAgLy8vIHByb3AgdmFsdWVzIGZvciBlYWNoIG5vZGUgdHlwZSBpbiB0aGUgc2V0LiBUYWtlcyBhIFttYXRjaFxuICAgIC8vLyBvYmplY3RdKCNjb21tb24uTm9kZVR5cGVebWF0Y2gpIG9yIGZ1bmN0aW9uIHRoYXQgcmV0dXJucyB1bmRlZmluZWRcbiAgICAvLy8gaWYgdGhlIG5vZGUgdHlwZSBkb2Vzbid0IGdldCB0aGlzIHByb3AsIGFuZCB0aGUgcHJvcCdzIHZhbHVlIGlmXG4gICAgLy8vIGl0IGRvZXMuXG4gICAgYWRkKG1hdGNoKSB7XG4gICAgICAgIGlmICh0aGlzLnBlck5vZGUpXG4gICAgICAgICAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcihcIkNhbid0IGFkZCBwZXItbm9kZSBwcm9wcyB0byBub2RlIHR5cGVzXCIpO1xuICAgICAgICBpZiAodHlwZW9mIG1hdGNoICE9IFwiZnVuY3Rpb25cIilcbiAgICAgICAgICAgIG1hdGNoID0gTm9kZVR5cGUubWF0Y2gobWF0Y2gpO1xuICAgICAgICByZXR1cm4gKHR5cGUpID0+IHtcbiAgICAgICAgICAgIGxldCByZXN1bHQgPSBtYXRjaCh0eXBlKTtcbiAgICAgICAgICAgIHJldHVybiByZXN1bHQgPT09IHVuZGVmaW5lZCA/IG51bGwgOiBbdGhpcywgcmVzdWx0XTtcbiAgICAgICAgfTtcbiAgICB9XG59XG4vLy8gUHJvcCB0aGF0IGlzIHVzZWQgdG8gZGVzY3JpYmUgbWF0Y2hpbmcgZGVsaW1pdGVycy4gRm9yIG9wZW5pbmdcbi8vLyBkZWxpbWl0ZXJzLCB0aGlzIGhvbGRzIGFuIGFycmF5IG9mIG5vZGUgbmFtZXMgKHdyaXR0ZW4gYXMgYVxuLy8vIHNwYWNlLXNlcGFyYXRlZCBzdHJpbmcgd2hlbiBkZWNsYXJpbmcgdGhpcyBwcm9wIGluIGEgZ3JhbW1hcilcbi8vLyBmb3IgdGhlIG5vZGUgdHlwZXMgb2YgY2xvc2luZyBkZWxpbWl0ZXJzIHRoYXQgbWF0Y2ggaXQuXG5Ob2RlUHJvcC5jbG9zZWRCeSA9IG5ldyBOb2RlUHJvcCh7IGRlc2VyaWFsaXplOiBzdHIgPT4gc3RyLnNwbGl0KFwiIFwiKSB9KTtcbi8vLyBUaGUgaW52ZXJzZSBvZiBbYGNsb3NlZEJ5YF0oI2NvbW1vbi5Ob2RlUHJvcF5jbG9zZWRCeSkuIFRoaXMgaXNcbi8vLyBhdHRhY2hlZCB0byBjbG9zaW5nIGRlbGltaXRlcnMsIGhvbGRpbmcgYW4gYXJyYXkgb2Ygbm9kZSBuYW1lc1xuLy8vIG9mIHR5cGVzIG9mIG1hdGNoaW5nIG9wZW5pbmcgZGVsaW1pdGVycy5cbk5vZGVQcm9wLm9wZW5lZEJ5ID0gbmV3IE5vZGVQcm9wKHsgZGVzZXJpYWxpemU6IHN0ciA9PiBzdHIuc3BsaXQoXCIgXCIpIH0pO1xuLy8vIFVzZWQgdG8gYXNzaWduIG5vZGUgdHlwZXMgdG8gZ3JvdXBzIChmb3IgZXhhbXBsZSwgYWxsIG5vZGVcbi8vLyB0eXBlcyB0aGF0IHJlcHJlc2VudCBhbiBleHByZXNzaW9uIGNvdWxkIGJlIHRhZ2dlZCB3aXRoIGFuXG4vLy8gYFwiRXhwcmVzc2lvblwiYCBncm91cCkuXG5Ob2RlUHJvcC5ncm91cCA9IG5ldyBOb2RlUHJvcCh7IGRlc2VyaWFsaXplOiBzdHIgPT4gc3RyLnNwbGl0KFwiIFwiKSB9KTtcbi8vLyBUaGUgaGFzaCBvZiB0aGUgW2NvbnRleHRdKCNsci5Db250ZXh0VHJhY2tlci5jb25zdHJ1Y3Rvcilcbi8vLyB0aGF0IHRoZSBub2RlIHdhcyBwYXJzZWQgaW4sIGlmIGFueS4gVXNlZCB0byBsaW1pdCByZXVzZSBvZlxuLy8vIGNvbnRleHR1YWwgbm9kZXMuXG5Ob2RlUHJvcC5jb250ZXh0SGFzaCA9IG5ldyBOb2RlUHJvcCh7IHBlck5vZGU6IHRydWUgfSk7XG4vLy8gVGhlIGRpc3RhbmNlIGJleW9uZCB0aGUgZW5kIG9mIHRoZSBub2RlIHRoYXQgdGhlIHRva2VuaXplclxuLy8vIGxvb2tlZCBhaGVhZCBmb3IgYW55IG9mIHRoZSB0b2tlbnMgaW5zaWRlIHRoZSBub2RlLiAoVGhlIExSXG4vLy8gcGFyc2VyIG9ubHkgc3RvcmVzIHRoaXMgd2hlbiBpdCBpcyBsYXJnZXIgdGhhbiAyNSwgZm9yXG4vLy8gZWZmaWNpZW5jeSByZWFzb25zLilcbk5vZGVQcm9wLmxvb2tBaGVhZCA9IG5ldyBOb2RlUHJvcCh7IHBlck5vZGU6IHRydWUgfSk7XG4vLy8gVGhpcyBwZXItbm9kZSBwcm9wIGlzIHVzZWQgdG8gcmVwbGFjZSBhIGdpdmVuIG5vZGUsIG9yIHBhcnQgb2YgYVxuLy8vIG5vZGUsIHdpdGggYW5vdGhlciB0cmVlLiBUaGlzIGlzIHVzZWZ1bCB0byBpbmNsdWRlIHRyZWVzIGZyb21cbi8vLyBkaWZmZXJlbnQgbGFuZ3VhZ2VzLlxuTm9kZVByb3AubW91bnRlZCA9IG5ldyBOb2RlUHJvcCh7IHBlck5vZGU6IHRydWUgfSk7XG4vLy8gQSBtb3VudGVkIHRyZWUsIHdoaWNoIGNhbiBiZSBbc3RvcmVkXSgjY29tbW9uLk5vZGVQcm9wXm1vdW50ZWQpIG9uXG4vLy8gYSB0cmVlIG5vZGUgdG8gaW5kaWNhdGUgdGhhdCBwYXJ0cyBvZiBpdHMgY29udGVudCBhcmVcbi8vLyByZXByZXNlbnRlZCBieSBhbm90aGVyIHRyZWUuXG5jbGFzcyBNb3VudGVkVHJlZSB7XG4gICAgY29uc3RydWN0b3IoXG4gICAgLy8vIFRoZSBpbm5lciB0cmVlLlxuICAgIHRyZWUsIFxuICAgIC8vLyBJZiB0aGlzIGlzIG51bGwsIHRoaXMgdHJlZSByZXBsYWNlcyB0aGUgZW50aXJlIG5vZGUgKGl0IHdpbGxcbiAgICAvLy8gYmUgaW5jbHVkZWQgaW4gdGhlIHJlZ3VsYXIgaXRlcmF0aW9uIGluc3RlYWQgb2YgaXRzIGhvc3RcbiAgICAvLy8gbm9kZSkuIElmIG5vdCwgb25seSB0aGUgZ2l2ZW4gcmFuZ2VzIGFyZSBjb25zaWRlcmVkIHRvIGJlXG4gICAgLy8vIGNvdmVyZWQgYnkgdGhpcyB0cmVlLiBUaGlzIGlzIHVzZWQgZm9yIHRyZWVzIHRoYXQgYXJlIG1peGVkIGluXG4gICAgLy8vIGEgd2F5IHRoYXQgaXNuJ3Qgc3RyaWN0bHkgaGllcmFyY2hpY2FsLiBTdWNoIG1vdW50ZWQgdHJlZXMgYXJlXG4gICAgLy8vIG9ubHkgZW50ZXJlZCBieSBbYHJlc29sdmVJbm5lcmBdKCNjb21tb24uVHJlZS5yZXNvbHZlSW5uZXIpXG4gICAgLy8vIGFuZCBbYGVudGVyYF0oI2NvbW1vbi5TeW50YXhOb2RlLmVudGVyKS5cbiAgICBvdmVybGF5LCBcbiAgICAvLy8gVGhlIHBhcnNlciB1c2VkIHRvIGNyZWF0ZSB0aGlzIHN1YnRyZWUuXG4gICAgcGFyc2VyKSB7XG4gICAgICAgIHRoaXMudHJlZSA9IHRyZWU7XG4gICAgICAgIHRoaXMub3ZlcmxheSA9IG92ZXJsYXk7XG4gICAgICAgIHRoaXMucGFyc2VyID0gcGFyc2VyO1xuICAgIH1cbn1cbmNvbnN0IG5vUHJvcHMgPSBPYmplY3QuY3JlYXRlKG51bGwpO1xuLy8vIEVhY2ggbm9kZSBpbiBhIHN5bnRheCB0cmVlIGhhcyBhIG5vZGUgdHlwZSBhc3NvY2lhdGVkIHdpdGggaXQuXG5jbGFzcyBOb2RlVHlwZSB7XG4gICAgLy8vIEBpbnRlcm5hbFxuICAgIGNvbnN0cnVjdG9yKFxuICAgIC8vLyBUaGUgbmFtZSBvZiB0aGUgbm9kZSB0eXBlLiBOb3QgbmVjZXNzYXJpbHkgdW5pcXVlLCBidXQgaWYgdGhlXG4gICAgLy8vIGdyYW1tYXIgd2FzIHdyaXR0ZW4gcHJvcGVybHksIGRpZmZlcmVudCBub2RlIHR5cGVzIHdpdGggdGhlXG4gICAgLy8vIHNhbWUgbmFtZSB3aXRoaW4gYSBub2RlIHNldCBzaG91bGQgcGxheSB0aGUgc2FtZSBzZW1hbnRpY1xuICAgIC8vLyByb2xlLlxuICAgIG5hbWUsIFxuICAgIC8vLyBAaW50ZXJuYWxcbiAgICBwcm9wcywgXG4gICAgLy8vIFRoZSBpZCBvZiB0aGlzIG5vZGUgaW4gaXRzIHNldC4gQ29ycmVzcG9uZHMgdG8gdGhlIHRlcm0gaWRzXG4gICAgLy8vIHVzZWQgaW4gdGhlIHBhcnNlci5cbiAgICBpZCwgXG4gICAgLy8vIEBpbnRlcm5hbFxuICAgIGZsYWdzID0gMCkge1xuICAgICAgICB0aGlzLm5hbWUgPSBuYW1lO1xuICAgICAgICB0aGlzLnByb3BzID0gcHJvcHM7XG4gICAgICAgIHRoaXMuaWQgPSBpZDtcbiAgICAgICAgdGhpcy5mbGFncyA9IGZsYWdzO1xuICAgIH1cbiAgICBzdGF0aWMgZGVmaW5lKHNwZWMpIHtcbiAgICAgICAgbGV0IHByb3BzID0gc3BlYy5wcm9wcyAmJiBzcGVjLnByb3BzLmxlbmd0aCA/IE9iamVjdC5jcmVhdGUobnVsbCkgOiBub1Byb3BzO1xuICAgICAgICBsZXQgZmxhZ3MgPSAoc3BlYy50b3AgPyAxIC8qIFRvcCAqLyA6IDApIHwgKHNwZWMuc2tpcHBlZCA/IDIgLyogU2tpcHBlZCAqLyA6IDApIHxcbiAgICAgICAgICAgIChzcGVjLmVycm9yID8gNCAvKiBFcnJvciAqLyA6IDApIHwgKHNwZWMubmFtZSA9PSBudWxsID8gOCAvKiBBbm9ueW1vdXMgKi8gOiAwKTtcbiAgICAgICAgbGV0IHR5cGUgPSBuZXcgTm9kZVR5cGUoc3BlYy5uYW1lIHx8IFwiXCIsIHByb3BzLCBzcGVjLmlkLCBmbGFncyk7XG4gICAgICAgIGlmIChzcGVjLnByb3BzKVxuICAgICAgICAgICAgZm9yIChsZXQgc3JjIG9mIHNwZWMucHJvcHMpIHtcbiAgICAgICAgICAgICAgICBpZiAoIUFycmF5LmlzQXJyYXkoc3JjKSlcbiAgICAgICAgICAgICAgICAgICAgc3JjID0gc3JjKHR5cGUpO1xuICAgICAgICAgICAgICAgIGlmIChzcmMpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHNyY1swXS5wZXJOb2RlKVxuICAgICAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoXCJDYW4ndCBzdG9yZSBhIHBlci1ub2RlIHByb3Agb24gYSBub2RlIHR5cGVcIik7XG4gICAgICAgICAgICAgICAgICAgIHByb3BzW3NyY1swXS5pZF0gPSBzcmNbMV07XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICByZXR1cm4gdHlwZTtcbiAgICB9XG4gICAgLy8vIFJldHJpZXZlcyBhIG5vZGUgcHJvcCBmb3IgdGhpcyB0eXBlLiBXaWxsIHJldHVybiBgdW5kZWZpbmVkYCBpZlxuICAgIC8vLyB0aGUgcHJvcCBpc24ndCBwcmVzZW50IG9uIHRoaXMgbm9kZS5cbiAgICBwcm9wKHByb3ApIHsgcmV0dXJuIHRoaXMucHJvcHNbcHJvcC5pZF07IH1cbiAgICAvLy8gVHJ1ZSB3aGVuIHRoaXMgaXMgdGhlIHRvcCBub2RlIG9mIGEgZ3JhbW1hci5cbiAgICBnZXQgaXNUb3AoKSB7IHJldHVybiAodGhpcy5mbGFncyAmIDEgLyogVG9wICovKSA+IDA7IH1cbiAgICAvLy8gVHJ1ZSB3aGVuIHRoaXMgbm9kZSBpcyBwcm9kdWNlZCBieSBhIHNraXAgcnVsZS5cbiAgICBnZXQgaXNTa2lwcGVkKCkgeyByZXR1cm4gKHRoaXMuZmxhZ3MgJiAyIC8qIFNraXBwZWQgKi8pID4gMDsgfVxuICAgIC8vLyBJbmRpY2F0ZXMgd2hldGhlciB0aGlzIGlzIGFuIGVycm9yIG5vZGUuXG4gICAgZ2V0IGlzRXJyb3IoKSB7IHJldHVybiAodGhpcy5mbGFncyAmIDQgLyogRXJyb3IgKi8pID4gMDsgfVxuICAgIC8vLyBXaGVuIHRydWUsIHRoaXMgbm9kZSB0eXBlIGRvZXNuJ3QgY29ycmVzcG9uZCB0byBhIHVzZXItZGVjbGFyZWRcbiAgICAvLy8gbmFtZWQgbm9kZSwgZm9yIGV4YW1wbGUgYmVjYXVzZSBpdCBpcyB1c2VkIHRvIGNhY2hlIHJlcGV0aXRpb24uXG4gICAgZ2V0IGlzQW5vbnltb3VzKCkgeyByZXR1cm4gKHRoaXMuZmxhZ3MgJiA4IC8qIEFub255bW91cyAqLykgPiAwOyB9XG4gICAgLy8vIFJldHVybnMgdHJ1ZSB3aGVuIHRoaXMgbm9kZSdzIG5hbWUgb3Igb25lIG9mIGl0c1xuICAgIC8vLyBbZ3JvdXBzXSgjY29tbW9uLk5vZGVQcm9wXmdyb3VwKSBtYXRjaGVzIHRoZSBnaXZlbiBzdHJpbmcuXG4gICAgaXMobmFtZSkge1xuICAgICAgICBpZiAodHlwZW9mIG5hbWUgPT0gJ3N0cmluZycpIHtcbiAgICAgICAgICAgIGlmICh0aGlzLm5hbWUgPT0gbmFtZSlcbiAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgICAgIGxldCBncm91cCA9IHRoaXMucHJvcChOb2RlUHJvcC5ncm91cCk7XG4gICAgICAgICAgICByZXR1cm4gZ3JvdXAgPyBncm91cC5pbmRleE9mKG5hbWUpID4gLTEgOiBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGhpcy5pZCA9PSBuYW1lO1xuICAgIH1cbiAgICAvLy8gQ3JlYXRlIGEgZnVuY3Rpb24gZnJvbSBub2RlIHR5cGVzIHRvIGFyYml0cmFyeSB2YWx1ZXMgYnlcbiAgICAvLy8gc3BlY2lmeWluZyBhbiBvYmplY3Qgd2hvc2UgcHJvcGVydHkgbmFtZXMgYXJlIG5vZGUgb3JcbiAgICAvLy8gW2dyb3VwXSgjY29tbW9uLk5vZGVQcm9wXmdyb3VwKSBuYW1lcy4gT2Z0ZW4gdXNlZnVsIHdpdGhcbiAgICAvLy8gW2BOb2RlUHJvcC5hZGRgXSgjY29tbW9uLk5vZGVQcm9wLmFkZCkuIFlvdSBjYW4gcHV0IG11bHRpcGxlXG4gICAgLy8vIG5hbWVzLCBzZXBhcmF0ZWQgYnkgc3BhY2VzLCBpbiBhIHNpbmdsZSBwcm9wZXJ0eSBuYW1lIHRvIG1hcFxuICAgIC8vLyBtdWx0aXBsZSBub2RlIG5hbWVzIHRvIGEgc2luZ2xlIHZhbHVlLlxuICAgIHN0YXRpYyBtYXRjaChtYXApIHtcbiAgICAgICAgbGV0IGRpcmVjdCA9IE9iamVjdC5jcmVhdGUobnVsbCk7XG4gICAgICAgIGZvciAobGV0IHByb3AgaW4gbWFwKVxuICAgICAgICAgICAgZm9yIChsZXQgbmFtZSBvZiBwcm9wLnNwbGl0KFwiIFwiKSlcbiAgICAgICAgICAgICAgICBkaXJlY3RbbmFtZV0gPSBtYXBbcHJvcF07XG4gICAgICAgIHJldHVybiAobm9kZSkgPT4ge1xuICAgICAgICAgICAgZm9yIChsZXQgZ3JvdXBzID0gbm9kZS5wcm9wKE5vZGVQcm9wLmdyb3VwKSwgaSA9IC0xOyBpIDwgKGdyb3VwcyA/IGdyb3Vwcy5sZW5ndGggOiAwKTsgaSsrKSB7XG4gICAgICAgICAgICAgICAgbGV0IGZvdW5kID0gZGlyZWN0W2kgPCAwID8gbm9kZS5uYW1lIDogZ3JvdXBzW2ldXTtcbiAgICAgICAgICAgICAgICBpZiAoZm91bmQpXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBmb3VuZDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICB9XG59XG4vLy8gQW4gZW1wdHkgZHVtbXkgbm9kZSB0eXBlIHRvIHVzZSB3aGVuIG5vIGFjdHVhbCB0eXBlIGlzIGF2YWlsYWJsZS5cbk5vZGVUeXBlLm5vbmUgPSBuZXcgTm9kZVR5cGUoXCJcIiwgT2JqZWN0LmNyZWF0ZShudWxsKSwgMCwgOCAvKiBBbm9ueW1vdXMgKi8pO1xuLy8vIEEgbm9kZSBzZXQgaG9sZHMgYSBjb2xsZWN0aW9uIG9mIG5vZGUgdHlwZXMuIEl0IGlzIHVzZWQgdG9cbi8vLyBjb21wYWN0bHkgcmVwcmVzZW50IHRyZWVzIGJ5IHN0b3JpbmcgdGhlaXIgdHlwZSBpZHMsIHJhdGhlciB0aGFuIGFcbi8vLyBmdWxsIHBvaW50ZXIgdG8gdGhlIHR5cGUgb2JqZWN0LCBpbiBhIG51bWVyaWMgYXJyYXkuIEVhY2ggcGFyc2VyXG4vLy8gW2hhc10oI2xyLkxSUGFyc2VyLm5vZGVTZXQpIGEgbm9kZSBzZXQsIGFuZCBbdHJlZVxuLy8vIGJ1ZmZlcnNdKCNjb21tb24uVHJlZUJ1ZmZlcikgY2FuIG9ubHkgc3RvcmUgY29sbGVjdGlvbnMgb2Ygbm9kZXNcbi8vLyBmcm9tIHRoZSBzYW1lIHNldC4gQSBzZXQgY2FuIGhhdmUgYSBtYXhpbXVtIG9mIDIqKjE2ICg2NTUzNikgbm9kZVxuLy8vIHR5cGVzIGluIGl0LCBzbyB0aGF0IHRoZSBpZHMgZml0IGludG8gMTYtYml0IHR5cGVkIGFycmF5IHNsb3RzLlxuY2xhc3MgTm9kZVNldCB7XG4gICAgLy8vIENyZWF0ZSBhIHNldCB3aXRoIHRoZSBnaXZlbiB0eXBlcy4gVGhlIGBpZGAgcHJvcGVydHkgb2YgZWFjaFxuICAgIC8vLyB0eXBlIHNob3VsZCBjb3JyZXNwb25kIHRvIGl0cyBwb3NpdGlvbiB3aXRoaW4gdGhlIGFycmF5LlxuICAgIGNvbnN0cnVjdG9yKFxuICAgIC8vLyBUaGUgbm9kZSB0eXBlcyBpbiB0aGlzIHNldCwgYnkgaWQuXG4gICAgdHlwZXMpIHtcbiAgICAgICAgdGhpcy50eXBlcyA9IHR5cGVzO1xuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHR5cGVzLmxlbmd0aDsgaSsrKVxuICAgICAgICAgICAgaWYgKHR5cGVzW2ldLmlkICE9IGkpXG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoXCJOb2RlIHR5cGUgaWRzIHNob3VsZCBjb3JyZXNwb25kIHRvIGFycmF5IHBvc2l0aW9ucyB3aGVuIGNyZWF0aW5nIGEgbm9kZSBzZXRcIik7XG4gICAgfVxuICAgIC8vLyBDcmVhdGUgYSBjb3B5IG9mIHRoaXMgc2V0IHdpdGggc29tZSBub2RlIHByb3BlcnRpZXMgYWRkZWQuIFRoZVxuICAgIC8vLyBhcmd1bWVudHMgdG8gdGhpcyBtZXRob2Qgc2hvdWxkIGJlIGNyZWF0ZWQgd2l0aFxuICAgIC8vLyBbYE5vZGVQcm9wLmFkZGBdKCNjb21tb24uTm9kZVByb3AuYWRkKS5cbiAgICBleHRlbmQoLi4ucHJvcHMpIHtcbiAgICAgICAgbGV0IG5ld1R5cGVzID0gW107XG4gICAgICAgIGZvciAobGV0IHR5cGUgb2YgdGhpcy50eXBlcykge1xuICAgICAgICAgICAgbGV0IG5ld1Byb3BzID0gbnVsbDtcbiAgICAgICAgICAgIGZvciAobGV0IHNvdXJjZSBvZiBwcm9wcykge1xuICAgICAgICAgICAgICAgIGxldCBhZGQgPSBzb3VyY2UodHlwZSk7XG4gICAgICAgICAgICAgICAgaWYgKGFkZCkge1xuICAgICAgICAgICAgICAgICAgICBpZiAoIW5ld1Byb3BzKVxuICAgICAgICAgICAgICAgICAgICAgICAgbmV3UHJvcHMgPSBPYmplY3QuYXNzaWduKHt9LCB0eXBlLnByb3BzKTtcbiAgICAgICAgICAgICAgICAgICAgbmV3UHJvcHNbYWRkWzBdLmlkXSA9IGFkZFsxXTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBuZXdUeXBlcy5wdXNoKG5ld1Byb3BzID8gbmV3IE5vZGVUeXBlKHR5cGUubmFtZSwgbmV3UHJvcHMsIHR5cGUuaWQsIHR5cGUuZmxhZ3MpIDogdHlwZSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG5ldyBOb2RlU2V0KG5ld1R5cGVzKTtcbiAgICB9XG59XG5jb25zdCBDYWNoZWROb2RlID0gbmV3IFdlYWtNYXAoKSwgQ2FjaGVkSW5uZXJOb2RlID0gbmV3IFdlYWtNYXAoKTtcbi8vLyBPcHRpb25zIHRoYXQgY29udHJvbCBpdGVyYXRpb24uIENhbiBiZSBjb21iaW5lZCB3aXRoIHRoZSBgfGBcbi8vLyBvcGVyYXRvciB0byBlbmFibGUgbXVsdGlwbGUgb25lcy5cbmV4cG9ydHMuSXRlck1vZGUgPSB2b2lkIDA7XG4oZnVuY3Rpb24gKEl0ZXJNb2RlKSB7XG4gICAgLy8vIFdoZW4gZW5hYmxlZCwgaXRlcmF0aW9uIHdpbGwgb25seSB2aXNpdCBbYFRyZWVgXSgjY29tbW9uLlRyZWUpXG4gICAgLy8vIG9iamVjdHMsIG5vdCBub2RlcyBwYWNrZWQgaW50b1xuICAgIC8vLyBbYFRyZWVCdWZmZXJgXSgjY29tbW9uLlRyZWVCdWZmZXIpcy5cbiAgICBJdGVyTW9kZVtJdGVyTW9kZVtcIkV4Y2x1ZGVCdWZmZXJzXCJdID0gMV0gPSBcIkV4Y2x1ZGVCdWZmZXJzXCI7XG4gICAgLy8vIEVuYWJsZSB0aGlzIHRvIG1ha2UgaXRlcmF0aW9uIGluY2x1ZGUgYW5vbnltb3VzIG5vZGVzIChzdWNoIGFzXG4gICAgLy8vIHRoZSBub2RlcyB0aGF0IHdyYXAgcmVwZWF0ZWQgZ3JhbW1hciBjb25zdHJ1Y3RzIGludG8gYSBiYWxhbmNlZFxuICAgIC8vLyB0cmVlKS5cbiAgICBJdGVyTW9kZVtJdGVyTW9kZVtcIkluY2x1ZGVBbm9ueW1vdXNcIl0gPSAyXSA9IFwiSW5jbHVkZUFub255bW91c1wiO1xuICAgIC8vLyBCeSBkZWZhdWx0LCByZWd1bGFyIFttb3VudGVkXSgjY29tbW9uLk5vZGVQcm9wXm1vdW50ZWQpIG5vZGVzXG4gICAgLy8vIHJlcGxhY2UgdGhlaXIgYmFzZSBub2RlIGluIGl0ZXJhdGlvbi4gRW5hYmxlIHRoaXMgdG8gaWdub3JlIHRoZW1cbiAgICAvLy8gaW5zdGVhZC5cbiAgICBJdGVyTW9kZVtJdGVyTW9kZVtcIklnbm9yZU1vdW50c1wiXSA9IDRdID0gXCJJZ25vcmVNb3VudHNcIjtcbiAgICAvLy8gVGhpcyBvcHRpb24gb25seSBhcHBsaWVzIGluXG4gICAgLy8vIFtgZW50ZXJgXSgjY29tbW9uLlN5bnRheE5vZGUuZW50ZXIpLXN0eWxlIG1ldGhvZHMuIEl0IHRlbGxzIHRoZVxuICAgIC8vLyBsaWJyYXJ5IHRvIG5vdCBlbnRlciBtb3VudGVkIG92ZXJsYXlzIGlmIG9uZSBjb3ZlcnMgdGhlIGdpdmVuXG4gICAgLy8vIHBvc2l0aW9uLlxuICAgIEl0ZXJNb2RlW0l0ZXJNb2RlW1wiSWdub3JlT3ZlcmxheXNcIl0gPSA4XSA9IFwiSWdub3JlT3ZlcmxheXNcIjtcbn0pKGV4cG9ydHMuSXRlck1vZGUgfHwgKGV4cG9ydHMuSXRlck1vZGUgPSB7fSkpO1xuLy8vIEEgcGllY2Ugb2Ygc3ludGF4IHRyZWUuIFRoZXJlIGFyZSB0d28gd2F5cyB0byBhcHByb2FjaCB0aGVzZVxuLy8vIHRyZWVzOiB0aGUgd2F5IHRoZXkgYXJlIGFjdHVhbGx5IHN0b3JlZCBpbiBtZW1vcnksIGFuZCB0aGVcbi8vLyBjb252ZW5pZW50IHdheS5cbi8vL1xuLy8vIFN5bnRheCB0cmVlcyBhcmUgc3RvcmVkIGFzIGEgdHJlZSBvZiBgVHJlZWAgYW5kIGBUcmVlQnVmZmVyYFxuLy8vIG9iamVjdHMuIEJ5IHBhY2tpbmcgZGV0YWlsIGluZm9ybWF0aW9uIGludG8gYFRyZWVCdWZmZXJgIGxlYWZcbi8vLyBub2RlcywgdGhlIHJlcHJlc2VudGF0aW9uIGlzIG1hZGUgYSBsb3QgbW9yZSBtZW1vcnktZWZmaWNpZW50LlxuLy8vXG4vLy8gSG93ZXZlciwgd2hlbiB5b3Ugd2FudCB0byBhY3R1YWxseSB3b3JrIHdpdGggdHJlZSBub2RlcywgdGhpc1xuLy8vIHJlcHJlc2VudGF0aW9uIGlzIHZlcnkgYXdrd2FyZCwgc28gbW9zdCBjbGllbnQgY29kZSB3aWxsIHdhbnQgdG9cbi8vLyB1c2UgdGhlIFtgVHJlZUN1cnNvcmBdKCNjb21tb24uVHJlZUN1cnNvcikgb3Jcbi8vLyBbYFN5bnRheE5vZGVgXSgjY29tbW9uLlN5bnRheE5vZGUpIGludGVyZmFjZSBpbnN0ZWFkLCB3aGljaCBwcm92aWRlc1xuLy8vIGEgdmlldyBvbiBzb21lIHBhcnQgb2YgdGhpcyBkYXRhIHN0cnVjdHVyZSwgYW5kIGNhbiBiZSB1c2VkIHRvXG4vLy8gbW92ZSBhcm91bmQgdG8gYWRqYWNlbnQgbm9kZXMuXG5jbGFzcyBUcmVlIHtcbiAgICAvLy8gQ29uc3RydWN0IGEgbmV3IHRyZWUuIFNlZSBhbHNvIFtgVHJlZS5idWlsZGBdKCNjb21tb24uVHJlZV5idWlsZCkuXG4gICAgY29uc3RydWN0b3IoXG4gICAgLy8vIFRoZSB0eXBlIG9mIHRoZSB0b3Agbm9kZS5cbiAgICB0eXBlLCBcbiAgICAvLy8gVGhpcyBub2RlJ3MgY2hpbGQgbm9kZXMuXG4gICAgY2hpbGRyZW4sIFxuICAgIC8vLyBUaGUgcG9zaXRpb25zIChvZmZzZXRzIHJlbGF0aXZlIHRvIHRoZSBzdGFydCBvZiB0aGlzIHRyZWUpIG9mXG4gICAgLy8vIHRoZSBjaGlsZHJlbi5cbiAgICBwb3NpdGlvbnMsIFxuICAgIC8vLyBUaGUgdG90YWwgbGVuZ3RoIG9mIHRoaXMgdHJlZVxuICAgIGxlbmd0aCwgXG4gICAgLy8vIFBlci1ub2RlIFtub2RlIHByb3BzXSgjY29tbW9uLk5vZGVQcm9wKSB0byBhc3NvY2lhdGUgd2l0aCB0aGlzIG5vZGUuXG4gICAgcHJvcHMpIHtcbiAgICAgICAgdGhpcy50eXBlID0gdHlwZTtcbiAgICAgICAgdGhpcy5jaGlsZHJlbiA9IGNoaWxkcmVuO1xuICAgICAgICB0aGlzLnBvc2l0aW9ucyA9IHBvc2l0aW9ucztcbiAgICAgICAgdGhpcy5sZW5ndGggPSBsZW5ndGg7XG4gICAgICAgIC8vLyBAaW50ZXJuYWxcbiAgICAgICAgdGhpcy5wcm9wcyA9IG51bGw7XG4gICAgICAgIGlmIChwcm9wcyAmJiBwcm9wcy5sZW5ndGgpIHtcbiAgICAgICAgICAgIHRoaXMucHJvcHMgPSBPYmplY3QuY3JlYXRlKG51bGwpO1xuICAgICAgICAgICAgZm9yIChsZXQgW3Byb3AsIHZhbHVlXSBvZiBwcm9wcylcbiAgICAgICAgICAgICAgICB0aGlzLnByb3BzW3R5cGVvZiBwcm9wID09IFwibnVtYmVyXCIgPyBwcm9wIDogcHJvcC5pZF0gPSB2YWx1ZTtcbiAgICAgICAgfVxuICAgIH1cbiAgICAvLy8gQGludGVybmFsXG4gICAgdG9TdHJpbmcoKSB7XG4gICAgICAgIGxldCBtb3VudGVkID0gdGhpcy5wcm9wKE5vZGVQcm9wLm1vdW50ZWQpO1xuICAgICAgICBpZiAobW91bnRlZCAmJiAhbW91bnRlZC5vdmVybGF5KVxuICAgICAgICAgICAgcmV0dXJuIG1vdW50ZWQudHJlZS50b1N0cmluZygpO1xuICAgICAgICBsZXQgY2hpbGRyZW4gPSBcIlwiO1xuICAgICAgICBmb3IgKGxldCBjaCBvZiB0aGlzLmNoaWxkcmVuKSB7XG4gICAgICAgICAgICBsZXQgc3RyID0gY2gudG9TdHJpbmcoKTtcbiAgICAgICAgICAgIGlmIChzdHIpIHtcbiAgICAgICAgICAgICAgICBpZiAoY2hpbGRyZW4pXG4gICAgICAgICAgICAgICAgICAgIGNoaWxkcmVuICs9IFwiLFwiO1xuICAgICAgICAgICAgICAgIGNoaWxkcmVuICs9IHN0cjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gIXRoaXMudHlwZS5uYW1lID8gY2hpbGRyZW4gOlxuICAgICAgICAgICAgKC9cXFcvLnRlc3QodGhpcy50eXBlLm5hbWUpICYmICF0aGlzLnR5cGUuaXNFcnJvciA/IEpTT04uc3RyaW5naWZ5KHRoaXMudHlwZS5uYW1lKSA6IHRoaXMudHlwZS5uYW1lKSArXG4gICAgICAgICAgICAgICAgKGNoaWxkcmVuLmxlbmd0aCA/IFwiKFwiICsgY2hpbGRyZW4gKyBcIilcIiA6IFwiXCIpO1xuICAgIH1cbiAgICAvLy8gR2V0IGEgW3RyZWUgY3Vyc29yXSgjY29tbW9uLlRyZWVDdXJzb3IpIHBvc2l0aW9uZWQgYXQgdGhlIHRvcCBvZlxuICAgIC8vLyB0aGUgdHJlZS4gTW9kZSBjYW4gYmUgdXNlZCB0byBbY29udHJvbF0oI2NvbW1vbi5JdGVyTW9kZSkgd2hpY2hcbiAgICAvLy8gbm9kZXMgdGhlIGN1cnNvciB2aXNpdHMuXG4gICAgY3Vyc29yKG1vZGUgPSAwKSB7XG4gICAgICAgIHJldHVybiBuZXcgVHJlZUN1cnNvcih0aGlzLnRvcE5vZGUsIG1vZGUpO1xuICAgIH1cbiAgICAvLy8gR2V0IGEgW3RyZWUgY3Vyc29yXSgjY29tbW9uLlRyZWVDdXJzb3IpIHBvaW50aW5nIGludG8gdGhpcyB0cmVlXG4gICAgLy8vIGF0IHRoZSBnaXZlbiBwb3NpdGlvbiBhbmQgc2lkZSAoc2VlXG4gICAgLy8vIFtgbW92ZVRvYF0oI2NvbW1vbi5UcmVlQ3Vyc29yLm1vdmVUbykuXG4gICAgY3Vyc29yQXQocG9zLCBzaWRlID0gMCwgbW9kZSA9IDApIHtcbiAgICAgICAgbGV0IHNjb3BlID0gQ2FjaGVkTm9kZS5nZXQodGhpcykgfHwgdGhpcy50b3BOb2RlO1xuICAgICAgICBsZXQgY3Vyc29yID0gbmV3IFRyZWVDdXJzb3Ioc2NvcGUpO1xuICAgICAgICBjdXJzb3IubW92ZVRvKHBvcywgc2lkZSk7XG4gICAgICAgIENhY2hlZE5vZGUuc2V0KHRoaXMsIGN1cnNvci5fdHJlZSk7XG4gICAgICAgIHJldHVybiBjdXJzb3I7XG4gICAgfVxuICAgIC8vLyBHZXQgYSBbc3ludGF4IG5vZGVdKCNjb21tb24uU3ludGF4Tm9kZSkgb2JqZWN0IGZvciB0aGUgdG9wIG9mIHRoZVxuICAgIC8vLyB0cmVlLlxuICAgIGdldCB0b3BOb2RlKCkge1xuICAgICAgICByZXR1cm4gbmV3IFRyZWVOb2RlKHRoaXMsIDAsIDAsIG51bGwpO1xuICAgIH1cbiAgICAvLy8gR2V0IHRoZSBbc3ludGF4IG5vZGVdKCNjb21tb24uU3ludGF4Tm9kZSkgYXQgdGhlIGdpdmVuIHBvc2l0aW9uLlxuICAgIC8vLyBJZiBgc2lkZWAgaXMgLTEsIHRoaXMgd2lsbCBtb3ZlIGludG8gbm9kZXMgdGhhdCBlbmQgYXQgdGhlXG4gICAgLy8vIHBvc2l0aW9uLiBJZiAxLCBpdCdsbCBtb3ZlIGludG8gbm9kZXMgdGhhdCBzdGFydCBhdCB0aGVcbiAgICAvLy8gcG9zaXRpb24uIFdpdGggMCwgaXQnbGwgb25seSBlbnRlciBub2RlcyB0aGF0IGNvdmVyIHRoZSBwb3NpdGlvblxuICAgIC8vLyBmcm9tIGJvdGggc2lkZXMuXG4gICAgcmVzb2x2ZShwb3MsIHNpZGUgPSAwKSB7XG4gICAgICAgIGxldCBub2RlID0gcmVzb2x2ZU5vZGUoQ2FjaGVkTm9kZS5nZXQodGhpcykgfHwgdGhpcy50b3BOb2RlLCBwb3MsIHNpZGUsIGZhbHNlKTtcbiAgICAgICAgQ2FjaGVkTm9kZS5zZXQodGhpcywgbm9kZSk7XG4gICAgICAgIHJldHVybiBub2RlO1xuICAgIH1cbiAgICAvLy8gTGlrZSBbYHJlc29sdmVgXSgjY29tbW9uLlRyZWUucmVzb2x2ZSksIGJ1dCB3aWxsIGVudGVyXG4gICAgLy8vIFtvdmVybGFpZF0oI2NvbW1vbi5Nb3VudGVkVHJlZS5vdmVybGF5KSBub2RlcywgcHJvZHVjaW5nIGEgc3ludGF4IG5vZGVcbiAgICAvLy8gcG9pbnRpbmcgaW50byB0aGUgaW5uZXJtb3N0IG92ZXJsYWlkIHRyZWUgYXQgdGhlIGdpdmVuIHBvc2l0aW9uXG4gICAgLy8vICh3aXRoIHBhcmVudCBsaW5rcyBnb2luZyB0aHJvdWdoIGFsbCBwYXJlbnQgc3RydWN0dXJlLCBpbmNsdWRpbmdcbiAgICAvLy8gdGhlIGhvc3QgdHJlZXMpLlxuICAgIHJlc29sdmVJbm5lcihwb3MsIHNpZGUgPSAwKSB7XG4gICAgICAgIGxldCBub2RlID0gcmVzb2x2ZU5vZGUoQ2FjaGVkSW5uZXJOb2RlLmdldCh0aGlzKSB8fCB0aGlzLnRvcE5vZGUsIHBvcywgc2lkZSwgdHJ1ZSk7XG4gICAgICAgIENhY2hlZElubmVyTm9kZS5zZXQodGhpcywgbm9kZSk7XG4gICAgICAgIHJldHVybiBub2RlO1xuICAgIH1cbiAgICAvLy8gSXRlcmF0ZSBvdmVyIHRoZSB0cmVlIGFuZCBpdHMgY2hpbGRyZW4sIGNhbGxpbmcgYGVudGVyYCBmb3IgYW55XG4gICAgLy8vIG5vZGUgdGhhdCB0b3VjaGVzIHRoZSBgZnJvbWAvYHRvYCByZWdpb24gKGlmIGdpdmVuKSBiZWZvcmVcbiAgICAvLy8gcnVubmluZyBvdmVyIHN1Y2ggYSBub2RlJ3MgY2hpbGRyZW4sIGFuZCBgbGVhdmVgIChpZiBnaXZlbikgd2hlblxuICAgIC8vLyBsZWF2aW5nIHRoZSBub2RlLiBXaGVuIGBlbnRlcmAgcmV0dXJucyBgZmFsc2VgLCB0aGF0IG5vZGUgd2lsbFxuICAgIC8vLyBub3QgaGF2ZSBpdHMgY2hpbGRyZW4gaXRlcmF0ZWQgb3ZlciAob3IgYGxlYXZlYCBjYWxsZWQpLlxuICAgIGl0ZXJhdGUoc3BlYykge1xuICAgICAgICBsZXQgeyBlbnRlciwgbGVhdmUsIGZyb20gPSAwLCB0byA9IHRoaXMubGVuZ3RoIH0gPSBzcGVjO1xuICAgICAgICBmb3IgKGxldCBjID0gdGhpcy5jdXJzb3IoKHNwZWMubW9kZSB8fCAwKSB8IGV4cG9ydHMuSXRlck1vZGUuSW5jbHVkZUFub255bW91cyk7Oykge1xuICAgICAgICAgICAgbGV0IGVudGVyZWQgPSBmYWxzZTtcbiAgICAgICAgICAgIGlmIChjLmZyb20gPD0gdG8gJiYgYy50byA+PSBmcm9tICYmIChjLnR5cGUuaXNBbm9ueW1vdXMgfHwgZW50ZXIoYykgIT09IGZhbHNlKSkge1xuICAgICAgICAgICAgICAgIGlmIChjLmZpcnN0Q2hpbGQoKSlcbiAgICAgICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICAgICAgZW50ZXJlZCA9IHRydWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBmb3IgKDs7KSB7XG4gICAgICAgICAgICAgICAgaWYgKGVudGVyZWQgJiYgbGVhdmUgJiYgIWMudHlwZS5pc0Fub255bW91cylcbiAgICAgICAgICAgICAgICAgICAgbGVhdmUoYyk7XG4gICAgICAgICAgICAgICAgaWYgKGMubmV4dFNpYmxpbmcoKSlcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgaWYgKCFjLnBhcmVudCgpKVxuICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgZW50ZXJlZCA9IHRydWU7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG4gICAgLy8vIEdldCB0aGUgdmFsdWUgb2YgdGhlIGdpdmVuIFtub2RlIHByb3BdKCNjb21tb24uTm9kZVByb3ApIGZvciB0aGlzXG4gICAgLy8vIG5vZGUuIFdvcmtzIHdpdGggYm90aCBwZXItbm9kZSBhbmQgcGVyLXR5cGUgcHJvcHMuXG4gICAgcHJvcChwcm9wKSB7XG4gICAgICAgIHJldHVybiAhcHJvcC5wZXJOb2RlID8gdGhpcy50eXBlLnByb3AocHJvcCkgOiB0aGlzLnByb3BzID8gdGhpcy5wcm9wc1twcm9wLmlkXSA6IHVuZGVmaW5lZDtcbiAgICB9XG4gICAgLy8vIFJldHVybnMgdGhlIG5vZGUncyBbcGVyLW5vZGUgcHJvcHNdKCNjb21tb24uTm9kZVByb3AucGVyTm9kZSkgaW4gYVxuICAgIC8vLyBmb3JtYXQgdGhhdCBjYW4gYmUgcGFzc2VkIHRvIHRoZSBbYFRyZWVgXSgjY29tbW9uLlRyZWUpXG4gICAgLy8vIGNvbnN0cnVjdG9yLlxuICAgIGdldCBwcm9wVmFsdWVzKCkge1xuICAgICAgICBsZXQgcmVzdWx0ID0gW107XG4gICAgICAgIGlmICh0aGlzLnByb3BzKVxuICAgICAgICAgICAgZm9yIChsZXQgaWQgaW4gdGhpcy5wcm9wcylcbiAgICAgICAgICAgICAgICByZXN1bHQucHVzaChbK2lkLCB0aGlzLnByb3BzW2lkXV0pO1xuICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH1cbiAgICAvLy8gQmFsYW5jZSB0aGUgZGlyZWN0IGNoaWxkcmVuIG9mIHRoaXMgdHJlZSwgcHJvZHVjaW5nIGEgY29weSBvZlxuICAgIC8vLyB3aGljaCBtYXkgaGF2ZSBjaGlsZHJlbiBncm91cGVkIGludG8gc3VidHJlZXMgd2l0aCB0eXBlXG4gICAgLy8vIFtgTm9kZVR5cGUubm9uZWBdKCNjb21tb24uTm9kZVR5cGVebm9uZSkuXG4gICAgYmFsYW5jZShjb25maWcgPSB7fSkge1xuICAgICAgICByZXR1cm4gdGhpcy5jaGlsZHJlbi5sZW5ndGggPD0gOCAvKiBCcmFuY2hGYWN0b3IgKi8gPyB0aGlzIDpcbiAgICAgICAgICAgIGJhbGFuY2VSYW5nZShOb2RlVHlwZS5ub25lLCB0aGlzLmNoaWxkcmVuLCB0aGlzLnBvc2l0aW9ucywgMCwgdGhpcy5jaGlsZHJlbi5sZW5ndGgsIDAsIHRoaXMubGVuZ3RoLCAoY2hpbGRyZW4sIHBvc2l0aW9ucywgbGVuZ3RoKSA9PiBuZXcgVHJlZSh0aGlzLnR5cGUsIGNoaWxkcmVuLCBwb3NpdGlvbnMsIGxlbmd0aCwgdGhpcy5wcm9wVmFsdWVzKSwgY29uZmlnLm1ha2VUcmVlIHx8ICgoY2hpbGRyZW4sIHBvc2l0aW9ucywgbGVuZ3RoKSA9PiBuZXcgVHJlZShOb2RlVHlwZS5ub25lLCBjaGlsZHJlbiwgcG9zaXRpb25zLCBsZW5ndGgpKSk7XG4gICAgfVxuICAgIC8vLyBCdWlsZCBhIHRyZWUgZnJvbSBhIHBvc3RmaXgtb3JkZXJlZCBidWZmZXIgb2Ygbm9kZSBpbmZvcm1hdGlvbixcbiAgICAvLy8gb3IgYSBjdXJzb3Igb3ZlciBzdWNoIGEgYnVmZmVyLlxuICAgIHN0YXRpYyBidWlsZChkYXRhKSB7IHJldHVybiBidWlsZFRyZWUoZGF0YSk7IH1cbn1cbi8vLyBUaGUgZW1wdHkgdHJlZVxuVHJlZS5lbXB0eSA9IG5ldyBUcmVlKE5vZGVUeXBlLm5vbmUsIFtdLCBbXSwgMCk7XG5jbGFzcyBGbGF0QnVmZmVyQ3Vyc29yIHtcbiAgICBjb25zdHJ1Y3RvcihidWZmZXIsIGluZGV4KSB7XG4gICAgICAgIHRoaXMuYnVmZmVyID0gYnVmZmVyO1xuICAgICAgICB0aGlzLmluZGV4ID0gaW5kZXg7XG4gICAgfVxuICAgIGdldCBpZCgpIHsgcmV0dXJuIHRoaXMuYnVmZmVyW3RoaXMuaW5kZXggLSA0XTsgfVxuICAgIGdldCBzdGFydCgpIHsgcmV0dXJuIHRoaXMuYnVmZmVyW3RoaXMuaW5kZXggLSAzXTsgfVxuICAgIGdldCBlbmQoKSB7IHJldHVybiB0aGlzLmJ1ZmZlclt0aGlzLmluZGV4IC0gMl07IH1cbiAgICBnZXQgc2l6ZSgpIHsgcmV0dXJuIHRoaXMuYnVmZmVyW3RoaXMuaW5kZXggLSAxXTsgfVxuICAgIGdldCBwb3MoKSB7IHJldHVybiB0aGlzLmluZGV4OyB9XG4gICAgbmV4dCgpIHsgdGhpcy5pbmRleCAtPSA0OyB9XG4gICAgZm9yaygpIHsgcmV0dXJuIG5ldyBGbGF0QnVmZmVyQ3Vyc29yKHRoaXMuYnVmZmVyLCB0aGlzLmluZGV4KTsgfVxufVxuLy8vIFRyZWUgYnVmZmVycyBjb250YWluICh0eXBlLCBzdGFydCwgZW5kLCBlbmRJbmRleCkgcXVhZHMgZm9yIGVhY2hcbi8vLyBub2RlLiBJbiBzdWNoIGEgYnVmZmVyLCBub2RlcyBhcmUgc3RvcmVkIGluIHByZWZpeCBvcmRlciAocGFyZW50c1xuLy8vIGJlZm9yZSBjaGlsZHJlbiwgd2l0aCB0aGUgZW5kSW5kZXggb2YgdGhlIHBhcmVudCBpbmRpY2F0aW5nIHdoaWNoXG4vLy8gY2hpbGRyZW4gYmVsb25nIHRvIGl0KVxuY2xhc3MgVHJlZUJ1ZmZlciB7XG4gICAgLy8vIENyZWF0ZSBhIHRyZWUgYnVmZmVyLlxuICAgIGNvbnN0cnVjdG9yKFxuICAgIC8vLyBUaGUgYnVmZmVyJ3MgY29udGVudC5cbiAgICBidWZmZXIsIFxuICAgIC8vLyBUaGUgdG90YWwgbGVuZ3RoIG9mIHRoZSBncm91cCBvZiBub2RlcyBpbiB0aGUgYnVmZmVyLlxuICAgIGxlbmd0aCwgXG4gICAgLy8vIFRoZSBub2RlIHNldCB1c2VkIGluIHRoaXMgYnVmZmVyLlxuICAgIHNldCkge1xuICAgICAgICB0aGlzLmJ1ZmZlciA9IGJ1ZmZlcjtcbiAgICAgICAgdGhpcy5sZW5ndGggPSBsZW5ndGg7XG4gICAgICAgIHRoaXMuc2V0ID0gc2V0O1xuICAgIH1cbiAgICAvLy8gQGludGVybmFsXG4gICAgZ2V0IHR5cGUoKSB7IHJldHVybiBOb2RlVHlwZS5ub25lOyB9XG4gICAgLy8vIEBpbnRlcm5hbFxuICAgIHRvU3RyaW5nKCkge1xuICAgICAgICBsZXQgcmVzdWx0ID0gW107XG4gICAgICAgIGZvciAobGV0IGluZGV4ID0gMDsgaW5kZXggPCB0aGlzLmJ1ZmZlci5sZW5ndGg7KSB7XG4gICAgICAgICAgICByZXN1bHQucHVzaCh0aGlzLmNoaWxkU3RyaW5nKGluZGV4KSk7XG4gICAgICAgICAgICBpbmRleCA9IHRoaXMuYnVmZmVyW2luZGV4ICsgM107XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHJlc3VsdC5qb2luKFwiLFwiKTtcbiAgICB9XG4gICAgLy8vIEBpbnRlcm5hbFxuICAgIGNoaWxkU3RyaW5nKGluZGV4KSB7XG4gICAgICAgIGxldCBpZCA9IHRoaXMuYnVmZmVyW2luZGV4XSwgZW5kSW5kZXggPSB0aGlzLmJ1ZmZlcltpbmRleCArIDNdO1xuICAgICAgICBsZXQgdHlwZSA9IHRoaXMuc2V0LnR5cGVzW2lkXSwgcmVzdWx0ID0gdHlwZS5uYW1lO1xuICAgICAgICBpZiAoL1xcVy8udGVzdChyZXN1bHQpICYmICF0eXBlLmlzRXJyb3IpXG4gICAgICAgICAgICByZXN1bHQgPSBKU09OLnN0cmluZ2lmeShyZXN1bHQpO1xuICAgICAgICBpbmRleCArPSA0O1xuICAgICAgICBpZiAoZW5kSW5kZXggPT0gaW5kZXgpXG4gICAgICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgICAgICBsZXQgY2hpbGRyZW4gPSBbXTtcbiAgICAgICAgd2hpbGUgKGluZGV4IDwgZW5kSW5kZXgpIHtcbiAgICAgICAgICAgIGNoaWxkcmVuLnB1c2godGhpcy5jaGlsZFN0cmluZyhpbmRleCkpO1xuICAgICAgICAgICAgaW5kZXggPSB0aGlzLmJ1ZmZlcltpbmRleCArIDNdO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiByZXN1bHQgKyBcIihcIiArIGNoaWxkcmVuLmpvaW4oXCIsXCIpICsgXCIpXCI7XG4gICAgfVxuICAgIC8vLyBAaW50ZXJuYWxcbiAgICBmaW5kQ2hpbGQoc3RhcnRJbmRleCwgZW5kSW5kZXgsIGRpciwgcG9zLCBzaWRlKSB7XG4gICAgICAgIGxldCB7IGJ1ZmZlciB9ID0gdGhpcywgcGljayA9IC0xO1xuICAgICAgICBmb3IgKGxldCBpID0gc3RhcnRJbmRleDsgaSAhPSBlbmRJbmRleDsgaSA9IGJ1ZmZlcltpICsgM10pIHtcbiAgICAgICAgICAgIGlmIChjaGVja1NpZGUoc2lkZSwgcG9zLCBidWZmZXJbaSArIDFdLCBidWZmZXJbaSArIDJdKSkge1xuICAgICAgICAgICAgICAgIHBpY2sgPSBpO1xuICAgICAgICAgICAgICAgIGlmIChkaXIgPiAwKVxuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcGljaztcbiAgICB9XG4gICAgLy8vIEBpbnRlcm5hbFxuICAgIHNsaWNlKHN0YXJ0SSwgZW5kSSwgZnJvbSwgdG8pIHtcbiAgICAgICAgbGV0IGIgPSB0aGlzLmJ1ZmZlcjtcbiAgICAgICAgbGV0IGNvcHkgPSBuZXcgVWludDE2QXJyYXkoZW5kSSAtIHN0YXJ0SSk7XG4gICAgICAgIGZvciAobGV0IGkgPSBzdGFydEksIGogPSAwOyBpIDwgZW5kSTspIHtcbiAgICAgICAgICAgIGNvcHlbaisrXSA9IGJbaSsrXTtcbiAgICAgICAgICAgIGNvcHlbaisrXSA9IGJbaSsrXSAtIGZyb207XG4gICAgICAgICAgICBjb3B5W2orK10gPSBiW2krK10gLSBmcm9tO1xuICAgICAgICAgICAgY29weVtqKytdID0gYltpKytdIC0gc3RhcnRJO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBuZXcgVHJlZUJ1ZmZlcihjb3B5LCB0byAtIGZyb20sIHRoaXMuc2V0KTtcbiAgICB9XG59XG5mdW5jdGlvbiBjaGVja1NpZGUoc2lkZSwgcG9zLCBmcm9tLCB0bykge1xuICAgIHN3aXRjaCAoc2lkZSkge1xuICAgICAgICBjYXNlIC0yIC8qIEJlZm9yZSAqLzogcmV0dXJuIGZyb20gPCBwb3M7XG4gICAgICAgIGNhc2UgLTEgLyogQXRPckJlZm9yZSAqLzogcmV0dXJuIHRvID49IHBvcyAmJiBmcm9tIDwgcG9zO1xuICAgICAgICBjYXNlIDAgLyogQXJvdW5kICovOiByZXR1cm4gZnJvbSA8IHBvcyAmJiB0byA+IHBvcztcbiAgICAgICAgY2FzZSAxIC8qIEF0T3JBZnRlciAqLzogcmV0dXJuIGZyb20gPD0gcG9zICYmIHRvID4gcG9zO1xuICAgICAgICBjYXNlIDIgLyogQWZ0ZXIgKi86IHJldHVybiB0byA+IHBvcztcbiAgICAgICAgY2FzZSA0IC8qIERvbnRDYXJlICovOiByZXR1cm4gdHJ1ZTtcbiAgICB9XG59XG5mdW5jdGlvbiBlbnRlclVuZmluaXNoZWROb2Rlc0JlZm9yZShub2RlLCBwb3MpIHtcbiAgICBsZXQgc2NhbiA9IG5vZGUuY2hpbGRCZWZvcmUocG9zKTtcbiAgICB3aGlsZSAoc2Nhbikge1xuICAgICAgICBsZXQgbGFzdCA9IHNjYW4ubGFzdENoaWxkO1xuICAgICAgICBpZiAoIWxhc3QgfHwgbGFzdC50byAhPSBzY2FuLnRvKVxuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIGlmIChsYXN0LnR5cGUuaXNFcnJvciAmJiBsYXN0LmZyb20gPT0gbGFzdC50bykge1xuICAgICAgICAgICAgbm9kZSA9IHNjYW47XG4gICAgICAgICAgICBzY2FuID0gbGFzdC5wcmV2U2libGluZztcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHNjYW4gPSBsYXN0O1xuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiBub2RlO1xufVxuZnVuY3Rpb24gcmVzb2x2ZU5vZGUobm9kZSwgcG9zLCBzaWRlLCBvdmVybGF5cykge1xuICAgIHZhciBfYTtcbiAgICAvLyBNb3ZlIHVwIHRvIGEgbm9kZSB0aGF0IGFjdHVhbGx5IGhvbGRzIHRoZSBwb3NpdGlvbiwgaWYgcG9zc2libGVcbiAgICB3aGlsZSAobm9kZS5mcm9tID09IG5vZGUudG8gfHxcbiAgICAgICAgKHNpZGUgPCAxID8gbm9kZS5mcm9tID49IHBvcyA6IG5vZGUuZnJvbSA+IHBvcykgfHxcbiAgICAgICAgKHNpZGUgPiAtMSA/IG5vZGUudG8gPD0gcG9zIDogbm9kZS50byA8IHBvcykpIHtcbiAgICAgICAgbGV0IHBhcmVudCA9ICFvdmVybGF5cyAmJiBub2RlIGluc3RhbmNlb2YgVHJlZU5vZGUgJiYgbm9kZS5pbmRleCA8IDAgPyBudWxsIDogbm9kZS5wYXJlbnQ7XG4gICAgICAgIGlmICghcGFyZW50KVxuICAgICAgICAgICAgcmV0dXJuIG5vZGU7XG4gICAgICAgIG5vZGUgPSBwYXJlbnQ7XG4gICAgfVxuICAgIGxldCBtb2RlID0gb3ZlcmxheXMgPyAwIDogZXhwb3J0cy5JdGVyTW9kZS5JZ25vcmVPdmVybGF5cztcbiAgICAvLyBNdXN0IGdvIHVwIG91dCBvZiBvdmVybGF5cyB3aGVuIHRob3NlIGRvIG5vdCBvdmVybGFwIHdpdGggcG9zXG4gICAgaWYgKG92ZXJsYXlzKVxuICAgICAgICBmb3IgKGxldCBzY2FuID0gbm9kZSwgcGFyZW50ID0gc2Nhbi5wYXJlbnQ7IHBhcmVudDsgc2NhbiA9IHBhcmVudCwgcGFyZW50ID0gc2Nhbi5wYXJlbnQpIHtcbiAgICAgICAgICAgIGlmIChzY2FuIGluc3RhbmNlb2YgVHJlZU5vZGUgJiYgc2Nhbi5pbmRleCA8IDAgJiYgKChfYSA9IHBhcmVudC5lbnRlcihwb3MsIHNpZGUsIG1vZGUpKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EuZnJvbSkgIT0gc2Nhbi5mcm9tKVxuICAgICAgICAgICAgICAgIG5vZGUgPSBwYXJlbnQ7XG4gICAgICAgIH1cbiAgICBmb3IgKDs7KSB7XG4gICAgICAgIGxldCBpbm5lciA9IG5vZGUuZW50ZXIocG9zLCBzaWRlLCBtb2RlKTtcbiAgICAgICAgaWYgKCFpbm5lcilcbiAgICAgICAgICAgIHJldHVybiBub2RlO1xuICAgICAgICBub2RlID0gaW5uZXI7XG4gICAgfVxufVxuY2xhc3MgVHJlZU5vZGUge1xuICAgIGNvbnN0cnVjdG9yKF90cmVlLCBmcm9tLCBcbiAgICAvLyBJbmRleCBpbiBwYXJlbnQgbm9kZSwgc2V0IHRvIC0xIGlmIHRoZSBub2RlIGlzIG5vdCBhIGRpcmVjdCBjaGlsZCBvZiBfcGFyZW50Lm5vZGUgKG92ZXJsYXkpXG4gICAgaW5kZXgsIF9wYXJlbnQpIHtcbiAgICAgICAgdGhpcy5fdHJlZSA9IF90cmVlO1xuICAgICAgICB0aGlzLmZyb20gPSBmcm9tO1xuICAgICAgICB0aGlzLmluZGV4ID0gaW5kZXg7XG4gICAgICAgIHRoaXMuX3BhcmVudCA9IF9wYXJlbnQ7XG4gICAgfVxuICAgIGdldCB0eXBlKCkgeyByZXR1cm4gdGhpcy5fdHJlZS50eXBlOyB9XG4gICAgZ2V0IG5hbWUoKSB7IHJldHVybiB0aGlzLl90cmVlLnR5cGUubmFtZTsgfVxuICAgIGdldCB0bygpIHsgcmV0dXJuIHRoaXMuZnJvbSArIHRoaXMuX3RyZWUubGVuZ3RoOyB9XG4gICAgbmV4dENoaWxkKGksIGRpciwgcG9zLCBzaWRlLCBtb2RlID0gMCkge1xuICAgICAgICBmb3IgKGxldCBwYXJlbnQgPSB0aGlzOzspIHtcbiAgICAgICAgICAgIGZvciAobGV0IHsgY2hpbGRyZW4sIHBvc2l0aW9ucyB9ID0gcGFyZW50Ll90cmVlLCBlID0gZGlyID4gMCA/IGNoaWxkcmVuLmxlbmd0aCA6IC0xOyBpICE9IGU7IGkgKz0gZGlyKSB7XG4gICAgICAgICAgICAgICAgbGV0IG5leHQgPSBjaGlsZHJlbltpXSwgc3RhcnQgPSBwb3NpdGlvbnNbaV0gKyBwYXJlbnQuZnJvbTtcbiAgICAgICAgICAgICAgICBpZiAoIWNoZWNrU2lkZShzaWRlLCBwb3MsIHN0YXJ0LCBzdGFydCArIG5leHQubGVuZ3RoKSlcbiAgICAgICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICAgICAgaWYgKG5leHQgaW5zdGFuY2VvZiBUcmVlQnVmZmVyKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChtb2RlICYgZXhwb3J0cy5JdGVyTW9kZS5FeGNsdWRlQnVmZmVycylcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgICAgICAgICBsZXQgaW5kZXggPSBuZXh0LmZpbmRDaGlsZCgwLCBuZXh0LmJ1ZmZlci5sZW5ndGgsIGRpciwgcG9zIC0gc3RhcnQsIHNpZGUpO1xuICAgICAgICAgICAgICAgICAgICBpZiAoaW5kZXggPiAtMSlcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBuZXcgQnVmZmVyTm9kZShuZXcgQnVmZmVyQ29udGV4dChwYXJlbnQsIG5leHQsIGksIHN0YXJ0KSwgbnVsbCwgaW5kZXgpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIGlmICgobW9kZSAmIGV4cG9ydHMuSXRlck1vZGUuSW5jbHVkZUFub255bW91cykgfHwgKCFuZXh0LnR5cGUuaXNBbm9ueW1vdXMgfHwgaGFzQ2hpbGQobmV4dCkpKSB7XG4gICAgICAgICAgICAgICAgICAgIGxldCBtb3VudGVkO1xuICAgICAgICAgICAgICAgICAgICBpZiAoIShtb2RlICYgZXhwb3J0cy5JdGVyTW9kZS5JZ25vcmVNb3VudHMpICYmXG4gICAgICAgICAgICAgICAgICAgICAgICBuZXh0LnByb3BzICYmIChtb3VudGVkID0gbmV4dC5wcm9wKE5vZGVQcm9wLm1vdW50ZWQpKSAmJiAhbW91bnRlZC5vdmVybGF5KVxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG5ldyBUcmVlTm9kZShtb3VudGVkLnRyZWUsIHN0YXJ0LCBpLCBwYXJlbnQpO1xuICAgICAgICAgICAgICAgICAgICBsZXQgaW5uZXIgPSBuZXcgVHJlZU5vZGUobmV4dCwgc3RhcnQsIGksIHBhcmVudCk7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiAobW9kZSAmIGV4cG9ydHMuSXRlck1vZGUuSW5jbHVkZUFub255bW91cykgfHwgIWlubmVyLnR5cGUuaXNBbm9ueW1vdXMgPyBpbm5lclxuICAgICAgICAgICAgICAgICAgICAgICAgOiBpbm5lci5uZXh0Q2hpbGQoZGlyIDwgMCA/IG5leHQuY2hpbGRyZW4ubGVuZ3RoIC0gMSA6IDAsIGRpciwgcG9zLCBzaWRlKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoKG1vZGUgJiBleHBvcnRzLkl0ZXJNb2RlLkluY2x1ZGVBbm9ueW1vdXMpIHx8ICFwYXJlbnQudHlwZS5pc0Fub255bW91cylcbiAgICAgICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgICAgIGlmIChwYXJlbnQuaW5kZXggPj0gMClcbiAgICAgICAgICAgICAgICBpID0gcGFyZW50LmluZGV4ICsgZGlyO1xuICAgICAgICAgICAgZWxzZVxuICAgICAgICAgICAgICAgIGkgPSBkaXIgPCAwID8gLTEgOiBwYXJlbnQuX3BhcmVudC5fdHJlZS5jaGlsZHJlbi5sZW5ndGg7XG4gICAgICAgICAgICBwYXJlbnQgPSBwYXJlbnQuX3BhcmVudDtcbiAgICAgICAgICAgIGlmICghcGFyZW50KVxuICAgICAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICB9XG4gICAgfVxuICAgIGdldCBmaXJzdENoaWxkKCkgeyByZXR1cm4gdGhpcy5uZXh0Q2hpbGQoMCwgMSwgMCwgNCAvKiBEb250Q2FyZSAqLyk7IH1cbiAgICBnZXQgbGFzdENoaWxkKCkgeyByZXR1cm4gdGhpcy5uZXh0Q2hpbGQodGhpcy5fdHJlZS5jaGlsZHJlbi5sZW5ndGggLSAxLCAtMSwgMCwgNCAvKiBEb250Q2FyZSAqLyk7IH1cbiAgICBjaGlsZEFmdGVyKHBvcykgeyByZXR1cm4gdGhpcy5uZXh0Q2hpbGQoMCwgMSwgcG9zLCAyIC8qIEFmdGVyICovKTsgfVxuICAgIGNoaWxkQmVmb3JlKHBvcykgeyByZXR1cm4gdGhpcy5uZXh0Q2hpbGQodGhpcy5fdHJlZS5jaGlsZHJlbi5sZW5ndGggLSAxLCAtMSwgcG9zLCAtMiAvKiBCZWZvcmUgKi8pOyB9XG4gICAgZW50ZXIocG9zLCBzaWRlLCBtb2RlID0gMCkge1xuICAgICAgICBsZXQgbW91bnRlZDtcbiAgICAgICAgaWYgKCEobW9kZSAmIGV4cG9ydHMuSXRlck1vZGUuSWdub3JlT3ZlcmxheXMpICYmIChtb3VudGVkID0gdGhpcy5fdHJlZS5wcm9wKE5vZGVQcm9wLm1vdW50ZWQpKSAmJiBtb3VudGVkLm92ZXJsYXkpIHtcbiAgICAgICAgICAgIGxldCByUG9zID0gcG9zIC0gdGhpcy5mcm9tO1xuICAgICAgICAgICAgZm9yIChsZXQgeyBmcm9tLCB0byB9IG9mIG1vdW50ZWQub3ZlcmxheSkge1xuICAgICAgICAgICAgICAgIGlmICgoc2lkZSA+IDAgPyBmcm9tIDw9IHJQb3MgOiBmcm9tIDwgclBvcykgJiZcbiAgICAgICAgICAgICAgICAgICAgKHNpZGUgPCAwID8gdG8gPj0gclBvcyA6IHRvID4gclBvcykpXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBuZXcgVHJlZU5vZGUobW91bnRlZC50cmVlLCBtb3VudGVkLm92ZXJsYXlbMF0uZnJvbSArIHRoaXMuZnJvbSwgLTEsIHRoaXMpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aGlzLm5leHRDaGlsZCgwLCAxLCBwb3MsIHNpZGUsIG1vZGUpO1xuICAgIH1cbiAgICBuZXh0U2lnbmlmaWNhbnRQYXJlbnQoKSB7XG4gICAgICAgIGxldCB2YWwgPSB0aGlzO1xuICAgICAgICB3aGlsZSAodmFsLnR5cGUuaXNBbm9ueW1vdXMgJiYgdmFsLl9wYXJlbnQpXG4gICAgICAgICAgICB2YWwgPSB2YWwuX3BhcmVudDtcbiAgICAgICAgcmV0dXJuIHZhbDtcbiAgICB9XG4gICAgZ2V0IHBhcmVudCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX3BhcmVudCA/IHRoaXMuX3BhcmVudC5uZXh0U2lnbmlmaWNhbnRQYXJlbnQoKSA6IG51bGw7XG4gICAgfVxuICAgIGdldCBuZXh0U2libGluZygpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX3BhcmVudCAmJiB0aGlzLmluZGV4ID49IDAgPyB0aGlzLl9wYXJlbnQubmV4dENoaWxkKHRoaXMuaW5kZXggKyAxLCAxLCAwLCA0IC8qIERvbnRDYXJlICovKSA6IG51bGw7XG4gICAgfVxuICAgIGdldCBwcmV2U2libGluZygpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX3BhcmVudCAmJiB0aGlzLmluZGV4ID49IDAgPyB0aGlzLl9wYXJlbnQubmV4dENoaWxkKHRoaXMuaW5kZXggLSAxLCAtMSwgMCwgNCAvKiBEb250Q2FyZSAqLykgOiBudWxsO1xuICAgIH1cbiAgICBjdXJzb3IobW9kZSA9IDApIHsgcmV0dXJuIG5ldyBUcmVlQ3Vyc29yKHRoaXMsIG1vZGUpOyB9XG4gICAgZ2V0IHRyZWUoKSB7IHJldHVybiB0aGlzLl90cmVlOyB9XG4gICAgdG9UcmVlKCkgeyByZXR1cm4gdGhpcy5fdHJlZTsgfVxuICAgIHJlc29sdmUocG9zLCBzaWRlID0gMCkge1xuICAgICAgICByZXR1cm4gcmVzb2x2ZU5vZGUodGhpcywgcG9zLCBzaWRlLCBmYWxzZSk7XG4gICAgfVxuICAgIHJlc29sdmVJbm5lcihwb3MsIHNpZGUgPSAwKSB7XG4gICAgICAgIHJldHVybiByZXNvbHZlTm9kZSh0aGlzLCBwb3MsIHNpZGUsIHRydWUpO1xuICAgIH1cbiAgICBlbnRlclVuZmluaXNoZWROb2Rlc0JlZm9yZShwb3MpIHsgcmV0dXJuIGVudGVyVW5maW5pc2hlZE5vZGVzQmVmb3JlKHRoaXMsIHBvcyk7IH1cbiAgICBnZXRDaGlsZCh0eXBlLCBiZWZvcmUgPSBudWxsLCBhZnRlciA9IG51bGwpIHtcbiAgICAgICAgbGV0IHIgPSBnZXRDaGlsZHJlbih0aGlzLCB0eXBlLCBiZWZvcmUsIGFmdGVyKTtcbiAgICAgICAgcmV0dXJuIHIubGVuZ3RoID8gclswXSA6IG51bGw7XG4gICAgfVxuICAgIGdldENoaWxkcmVuKHR5cGUsIGJlZm9yZSA9IG51bGwsIGFmdGVyID0gbnVsbCkge1xuICAgICAgICByZXR1cm4gZ2V0Q2hpbGRyZW4odGhpcywgdHlwZSwgYmVmb3JlLCBhZnRlcik7XG4gICAgfVxuICAgIC8vLyBAaW50ZXJuYWxcbiAgICB0b1N0cmluZygpIHsgcmV0dXJuIHRoaXMuX3RyZWUudG9TdHJpbmcoKTsgfVxuICAgIGdldCBub2RlKCkgeyByZXR1cm4gdGhpczsgfVxuICAgIG1hdGNoQ29udGV4dChjb250ZXh0KSB7IHJldHVybiBtYXRjaE5vZGVDb250ZXh0KHRoaXMsIGNvbnRleHQpOyB9XG59XG5mdW5jdGlvbiBnZXRDaGlsZHJlbihub2RlLCB0eXBlLCBiZWZvcmUsIGFmdGVyKSB7XG4gICAgbGV0IGN1ciA9IG5vZGUuY3Vyc29yKCksIHJlc3VsdCA9IFtdO1xuICAgIGlmICghY3VyLmZpcnN0Q2hpbGQoKSlcbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICBpZiAoYmVmb3JlICE9IG51bGwpXG4gICAgICAgIHdoaWxlICghY3VyLnR5cGUuaXMoYmVmb3JlKSlcbiAgICAgICAgICAgIGlmICghY3VyLm5leHRTaWJsaW5nKCkpXG4gICAgICAgICAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICBmb3IgKDs7KSB7XG4gICAgICAgIGlmIChhZnRlciAhPSBudWxsICYmIGN1ci50eXBlLmlzKGFmdGVyKSlcbiAgICAgICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgICAgIGlmIChjdXIudHlwZS5pcyh0eXBlKSlcbiAgICAgICAgICAgIHJlc3VsdC5wdXNoKGN1ci5ub2RlKTtcbiAgICAgICAgaWYgKCFjdXIubmV4dFNpYmxpbmcoKSlcbiAgICAgICAgICAgIHJldHVybiBhZnRlciA9PSBudWxsID8gcmVzdWx0IDogW107XG4gICAgfVxufVxuZnVuY3Rpb24gbWF0Y2hOb2RlQ29udGV4dChub2RlLCBjb250ZXh0LCBpID0gY29udGV4dC5sZW5ndGggLSAxKSB7XG4gICAgZm9yIChsZXQgcCA9IG5vZGUucGFyZW50OyBpID49IDA7IHAgPSBwLnBhcmVudCkge1xuICAgICAgICBpZiAoIXApXG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIGlmICghcC50eXBlLmlzQW5vbnltb3VzKSB7XG4gICAgICAgICAgICBpZiAoY29udGV4dFtpXSAmJiBjb250ZXh0W2ldICE9IHAubmFtZSlcbiAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICBpLS07XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHRydWU7XG59XG5jbGFzcyBCdWZmZXJDb250ZXh0IHtcbiAgICBjb25zdHJ1Y3RvcihwYXJlbnQsIGJ1ZmZlciwgaW5kZXgsIHN0YXJ0KSB7XG4gICAgICAgIHRoaXMucGFyZW50ID0gcGFyZW50O1xuICAgICAgICB0aGlzLmJ1ZmZlciA9IGJ1ZmZlcjtcbiAgICAgICAgdGhpcy5pbmRleCA9IGluZGV4O1xuICAgICAgICB0aGlzLnN0YXJ0ID0gc3RhcnQ7XG4gICAgfVxufVxuY2xhc3MgQnVmZmVyTm9kZSB7XG4gICAgY29uc3RydWN0b3IoY29udGV4dCwgX3BhcmVudCwgaW5kZXgpIHtcbiAgICAgICAgdGhpcy5jb250ZXh0ID0gY29udGV4dDtcbiAgICAgICAgdGhpcy5fcGFyZW50ID0gX3BhcmVudDtcbiAgICAgICAgdGhpcy5pbmRleCA9IGluZGV4O1xuICAgICAgICB0aGlzLnR5cGUgPSBjb250ZXh0LmJ1ZmZlci5zZXQudHlwZXNbY29udGV4dC5idWZmZXIuYnVmZmVyW2luZGV4XV07XG4gICAgfVxuICAgIGdldCBuYW1lKCkgeyByZXR1cm4gdGhpcy50eXBlLm5hbWU7IH1cbiAgICBnZXQgZnJvbSgpIHsgcmV0dXJuIHRoaXMuY29udGV4dC5zdGFydCArIHRoaXMuY29udGV4dC5idWZmZXIuYnVmZmVyW3RoaXMuaW5kZXggKyAxXTsgfVxuICAgIGdldCB0bygpIHsgcmV0dXJuIHRoaXMuY29udGV4dC5zdGFydCArIHRoaXMuY29udGV4dC5idWZmZXIuYnVmZmVyW3RoaXMuaW5kZXggKyAyXTsgfVxuICAgIGNoaWxkKGRpciwgcG9zLCBzaWRlKSB7XG4gICAgICAgIGxldCB7IGJ1ZmZlciB9ID0gdGhpcy5jb250ZXh0O1xuICAgICAgICBsZXQgaW5kZXggPSBidWZmZXIuZmluZENoaWxkKHRoaXMuaW5kZXggKyA0LCBidWZmZXIuYnVmZmVyW3RoaXMuaW5kZXggKyAzXSwgZGlyLCBwb3MgLSB0aGlzLmNvbnRleHQuc3RhcnQsIHNpZGUpO1xuICAgICAgICByZXR1cm4gaW5kZXggPCAwID8gbnVsbCA6IG5ldyBCdWZmZXJOb2RlKHRoaXMuY29udGV4dCwgdGhpcywgaW5kZXgpO1xuICAgIH1cbiAgICBnZXQgZmlyc3RDaGlsZCgpIHsgcmV0dXJuIHRoaXMuY2hpbGQoMSwgMCwgNCAvKiBEb250Q2FyZSAqLyk7IH1cbiAgICBnZXQgbGFzdENoaWxkKCkgeyByZXR1cm4gdGhpcy5jaGlsZCgtMSwgMCwgNCAvKiBEb250Q2FyZSAqLyk7IH1cbiAgICBjaGlsZEFmdGVyKHBvcykgeyByZXR1cm4gdGhpcy5jaGlsZCgxLCBwb3MsIDIgLyogQWZ0ZXIgKi8pOyB9XG4gICAgY2hpbGRCZWZvcmUocG9zKSB7IHJldHVybiB0aGlzLmNoaWxkKC0xLCBwb3MsIC0yIC8qIEJlZm9yZSAqLyk7IH1cbiAgICBlbnRlcihwb3MsIHNpZGUsIG1vZGUgPSAwKSB7XG4gICAgICAgIGlmIChtb2RlICYgZXhwb3J0cy5JdGVyTW9kZS5FeGNsdWRlQnVmZmVycylcbiAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICBsZXQgeyBidWZmZXIgfSA9IHRoaXMuY29udGV4dDtcbiAgICAgICAgbGV0IGluZGV4ID0gYnVmZmVyLmZpbmRDaGlsZCh0aGlzLmluZGV4ICsgNCwgYnVmZmVyLmJ1ZmZlclt0aGlzLmluZGV4ICsgM10sIHNpZGUgPiAwID8gMSA6IC0xLCBwb3MgLSB0aGlzLmNvbnRleHQuc3RhcnQsIHNpZGUpO1xuICAgICAgICByZXR1cm4gaW5kZXggPCAwID8gbnVsbCA6IG5ldyBCdWZmZXJOb2RlKHRoaXMuY29udGV4dCwgdGhpcywgaW5kZXgpO1xuICAgIH1cbiAgICBnZXQgcGFyZW50KCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fcGFyZW50IHx8IHRoaXMuY29udGV4dC5wYXJlbnQubmV4dFNpZ25pZmljYW50UGFyZW50KCk7XG4gICAgfVxuICAgIGV4dGVybmFsU2libGluZyhkaXIpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX3BhcmVudCA/IG51bGwgOiB0aGlzLmNvbnRleHQucGFyZW50Lm5leHRDaGlsZCh0aGlzLmNvbnRleHQuaW5kZXggKyBkaXIsIGRpciwgMCwgNCAvKiBEb250Q2FyZSAqLyk7XG4gICAgfVxuICAgIGdldCBuZXh0U2libGluZygpIHtcbiAgICAgICAgbGV0IHsgYnVmZmVyIH0gPSB0aGlzLmNvbnRleHQ7XG4gICAgICAgIGxldCBhZnRlciA9IGJ1ZmZlci5idWZmZXJbdGhpcy5pbmRleCArIDNdO1xuICAgICAgICBpZiAoYWZ0ZXIgPCAodGhpcy5fcGFyZW50ID8gYnVmZmVyLmJ1ZmZlclt0aGlzLl9wYXJlbnQuaW5kZXggKyAzXSA6IGJ1ZmZlci5idWZmZXIubGVuZ3RoKSlcbiAgICAgICAgICAgIHJldHVybiBuZXcgQnVmZmVyTm9kZSh0aGlzLmNvbnRleHQsIHRoaXMuX3BhcmVudCwgYWZ0ZXIpO1xuICAgICAgICByZXR1cm4gdGhpcy5leHRlcm5hbFNpYmxpbmcoMSk7XG4gICAgfVxuICAgIGdldCBwcmV2U2libGluZygpIHtcbiAgICAgICAgbGV0IHsgYnVmZmVyIH0gPSB0aGlzLmNvbnRleHQ7XG4gICAgICAgIGxldCBwYXJlbnRTdGFydCA9IHRoaXMuX3BhcmVudCA/IHRoaXMuX3BhcmVudC5pbmRleCArIDQgOiAwO1xuICAgICAgICBpZiAodGhpcy5pbmRleCA9PSBwYXJlbnRTdGFydClcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmV4dGVybmFsU2libGluZygtMSk7XG4gICAgICAgIHJldHVybiBuZXcgQnVmZmVyTm9kZSh0aGlzLmNvbnRleHQsIHRoaXMuX3BhcmVudCwgYnVmZmVyLmZpbmRDaGlsZChwYXJlbnRTdGFydCwgdGhpcy5pbmRleCwgLTEsIDAsIDQgLyogRG9udENhcmUgKi8pKTtcbiAgICB9XG4gICAgY3Vyc29yKG1vZGUgPSAwKSB7IHJldHVybiBuZXcgVHJlZUN1cnNvcih0aGlzLCBtb2RlKTsgfVxuICAgIGdldCB0cmVlKCkgeyByZXR1cm4gbnVsbDsgfVxuICAgIHRvVHJlZSgpIHtcbiAgICAgICAgbGV0IGNoaWxkcmVuID0gW10sIHBvc2l0aW9ucyA9IFtdO1xuICAgICAgICBsZXQgeyBidWZmZXIgfSA9IHRoaXMuY29udGV4dDtcbiAgICAgICAgbGV0IHN0YXJ0SSA9IHRoaXMuaW5kZXggKyA0LCBlbmRJID0gYnVmZmVyLmJ1ZmZlclt0aGlzLmluZGV4ICsgM107XG4gICAgICAgIGlmIChlbmRJID4gc3RhcnRJKSB7XG4gICAgICAgICAgICBsZXQgZnJvbSA9IGJ1ZmZlci5idWZmZXJbdGhpcy5pbmRleCArIDFdLCB0byA9IGJ1ZmZlci5idWZmZXJbdGhpcy5pbmRleCArIDJdO1xuICAgICAgICAgICAgY2hpbGRyZW4ucHVzaChidWZmZXIuc2xpY2Uoc3RhcnRJLCBlbmRJLCBmcm9tLCB0bykpO1xuICAgICAgICAgICAgcG9zaXRpb25zLnB1c2goMCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG5ldyBUcmVlKHRoaXMudHlwZSwgY2hpbGRyZW4sIHBvc2l0aW9ucywgdGhpcy50byAtIHRoaXMuZnJvbSk7XG4gICAgfVxuICAgIHJlc29sdmUocG9zLCBzaWRlID0gMCkge1xuICAgICAgICByZXR1cm4gcmVzb2x2ZU5vZGUodGhpcywgcG9zLCBzaWRlLCBmYWxzZSk7XG4gICAgfVxuICAgIHJlc29sdmVJbm5lcihwb3MsIHNpZGUgPSAwKSB7XG4gICAgICAgIHJldHVybiByZXNvbHZlTm9kZSh0aGlzLCBwb3MsIHNpZGUsIHRydWUpO1xuICAgIH1cbiAgICBlbnRlclVuZmluaXNoZWROb2Rlc0JlZm9yZShwb3MpIHsgcmV0dXJuIGVudGVyVW5maW5pc2hlZE5vZGVzQmVmb3JlKHRoaXMsIHBvcyk7IH1cbiAgICAvLy8gQGludGVybmFsXG4gICAgdG9TdHJpbmcoKSB7IHJldHVybiB0aGlzLmNvbnRleHQuYnVmZmVyLmNoaWxkU3RyaW5nKHRoaXMuaW5kZXgpOyB9XG4gICAgZ2V0Q2hpbGQodHlwZSwgYmVmb3JlID0gbnVsbCwgYWZ0ZXIgPSBudWxsKSB7XG4gICAgICAgIGxldCByID0gZ2V0Q2hpbGRyZW4odGhpcywgdHlwZSwgYmVmb3JlLCBhZnRlcik7XG4gICAgICAgIHJldHVybiByLmxlbmd0aCA/IHJbMF0gOiBudWxsO1xuICAgIH1cbiAgICBnZXRDaGlsZHJlbih0eXBlLCBiZWZvcmUgPSBudWxsLCBhZnRlciA9IG51bGwpIHtcbiAgICAgICAgcmV0dXJuIGdldENoaWxkcmVuKHRoaXMsIHR5cGUsIGJlZm9yZSwgYWZ0ZXIpO1xuICAgIH1cbiAgICBnZXQgbm9kZSgpIHsgcmV0dXJuIHRoaXM7IH1cbiAgICBtYXRjaENvbnRleHQoY29udGV4dCkgeyByZXR1cm4gbWF0Y2hOb2RlQ29udGV4dCh0aGlzLCBjb250ZXh0KTsgfVxufVxuLy8vIEEgdHJlZSBjdXJzb3Igb2JqZWN0IGZvY3VzZXMgb24gYSBnaXZlbiBub2RlIGluIGEgc3ludGF4IHRyZWUsIGFuZFxuLy8vIGFsbG93cyB5b3UgdG8gbW92ZSB0byBhZGphY2VudCBub2Rlcy5cbmNsYXNzIFRyZWVDdXJzb3Ige1xuICAgIC8vLyBAaW50ZXJuYWxcbiAgICBjb25zdHJ1Y3Rvcihub2RlLCBcbiAgICAvLy8gQGludGVybmFsXG4gICAgbW9kZSA9IDApIHtcbiAgICAgICAgdGhpcy5tb2RlID0gbW9kZTtcbiAgICAgICAgLy8vIEBpbnRlcm5hbFxuICAgICAgICB0aGlzLmJ1ZmZlciA9IG51bGw7XG4gICAgICAgIHRoaXMuc3RhY2sgPSBbXTtcbiAgICAgICAgLy8vIEBpbnRlcm5hbFxuICAgICAgICB0aGlzLmluZGV4ID0gMDtcbiAgICAgICAgdGhpcy5idWZmZXJOb2RlID0gbnVsbDtcbiAgICAgICAgaWYgKG5vZGUgaW5zdGFuY2VvZiBUcmVlTm9kZSkge1xuICAgICAgICAgICAgdGhpcy55aWVsZE5vZGUobm9kZSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB0aGlzLl90cmVlID0gbm9kZS5jb250ZXh0LnBhcmVudDtcbiAgICAgICAgICAgIHRoaXMuYnVmZmVyID0gbm9kZS5jb250ZXh0O1xuICAgICAgICAgICAgZm9yIChsZXQgbiA9IG5vZGUuX3BhcmVudDsgbjsgbiA9IG4uX3BhcmVudClcbiAgICAgICAgICAgICAgICB0aGlzLnN0YWNrLnVuc2hpZnQobi5pbmRleCk7XG4gICAgICAgICAgICB0aGlzLmJ1ZmZlck5vZGUgPSBub2RlO1xuICAgICAgICAgICAgdGhpcy55aWVsZEJ1Zihub2RlLmluZGV4KTtcbiAgICAgICAgfVxuICAgIH1cbiAgICAvLy8gU2hvcnRoYW5kIGZvciBgLnR5cGUubmFtZWAuXG4gICAgZ2V0IG5hbWUoKSB7IHJldHVybiB0aGlzLnR5cGUubmFtZTsgfVxuICAgIHlpZWxkTm9kZShub2RlKSB7XG4gICAgICAgIGlmICghbm9kZSlcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgdGhpcy5fdHJlZSA9IG5vZGU7XG4gICAgICAgIHRoaXMudHlwZSA9IG5vZGUudHlwZTtcbiAgICAgICAgdGhpcy5mcm9tID0gbm9kZS5mcm9tO1xuICAgICAgICB0aGlzLnRvID0gbm9kZS50bztcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICAgIHlpZWxkQnVmKGluZGV4LCB0eXBlKSB7XG4gICAgICAgIHRoaXMuaW5kZXggPSBpbmRleDtcbiAgICAgICAgbGV0IHsgc3RhcnQsIGJ1ZmZlciB9ID0gdGhpcy5idWZmZXI7XG4gICAgICAgIHRoaXMudHlwZSA9IHR5cGUgfHwgYnVmZmVyLnNldC50eXBlc1tidWZmZXIuYnVmZmVyW2luZGV4XV07XG4gICAgICAgIHRoaXMuZnJvbSA9IHN0YXJ0ICsgYnVmZmVyLmJ1ZmZlcltpbmRleCArIDFdO1xuICAgICAgICB0aGlzLnRvID0gc3RhcnQgKyBidWZmZXIuYnVmZmVyW2luZGV4ICsgMl07XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgICB5aWVsZChub2RlKSB7XG4gICAgICAgIGlmICghbm9kZSlcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgaWYgKG5vZGUgaW5zdGFuY2VvZiBUcmVlTm9kZSkge1xuICAgICAgICAgICAgdGhpcy5idWZmZXIgPSBudWxsO1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMueWllbGROb2RlKG5vZGUpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuYnVmZmVyID0gbm9kZS5jb250ZXh0O1xuICAgICAgICByZXR1cm4gdGhpcy55aWVsZEJ1Zihub2RlLmluZGV4LCBub2RlLnR5cGUpO1xuICAgIH1cbiAgICAvLy8gQGludGVybmFsXG4gICAgdG9TdHJpbmcoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmJ1ZmZlciA/IHRoaXMuYnVmZmVyLmJ1ZmZlci5jaGlsZFN0cmluZyh0aGlzLmluZGV4KSA6IHRoaXMuX3RyZWUudG9TdHJpbmcoKTtcbiAgICB9XG4gICAgLy8vIEBpbnRlcm5hbFxuICAgIGVudGVyQ2hpbGQoZGlyLCBwb3MsIHNpZGUpIHtcbiAgICAgICAgaWYgKCF0aGlzLmJ1ZmZlcilcbiAgICAgICAgICAgIHJldHVybiB0aGlzLnlpZWxkKHRoaXMuX3RyZWUubmV4dENoaWxkKGRpciA8IDAgPyB0aGlzLl90cmVlLl90cmVlLmNoaWxkcmVuLmxlbmd0aCAtIDEgOiAwLCBkaXIsIHBvcywgc2lkZSwgdGhpcy5tb2RlKSk7XG4gICAgICAgIGxldCB7IGJ1ZmZlciB9ID0gdGhpcy5idWZmZXI7XG4gICAgICAgIGxldCBpbmRleCA9IGJ1ZmZlci5maW5kQ2hpbGQodGhpcy5pbmRleCArIDQsIGJ1ZmZlci5idWZmZXJbdGhpcy5pbmRleCArIDNdLCBkaXIsIHBvcyAtIHRoaXMuYnVmZmVyLnN0YXJ0LCBzaWRlKTtcbiAgICAgICAgaWYgKGluZGV4IDwgMClcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgdGhpcy5zdGFjay5wdXNoKHRoaXMuaW5kZXgpO1xuICAgICAgICByZXR1cm4gdGhpcy55aWVsZEJ1ZihpbmRleCk7XG4gICAgfVxuICAgIC8vLyBNb3ZlIHRoZSBjdXJzb3IgdG8gdGhpcyBub2RlJ3MgZmlyc3QgY2hpbGQuIFdoZW4gdGhpcyByZXR1cm5zXG4gICAgLy8vIGZhbHNlLCB0aGUgbm9kZSBoYXMgbm8gY2hpbGQsIGFuZCB0aGUgY3Vyc29yIGhhcyBub3QgYmVlbiBtb3ZlZC5cbiAgICBmaXJzdENoaWxkKCkgeyByZXR1cm4gdGhpcy5lbnRlckNoaWxkKDEsIDAsIDQgLyogRG9udENhcmUgKi8pOyB9XG4gICAgLy8vIE1vdmUgdGhlIGN1cnNvciB0byB0aGlzIG5vZGUncyBsYXN0IGNoaWxkLlxuICAgIGxhc3RDaGlsZCgpIHsgcmV0dXJuIHRoaXMuZW50ZXJDaGlsZCgtMSwgMCwgNCAvKiBEb250Q2FyZSAqLyk7IH1cbiAgICAvLy8gTW92ZSB0aGUgY3Vyc29yIHRvIHRoZSBmaXJzdCBjaGlsZCB0aGF0IGVuZHMgYWZ0ZXIgYHBvc2AuXG4gICAgY2hpbGRBZnRlcihwb3MpIHsgcmV0dXJuIHRoaXMuZW50ZXJDaGlsZCgxLCBwb3MsIDIgLyogQWZ0ZXIgKi8pOyB9XG4gICAgLy8vIE1vdmUgdG8gdGhlIGxhc3QgY2hpbGQgdGhhdCBzdGFydHMgYmVmb3JlIGBwb3NgLlxuICAgIGNoaWxkQmVmb3JlKHBvcykgeyByZXR1cm4gdGhpcy5lbnRlckNoaWxkKC0xLCBwb3MsIC0yIC8qIEJlZm9yZSAqLyk7IH1cbiAgICAvLy8gTW92ZSB0aGUgY3Vyc29yIHRvIHRoZSBjaGlsZCBhcm91bmQgYHBvc2AuIElmIHNpZGUgaXMgLTEgdGhlXG4gICAgLy8vIGNoaWxkIG1heSBlbmQgYXQgdGhhdCBwb3NpdGlvbiwgd2hlbiAxIGl0IG1heSBzdGFydCB0aGVyZS4gVGhpc1xuICAgIC8vLyB3aWxsIGFsc28gZW50ZXIgW292ZXJsYWlkXSgjY29tbW9uLk1vdW50ZWRUcmVlLm92ZXJsYXkpXG4gICAgLy8vIFttb3VudGVkXSgjY29tbW9uLk5vZGVQcm9wXm1vdW50ZWQpIHRyZWVzIHVubGVzcyBgb3ZlcmxheXNgIGlzXG4gICAgLy8vIHNldCB0byBmYWxzZS5cbiAgICBlbnRlcihwb3MsIHNpZGUsIG1vZGUgPSB0aGlzLm1vZGUpIHtcbiAgICAgICAgaWYgKCF0aGlzLmJ1ZmZlcilcbiAgICAgICAgICAgIHJldHVybiB0aGlzLnlpZWxkKHRoaXMuX3RyZWUuZW50ZXIocG9zLCBzaWRlLCBtb2RlKSk7XG4gICAgICAgIHJldHVybiBtb2RlICYgZXhwb3J0cy5JdGVyTW9kZS5FeGNsdWRlQnVmZmVycyA/IGZhbHNlIDogdGhpcy5lbnRlckNoaWxkKDEsIHBvcywgc2lkZSk7XG4gICAgfVxuICAgIC8vLyBNb3ZlIHRvIHRoZSBub2RlJ3MgcGFyZW50IG5vZGUsIGlmIHRoaXMgaXNuJ3QgdGhlIHRvcCBub2RlLlxuICAgIHBhcmVudCgpIHtcbiAgICAgICAgaWYgKCF0aGlzLmJ1ZmZlcilcbiAgICAgICAgICAgIHJldHVybiB0aGlzLnlpZWxkTm9kZSgodGhpcy5tb2RlICYgZXhwb3J0cy5JdGVyTW9kZS5JbmNsdWRlQW5vbnltb3VzKSA/IHRoaXMuX3RyZWUuX3BhcmVudCA6IHRoaXMuX3RyZWUucGFyZW50KTtcbiAgICAgICAgaWYgKHRoaXMuc3RhY2subGVuZ3RoKVxuICAgICAgICAgICAgcmV0dXJuIHRoaXMueWllbGRCdWYodGhpcy5zdGFjay5wb3AoKSk7XG4gICAgICAgIGxldCBwYXJlbnQgPSAodGhpcy5tb2RlICYgZXhwb3J0cy5JdGVyTW9kZS5JbmNsdWRlQW5vbnltb3VzKSA/IHRoaXMuYnVmZmVyLnBhcmVudCA6IHRoaXMuYnVmZmVyLnBhcmVudC5uZXh0U2lnbmlmaWNhbnRQYXJlbnQoKTtcbiAgICAgICAgdGhpcy5idWZmZXIgPSBudWxsO1xuICAgICAgICByZXR1cm4gdGhpcy55aWVsZE5vZGUocGFyZW50KTtcbiAgICB9XG4gICAgLy8vIEBpbnRlcm5hbFxuICAgIHNpYmxpbmcoZGlyKSB7XG4gICAgICAgIGlmICghdGhpcy5idWZmZXIpXG4gICAgICAgICAgICByZXR1cm4gIXRoaXMuX3RyZWUuX3BhcmVudCA/IGZhbHNlXG4gICAgICAgICAgICAgICAgOiB0aGlzLnlpZWxkKHRoaXMuX3RyZWUuaW5kZXggPCAwID8gbnVsbFxuICAgICAgICAgICAgICAgICAgICA6IHRoaXMuX3RyZWUuX3BhcmVudC5uZXh0Q2hpbGQodGhpcy5fdHJlZS5pbmRleCArIGRpciwgZGlyLCAwLCA0IC8qIERvbnRDYXJlICovLCB0aGlzLm1vZGUpKTtcbiAgICAgICAgbGV0IHsgYnVmZmVyIH0gPSB0aGlzLmJ1ZmZlciwgZCA9IHRoaXMuc3RhY2subGVuZ3RoIC0gMTtcbiAgICAgICAgaWYgKGRpciA8IDApIHtcbiAgICAgICAgICAgIGxldCBwYXJlbnRTdGFydCA9IGQgPCAwID8gMCA6IHRoaXMuc3RhY2tbZF0gKyA0O1xuICAgICAgICAgICAgaWYgKHRoaXMuaW5kZXggIT0gcGFyZW50U3RhcnQpXG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMueWllbGRCdWYoYnVmZmVyLmZpbmRDaGlsZChwYXJlbnRTdGFydCwgdGhpcy5pbmRleCwgLTEsIDAsIDQgLyogRG9udENhcmUgKi8pKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGxldCBhZnRlciA9IGJ1ZmZlci5idWZmZXJbdGhpcy5pbmRleCArIDNdO1xuICAgICAgICAgICAgaWYgKGFmdGVyIDwgKGQgPCAwID8gYnVmZmVyLmJ1ZmZlci5sZW5ndGggOiBidWZmZXIuYnVmZmVyW3RoaXMuc3RhY2tbZF0gKyAzXSkpXG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMueWllbGRCdWYoYWZ0ZXIpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBkIDwgMCA/IHRoaXMueWllbGQodGhpcy5idWZmZXIucGFyZW50Lm5leHRDaGlsZCh0aGlzLmJ1ZmZlci5pbmRleCArIGRpciwgZGlyLCAwLCA0IC8qIERvbnRDYXJlICovLCB0aGlzLm1vZGUpKSA6IGZhbHNlO1xuICAgIH1cbiAgICAvLy8gTW92ZSB0byB0aGlzIG5vZGUncyBuZXh0IHNpYmxpbmcsIGlmIGFueS5cbiAgICBuZXh0U2libGluZygpIHsgcmV0dXJuIHRoaXMuc2libGluZygxKTsgfVxuICAgIC8vLyBNb3ZlIHRvIHRoaXMgbm9kZSdzIHByZXZpb3VzIHNpYmxpbmcsIGlmIGFueS5cbiAgICBwcmV2U2libGluZygpIHsgcmV0dXJuIHRoaXMuc2libGluZygtMSk7IH1cbiAgICBhdExhc3ROb2RlKGRpcikge1xuICAgICAgICBsZXQgaW5kZXgsIHBhcmVudCwgeyBidWZmZXIgfSA9IHRoaXM7XG4gICAgICAgIGlmIChidWZmZXIpIHtcbiAgICAgICAgICAgIGlmIChkaXIgPiAwKSB7XG4gICAgICAgICAgICAgICAgaWYgKHRoaXMuaW5kZXggPCBidWZmZXIuYnVmZmVyLmJ1ZmZlci5sZW5ndGgpXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgdGhpcy5pbmRleDsgaSsrKVxuICAgICAgICAgICAgICAgICAgICBpZiAoYnVmZmVyLmJ1ZmZlci5idWZmZXJbaSArIDNdIDwgdGhpcy5pbmRleClcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgICh7IGluZGV4LCBwYXJlbnQgfSA9IGJ1ZmZlcik7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAoeyBpbmRleCwgX3BhcmVudDogcGFyZW50IH0gPSB0aGlzLl90cmVlKTtcbiAgICAgICAgfVxuICAgICAgICBmb3IgKDsgcGFyZW50OyB7IGluZGV4LCBfcGFyZW50OiBwYXJlbnQgfSA9IHBhcmVudCkge1xuICAgICAgICAgICAgaWYgKGluZGV4ID4gLTEpXG4gICAgICAgICAgICAgICAgZm9yIChsZXQgaSA9IGluZGV4ICsgZGlyLCBlID0gZGlyIDwgMCA/IC0xIDogcGFyZW50Ll90cmVlLmNoaWxkcmVuLmxlbmd0aDsgaSAhPSBlOyBpICs9IGRpcikge1xuICAgICAgICAgICAgICAgICAgICBsZXQgY2hpbGQgPSBwYXJlbnQuX3RyZWUuY2hpbGRyZW5baV07XG4gICAgICAgICAgICAgICAgICAgIGlmICgodGhpcy5tb2RlICYgZXhwb3J0cy5JdGVyTW9kZS5JbmNsdWRlQW5vbnltb3VzKSB8fFxuICAgICAgICAgICAgICAgICAgICAgICAgY2hpbGQgaW5zdGFuY2VvZiBUcmVlQnVmZmVyIHx8XG4gICAgICAgICAgICAgICAgICAgICAgICAhY2hpbGQudHlwZS5pc0Fub255bW91cyB8fFxuICAgICAgICAgICAgICAgICAgICAgICAgaGFzQ2hpbGQoY2hpbGQpKVxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gICAgbW92ZShkaXIsIGVudGVyKSB7XG4gICAgICAgIGlmIChlbnRlciAmJiB0aGlzLmVudGVyQ2hpbGQoZGlyLCAwLCA0IC8qIERvbnRDYXJlICovKSlcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICBmb3IgKDs7KSB7XG4gICAgICAgICAgICBpZiAodGhpcy5zaWJsaW5nKGRpcikpXG4gICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgICAgICBpZiAodGhpcy5hdExhc3ROb2RlKGRpcikgfHwgIXRoaXMucGFyZW50KCkpXG4gICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgfVxuICAgIC8vLyBNb3ZlIHRvIHRoZSBuZXh0IG5vZGUgaW4gYVxuICAgIC8vLyBbcHJlLW9yZGVyXShodHRwczovL2VuLndpa2lwZWRpYS5vcmcvd2lraS9UcmVlX3RyYXZlcnNhbCNQcmUtb3JkZXJfKE5MUikpXG4gICAgLy8vIHRyYXZlcnNhbCwgZ29pbmcgZnJvbSBhIG5vZGUgdG8gaXRzIGZpcnN0IGNoaWxkIG9yLCBpZiB0aGVcbiAgICAvLy8gY3VycmVudCBub2RlIGlzIGVtcHR5IG9yIGBlbnRlcmAgaXMgZmFsc2UsIGl0cyBuZXh0IHNpYmxpbmcgb3JcbiAgICAvLy8gdGhlIG5leHQgc2libGluZyBvZiB0aGUgZmlyc3QgcGFyZW50IG5vZGUgdGhhdCBoYXMgb25lLlxuICAgIG5leHQoZW50ZXIgPSB0cnVlKSB7IHJldHVybiB0aGlzLm1vdmUoMSwgZW50ZXIpOyB9XG4gICAgLy8vIE1vdmUgdG8gdGhlIG5leHQgbm9kZSBpbiBhIGxhc3QtdG8tZmlyc3QgcHJlLW9yZGVyIHRyYXZlcmFsLiBBXG4gICAgLy8vIG5vZGUgaXMgZm9sbG93ZWQgYnkgaXRzIGxhc3QgY2hpbGQgb3IsIGlmIGl0IGhhcyBub25lLCBpdHNcbiAgICAvLy8gcHJldmlvdXMgc2libGluZyBvciB0aGUgcHJldmlvdXMgc2libGluZyBvZiB0aGUgZmlyc3QgcGFyZW50XG4gICAgLy8vIG5vZGUgdGhhdCBoYXMgb25lLlxuICAgIHByZXYoZW50ZXIgPSB0cnVlKSB7IHJldHVybiB0aGlzLm1vdmUoLTEsIGVudGVyKTsgfVxuICAgIC8vLyBNb3ZlIHRoZSBjdXJzb3IgdG8gdGhlIGlubmVybW9zdCBub2RlIHRoYXQgY292ZXJzIGBwb3NgLiBJZlxuICAgIC8vLyBgc2lkZWAgaXMgLTEsIGl0IHdpbGwgZW50ZXIgbm9kZXMgdGhhdCBlbmQgYXQgYHBvc2AuIElmIGl0IGlzIDEsXG4gICAgLy8vIGl0IHdpbGwgZW50ZXIgbm9kZXMgdGhhdCBzdGFydCBhdCBgcG9zYC5cbiAgICBtb3ZlVG8ocG9zLCBzaWRlID0gMCkge1xuICAgICAgICAvLyBNb3ZlIHVwIHRvIGEgbm9kZSB0aGF0IGFjdHVhbGx5IGhvbGRzIHRoZSBwb3NpdGlvbiwgaWYgcG9zc2libGVcbiAgICAgICAgd2hpbGUgKHRoaXMuZnJvbSA9PSB0aGlzLnRvIHx8XG4gICAgICAgICAgICAoc2lkZSA8IDEgPyB0aGlzLmZyb20gPj0gcG9zIDogdGhpcy5mcm9tID4gcG9zKSB8fFxuICAgICAgICAgICAgKHNpZGUgPiAtMSA/IHRoaXMudG8gPD0gcG9zIDogdGhpcy50byA8IHBvcykpXG4gICAgICAgICAgICBpZiAoIXRoaXMucGFyZW50KCkpXG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIC8vIFRoZW4gc2NhbiBkb3duIGludG8gY2hpbGQgbm9kZXMgYXMgZmFyIGFzIHBvc3NpYmxlXG4gICAgICAgIHdoaWxlICh0aGlzLmVudGVyQ2hpbGQoMSwgcG9zLCBzaWRlKSkgeyB9XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cbiAgICAvLy8gR2V0IGEgW3N5bnRheCBub2RlXSgjY29tbW9uLlN5bnRheE5vZGUpIGF0IHRoZSBjdXJzb3IncyBjdXJyZW50XG4gICAgLy8vIHBvc2l0aW9uLlxuICAgIGdldCBub2RlKCkge1xuICAgICAgICBpZiAoIXRoaXMuYnVmZmVyKVxuICAgICAgICAgICAgcmV0dXJuIHRoaXMuX3RyZWU7XG4gICAgICAgIGxldCBjYWNoZSA9IHRoaXMuYnVmZmVyTm9kZSwgcmVzdWx0ID0gbnVsbCwgZGVwdGggPSAwO1xuICAgICAgICBpZiAoY2FjaGUgJiYgY2FjaGUuY29udGV4dCA9PSB0aGlzLmJ1ZmZlcikge1xuICAgICAgICAgICAgc2NhbjogZm9yIChsZXQgaW5kZXggPSB0aGlzLmluZGV4LCBkID0gdGhpcy5zdGFjay5sZW5ndGg7IGQgPj0gMDspIHtcbiAgICAgICAgICAgICAgICBmb3IgKGxldCBjID0gY2FjaGU7IGM7IGMgPSBjLl9wYXJlbnQpXG4gICAgICAgICAgICAgICAgICAgIGlmIChjLmluZGV4ID09IGluZGV4KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoaW5kZXggPT0gdGhpcy5pbmRleClcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gYztcbiAgICAgICAgICAgICAgICAgICAgICAgIHJlc3VsdCA9IGM7XG4gICAgICAgICAgICAgICAgICAgICAgICBkZXB0aCA9IGQgKyAxO1xuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWsgc2NhbjtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGluZGV4ID0gdGhpcy5zdGFja1stLWRdO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGZvciAobGV0IGkgPSBkZXB0aDsgaSA8IHRoaXMuc3RhY2subGVuZ3RoOyBpKyspXG4gICAgICAgICAgICByZXN1bHQgPSBuZXcgQnVmZmVyTm9kZSh0aGlzLmJ1ZmZlciwgcmVzdWx0LCB0aGlzLnN0YWNrW2ldKTtcbiAgICAgICAgcmV0dXJuIHRoaXMuYnVmZmVyTm9kZSA9IG5ldyBCdWZmZXJOb2RlKHRoaXMuYnVmZmVyLCByZXN1bHQsIHRoaXMuaW5kZXgpO1xuICAgIH1cbiAgICAvLy8gR2V0IHRoZSBbdHJlZV0oI2NvbW1vbi5UcmVlKSB0aGF0IHJlcHJlc2VudHMgdGhlIGN1cnJlbnQgbm9kZSwgaWZcbiAgICAvLy8gYW55LiBXaWxsIHJldHVybiBudWxsIHdoZW4gdGhlIG5vZGUgaXMgaW4gYSBbdHJlZVxuICAgIC8vLyBidWZmZXJdKCNjb21tb24uVHJlZUJ1ZmZlcikuXG4gICAgZ2V0IHRyZWUoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmJ1ZmZlciA/IG51bGwgOiB0aGlzLl90cmVlLl90cmVlO1xuICAgIH1cbiAgICAvLy8gSXRlcmF0ZSBvdmVyIHRoZSBjdXJyZW50IG5vZGUgYW5kIGFsbCBpdHMgZGVzY2VuZGFudHMsIGNhbGxpbmdcbiAgICAvLy8gYGVudGVyYCB3aGVuIGVudGVyaW5nIGEgbm9kZSBhbmQgYGxlYXZlYCwgaWYgZ2l2ZW4sIHdoZW4gbGVhdmluZ1xuICAgIC8vLyBvbmUuIFdoZW4gYGVudGVyYCByZXR1cm5zIGBmYWxzZWAsIGFueSBjaGlsZHJlbiBvZiB0aGF0IG5vZGUgYXJlXG4gICAgLy8vIHNraXBwZWQsIGFuZCBgbGVhdmVgIGlzbid0IGNhbGxlZCBmb3IgaXQuXG4gICAgaXRlcmF0ZShlbnRlciwgbGVhdmUpIHtcbiAgICAgICAgZm9yIChsZXQgZGVwdGggPSAwOzspIHtcbiAgICAgICAgICAgIGxldCBtdXN0TGVhdmUgPSBmYWxzZTtcbiAgICAgICAgICAgIGlmICh0aGlzLnR5cGUuaXNBbm9ueW1vdXMgfHwgZW50ZXIodGhpcykgIT09IGZhbHNlKSB7XG4gICAgICAgICAgICAgICAgaWYgKHRoaXMuZmlyc3RDaGlsZCgpKSB7XG4gICAgICAgICAgICAgICAgICAgIGRlcHRoKys7XG4gICAgICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAoIXRoaXMudHlwZS5pc0Fub255bW91cylcbiAgICAgICAgICAgICAgICAgICAgbXVzdExlYXZlID0gdHJ1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGZvciAoOzspIHtcbiAgICAgICAgICAgICAgICBpZiAobXVzdExlYXZlICYmIGxlYXZlKVxuICAgICAgICAgICAgICAgICAgICBsZWF2ZSh0aGlzKTtcbiAgICAgICAgICAgICAgICBtdXN0TGVhdmUgPSB0aGlzLnR5cGUuaXNBbm9ueW1vdXM7XG4gICAgICAgICAgICAgICAgaWYgKHRoaXMubmV4dFNpYmxpbmcoKSlcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgaWYgKCFkZXB0aClcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICAgIHRoaXMucGFyZW50KCk7XG4gICAgICAgICAgICAgICAgZGVwdGgtLTtcbiAgICAgICAgICAgICAgICBtdXN0TGVhdmUgPSB0cnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuICAgIC8vLyBUZXN0IHdoZXRoZXIgdGhlIGN1cnJlbnQgbm9kZSBtYXRjaGVzIGEgZ2l2ZW4gY29udGV4dOKAlGEgc2VxdWVuY2VcbiAgICAvLy8gb2YgZGlyZWN0IHBhcmVudCBub2RlIG5hbWVzLiBFbXB0eSBzdHJpbmdzIGluIHRoZSBjb250ZXh0IGFycmF5XG4gICAgLy8vIGFyZSB0cmVhdGVkIGFzIHdpbGRjYXJkcy5cbiAgICBtYXRjaENvbnRleHQoY29udGV4dCkge1xuICAgICAgICBpZiAoIXRoaXMuYnVmZmVyKVxuICAgICAgICAgICAgcmV0dXJuIG1hdGNoTm9kZUNvbnRleHQodGhpcy5ub2RlLCBjb250ZXh0KTtcbiAgICAgICAgbGV0IHsgYnVmZmVyIH0gPSB0aGlzLmJ1ZmZlciwgeyB0eXBlcyB9ID0gYnVmZmVyLnNldDtcbiAgICAgICAgZm9yIChsZXQgaSA9IGNvbnRleHQubGVuZ3RoIC0gMSwgZCA9IHRoaXMuc3RhY2subGVuZ3RoIC0gMTsgaSA+PSAwOyBkLS0pIHtcbiAgICAgICAgICAgIGlmIChkIDwgMClcbiAgICAgICAgICAgICAgICByZXR1cm4gbWF0Y2hOb2RlQ29udGV4dCh0aGlzLm5vZGUsIGNvbnRleHQsIGkpO1xuICAgICAgICAgICAgbGV0IHR5cGUgPSB0eXBlc1tidWZmZXIuYnVmZmVyW3RoaXMuc3RhY2tbZF1dXTtcbiAgICAgICAgICAgIGlmICghdHlwZS5pc0Fub255bW91cykge1xuICAgICAgICAgICAgICAgIGlmIChjb250ZXh0W2ldICYmIGNvbnRleHRbaV0gIT0gdHlwZS5uYW1lKVxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICAgICAgaS0tO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbn1cbmZ1bmN0aW9uIGhhc0NoaWxkKHRyZWUpIHtcbiAgICByZXR1cm4gdHJlZS5jaGlsZHJlbi5zb21lKGNoID0+IGNoIGluc3RhbmNlb2YgVHJlZUJ1ZmZlciB8fCAhY2gudHlwZS5pc0Fub255bW91cyB8fCBoYXNDaGlsZChjaCkpO1xufVxuZnVuY3Rpb24gYnVpbGRUcmVlKGRhdGEpIHtcbiAgICB2YXIgX2E7XG4gICAgbGV0IHsgYnVmZmVyLCBub2RlU2V0LCBtYXhCdWZmZXJMZW5ndGggPSBEZWZhdWx0QnVmZmVyTGVuZ3RoLCByZXVzZWQgPSBbXSwgbWluUmVwZWF0VHlwZSA9IG5vZGVTZXQudHlwZXMubGVuZ3RoIH0gPSBkYXRhO1xuICAgIGxldCBjdXJzb3IgPSBBcnJheS5pc0FycmF5KGJ1ZmZlcikgPyBuZXcgRmxhdEJ1ZmZlckN1cnNvcihidWZmZXIsIGJ1ZmZlci5sZW5ndGgpIDogYnVmZmVyO1xuICAgIGxldCB0eXBlcyA9IG5vZGVTZXQudHlwZXM7XG4gICAgbGV0IGNvbnRleHRIYXNoID0gMCwgbG9va0FoZWFkID0gMDtcbiAgICBmdW5jdGlvbiB0YWtlTm9kZShwYXJlbnRTdGFydCwgbWluUG9zLCBjaGlsZHJlbiwgcG9zaXRpb25zLCBpblJlcGVhdCkge1xuICAgICAgICBsZXQgeyBpZCwgc3RhcnQsIGVuZCwgc2l6ZSB9ID0gY3Vyc29yO1xuICAgICAgICBsZXQgbG9va0FoZWFkQXRTdGFydCA9IGxvb2tBaGVhZDtcbiAgICAgICAgd2hpbGUgKHNpemUgPCAwKSB7XG4gICAgICAgICAgICBjdXJzb3IubmV4dCgpO1xuICAgICAgICAgICAgaWYgKHNpemUgPT0gLTEgLyogUmV1c2UgKi8pIHtcbiAgICAgICAgICAgICAgICBsZXQgbm9kZSA9IHJldXNlZFtpZF07XG4gICAgICAgICAgICAgICAgY2hpbGRyZW4ucHVzaChub2RlKTtcbiAgICAgICAgICAgICAgICBwb3NpdGlvbnMucHVzaChzdGFydCAtIHBhcmVudFN0YXJ0KTtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmIChzaXplID09IC0zIC8qIENvbnRleHRDaGFuZ2UgKi8pIHsgLy8gQ29udGV4dCBjaGFuZ2VcbiAgICAgICAgICAgICAgICBjb250ZXh0SGFzaCA9IGlkO1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKHNpemUgPT0gLTQgLyogTG9va0FoZWFkICovKSB7XG4gICAgICAgICAgICAgICAgbG9va0FoZWFkID0gaWQ7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoYFVucmVjb2duaXplZCByZWNvcmQgc2l6ZTogJHtzaXplfWApO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGxldCB0eXBlID0gdHlwZXNbaWRdLCBub2RlLCBidWZmZXI7XG4gICAgICAgIGxldCBzdGFydFBvcyA9IHN0YXJ0IC0gcGFyZW50U3RhcnQ7XG4gICAgICAgIGlmIChlbmQgLSBzdGFydCA8PSBtYXhCdWZmZXJMZW5ndGggJiYgKGJ1ZmZlciA9IGZpbmRCdWZmZXJTaXplKGN1cnNvci5wb3MgLSBtaW5Qb3MsIGluUmVwZWF0KSkpIHtcbiAgICAgICAgICAgIC8vIFNtYWxsIGVub3VnaCBmb3IgYSBidWZmZXIsIGFuZCBubyByZXVzZWQgbm9kZXMgaW5zaWRlXG4gICAgICAgICAgICBsZXQgZGF0YSA9IG5ldyBVaW50MTZBcnJheShidWZmZXIuc2l6ZSAtIGJ1ZmZlci5za2lwKTtcbiAgICAgICAgICAgIGxldCBlbmRQb3MgPSBjdXJzb3IucG9zIC0gYnVmZmVyLnNpemUsIGluZGV4ID0gZGF0YS5sZW5ndGg7XG4gICAgICAgICAgICB3aGlsZSAoY3Vyc29yLnBvcyA+IGVuZFBvcylcbiAgICAgICAgICAgICAgICBpbmRleCA9IGNvcHlUb0J1ZmZlcihidWZmZXIuc3RhcnQsIGRhdGEsIGluZGV4KTtcbiAgICAgICAgICAgIG5vZGUgPSBuZXcgVHJlZUJ1ZmZlcihkYXRhLCBlbmQgLSBidWZmZXIuc3RhcnQsIG5vZGVTZXQpO1xuICAgICAgICAgICAgc3RhcnRQb3MgPSBidWZmZXIuc3RhcnQgLSBwYXJlbnRTdGFydDtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHsgLy8gTWFrZSBpdCBhIG5vZGVcbiAgICAgICAgICAgIGxldCBlbmRQb3MgPSBjdXJzb3IucG9zIC0gc2l6ZTtcbiAgICAgICAgICAgIGN1cnNvci5uZXh0KCk7XG4gICAgICAgICAgICBsZXQgbG9jYWxDaGlsZHJlbiA9IFtdLCBsb2NhbFBvc2l0aW9ucyA9IFtdO1xuICAgICAgICAgICAgbGV0IGxvY2FsSW5SZXBlYXQgPSBpZCA+PSBtaW5SZXBlYXRUeXBlID8gaWQgOiAtMTtcbiAgICAgICAgICAgIGxldCBsYXN0R3JvdXAgPSAwLCBsYXN0RW5kID0gZW5kO1xuICAgICAgICAgICAgd2hpbGUgKGN1cnNvci5wb3MgPiBlbmRQb3MpIHtcbiAgICAgICAgICAgICAgICBpZiAobG9jYWxJblJlcGVhdCA+PSAwICYmIGN1cnNvci5pZCA9PSBsb2NhbEluUmVwZWF0ICYmIGN1cnNvci5zaXplID49IDApIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGN1cnNvci5lbmQgPD0gbGFzdEVuZCAtIG1heEJ1ZmZlckxlbmd0aCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgbWFrZVJlcGVhdExlYWYobG9jYWxDaGlsZHJlbiwgbG9jYWxQb3NpdGlvbnMsIHN0YXJ0LCBsYXN0R3JvdXAsIGN1cnNvci5lbmQsIGxhc3RFbmQsIGxvY2FsSW5SZXBlYXQsIGxvb2tBaGVhZEF0U3RhcnQpO1xuICAgICAgICAgICAgICAgICAgICAgICAgbGFzdEdyb3VwID0gbG9jYWxDaGlsZHJlbi5sZW5ndGg7XG4gICAgICAgICAgICAgICAgICAgICAgICBsYXN0RW5kID0gY3Vyc29yLmVuZDtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBjdXJzb3IubmV4dCgpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgdGFrZU5vZGUoc3RhcnQsIGVuZFBvcywgbG9jYWxDaGlsZHJlbiwgbG9jYWxQb3NpdGlvbnMsIGxvY2FsSW5SZXBlYXQpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChsb2NhbEluUmVwZWF0ID49IDAgJiYgbGFzdEdyb3VwID4gMCAmJiBsYXN0R3JvdXAgPCBsb2NhbENoaWxkcmVuLmxlbmd0aClcbiAgICAgICAgICAgICAgICBtYWtlUmVwZWF0TGVhZihsb2NhbENoaWxkcmVuLCBsb2NhbFBvc2l0aW9ucywgc3RhcnQsIGxhc3RHcm91cCwgc3RhcnQsIGxhc3RFbmQsIGxvY2FsSW5SZXBlYXQsIGxvb2tBaGVhZEF0U3RhcnQpO1xuICAgICAgICAgICAgbG9jYWxDaGlsZHJlbi5yZXZlcnNlKCk7XG4gICAgICAgICAgICBsb2NhbFBvc2l0aW9ucy5yZXZlcnNlKCk7XG4gICAgICAgICAgICBpZiAobG9jYWxJblJlcGVhdCA+IC0xICYmIGxhc3RHcm91cCA+IDApIHtcbiAgICAgICAgICAgICAgICBsZXQgbWFrZSA9IG1ha2VCYWxhbmNlZCh0eXBlKTtcbiAgICAgICAgICAgICAgICBub2RlID0gYmFsYW5jZVJhbmdlKHR5cGUsIGxvY2FsQ2hpbGRyZW4sIGxvY2FsUG9zaXRpb25zLCAwLCBsb2NhbENoaWxkcmVuLmxlbmd0aCwgMCwgZW5kIC0gc3RhcnQsIG1ha2UsIG1ha2UpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgbm9kZSA9IG1ha2VUcmVlKHR5cGUsIGxvY2FsQ2hpbGRyZW4sIGxvY2FsUG9zaXRpb25zLCBlbmQgLSBzdGFydCwgbG9va0FoZWFkQXRTdGFydCAtIGVuZCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgY2hpbGRyZW4ucHVzaChub2RlKTtcbiAgICAgICAgcG9zaXRpb25zLnB1c2goc3RhcnRQb3MpO1xuICAgIH1cbiAgICBmdW5jdGlvbiBtYWtlQmFsYW5jZWQodHlwZSkge1xuICAgICAgICByZXR1cm4gKGNoaWxkcmVuLCBwb3NpdGlvbnMsIGxlbmd0aCkgPT4ge1xuICAgICAgICAgICAgbGV0IGxvb2tBaGVhZCA9IDAsIGxhc3RJID0gY2hpbGRyZW4ubGVuZ3RoIC0gMSwgbGFzdCwgbG9va0FoZWFkUHJvcDtcbiAgICAgICAgICAgIGlmIChsYXN0SSA+PSAwICYmIChsYXN0ID0gY2hpbGRyZW5bbGFzdEldKSBpbnN0YW5jZW9mIFRyZWUpIHtcbiAgICAgICAgICAgICAgICBpZiAoIWxhc3RJICYmIGxhc3QudHlwZSA9PSB0eXBlICYmIGxhc3QubGVuZ3RoID09IGxlbmd0aClcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGxhc3Q7XG4gICAgICAgICAgICAgICAgaWYgKGxvb2tBaGVhZFByb3AgPSBsYXN0LnByb3AoTm9kZVByb3AubG9va0FoZWFkKSlcbiAgICAgICAgICAgICAgICAgICAgbG9va0FoZWFkID0gcG9zaXRpb25zW2xhc3RJXSArIGxhc3QubGVuZ3RoICsgbG9va0FoZWFkUHJvcDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBtYWtlVHJlZSh0eXBlLCBjaGlsZHJlbiwgcG9zaXRpb25zLCBsZW5ndGgsIGxvb2tBaGVhZCk7XG4gICAgICAgIH07XG4gICAgfVxuICAgIGZ1bmN0aW9uIG1ha2VSZXBlYXRMZWFmKGNoaWxkcmVuLCBwb3NpdGlvbnMsIGJhc2UsIGksIGZyb20sIHRvLCB0eXBlLCBsb29rQWhlYWQpIHtcbiAgICAgICAgbGV0IGxvY2FsQ2hpbGRyZW4gPSBbXSwgbG9jYWxQb3NpdGlvbnMgPSBbXTtcbiAgICAgICAgd2hpbGUgKGNoaWxkcmVuLmxlbmd0aCA+IGkpIHtcbiAgICAgICAgICAgIGxvY2FsQ2hpbGRyZW4ucHVzaChjaGlsZHJlbi5wb3AoKSk7XG4gICAgICAgICAgICBsb2NhbFBvc2l0aW9ucy5wdXNoKHBvc2l0aW9ucy5wb3AoKSArIGJhc2UgLSBmcm9tKTtcbiAgICAgICAgfVxuICAgICAgICBjaGlsZHJlbi5wdXNoKG1ha2VUcmVlKG5vZGVTZXQudHlwZXNbdHlwZV0sIGxvY2FsQ2hpbGRyZW4sIGxvY2FsUG9zaXRpb25zLCB0byAtIGZyb20sIGxvb2tBaGVhZCAtIHRvKSk7XG4gICAgICAgIHBvc2l0aW9ucy5wdXNoKGZyb20gLSBiYXNlKTtcbiAgICB9XG4gICAgZnVuY3Rpb24gbWFrZVRyZWUodHlwZSwgY2hpbGRyZW4sIHBvc2l0aW9ucywgbGVuZ3RoLCBsb29rQWhlYWQgPSAwLCBwcm9wcykge1xuICAgICAgICBpZiAoY29udGV4dEhhc2gpIHtcbiAgICAgICAgICAgIGxldCBwYWlyID0gW05vZGVQcm9wLmNvbnRleHRIYXNoLCBjb250ZXh0SGFzaF07XG4gICAgICAgICAgICBwcm9wcyA9IHByb3BzID8gW3BhaXJdLmNvbmNhdChwcm9wcykgOiBbcGFpcl07XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGxvb2tBaGVhZCA+IDI1KSB7XG4gICAgICAgICAgICBsZXQgcGFpciA9IFtOb2RlUHJvcC5sb29rQWhlYWQsIGxvb2tBaGVhZF07XG4gICAgICAgICAgICBwcm9wcyA9IHByb3BzID8gW3BhaXJdLmNvbmNhdChwcm9wcykgOiBbcGFpcl07XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG5ldyBUcmVlKHR5cGUsIGNoaWxkcmVuLCBwb3NpdGlvbnMsIGxlbmd0aCwgcHJvcHMpO1xuICAgIH1cbiAgICBmdW5jdGlvbiBmaW5kQnVmZmVyU2l6ZShtYXhTaXplLCBpblJlcGVhdCkge1xuICAgICAgICAvLyBTY2FuIHRocm91Z2ggdGhlIGJ1ZmZlciB0byBmaW5kIHByZXZpb3VzIHNpYmxpbmdzIHRoYXQgZml0XG4gICAgICAgIC8vIHRvZ2V0aGVyIGluIGEgVHJlZUJ1ZmZlciwgYW5kIGRvbid0IGNvbnRhaW4gYW55IHJldXNlZCBub2Rlc1xuICAgICAgICAvLyAod2hpY2ggY2FuJ3QgYmUgc3RvcmVkIGluIGEgYnVmZmVyKS5cbiAgICAgICAgLy8gSWYgYGluUmVwZWF0YCBpcyA+IC0xLCBpZ25vcmUgbm9kZSBib3VuZGFyaWVzIG9mIHRoYXQgdHlwZSBmb3JcbiAgICAgICAgLy8gbmVzdGluZywgYnV0IG1ha2Ugc3VyZSB0aGUgZW5kIGZhbGxzIGVpdGhlciBhdCB0aGUgc3RhcnRcbiAgICAgICAgLy8gKGBtYXhTaXplYCkgb3IgYmVmb3JlIHN1Y2ggYSBub2RlLlxuICAgICAgICBsZXQgZm9yayA9IGN1cnNvci5mb3JrKCk7XG4gICAgICAgIGxldCBzaXplID0gMCwgc3RhcnQgPSAwLCBza2lwID0gMCwgbWluU3RhcnQgPSBmb3JrLmVuZCAtIG1heEJ1ZmZlckxlbmd0aDtcbiAgICAgICAgbGV0IHJlc3VsdCA9IHsgc2l6ZTogMCwgc3RhcnQ6IDAsIHNraXA6IDAgfTtcbiAgICAgICAgc2NhbjogZm9yIChsZXQgbWluUG9zID0gZm9yay5wb3MgLSBtYXhTaXplOyBmb3JrLnBvcyA+IG1pblBvczspIHtcbiAgICAgICAgICAgIGxldCBub2RlU2l6ZSA9IGZvcmsuc2l6ZTtcbiAgICAgICAgICAgIC8vIFByZXRlbmQgbmVzdGVkIHJlcGVhdCBub2RlcyBvZiB0aGUgc2FtZSB0eXBlIGRvbid0IGV4aXN0XG4gICAgICAgICAgICBpZiAoZm9yay5pZCA9PSBpblJlcGVhdCAmJiBub2RlU2l6ZSA+PSAwKSB7XG4gICAgICAgICAgICAgICAgLy8gRXhjZXB0IHRoYXQgd2Ugc3RvcmUgdGhlIGN1cnJlbnQgc3RhdGUgYXMgYSB2YWxpZCByZXR1cm5cbiAgICAgICAgICAgICAgICAvLyB2YWx1ZS5cbiAgICAgICAgICAgICAgICByZXN1bHQuc2l6ZSA9IHNpemU7XG4gICAgICAgICAgICAgICAgcmVzdWx0LnN0YXJ0ID0gc3RhcnQ7XG4gICAgICAgICAgICAgICAgcmVzdWx0LnNraXAgPSBza2lwO1xuICAgICAgICAgICAgICAgIHNraXAgKz0gNDtcbiAgICAgICAgICAgICAgICBzaXplICs9IDQ7XG4gICAgICAgICAgICAgICAgZm9yay5uZXh0KCk7XG4gICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBsZXQgc3RhcnRQb3MgPSBmb3JrLnBvcyAtIG5vZGVTaXplO1xuICAgICAgICAgICAgaWYgKG5vZGVTaXplIDwgMCB8fCBzdGFydFBvcyA8IG1pblBvcyB8fCBmb3JrLnN0YXJ0IDwgbWluU3RhcnQpXG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBsZXQgbG9jYWxTa2lwcGVkID0gZm9yay5pZCA+PSBtaW5SZXBlYXRUeXBlID8gNCA6IDA7XG4gICAgICAgICAgICBsZXQgbm9kZVN0YXJ0ID0gZm9yay5zdGFydDtcbiAgICAgICAgICAgIGZvcmsubmV4dCgpO1xuICAgICAgICAgICAgd2hpbGUgKGZvcmsucG9zID4gc3RhcnRQb3MpIHtcbiAgICAgICAgICAgICAgICBpZiAoZm9yay5zaXplIDwgMCkge1xuICAgICAgICAgICAgICAgICAgICBpZiAoZm9yay5zaXplID09IC0zIC8qIENvbnRleHRDaGFuZ2UgKi8pXG4gICAgICAgICAgICAgICAgICAgICAgICBsb2NhbFNraXBwZWQgKz0gNDtcbiAgICAgICAgICAgICAgICAgICAgZWxzZVxuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWsgc2NhbjtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSBpZiAoZm9yay5pZCA+PSBtaW5SZXBlYXRUeXBlKSB7XG4gICAgICAgICAgICAgICAgICAgIGxvY2FsU2tpcHBlZCArPSA0O1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBmb3JrLm5leHQoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHN0YXJ0ID0gbm9kZVN0YXJ0O1xuICAgICAgICAgICAgc2l6ZSArPSBub2RlU2l6ZTtcbiAgICAgICAgICAgIHNraXAgKz0gbG9jYWxTa2lwcGVkO1xuICAgICAgICB9XG4gICAgICAgIGlmIChpblJlcGVhdCA8IDAgfHwgc2l6ZSA9PSBtYXhTaXplKSB7XG4gICAgICAgICAgICByZXN1bHQuc2l6ZSA9IHNpemU7XG4gICAgICAgICAgICByZXN1bHQuc3RhcnQgPSBzdGFydDtcbiAgICAgICAgICAgIHJlc3VsdC5za2lwID0gc2tpcDtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcmVzdWx0LnNpemUgPiA0ID8gcmVzdWx0IDogdW5kZWZpbmVkO1xuICAgIH1cbiAgICBmdW5jdGlvbiBjb3B5VG9CdWZmZXIoYnVmZmVyU3RhcnQsIGJ1ZmZlciwgaW5kZXgpIHtcbiAgICAgICAgbGV0IHsgaWQsIHN0YXJ0LCBlbmQsIHNpemUgfSA9IGN1cnNvcjtcbiAgICAgICAgY3Vyc29yLm5leHQoKTtcbiAgICAgICAgaWYgKHNpemUgPj0gMCAmJiBpZCA8IG1pblJlcGVhdFR5cGUpIHtcbiAgICAgICAgICAgIGxldCBzdGFydEluZGV4ID0gaW5kZXg7XG4gICAgICAgICAgICBpZiAoc2l6ZSA+IDQpIHtcbiAgICAgICAgICAgICAgICBsZXQgZW5kUG9zID0gY3Vyc29yLnBvcyAtIChzaXplIC0gNCk7XG4gICAgICAgICAgICAgICAgd2hpbGUgKGN1cnNvci5wb3MgPiBlbmRQb3MpXG4gICAgICAgICAgICAgICAgICAgIGluZGV4ID0gY29weVRvQnVmZmVyKGJ1ZmZlclN0YXJ0LCBidWZmZXIsIGluZGV4KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGJ1ZmZlclstLWluZGV4XSA9IHN0YXJ0SW5kZXg7XG4gICAgICAgICAgICBidWZmZXJbLS1pbmRleF0gPSBlbmQgLSBidWZmZXJTdGFydDtcbiAgICAgICAgICAgIGJ1ZmZlclstLWluZGV4XSA9IHN0YXJ0IC0gYnVmZmVyU3RhcnQ7XG4gICAgICAgICAgICBidWZmZXJbLS1pbmRleF0gPSBpZDtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChzaXplID09IC0zIC8qIENvbnRleHRDaGFuZ2UgKi8pIHtcbiAgICAgICAgICAgIGNvbnRleHRIYXNoID0gaWQ7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoc2l6ZSA9PSAtNCAvKiBMb29rQWhlYWQgKi8pIHtcbiAgICAgICAgICAgIGxvb2tBaGVhZCA9IGlkO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBpbmRleDtcbiAgICB9XG4gICAgbGV0IGNoaWxkcmVuID0gW10sIHBvc2l0aW9ucyA9IFtdO1xuICAgIHdoaWxlIChjdXJzb3IucG9zID4gMClcbiAgICAgICAgdGFrZU5vZGUoZGF0YS5zdGFydCB8fCAwLCBkYXRhLmJ1ZmZlclN0YXJ0IHx8IDAsIGNoaWxkcmVuLCBwb3NpdGlvbnMsIC0xKTtcbiAgICBsZXQgbGVuZ3RoID0gKF9hID0gZGF0YS5sZW5ndGgpICE9PSBudWxsICYmIF9hICE9PSB2b2lkIDAgPyBfYSA6IChjaGlsZHJlbi5sZW5ndGggPyBwb3NpdGlvbnNbMF0gKyBjaGlsZHJlblswXS5sZW5ndGggOiAwKTtcbiAgICByZXR1cm4gbmV3IFRyZWUodHlwZXNbZGF0YS50b3BJRF0sIGNoaWxkcmVuLnJldmVyc2UoKSwgcG9zaXRpb25zLnJldmVyc2UoKSwgbGVuZ3RoKTtcbn1cbmNvbnN0IG5vZGVTaXplQ2FjaGUgPSBuZXcgV2Vha01hcDtcbmZ1bmN0aW9uIG5vZGVTaXplKGJhbGFuY2VUeXBlLCBub2RlKSB7XG4gICAgaWYgKCFiYWxhbmNlVHlwZS5pc0Fub255bW91cyB8fCBub2RlIGluc3RhbmNlb2YgVHJlZUJ1ZmZlciB8fCBub2RlLnR5cGUgIT0gYmFsYW5jZVR5cGUpXG4gICAgICAgIHJldHVybiAxO1xuICAgIGxldCBzaXplID0gbm9kZVNpemVDYWNoZS5nZXQobm9kZSk7XG4gICAgaWYgKHNpemUgPT0gbnVsbCkge1xuICAgICAgICBzaXplID0gMTtcbiAgICAgICAgZm9yIChsZXQgY2hpbGQgb2Ygbm9kZS5jaGlsZHJlbikge1xuICAgICAgICAgICAgaWYgKGNoaWxkLnR5cGUgIT0gYmFsYW5jZVR5cGUgfHwgIShjaGlsZCBpbnN0YW5jZW9mIFRyZWUpKSB7XG4gICAgICAgICAgICAgICAgc2l6ZSA9IDE7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBzaXplICs9IG5vZGVTaXplKGJhbGFuY2VUeXBlLCBjaGlsZCk7XG4gICAgICAgIH1cbiAgICAgICAgbm9kZVNpemVDYWNoZS5zZXQobm9kZSwgc2l6ZSk7XG4gICAgfVxuICAgIHJldHVybiBzaXplO1xufVxuZnVuY3Rpb24gYmFsYW5jZVJhbmdlKFxuLy8gVGhlIHR5cGUgdGhlIGJhbGFuY2VkIHRyZWUncyBpbm5lciBub2Rlcy5cbmJhbGFuY2VUeXBlLCBcbi8vIFRoZSBkaXJlY3QgY2hpbGRyZW4gYW5kIHRoZWlyIHBvc2l0aW9uc1xuY2hpbGRyZW4sIHBvc2l0aW9ucywgXG4vLyBUaGUgaW5kZXggcmFuZ2UgaW4gY2hpbGRyZW4vcG9zaXRpb25zIHRvIHVzZVxuZnJvbSwgdG8sIFxuLy8gVGhlIHN0YXJ0IHBvc2l0aW9uIG9mIHRoZSBub2RlcywgcmVsYXRpdmUgdG8gdGhlaXIgcGFyZW50Llxuc3RhcnQsIFxuLy8gTGVuZ3RoIG9mIHRoZSBvdXRlciBub2RlXG5sZW5ndGgsIFxuLy8gRnVuY3Rpb24gdG8gYnVpbGQgdGhlIHRvcCBub2RlIG9mIHRoZSBiYWxhbmNlZCB0cmVlXG5ta1RvcCwgXG4vLyBGdW5jdGlvbiB0byBidWlsZCBpbnRlcm5hbCBub2RlcyBmb3IgdGhlIGJhbGFuY2VkIHRyZWVcbm1rVHJlZSkge1xuICAgIGxldCB0b3RhbCA9IDA7XG4gICAgZm9yIChsZXQgaSA9IGZyb207IGkgPCB0bzsgaSsrKVxuICAgICAgICB0b3RhbCArPSBub2RlU2l6ZShiYWxhbmNlVHlwZSwgY2hpbGRyZW5baV0pO1xuICAgIGxldCBtYXhDaGlsZCA9IE1hdGguY2VpbCgodG90YWwgKiAxLjUpIC8gOCAvKiBCcmFuY2hGYWN0b3IgKi8pO1xuICAgIGxldCBsb2NhbENoaWxkcmVuID0gW10sIGxvY2FsUG9zaXRpb25zID0gW107XG4gICAgZnVuY3Rpb24gZGl2aWRlKGNoaWxkcmVuLCBwb3NpdGlvbnMsIGZyb20sIHRvLCBvZmZzZXQpIHtcbiAgICAgICAgZm9yIChsZXQgaSA9IGZyb207IGkgPCB0bzspIHtcbiAgICAgICAgICAgIGxldCBncm91cEZyb20gPSBpLCBncm91cFN0YXJ0ID0gcG9zaXRpb25zW2ldLCBncm91cFNpemUgPSBub2RlU2l6ZShiYWxhbmNlVHlwZSwgY2hpbGRyZW5baV0pO1xuICAgICAgICAgICAgaSsrO1xuICAgICAgICAgICAgZm9yICg7IGkgPCB0bzsgaSsrKSB7XG4gICAgICAgICAgICAgICAgbGV0IG5leHRTaXplID0gbm9kZVNpemUoYmFsYW5jZVR5cGUsIGNoaWxkcmVuW2ldKTtcbiAgICAgICAgICAgICAgICBpZiAoZ3JvdXBTaXplICsgbmV4dFNpemUgPj0gbWF4Q2hpbGQpXG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGdyb3VwU2l6ZSArPSBuZXh0U2l6ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChpID09IGdyb3VwRnJvbSArIDEpIHtcbiAgICAgICAgICAgICAgICBpZiAoZ3JvdXBTaXplID4gbWF4Q2hpbGQpIHtcbiAgICAgICAgICAgICAgICAgICAgbGV0IG9ubHkgPSBjaGlsZHJlbltncm91cEZyb21dOyAvLyBPbmx5IHRyZWVzIGNhbiBoYXZlIGEgc2l6ZSA+IDFcbiAgICAgICAgICAgICAgICAgICAgZGl2aWRlKG9ubHkuY2hpbGRyZW4sIG9ubHkucG9zaXRpb25zLCAwLCBvbmx5LmNoaWxkcmVuLmxlbmd0aCwgcG9zaXRpb25zW2dyb3VwRnJvbV0gKyBvZmZzZXQpO1xuICAgICAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgbG9jYWxDaGlsZHJlbi5wdXNoKGNoaWxkcmVuW2dyb3VwRnJvbV0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgbGV0IGxlbmd0aCA9IHBvc2l0aW9uc1tpIC0gMV0gKyBjaGlsZHJlbltpIC0gMV0ubGVuZ3RoIC0gZ3JvdXBTdGFydDtcbiAgICAgICAgICAgICAgICBsb2NhbENoaWxkcmVuLnB1c2goYmFsYW5jZVJhbmdlKGJhbGFuY2VUeXBlLCBjaGlsZHJlbiwgcG9zaXRpb25zLCBncm91cEZyb20sIGksIGdyb3VwU3RhcnQsIGxlbmd0aCwgbnVsbCwgbWtUcmVlKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBsb2NhbFBvc2l0aW9ucy5wdXNoKGdyb3VwU3RhcnQgKyBvZmZzZXQgLSBzdGFydCk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgZGl2aWRlKGNoaWxkcmVuLCBwb3NpdGlvbnMsIGZyb20sIHRvLCAwKTtcbiAgICByZXR1cm4gKG1rVG9wIHx8IG1rVHJlZSkobG9jYWxDaGlsZHJlbiwgbG9jYWxQb3NpdGlvbnMsIGxlbmd0aCk7XG59XG4vLy8gUHJvdmlkZXMgYSB3YXkgdG8gYXNzb2NpYXRlIHZhbHVlcyB3aXRoIHBpZWNlcyBvZiB0cmVlcy4gQXMgbG9uZ1xuLy8vIGFzIHRoYXQgcGFydCBvZiB0aGUgdHJlZSBpcyByZXVzZWQsIHRoZSBhc3NvY2lhdGVkIHZhbHVlcyBjYW4gYmVcbi8vLyByZXRyaWV2ZWQgZnJvbSBhbiB1cGRhdGVkIHRyZWUuXG5jbGFzcyBOb2RlV2Vha01hcCB7XG4gICAgY29uc3RydWN0b3IoKSB7XG4gICAgICAgIHRoaXMubWFwID0gbmV3IFdlYWtNYXAoKTtcbiAgICB9XG4gICAgc2V0QnVmZmVyKGJ1ZmZlciwgaW5kZXgsIHZhbHVlKSB7XG4gICAgICAgIGxldCBpbm5lciA9IHRoaXMubWFwLmdldChidWZmZXIpO1xuICAgICAgICBpZiAoIWlubmVyKVxuICAgICAgICAgICAgdGhpcy5tYXAuc2V0KGJ1ZmZlciwgaW5uZXIgPSBuZXcgTWFwKTtcbiAgICAgICAgaW5uZXIuc2V0KGluZGV4LCB2YWx1ZSk7XG4gICAgfVxuICAgIGdldEJ1ZmZlcihidWZmZXIsIGluZGV4KSB7XG4gICAgICAgIGxldCBpbm5lciA9IHRoaXMubWFwLmdldChidWZmZXIpO1xuICAgICAgICByZXR1cm4gaW5uZXIgJiYgaW5uZXIuZ2V0KGluZGV4KTtcbiAgICB9XG4gICAgLy8vIFNldCB0aGUgdmFsdWUgZm9yIHRoaXMgc3ludGF4IG5vZGUuXG4gICAgc2V0KG5vZGUsIHZhbHVlKSB7XG4gICAgICAgIGlmIChub2RlIGluc3RhbmNlb2YgQnVmZmVyTm9kZSlcbiAgICAgICAgICAgIHRoaXMuc2V0QnVmZmVyKG5vZGUuY29udGV4dC5idWZmZXIsIG5vZGUuaW5kZXgsIHZhbHVlKTtcbiAgICAgICAgZWxzZSBpZiAobm9kZSBpbnN0YW5jZW9mIFRyZWVOb2RlKVxuICAgICAgICAgICAgdGhpcy5tYXAuc2V0KG5vZGUudHJlZSwgdmFsdWUpO1xuICAgIH1cbiAgICAvLy8gUmV0cmlldmUgdmFsdWUgZm9yIHRoaXMgc3ludGF4IG5vZGUsIGlmIGl0IGV4aXN0cyBpbiB0aGUgbWFwLlxuICAgIGdldChub2RlKSB7XG4gICAgICAgIHJldHVybiBub2RlIGluc3RhbmNlb2YgQnVmZmVyTm9kZSA/IHRoaXMuZ2V0QnVmZmVyKG5vZGUuY29udGV4dC5idWZmZXIsIG5vZGUuaW5kZXgpXG4gICAgICAgICAgICA6IG5vZGUgaW5zdGFuY2VvZiBUcmVlTm9kZSA/IHRoaXMubWFwLmdldChub2RlLnRyZWUpIDogdW5kZWZpbmVkO1xuICAgIH1cbiAgICAvLy8gU2V0IHRoZSB2YWx1ZSBmb3IgdGhlIG5vZGUgdGhhdCBhIGN1cnNvciBjdXJyZW50bHkgcG9pbnRzIHRvLlxuICAgIGN1cnNvclNldChjdXJzb3IsIHZhbHVlKSB7XG4gICAgICAgIGlmIChjdXJzb3IuYnVmZmVyKVxuICAgICAgICAgICAgdGhpcy5zZXRCdWZmZXIoY3Vyc29yLmJ1ZmZlci5idWZmZXIsIGN1cnNvci5pbmRleCwgdmFsdWUpO1xuICAgICAgICBlbHNlXG4gICAgICAgICAgICB0aGlzLm1hcC5zZXQoY3Vyc29yLnRyZWUsIHZhbHVlKTtcbiAgICB9XG4gICAgLy8vIFJldHJpZXZlIHRoZSB2YWx1ZSBmb3IgdGhlIG5vZGUgdGhhdCBhIGN1cnNvciBjdXJyZW50bHkgcG9pbnRzXG4gICAgLy8vIHRvLlxuICAgIGN1cnNvckdldChjdXJzb3IpIHtcbiAgICAgICAgcmV0dXJuIGN1cnNvci5idWZmZXIgPyB0aGlzLmdldEJ1ZmZlcihjdXJzb3IuYnVmZmVyLmJ1ZmZlciwgY3Vyc29yLmluZGV4KSA6IHRoaXMubWFwLmdldChjdXJzb3IudHJlZSk7XG4gICAgfVxufVxuXG4vLy8gVHJlZSBmcmFnbWVudHMgYXJlIHVzZWQgZHVyaW5nIFtpbmNyZW1lbnRhbFxuLy8vIHBhcnNpbmddKCNjb21tb24uUGFyc2VyLnN0YXJ0UGFyc2UpIHRvIHRyYWNrIHBhcnRzIG9mIG9sZCB0cmVlc1xuLy8vIHRoYXQgY2FuIGJlIHJldXNlZCBpbiBhIG5ldyBwYXJzZS4gQW4gYXJyYXkgb2YgZnJhZ21lbnRzIGlzIHVzZWRcbi8vLyB0byB0cmFjayByZWdpb25zIG9mIGFuIG9sZCB0cmVlIHdob3NlIG5vZGVzIG1pZ2h0IGJlIHJldXNlZCBpbiBuZXdcbi8vLyBwYXJzZXMuIFVzZSB0aGUgc3RhdGljXG4vLy8gW2BhcHBseUNoYW5nZXNgXSgjY29tbW9uLlRyZWVGcmFnbWVudF5hcHBseUNoYW5nZXMpIG1ldGhvZCB0b1xuLy8vIHVwZGF0ZSBmcmFnbWVudHMgZm9yIGRvY3VtZW50IGNoYW5nZXMuXG5jbGFzcyBUcmVlRnJhZ21lbnQge1xuICAgIC8vLyBDb25zdHJ1Y3QgYSB0cmVlIGZyYWdtZW50LlxuICAgIGNvbnN0cnVjdG9yKFxuICAgIC8vLyBUaGUgc3RhcnQgb2YgdGhlIHVuY2hhbmdlZCByYW5nZSBwb2ludGVkIHRvIGJ5IHRoaXMgZnJhZ21lbnQuXG4gICAgLy8vIFRoaXMgcmVmZXJzIHRvIGFuIG9mZnNldCBpbiB0aGUgX3VwZGF0ZWRfIGRvY3VtZW50IChhcyBvcHBvc2VkXG4gICAgLy8vIHRvIHRoZSBvcmlnaW5hbCB0cmVlKS5cbiAgICBmcm9tLCBcbiAgICAvLy8gVGhlIGVuZCBvZiB0aGUgdW5jaGFuZ2VkIHJhbmdlLlxuICAgIHRvLCBcbiAgICAvLy8gVGhlIHRyZWUgdGhhdCB0aGlzIGZyYWdtZW50IGlzIGJhc2VkIG9uLlxuICAgIHRyZWUsIFxuICAgIC8vLyBUaGUgb2Zmc2V0IGJldHdlZW4gdGhlIGZyYWdtZW50J3MgdHJlZSBhbmQgdGhlIGRvY3VtZW50IHRoYXRcbiAgICAvLy8gdGhpcyBmcmFnbWVudCBjYW4gYmUgdXNlZCBhZ2FpbnN0LiBBZGQgdGhpcyB3aGVuIGdvaW5nIGZyb21cbiAgICAvLy8gZG9jdW1lbnQgdG8gdHJlZSBwb3NpdGlvbnMsIHN1YnRyYWN0IGl0IHRvIGdvIGZyb20gdHJlZSB0b1xuICAgIC8vLyBkb2N1bWVudCBwb3NpdGlvbnMuXG4gICAgb2Zmc2V0LCBvcGVuU3RhcnQgPSBmYWxzZSwgb3BlbkVuZCA9IGZhbHNlKSB7XG4gICAgICAgIHRoaXMuZnJvbSA9IGZyb207XG4gICAgICAgIHRoaXMudG8gPSB0bztcbiAgICAgICAgdGhpcy50cmVlID0gdHJlZTtcbiAgICAgICAgdGhpcy5vZmZzZXQgPSBvZmZzZXQ7XG4gICAgICAgIHRoaXMub3BlbiA9IChvcGVuU3RhcnQgPyAxIC8qIFN0YXJ0ICovIDogMCkgfCAob3BlbkVuZCA/IDIgLyogRW5kICovIDogMCk7XG4gICAgfVxuICAgIC8vLyBXaGV0aGVyIHRoZSBzdGFydCBvZiB0aGUgZnJhZ21lbnQgcmVwcmVzZW50cyB0aGUgc3RhcnQgb2YgYVxuICAgIC8vLyBwYXJzZSwgb3IgdGhlIGVuZCBvZiBhIGNoYW5nZS4gKEluIHRoZSBzZWNvbmQgY2FzZSwgaXQgbWF5IG5vdFxuICAgIC8vLyBiZSBzYWZlIHRvIHJldXNlIHNvbWUgbm9kZXMgYXQgdGhlIHN0YXJ0LCBkZXBlbmRpbmcgb24gdGhlXG4gICAgLy8vIHBhcnNpbmcgYWxnb3JpdGhtLilcbiAgICBnZXQgb3BlblN0YXJ0KCkgeyByZXR1cm4gKHRoaXMub3BlbiAmIDEgLyogU3RhcnQgKi8pID4gMDsgfVxuICAgIC8vLyBXaGV0aGVyIHRoZSBlbmQgb2YgdGhlIGZyYWdtZW50IHJlcHJlc2VudHMgdGhlIGVuZCBvZiBhXG4gICAgLy8vIGZ1bGwtZG9jdW1lbnQgcGFyc2UsIG9yIHRoZSBzdGFydCBvZiBhIGNoYW5nZS5cbiAgICBnZXQgb3BlbkVuZCgpIHsgcmV0dXJuICh0aGlzLm9wZW4gJiAyIC8qIEVuZCAqLykgPiAwOyB9XG4gICAgLy8vIENyZWF0ZSBhIHNldCBvZiBmcmFnbWVudHMgZnJvbSBhIGZyZXNobHkgcGFyc2VkIHRyZWUsIG9yIHVwZGF0ZVxuICAgIC8vLyBhbiBleGlzdGluZyBzZXQgb2YgZnJhZ21lbnRzIGJ5IHJlcGxhY2luZyB0aGUgb25lcyB0aGF0IG92ZXJsYXBcbiAgICAvLy8gd2l0aCBhIHRyZWUgd2l0aCBjb250ZW50IGZyb20gdGhlIG5ldyB0cmVlLiBXaGVuIGBwYXJ0aWFsYCBpc1xuICAgIC8vLyB0cnVlLCB0aGUgcGFyc2UgaXMgdHJlYXRlZCBhcyBpbmNvbXBsZXRlLCBhbmQgdGhlIHJlc3VsdGluZ1xuICAgIC8vLyBmcmFnbWVudCBoYXMgW2BvcGVuRW5kYF0oI2NvbW1vbi5UcmVlRnJhZ21lbnQub3BlbkVuZCkgc2V0IHRvXG4gICAgLy8vIHRydWUuXG4gICAgc3RhdGljIGFkZFRyZWUodHJlZSwgZnJhZ21lbnRzID0gW10sIHBhcnRpYWwgPSBmYWxzZSkge1xuICAgICAgICBsZXQgcmVzdWx0ID0gW25ldyBUcmVlRnJhZ21lbnQoMCwgdHJlZS5sZW5ndGgsIHRyZWUsIDAsIGZhbHNlLCBwYXJ0aWFsKV07XG4gICAgICAgIGZvciAobGV0IGYgb2YgZnJhZ21lbnRzKVxuICAgICAgICAgICAgaWYgKGYudG8gPiB0cmVlLmxlbmd0aClcbiAgICAgICAgICAgICAgICByZXN1bHQucHVzaChmKTtcbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG4gICAgLy8vIEFwcGx5IGEgc2V0IG9mIGVkaXRzIHRvIGFuIGFycmF5IG9mIGZyYWdtZW50cywgcmVtb3Zpbmcgb3JcbiAgICAvLy8gc3BsaXR0aW5nIGZyYWdtZW50cyBhcyBuZWNlc3NhcnkgdG8gcmVtb3ZlIGVkaXRlZCByYW5nZXMsIGFuZFxuICAgIC8vLyBhZGp1c3Rpbmcgb2Zmc2V0cyBmb3IgZnJhZ21lbnRzIHRoYXQgbW92ZWQuXG4gICAgc3RhdGljIGFwcGx5Q2hhbmdlcyhmcmFnbWVudHMsIGNoYW5nZXMsIG1pbkdhcCA9IDEyOCkge1xuICAgICAgICBpZiAoIWNoYW5nZXMubGVuZ3RoKVxuICAgICAgICAgICAgcmV0dXJuIGZyYWdtZW50cztcbiAgICAgICAgbGV0IHJlc3VsdCA9IFtdO1xuICAgICAgICBsZXQgZkkgPSAxLCBuZXh0RiA9IGZyYWdtZW50cy5sZW5ndGggPyBmcmFnbWVudHNbMF0gOiBudWxsO1xuICAgICAgICBmb3IgKGxldCBjSSA9IDAsIHBvcyA9IDAsIG9mZiA9IDA7OyBjSSsrKSB7XG4gICAgICAgICAgICBsZXQgbmV4dEMgPSBjSSA8IGNoYW5nZXMubGVuZ3RoID8gY2hhbmdlc1tjSV0gOiBudWxsO1xuICAgICAgICAgICAgbGV0IG5leHRQb3MgPSBuZXh0QyA/IG5leHRDLmZyb21BIDogMWU5O1xuICAgICAgICAgICAgaWYgKG5leHRQb3MgLSBwb3MgPj0gbWluR2FwKVxuICAgICAgICAgICAgICAgIHdoaWxlIChuZXh0RiAmJiBuZXh0Ri5mcm9tIDwgbmV4dFBvcykge1xuICAgICAgICAgICAgICAgICAgICBsZXQgY3V0ID0gbmV4dEY7XG4gICAgICAgICAgICAgICAgICAgIGlmIChwb3MgPj0gY3V0LmZyb20gfHwgbmV4dFBvcyA8PSBjdXQudG8gfHwgb2ZmKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBsZXQgZkZyb20gPSBNYXRoLm1heChjdXQuZnJvbSwgcG9zKSAtIG9mZiwgZlRvID0gTWF0aC5taW4oY3V0LnRvLCBuZXh0UG9zKSAtIG9mZjtcbiAgICAgICAgICAgICAgICAgICAgICAgIGN1dCA9IGZGcm9tID49IGZUbyA/IG51bGwgOiBuZXcgVHJlZUZyYWdtZW50KGZGcm9tLCBmVG8sIGN1dC50cmVlLCBjdXQub2Zmc2V0ICsgb2ZmLCBjSSA+IDAsICEhbmV4dEMpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGlmIChjdXQpXG4gICAgICAgICAgICAgICAgICAgICAgICByZXN1bHQucHVzaChjdXQpO1xuICAgICAgICAgICAgICAgICAgICBpZiAobmV4dEYudG8gPiBuZXh0UG9zKVxuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgIG5leHRGID0gZkkgPCBmcmFnbWVudHMubGVuZ3RoID8gZnJhZ21lbnRzW2ZJKytdIDogbnVsbDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoIW5leHRDKVxuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgcG9zID0gbmV4dEMudG9BO1xuICAgICAgICAgICAgb2ZmID0gbmV4dEMudG9BIC0gbmV4dEMudG9CO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxufVxuLy8vIEEgc3VwZXJjbGFzcyB0aGF0IHBhcnNlcnMgc2hvdWxkIGV4dGVuZC5cbmNsYXNzIFBhcnNlciB7XG4gICAgLy8vIFN0YXJ0IGEgcGFyc2UsIHJldHVybmluZyBhIFtwYXJ0aWFsIHBhcnNlXSgjY29tbW9uLlBhcnRpYWxQYXJzZSlcbiAgICAvLy8gb2JqZWN0LiBbYGZyYWdtZW50c2BdKCNjb21tb24uVHJlZUZyYWdtZW50KSBjYW4gYmUgcGFzc2VkIGluIHRvXG4gICAgLy8vIG1ha2UgdGhlIHBhcnNlIGluY3JlbWVudGFsLlxuICAgIC8vL1xuICAgIC8vLyBCeSBkZWZhdWx0LCB0aGUgZW50aXJlIGlucHV0IGlzIHBhcnNlZC4gWW91IGNhbiBwYXNzIGByYW5nZXNgLFxuICAgIC8vLyB3aGljaCBzaG91bGQgYmUgYSBzb3J0ZWQgYXJyYXkgb2Ygbm9uLWVtcHR5LCBub24tb3ZlcmxhcHBpbmdcbiAgICAvLy8gcmFuZ2VzLCB0byBwYXJzZSBvbmx5IHRob3NlIHJhbmdlcy4gVGhlIHRyZWUgcmV0dXJuZWQgaW4gdGhhdFxuICAgIC8vLyBjYXNlIHdpbGwgc3RhcnQgYXQgYHJhbmdlc1swXS5mcm9tYC5cbiAgICBzdGFydFBhcnNlKGlucHV0LCBmcmFnbWVudHMsIHJhbmdlcykge1xuICAgICAgICBpZiAodHlwZW9mIGlucHV0ID09IFwic3RyaW5nXCIpXG4gICAgICAgICAgICBpbnB1dCA9IG5ldyBTdHJpbmdJbnB1dChpbnB1dCk7XG4gICAgICAgIHJhbmdlcyA9ICFyYW5nZXMgPyBbbmV3IFJhbmdlKDAsIGlucHV0Lmxlbmd0aCldIDogcmFuZ2VzLmxlbmd0aCA/IHJhbmdlcy5tYXAociA9PiBuZXcgUmFuZ2Uoci5mcm9tLCByLnRvKSkgOiBbbmV3IFJhbmdlKDAsIDApXTtcbiAgICAgICAgcmV0dXJuIHRoaXMuY3JlYXRlUGFyc2UoaW5wdXQsIGZyYWdtZW50cyB8fCBbXSwgcmFuZ2VzKTtcbiAgICB9XG4gICAgLy8vIFJ1biBhIGZ1bGwgcGFyc2UsIHJldHVybmluZyB0aGUgcmVzdWx0aW5nIHRyZWUuXG4gICAgcGFyc2UoaW5wdXQsIGZyYWdtZW50cywgcmFuZ2VzKSB7XG4gICAgICAgIGxldCBwYXJzZSA9IHRoaXMuc3RhcnRQYXJzZShpbnB1dCwgZnJhZ21lbnRzLCByYW5nZXMpO1xuICAgICAgICBmb3IgKDs7KSB7XG4gICAgICAgICAgICBsZXQgZG9uZSA9IHBhcnNlLmFkdmFuY2UoKTtcbiAgICAgICAgICAgIGlmIChkb25lKVxuICAgICAgICAgICAgICAgIHJldHVybiBkb25lO1xuICAgICAgICB9XG4gICAgfVxufVxuY2xhc3MgU3RyaW5nSW5wdXQge1xuICAgIGNvbnN0cnVjdG9yKHN0cmluZykge1xuICAgICAgICB0aGlzLnN0cmluZyA9IHN0cmluZztcbiAgICB9XG4gICAgZ2V0IGxlbmd0aCgpIHsgcmV0dXJuIHRoaXMuc3RyaW5nLmxlbmd0aDsgfVxuICAgIGNodW5rKGZyb20pIHsgcmV0dXJuIHRoaXMuc3RyaW5nLnNsaWNlKGZyb20pOyB9XG4gICAgZ2V0IGxpbmVDaHVua3MoKSB7IHJldHVybiBmYWxzZTsgfVxuICAgIHJlYWQoZnJvbSwgdG8pIHsgcmV0dXJuIHRoaXMuc3RyaW5nLnNsaWNlKGZyb20sIHRvKTsgfVxufVxuXG4vLy8gQ3JlYXRlIGEgcGFyc2Ugd3JhcHBlciB0aGF0LCBhZnRlciB0aGUgaW5uZXIgcGFyc2UgY29tcGxldGVzLFxuLy8vIHNjYW5zIGl0cyB0cmVlIGZvciBtaXhlZCBsYW5ndWFnZSByZWdpb25zIHdpdGggdGhlIGBuZXN0YFxuLy8vIGZ1bmN0aW9uLCBydW5zIHRoZSByZXN1bHRpbmcgW2lubmVyIHBhcnNlc10oI2NvbW1vbi5OZXN0ZWRQYXJzZSksXG4vLy8gYW5kIHRoZW4gW21vdW50c10oI2NvbW1vbi5Ob2RlUHJvcF5tb3VudGVkKSB0aGVpciByZXN1bHRzIG9udG8gdGhlXG4vLy8gdHJlZS5cbi8vL1xuLy8vIFRoZSBuZXN0aW5nIGZ1bmN0aW9uIGlzIHBhc3NlZCBhIGN1cnNvciB0byBwcm92aWRlIGNvbnRleHQgZm9yIGFcbi8vLyBub2RlLCBidXQgX3Nob3VsZCBub3RfIG1vdmUgdGhhdCBjdXJzb3IsIG9ubHkgaW5zcGVjdCBpdHNcbi8vLyBwcm9wZXJ0aWVzIGFuZCBvcHRpb25hbGx5IGFjY2VzcyBpdHNcbi8vLyBbbm9kZSBvYmplY3RdKCNjb21tb24uVHJlZUN1cnNvci5ub2RlKS5cbmZ1bmN0aW9uIHBhcnNlTWl4ZWQobmVzdCkge1xuICAgIHJldHVybiAocGFyc2UsIGlucHV0LCBmcmFnbWVudHMsIHJhbmdlcykgPT4gbmV3IE1peGVkUGFyc2UocGFyc2UsIG5lc3QsIGlucHV0LCBmcmFnbWVudHMsIHJhbmdlcyk7XG59XG5jbGFzcyBJbm5lclBhcnNlIHtcbiAgICBjb25zdHJ1Y3RvcihwYXJzZXIsIHBhcnNlLCBvdmVybGF5LCB0YXJnZXQsIHJhbmdlcykge1xuICAgICAgICB0aGlzLnBhcnNlciA9IHBhcnNlcjtcbiAgICAgICAgdGhpcy5wYXJzZSA9IHBhcnNlO1xuICAgICAgICB0aGlzLm92ZXJsYXkgPSBvdmVybGF5O1xuICAgICAgICB0aGlzLnRhcmdldCA9IHRhcmdldDtcbiAgICAgICAgdGhpcy5yYW5nZXMgPSByYW5nZXM7XG4gICAgfVxufVxuY2xhc3MgQWN0aXZlT3ZlcmxheSB7XG4gICAgY29uc3RydWN0b3IocGFyc2VyLCBwcmVkaWNhdGUsIG1vdW50cywgaW5kZXgsIHN0YXJ0LCB0YXJnZXQsIHByZXYpIHtcbiAgICAgICAgdGhpcy5wYXJzZXIgPSBwYXJzZXI7XG4gICAgICAgIHRoaXMucHJlZGljYXRlID0gcHJlZGljYXRlO1xuICAgICAgICB0aGlzLm1vdW50cyA9IG1vdW50cztcbiAgICAgICAgdGhpcy5pbmRleCA9IGluZGV4O1xuICAgICAgICB0aGlzLnN0YXJ0ID0gc3RhcnQ7XG4gICAgICAgIHRoaXMudGFyZ2V0ID0gdGFyZ2V0O1xuICAgICAgICB0aGlzLnByZXYgPSBwcmV2O1xuICAgICAgICB0aGlzLmRlcHRoID0gMDtcbiAgICAgICAgdGhpcy5yYW5nZXMgPSBbXTtcbiAgICB9XG59XG5jb25zdCBzdG9wcGVkSW5uZXIgPSBuZXcgTm9kZVByb3AoeyBwZXJOb2RlOiB0cnVlIH0pO1xuY2xhc3MgTWl4ZWRQYXJzZSB7XG4gICAgY29uc3RydWN0b3IoYmFzZSwgbmVzdCwgaW5wdXQsIGZyYWdtZW50cywgcmFuZ2VzKSB7XG4gICAgICAgIHRoaXMubmVzdCA9IG5lc3Q7XG4gICAgICAgIHRoaXMuaW5wdXQgPSBpbnB1dDtcbiAgICAgICAgdGhpcy5mcmFnbWVudHMgPSBmcmFnbWVudHM7XG4gICAgICAgIHRoaXMucmFuZ2VzID0gcmFuZ2VzO1xuICAgICAgICB0aGlzLmlubmVyID0gW107XG4gICAgICAgIHRoaXMuaW5uZXJEb25lID0gMDtcbiAgICAgICAgdGhpcy5iYXNlVHJlZSA9IG51bGw7XG4gICAgICAgIHRoaXMuc3RvcHBlZEF0ID0gbnVsbDtcbiAgICAgICAgdGhpcy5iYXNlUGFyc2UgPSBiYXNlO1xuICAgIH1cbiAgICBhZHZhbmNlKCkge1xuICAgICAgICBpZiAodGhpcy5iYXNlUGFyc2UpIHtcbiAgICAgICAgICAgIGxldCBkb25lID0gdGhpcy5iYXNlUGFyc2UuYWR2YW5jZSgpO1xuICAgICAgICAgICAgaWYgKCFkb25lKVxuICAgICAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICAgICAgdGhpcy5iYXNlUGFyc2UgPSBudWxsO1xuICAgICAgICAgICAgdGhpcy5iYXNlVHJlZSA9IGRvbmU7XG4gICAgICAgICAgICB0aGlzLnN0YXJ0SW5uZXIoKTtcbiAgICAgICAgICAgIGlmICh0aGlzLnN0b3BwZWRBdCAhPSBudWxsKVxuICAgICAgICAgICAgICAgIGZvciAobGV0IGlubmVyIG9mIHRoaXMuaW5uZXIpXG4gICAgICAgICAgICAgICAgICAgIGlubmVyLnBhcnNlLnN0b3BBdCh0aGlzLnN0b3BwZWRBdCk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRoaXMuaW5uZXJEb25lID09IHRoaXMuaW5uZXIubGVuZ3RoKSB7XG4gICAgICAgICAgICBsZXQgcmVzdWx0ID0gdGhpcy5iYXNlVHJlZTtcbiAgICAgICAgICAgIGlmICh0aGlzLnN0b3BwZWRBdCAhPSBudWxsKVxuICAgICAgICAgICAgICAgIHJlc3VsdCA9IG5ldyBUcmVlKHJlc3VsdC50eXBlLCByZXN1bHQuY2hpbGRyZW4sIHJlc3VsdC5wb3NpdGlvbnMsIHJlc3VsdC5sZW5ndGgsIHJlc3VsdC5wcm9wVmFsdWVzLmNvbmNhdChbW3N0b3BwZWRJbm5lciwgdGhpcy5zdG9wcGVkQXRdXSkpO1xuICAgICAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICAgICAgfVxuICAgICAgICBsZXQgaW5uZXIgPSB0aGlzLmlubmVyW3RoaXMuaW5uZXJEb25lXSwgZG9uZSA9IGlubmVyLnBhcnNlLmFkdmFuY2UoKTtcbiAgICAgICAgaWYgKGRvbmUpIHtcbiAgICAgICAgICAgIHRoaXMuaW5uZXJEb25lKys7XG4gICAgICAgICAgICAvLyBUaGlzIGlzIGEgc29tZXdoYXQgZG9kZ3kgYnV0IHN1cGVyIGhlbHBmdWwgaGFjayB3aGVyZSB3ZVxuICAgICAgICAgICAgLy8gcGF0Y2ggdXAgbm9kZXMgY3JlYXRlZCBieSB0aGUgaW5uZXIgcGFyc2UgKGFuZCB0aHVzXG4gICAgICAgICAgICAvLyBwcmVzdW1hYmx5IG5vdCBhbGlhc2VkIGFueXdoZXJlIGVsc2UpIHRvIGhvbGQgdGhlIGluZm9ybWF0aW9uXG4gICAgICAgICAgICAvLyBhYm91dCB0aGUgaW5uZXIgcGFyc2UuXG4gICAgICAgICAgICBsZXQgcHJvcHMgPSBPYmplY3QuYXNzaWduKE9iamVjdC5jcmVhdGUobnVsbCksIGlubmVyLnRhcmdldC5wcm9wcyk7XG4gICAgICAgICAgICBwcm9wc1tOb2RlUHJvcC5tb3VudGVkLmlkXSA9IG5ldyBNb3VudGVkVHJlZShkb25lLCBpbm5lci5vdmVybGF5LCBpbm5lci5wYXJzZXIpO1xuICAgICAgICAgICAgaW5uZXIudGFyZ2V0LnByb3BzID0gcHJvcHM7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuICAgIGdldCBwYXJzZWRQb3MoKSB7XG4gICAgICAgIGlmICh0aGlzLmJhc2VQYXJzZSlcbiAgICAgICAgICAgIHJldHVybiAwO1xuICAgICAgICBsZXQgcG9zID0gdGhpcy5pbnB1dC5sZW5ndGg7XG4gICAgICAgIGZvciAobGV0IGkgPSB0aGlzLmlubmVyRG9uZTsgaSA8IHRoaXMuaW5uZXIubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIGlmICh0aGlzLmlubmVyW2ldLnJhbmdlc1swXS5mcm9tIDwgcG9zKVxuICAgICAgICAgICAgICAgIHBvcyA9IE1hdGgubWluKHBvcywgdGhpcy5pbm5lcltpXS5wYXJzZS5wYXJzZWRQb3MpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBwb3M7XG4gICAgfVxuICAgIHN0b3BBdChwb3MpIHtcbiAgICAgICAgdGhpcy5zdG9wcGVkQXQgPSBwb3M7XG4gICAgICAgIGlmICh0aGlzLmJhc2VQYXJzZSlcbiAgICAgICAgICAgIHRoaXMuYmFzZVBhcnNlLnN0b3BBdChwb3MpO1xuICAgICAgICBlbHNlXG4gICAgICAgICAgICBmb3IgKGxldCBpID0gdGhpcy5pbm5lckRvbmU7IGkgPCB0aGlzLmlubmVyLmxlbmd0aDsgaSsrKVxuICAgICAgICAgICAgICAgIHRoaXMuaW5uZXJbaV0ucGFyc2Uuc3RvcEF0KHBvcyk7XG4gICAgfVxuICAgIHN0YXJ0SW5uZXIoKSB7XG4gICAgICAgIGxldCBmcmFnbWVudEN1cnNvciA9IG5ldyBGcmFnbWVudEN1cnNvcih0aGlzLmZyYWdtZW50cyk7XG4gICAgICAgIGxldCBvdmVybGF5ID0gbnVsbDtcbiAgICAgICAgbGV0IGNvdmVyZWQgPSBudWxsO1xuICAgICAgICBsZXQgY3Vyc29yID0gbmV3IFRyZWVDdXJzb3IobmV3IFRyZWVOb2RlKHRoaXMuYmFzZVRyZWUsIHRoaXMucmFuZ2VzWzBdLmZyb20sIDAsIG51bGwpLCBleHBvcnRzLkl0ZXJNb2RlLkluY2x1ZGVBbm9ueW1vdXMgfCBleHBvcnRzLkl0ZXJNb2RlLklnbm9yZU1vdW50cyk7XG4gICAgICAgIHNjYW46IGZvciAobGV0IG5lc3QsIGlzQ292ZXJlZDsgdGhpcy5zdG9wcGVkQXQgPT0gbnVsbCB8fCBjdXJzb3IuZnJvbSA8IHRoaXMuc3RvcHBlZEF0Oykge1xuICAgICAgICAgICAgbGV0IGVudGVyID0gdHJ1ZSwgcmFuZ2U7XG4gICAgICAgICAgICBpZiAoZnJhZ21lbnRDdXJzb3IuaGFzTm9kZShjdXJzb3IpKSB7XG4gICAgICAgICAgICAgICAgaWYgKG92ZXJsYXkpIHtcbiAgICAgICAgICAgICAgICAgICAgbGV0IG1hdGNoID0gb3ZlcmxheS5tb3VudHMuZmluZChtID0+IG0uZnJhZy5mcm9tIDw9IGN1cnNvci5mcm9tICYmIG0uZnJhZy50byA+PSBjdXJzb3IudG8gJiYgbS5tb3VudC5vdmVybGF5KTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKG1hdGNoKVxuICAgICAgICAgICAgICAgICAgICAgICAgZm9yIChsZXQgciBvZiBtYXRjaC5tb3VudC5vdmVybGF5KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbGV0IGZyb20gPSByLmZyb20gKyBtYXRjaC5wb3MsIHRvID0gci50byArIG1hdGNoLnBvcztcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoZnJvbSA+PSBjdXJzb3IuZnJvbSAmJiB0byA8PSBjdXJzb3IudG8gJiYgIW92ZXJsYXkucmFuZ2VzLnNvbWUociA9PiByLmZyb20gPCB0byAmJiByLnRvID4gZnJvbSkpXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG92ZXJsYXkucmFuZ2VzLnB1c2goeyBmcm9tLCB0byB9KTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZW50ZXIgPSBmYWxzZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKGNvdmVyZWQgJiYgKGlzQ292ZXJlZCA9IGNoZWNrQ292ZXIoY292ZXJlZC5yYW5nZXMsIGN1cnNvci5mcm9tLCBjdXJzb3IudG8pKSkge1xuICAgICAgICAgICAgICAgIGVudGVyID0gaXNDb3ZlcmVkICE9IDIgLyogRnVsbCAqLztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKCFjdXJzb3IudHlwZS5pc0Fub255bW91cyAmJiBjdXJzb3IuZnJvbSA8IGN1cnNvci50byAmJiAobmVzdCA9IHRoaXMubmVzdChjdXJzb3IsIHRoaXMuaW5wdXQpKSkge1xuICAgICAgICAgICAgICAgIGlmICghY3Vyc29yLnRyZWUpXG4gICAgICAgICAgICAgICAgICAgIG1hdGVyaWFsaXplKGN1cnNvcik7XG4gICAgICAgICAgICAgICAgbGV0IG9sZE1vdW50cyA9IGZyYWdtZW50Q3Vyc29yLmZpbmRNb3VudHMoY3Vyc29yLmZyb20sIG5lc3QucGFyc2VyKTtcbiAgICAgICAgICAgICAgICBpZiAodHlwZW9mIG5lc3Qub3ZlcmxheSA9PSBcImZ1bmN0aW9uXCIpIHtcbiAgICAgICAgICAgICAgICAgICAgb3ZlcmxheSA9IG5ldyBBY3RpdmVPdmVybGF5KG5lc3QucGFyc2VyLCBuZXN0Lm92ZXJsYXksIG9sZE1vdW50cywgdGhpcy5pbm5lci5sZW5ndGgsIGN1cnNvci5mcm9tLCBjdXJzb3IudHJlZSwgb3ZlcmxheSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBsZXQgcmFuZ2VzID0gcHVuY2hSYW5nZXModGhpcy5yYW5nZXMsIG5lc3Qub3ZlcmxheSB8fCBbbmV3IFJhbmdlKGN1cnNvci5mcm9tLCBjdXJzb3IudG8pXSk7XG4gICAgICAgICAgICAgICAgICAgIGlmIChyYW5nZXMubGVuZ3RoKVxuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5pbm5lci5wdXNoKG5ldyBJbm5lclBhcnNlKG5lc3QucGFyc2VyLCBuZXN0LnBhcnNlci5zdGFydFBhcnNlKHRoaXMuaW5wdXQsIGVudGVyRnJhZ21lbnRzKG9sZE1vdW50cywgcmFuZ2VzKSwgcmFuZ2VzKSwgbmVzdC5vdmVybGF5ID8gbmVzdC5vdmVybGF5Lm1hcChyID0+IG5ldyBSYW5nZShyLmZyb20gLSBjdXJzb3IuZnJvbSwgci50byAtIGN1cnNvci5mcm9tKSkgOiBudWxsLCBjdXJzb3IudHJlZSwgcmFuZ2VzKSk7XG4gICAgICAgICAgICAgICAgICAgIGlmICghbmVzdC5vdmVybGF5KVxuICAgICAgICAgICAgICAgICAgICAgICAgZW50ZXIgPSBmYWxzZTtcbiAgICAgICAgICAgICAgICAgICAgZWxzZSBpZiAocmFuZ2VzLmxlbmd0aClcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvdmVyZWQgPSB7IHJhbmdlcywgZGVwdGg6IDAsIHByZXY6IGNvdmVyZWQgfTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmIChvdmVybGF5ICYmIChyYW5nZSA9IG92ZXJsYXkucHJlZGljYXRlKGN1cnNvcikpKSB7XG4gICAgICAgICAgICAgICAgaWYgKHJhbmdlID09PSB0cnVlKVxuICAgICAgICAgICAgICAgICAgICByYW5nZSA9IG5ldyBSYW5nZShjdXJzb3IuZnJvbSwgY3Vyc29yLnRvKTtcbiAgICAgICAgICAgICAgICBpZiAocmFuZ2UuZnJvbSA8IHJhbmdlLnRvKVxuICAgICAgICAgICAgICAgICAgICBvdmVybGF5LnJhbmdlcy5wdXNoKHJhbmdlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChlbnRlciAmJiBjdXJzb3IuZmlyc3RDaGlsZCgpKSB7XG4gICAgICAgICAgICAgICAgaWYgKG92ZXJsYXkpXG4gICAgICAgICAgICAgICAgICAgIG92ZXJsYXkuZGVwdGgrKztcbiAgICAgICAgICAgICAgICBpZiAoY292ZXJlZClcbiAgICAgICAgICAgICAgICAgICAgY292ZXJlZC5kZXB0aCsrO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgZm9yICg7Oykge1xuICAgICAgICAgICAgICAgICAgICBpZiAoY3Vyc29yLm5leHRTaWJsaW5nKCkpXG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgaWYgKCFjdXJzb3IucGFyZW50KCkpXG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhayBzY2FuO1xuICAgICAgICAgICAgICAgICAgICBpZiAob3ZlcmxheSAmJiAhLS1vdmVybGF5LmRlcHRoKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBsZXQgcmFuZ2VzID0gcHVuY2hSYW5nZXModGhpcy5yYW5nZXMsIG92ZXJsYXkucmFuZ2VzKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChyYW5nZXMubGVuZ3RoKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuaW5uZXIuc3BsaWNlKG92ZXJsYXkuaW5kZXgsIDAsIG5ldyBJbm5lclBhcnNlKG92ZXJsYXkucGFyc2VyLCBvdmVybGF5LnBhcnNlci5zdGFydFBhcnNlKHRoaXMuaW5wdXQsIGVudGVyRnJhZ21lbnRzKG92ZXJsYXkubW91bnRzLCByYW5nZXMpLCByYW5nZXMpLCBvdmVybGF5LnJhbmdlcy5tYXAociA9PiBuZXcgUmFuZ2Uoci5mcm9tIC0gb3ZlcmxheS5zdGFydCwgci50byAtIG92ZXJsYXkuc3RhcnQpKSwgb3ZlcmxheS50YXJnZXQsIHJhbmdlcykpO1xuICAgICAgICAgICAgICAgICAgICAgICAgb3ZlcmxheSA9IG92ZXJsYXkucHJldjtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBpZiAoY292ZXJlZCAmJiAhLS1jb3ZlcmVkLmRlcHRoKVxuICAgICAgICAgICAgICAgICAgICAgICAgY292ZXJlZCA9IGNvdmVyZWQucHJldjtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG59XG5mdW5jdGlvbiBjaGVja0NvdmVyKGNvdmVyZWQsIGZyb20sIHRvKSB7XG4gICAgZm9yIChsZXQgcmFuZ2Ugb2YgY292ZXJlZCkge1xuICAgICAgICBpZiAocmFuZ2UuZnJvbSA+PSB0bylcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICBpZiAocmFuZ2UudG8gPiBmcm9tKVxuICAgICAgICAgICAgcmV0dXJuIHJhbmdlLmZyb20gPD0gZnJvbSAmJiByYW5nZS50byA+PSB0byA/IDIgLyogRnVsbCAqLyA6IDEgLyogUGFydGlhbCAqLztcbiAgICB9XG4gICAgcmV0dXJuIDAgLyogTm9uZSAqLztcbn1cbi8vIFRha2UgYSBwaWVjZSBvZiBidWZmZXIgYW5kIGNvbnZlcnQgaXQgaW50byBhIHN0YW5kLWFsb25lXG4vLyBUcmVlQnVmZmVyLlxuZnVuY3Rpb24gc2xpY2VCdWYoYnVmLCBzdGFydEksIGVuZEksIG5vZGVzLCBwb3NpdGlvbnMsIG9mZikge1xuICAgIGlmIChzdGFydEkgPCBlbmRJKSB7XG4gICAgICAgIGxldCBmcm9tID0gYnVmLmJ1ZmZlcltzdGFydEkgKyAxXSwgdG8gPSBidWYuYnVmZmVyW2VuZEkgLSAyXTtcbiAgICAgICAgbm9kZXMucHVzaChidWYuc2xpY2Uoc3RhcnRJLCBlbmRJLCBmcm9tLCB0bykpO1xuICAgICAgICBwb3NpdGlvbnMucHVzaChmcm9tIC0gb2ZmKTtcbiAgICB9XG59XG4vLyBUaGlzIGZ1bmN0aW9uIHRha2VzIGEgbm9kZSB0aGF0J3MgaW4gYSBidWZmZXIsIGFuZCBjb252ZXJ0cyBpdCwgYW5kXG4vLyBpdHMgcGFyZW50IGJ1ZmZlciBub2RlcywgaW50byBhIFRyZWUuIFRoaXMgaXMgYWdhaW4gYWN0aW5nIG9uIHRoZVxuLy8gYXNzdW1wdGlvbiB0aGF0IHRoZSB0cmVlcyBhbmQgYnVmZmVycyBoYXZlIGJlZW4gY29uc3RydWN0ZWQgYnkgdGhlXG4vLyBwYXJzZSB0aGF0IHdhcyByYW4gdmlhIHRoZSBtaXggcGFyc2VyLCBhbmQgdGh1cyBhcmVuJ3Qgc2hhcmVkIHdpdGhcbi8vIGFueSBvdGhlciBjb2RlLCBtYWtpbmcgdmlvbGF0aW9ucyBvZiB0aGUgaW1tdXRhYmlsaXR5IHNhZmUuXG5mdW5jdGlvbiBtYXRlcmlhbGl6ZShjdXJzb3IpIHtcbiAgICBsZXQgeyBub2RlIH0gPSBjdXJzb3IsIGRlcHRoID0gMDtcbiAgICAvLyBTY2FuIHVwIHRvIHRoZSBuZWFyZXN0IHRyZWVcbiAgICBkbyB7XG4gICAgICAgIGN1cnNvci5wYXJlbnQoKTtcbiAgICAgICAgZGVwdGgrKztcbiAgICB9IHdoaWxlICghY3Vyc29yLnRyZWUpO1xuICAgIC8vIEZpbmQgdGhlIGluZGV4IG9mIHRoZSBidWZmZXIgaW4gdGhhdCB0cmVlXG4gICAgbGV0IGkgPSAwLCBiYXNlID0gY3Vyc29yLnRyZWUsIG9mZiA9IDA7XG4gICAgZm9yICg7OyBpKyspIHtcbiAgICAgICAgb2ZmID0gYmFzZS5wb3NpdGlvbnNbaV0gKyBjdXJzb3IuZnJvbTtcbiAgICAgICAgaWYgKG9mZiA8PSBub2RlLmZyb20gJiYgb2ZmICsgYmFzZS5jaGlsZHJlbltpXS5sZW5ndGggPj0gbm9kZS50bylcbiAgICAgICAgICAgIGJyZWFrO1xuICAgIH1cbiAgICBsZXQgYnVmID0gYmFzZS5jaGlsZHJlbltpXSwgYiA9IGJ1Zi5idWZmZXI7XG4gICAgLy8gU3BsaXQgYSBsZXZlbCBpbiB0aGUgYnVmZmVyLCBwdXR0aW5nIHRoZSBub2RlcyBiZWZvcmUgYW5kIGFmdGVyXG4gICAgLy8gdGhlIGNoaWxkIHRoYXQgY29udGFpbnMgYG5vZGVgIGludG8gbmV3IGJ1ZmZlcnMuXG4gICAgZnVuY3Rpb24gc3BsaXQoc3RhcnRJLCBlbmRJLCB0eXBlLCBpbm5lck9mZnNldCwgbGVuZ3RoKSB7XG4gICAgICAgIGxldCBpID0gc3RhcnRJO1xuICAgICAgICB3aGlsZSAoYltpICsgMl0gKyBvZmYgPD0gbm9kZS5mcm9tKVxuICAgICAgICAgICAgaSA9IGJbaSArIDNdO1xuICAgICAgICBsZXQgY2hpbGRyZW4gPSBbXSwgcG9zaXRpb25zID0gW107XG4gICAgICAgIHNsaWNlQnVmKGJ1Ziwgc3RhcnRJLCBpLCBjaGlsZHJlbiwgcG9zaXRpb25zLCBpbm5lck9mZnNldCk7XG4gICAgICAgIGxldCBmcm9tID0gYltpICsgMV0sIHRvID0gYltpICsgMl07XG4gICAgICAgIGxldCBpc1RhcmdldCA9IGZyb20gKyBvZmYgPT0gbm9kZS5mcm9tICYmIHRvICsgb2ZmID09IG5vZGUudG8gJiYgYltpXSA9PSBub2RlLnR5cGUuaWQ7XG4gICAgICAgIGNoaWxkcmVuLnB1c2goaXNUYXJnZXQgPyBub2RlLnRvVHJlZSgpIDogc3BsaXQoaSArIDQsIGJbaSArIDNdLCBidWYuc2V0LnR5cGVzW2JbaV1dLCBmcm9tLCB0byAtIGZyb20pKTtcbiAgICAgICAgcG9zaXRpb25zLnB1c2goZnJvbSAtIGlubmVyT2Zmc2V0KTtcbiAgICAgICAgc2xpY2VCdWYoYnVmLCBiW2kgKyAzXSwgZW5kSSwgY2hpbGRyZW4sIHBvc2l0aW9ucywgaW5uZXJPZmZzZXQpO1xuICAgICAgICByZXR1cm4gbmV3IFRyZWUodHlwZSwgY2hpbGRyZW4sIHBvc2l0aW9ucywgbGVuZ3RoKTtcbiAgICB9XG4gICAgYmFzZS5jaGlsZHJlbltpXSA9IHNwbGl0KDAsIGIubGVuZ3RoLCBOb2RlVHlwZS5ub25lLCAwLCBidWYubGVuZ3RoKTtcbiAgICAvLyBNb3ZlIHRoZSBjdXJzb3IgYmFjayB0byB0aGUgdGFyZ2V0IG5vZGVcbiAgICBmb3IgKGxldCBkID0gMDsgZCA8PSBkZXB0aDsgZCsrKVxuICAgICAgICBjdXJzb3IuY2hpbGRBZnRlcihub2RlLmZyb20pO1xufVxuY2xhc3MgU3RydWN0dXJlQ3Vyc29yIHtcbiAgICBjb25zdHJ1Y3Rvcihyb290LCBvZmZzZXQpIHtcbiAgICAgICAgdGhpcy5vZmZzZXQgPSBvZmZzZXQ7XG4gICAgICAgIHRoaXMuZG9uZSA9IGZhbHNlO1xuICAgICAgICB0aGlzLmN1cnNvciA9IHJvb3QuY3Vyc29yKGV4cG9ydHMuSXRlck1vZGUuSW5jbHVkZUFub255bW91cyB8IGV4cG9ydHMuSXRlck1vZGUuSWdub3JlTW91bnRzKTtcbiAgICB9XG4gICAgLy8gTW92ZSB0byB0aGUgZmlyc3Qgbm9kZSAoaW4gcHJlLW9yZGVyKSB0aGF0IHN0YXJ0cyBhdCBvciBhZnRlciBgcG9zYC5cbiAgICBtb3ZlVG8ocG9zKSB7XG4gICAgICAgIGxldCB7IGN1cnNvciB9ID0gdGhpcywgcCA9IHBvcyAtIHRoaXMub2Zmc2V0O1xuICAgICAgICB3aGlsZSAoIXRoaXMuZG9uZSAmJiBjdXJzb3IuZnJvbSA8IHApIHtcbiAgICAgICAgICAgIGlmIChjdXJzb3IudG8gPj0gcG9zICYmIGN1cnNvci5lbnRlcihwLCAxLCBleHBvcnRzLkl0ZXJNb2RlLklnbm9yZU92ZXJsYXlzIHwgZXhwb3J0cy5JdGVyTW9kZS5FeGNsdWRlQnVmZmVycykpIDtcbiAgICAgICAgICAgIGVsc2UgaWYgKCFjdXJzb3IubmV4dChmYWxzZSkpXG4gICAgICAgICAgICAgICAgdGhpcy5kb25lID0gdHJ1ZTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBoYXNOb2RlKGN1cnNvcikge1xuICAgICAgICB0aGlzLm1vdmVUbyhjdXJzb3IuZnJvbSk7XG4gICAgICAgIGlmICghdGhpcy5kb25lICYmIHRoaXMuY3Vyc29yLmZyb20gKyB0aGlzLm9mZnNldCA9PSBjdXJzb3IuZnJvbSAmJiB0aGlzLmN1cnNvci50cmVlKSB7XG4gICAgICAgICAgICBmb3IgKGxldCB0cmVlID0gdGhpcy5jdXJzb3IudHJlZTs7KSB7XG4gICAgICAgICAgICAgICAgaWYgKHRyZWUgPT0gY3Vyc29yLnRyZWUpXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICAgICAgICAgIGlmICh0cmVlLmNoaWxkcmVuLmxlbmd0aCAmJiB0cmVlLnBvc2l0aW9uc1swXSA9PSAwICYmIHRyZWUuY2hpbGRyZW5bMF0gaW5zdGFuY2VvZiBUcmVlKVxuICAgICAgICAgICAgICAgICAgICB0cmVlID0gdHJlZS5jaGlsZHJlblswXTtcbiAgICAgICAgICAgICAgICBlbHNlXG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG59XG5jbGFzcyBGcmFnbWVudEN1cnNvciB7XG4gICAgY29uc3RydWN0b3IoZnJhZ21lbnRzKSB7XG4gICAgICAgIHZhciBfYTtcbiAgICAgICAgdGhpcy5mcmFnbWVudHMgPSBmcmFnbWVudHM7XG4gICAgICAgIHRoaXMuY3VyVG8gPSAwO1xuICAgICAgICB0aGlzLmZyYWdJID0gMDtcbiAgICAgICAgaWYgKGZyYWdtZW50cy5sZW5ndGgpIHtcbiAgICAgICAgICAgIGxldCBmaXJzdCA9IHRoaXMuY3VyRnJhZyA9IGZyYWdtZW50c1swXTtcbiAgICAgICAgICAgIHRoaXMuY3VyVG8gPSAoX2EgPSBmaXJzdC50cmVlLnByb3Aoc3RvcHBlZElubmVyKSkgIT09IG51bGwgJiYgX2EgIT09IHZvaWQgMCA/IF9hIDogZmlyc3QudG87XG4gICAgICAgICAgICB0aGlzLmlubmVyID0gbmV3IFN0cnVjdHVyZUN1cnNvcihmaXJzdC50cmVlLCAtZmlyc3Qub2Zmc2V0KTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMuY3VyRnJhZyA9IHRoaXMuaW5uZXIgPSBudWxsO1xuICAgICAgICB9XG4gICAgfVxuICAgIGhhc05vZGUobm9kZSkge1xuICAgICAgICB3aGlsZSAodGhpcy5jdXJGcmFnICYmIG5vZGUuZnJvbSA+PSB0aGlzLmN1clRvKVxuICAgICAgICAgICAgdGhpcy5uZXh0RnJhZygpO1xuICAgICAgICByZXR1cm4gdGhpcy5jdXJGcmFnICYmIHRoaXMuY3VyRnJhZy5mcm9tIDw9IG5vZGUuZnJvbSAmJiB0aGlzLmN1clRvID49IG5vZGUudG8gJiYgdGhpcy5pbm5lci5oYXNOb2RlKG5vZGUpO1xuICAgIH1cbiAgICBuZXh0RnJhZygpIHtcbiAgICAgICAgdmFyIF9hO1xuICAgICAgICB0aGlzLmZyYWdJKys7XG4gICAgICAgIGlmICh0aGlzLmZyYWdJID09IHRoaXMuZnJhZ21lbnRzLmxlbmd0aCkge1xuICAgICAgICAgICAgdGhpcy5jdXJGcmFnID0gdGhpcy5pbm5lciA9IG51bGw7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBsZXQgZnJhZyA9IHRoaXMuY3VyRnJhZyA9IHRoaXMuZnJhZ21lbnRzW3RoaXMuZnJhZ0ldO1xuICAgICAgICAgICAgdGhpcy5jdXJUbyA9IChfYSA9IGZyYWcudHJlZS5wcm9wKHN0b3BwZWRJbm5lcikpICE9PSBudWxsICYmIF9hICE9PSB2b2lkIDAgPyBfYSA6IGZyYWcudG87XG4gICAgICAgICAgICB0aGlzLmlubmVyID0gbmV3IFN0cnVjdHVyZUN1cnNvcihmcmFnLnRyZWUsIC1mcmFnLm9mZnNldCk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgZmluZE1vdW50cyhwb3MsIHBhcnNlcikge1xuICAgICAgICB2YXIgX2E7XG4gICAgICAgIGxldCByZXN1bHQgPSBbXTtcbiAgICAgICAgaWYgKHRoaXMuaW5uZXIpIHtcbiAgICAgICAgICAgIHRoaXMuaW5uZXIuY3Vyc29yLm1vdmVUbyhwb3MsIDEpO1xuICAgICAgICAgICAgZm9yIChsZXQgcG9zID0gdGhpcy5pbm5lci5jdXJzb3Iubm9kZTsgcG9zOyBwb3MgPSBwb3MucGFyZW50KSB7XG4gICAgICAgICAgICAgICAgbGV0IG1vdW50ID0gKF9hID0gcG9zLnRyZWUpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5wcm9wKE5vZGVQcm9wLm1vdW50ZWQpO1xuICAgICAgICAgICAgICAgIGlmIChtb3VudCAmJiBtb3VudC5wYXJzZXIgPT0gcGFyc2VyKSB7XG4gICAgICAgICAgICAgICAgICAgIGZvciAobGV0IGkgPSB0aGlzLmZyYWdJOyBpIDwgdGhpcy5mcmFnbWVudHMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGxldCBmcmFnID0gdGhpcy5mcmFnbWVudHNbaV07XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoZnJhZy5mcm9tID49IHBvcy50bylcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChmcmFnLnRyZWUgPT0gdGhpcy5jdXJGcmFnLnRyZWUpXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVzdWx0LnB1c2goe1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBmcmFnLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBwb3M6IHBvcy5mcm9tIC0gZnJhZy5vZmZzZXQsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG1vdW50XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG59XG5mdW5jdGlvbiBwdW5jaFJhbmdlcyhvdXRlciwgcmFuZ2VzKSB7XG4gICAgbGV0IGNvcHkgPSBudWxsLCBjdXJyZW50ID0gcmFuZ2VzO1xuICAgIGZvciAobGV0IGkgPSAxLCBqID0gMDsgaSA8IG91dGVyLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIGxldCBnYXBGcm9tID0gb3V0ZXJbaSAtIDFdLnRvLCBnYXBUbyA9IG91dGVyW2ldLmZyb207XG4gICAgICAgIGZvciAoOyBqIDwgY3VycmVudC5sZW5ndGg7IGorKykge1xuICAgICAgICAgICAgbGV0IHIgPSBjdXJyZW50W2pdO1xuICAgICAgICAgICAgaWYgKHIuZnJvbSA+PSBnYXBUbylcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGlmIChyLnRvIDw9IGdhcEZyb20pXG4gICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICBpZiAoIWNvcHkpXG4gICAgICAgICAgICAgICAgY3VycmVudCA9IGNvcHkgPSByYW5nZXMuc2xpY2UoKTtcbiAgICAgICAgICAgIGlmIChyLmZyb20gPCBnYXBGcm9tKSB7XG4gICAgICAgICAgICAgICAgY29weVtqXSA9IG5ldyBSYW5nZShyLmZyb20sIGdhcEZyb20pO1xuICAgICAgICAgICAgICAgIGlmIChyLnRvID4gZ2FwVG8pXG4gICAgICAgICAgICAgICAgICAgIGNvcHkuc3BsaWNlKGogKyAxLCAwLCBuZXcgUmFuZ2UoZ2FwVG8sIHIudG8pKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKHIudG8gPiBnYXBUbykge1xuICAgICAgICAgICAgICAgIGNvcHlbai0tXSA9IG5ldyBSYW5nZShnYXBUbywgci50byk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBjb3B5LnNwbGljZShqLS0sIDEpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiBjdXJyZW50O1xufVxuZnVuY3Rpb24gZmluZENvdmVyQ2hhbmdlcyhhLCBiLCBmcm9tLCB0bykge1xuICAgIGxldCBpQSA9IDAsIGlCID0gMCwgaW5BID0gZmFsc2UsIGluQiA9IGZhbHNlLCBwb3MgPSAtMWU5O1xuICAgIGxldCByZXN1bHQgPSBbXTtcbiAgICBmb3IgKDs7KSB7XG4gICAgICAgIGxldCBuZXh0QSA9IGlBID09IGEubGVuZ3RoID8gMWU5IDogaW5BID8gYVtpQV0udG8gOiBhW2lBXS5mcm9tO1xuICAgICAgICBsZXQgbmV4dEIgPSBpQiA9PSBiLmxlbmd0aCA/IDFlOSA6IGluQiA/IGJbaUJdLnRvIDogYltpQl0uZnJvbTtcbiAgICAgICAgaWYgKGluQSAhPSBpbkIpIHtcbiAgICAgICAgICAgIGxldCBzdGFydCA9IE1hdGgubWF4KHBvcywgZnJvbSksIGVuZCA9IE1hdGgubWluKG5leHRBLCBuZXh0QiwgdG8pO1xuICAgICAgICAgICAgaWYgKHN0YXJ0IDwgZW5kKVxuICAgICAgICAgICAgICAgIHJlc3VsdC5wdXNoKG5ldyBSYW5nZShzdGFydCwgZW5kKSk7XG4gICAgICAgIH1cbiAgICAgICAgcG9zID0gTWF0aC5taW4obmV4dEEsIG5leHRCKTtcbiAgICAgICAgaWYgKHBvcyA9PSAxZTkpXG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgaWYgKG5leHRBID09IHBvcykge1xuICAgICAgICAgICAgaWYgKCFpbkEpXG4gICAgICAgICAgICAgICAgaW5BID0gdHJ1ZTtcbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIGluQSA9IGZhbHNlO1xuICAgICAgICAgICAgICAgIGlBKys7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgaWYgKG5leHRCID09IHBvcykge1xuICAgICAgICAgICAgaWYgKCFpbkIpXG4gICAgICAgICAgICAgICAgaW5CID0gdHJ1ZTtcbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIGluQiA9IGZhbHNlO1xuICAgICAgICAgICAgICAgIGlCKys7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHJlc3VsdDtcbn1cbi8vIEdpdmVuIGEgbnVtYmVyIG9mIGZyYWdtZW50cyBmb3IgdGhlIG91dGVyIHRyZWUsIGFuZCBhIHNldCBvZiByYW5nZXNcbi8vIHRvIHBhcnNlLCBmaW5kIGZyYWdtZW50cyBmb3IgaW5uZXIgdHJlZXMgbW91bnRlZCBhcm91bmQgdGhvc2Vcbi8vIHJhbmdlcywgaWYgYW55LlxuZnVuY3Rpb24gZW50ZXJGcmFnbWVudHMobW91bnRzLCByYW5nZXMpIHtcbiAgICBsZXQgcmVzdWx0ID0gW107XG4gICAgZm9yIChsZXQgeyBwb3MsIG1vdW50LCBmcmFnIH0gb2YgbW91bnRzKSB7XG4gICAgICAgIGxldCBzdGFydFBvcyA9IHBvcyArIChtb3VudC5vdmVybGF5ID8gbW91bnQub3ZlcmxheVswXS5mcm9tIDogMCksIGVuZFBvcyA9IHN0YXJ0UG9zICsgbW91bnQudHJlZS5sZW5ndGg7XG4gICAgICAgIGxldCBmcm9tID0gTWF0aC5tYXgoZnJhZy5mcm9tLCBzdGFydFBvcyksIHRvID0gTWF0aC5taW4oZnJhZy50bywgZW5kUG9zKTtcbiAgICAgICAgaWYgKG1vdW50Lm92ZXJsYXkpIHtcbiAgICAgICAgICAgIGxldCBvdmVybGF5ID0gbW91bnQub3ZlcmxheS5tYXAociA9PiBuZXcgUmFuZ2Uoci5mcm9tICsgcG9zLCByLnRvICsgcG9zKSk7XG4gICAgICAgICAgICBsZXQgY2hhbmdlcyA9IGZpbmRDb3ZlckNoYW5nZXMocmFuZ2VzLCBvdmVybGF5LCBmcm9tLCB0byk7XG4gICAgICAgICAgICBmb3IgKGxldCBpID0gMCwgcG9zID0gZnJvbTs7IGkrKykge1xuICAgICAgICAgICAgICAgIGxldCBsYXN0ID0gaSA9PSBjaGFuZ2VzLmxlbmd0aCwgZW5kID0gbGFzdCA/IHRvIDogY2hhbmdlc1tpXS5mcm9tO1xuICAgICAgICAgICAgICAgIGlmIChlbmQgPiBwb3MpXG4gICAgICAgICAgICAgICAgICAgIHJlc3VsdC5wdXNoKG5ldyBUcmVlRnJhZ21lbnQocG9zLCBlbmQsIG1vdW50LnRyZWUsIC1zdGFydFBvcywgZnJhZy5mcm9tID49IHBvcywgZnJhZy50byA8PSBlbmQpKTtcbiAgICAgICAgICAgICAgICBpZiAobGFzdClcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgcG9zID0gY2hhbmdlc1tpXS50bztcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHJlc3VsdC5wdXNoKG5ldyBUcmVlRnJhZ21lbnQoZnJvbSwgdG8sIG1vdW50LnRyZWUsIC1zdGFydFBvcywgZnJhZy5mcm9tID49IHN0YXJ0UG9zLCBmcmFnLnRvIDw9IGVuZFBvcykpO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiByZXN1bHQ7XG59XG5cbmV4cG9ydHMuRGVmYXVsdEJ1ZmZlckxlbmd0aCA9IERlZmF1bHRCdWZmZXJMZW5ndGg7XG5leHBvcnRzLk1vdW50ZWRUcmVlID0gTW91bnRlZFRyZWU7XG5leHBvcnRzLk5vZGVQcm9wID0gTm9kZVByb3A7XG5leHBvcnRzLk5vZGVTZXQgPSBOb2RlU2V0O1xuZXhwb3J0cy5Ob2RlVHlwZSA9IE5vZGVUeXBlO1xuZXhwb3J0cy5Ob2RlV2Vha01hcCA9IE5vZGVXZWFrTWFwO1xuZXhwb3J0cy5QYXJzZXIgPSBQYXJzZXI7XG5leHBvcnRzLlRyZWUgPSBUcmVlO1xuZXhwb3J0cy5UcmVlQnVmZmVyID0gVHJlZUJ1ZmZlcjtcbmV4cG9ydHMuVHJlZUN1cnNvciA9IFRyZWVDdXJzb3I7XG5leHBvcnRzLlRyZWVGcmFnbWVudCA9IFRyZWVGcmFnbWVudDtcbmV4cG9ydHMucGFyc2VNaXhlZCA9IHBhcnNlTWl4ZWQ7XG4iLCIndXNlIHN0cmljdCc7XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCAnX19lc01vZHVsZScsIHsgdmFsdWU6IHRydWUgfSk7XG5cbnZhciBjb21tb24gPSByZXF1aXJlKCdAbGV6ZXIvY29tbW9uJyk7XG5cbmxldCBuZXh0VGFnSUQgPSAwO1xuLy8vIEhpZ2hsaWdodGluZyB0YWdzIGFyZSBtYXJrZXJzIHRoYXQgZGVub3RlIGEgaGlnaGxpZ2h0aW5nIGNhdGVnb3J5LlxuLy8vIFRoZXkgYXJlIFthc3NvY2lhdGVkXSgjaGlnaGxpZ2h0LnN0eWxlVGFncykgd2l0aCBwYXJ0cyBvZiBhIHN5bnRheFxuLy8vIHRyZWUgYnkgYSBsYW5ndWFnZSBtb2RlLCBhbmQgdGhlbiBtYXBwZWQgdG8gYW4gYWN0dWFsIENTUyBzdHlsZSBieVxuLy8vIGEgW2hpZ2hsaWdodGVyXSgjaGlnaGxpZ2h0LkhpZ2hsaWdodGVyKS5cbi8vL1xuLy8vIEJlY2F1c2Ugc3ludGF4IHRyZWUgbm9kZSB0eXBlcyBhbmQgaGlnaGxpZ2h0IHN0eWxlcyBoYXZlIHRvIGJlXG4vLy8gYWJsZSB0byB0YWxrIHRoZSBzYW1lIGxhbmd1YWdlLCBDb2RlTWlycm9yIHVzZXMgYSBtb3N0bHkgX2Nsb3NlZF9cbi8vLyBbdm9jYWJ1bGFyeV0oI2hpZ2hsaWdodC50YWdzKSBvZiBzeW50YXggdGFncyAoYXMgb3Bwb3NlZCB0b1xuLy8vIHRyYWRpdGlvbmFsIG9wZW4gc3RyaW5nLWJhc2VkIHN5c3RlbXMsIHdoaWNoIG1ha2UgaXQgaGFyZCBmb3Jcbi8vLyBoaWdobGlnaHRpbmcgdGhlbWVzIHRvIGNvdmVyIGFsbCB0aGUgdG9rZW5zIHByb2R1Y2VkIGJ5IHRoZVxuLy8vIHZhcmlvdXMgbGFuZ3VhZ2VzKS5cbi8vL1xuLy8vIEl0IF9pc18gcG9zc2libGUgdG8gW2RlZmluZV0oI2hpZ2hsaWdodC5UYWdeZGVmaW5lKSB5b3VyIG93blxuLy8vIGhpZ2hsaWdodGluZyB0YWdzIGZvciBzeXN0ZW0taW50ZXJuYWwgdXNlICh3aGVyZSB5b3UgY29udHJvbCBib3RoXG4vLy8gdGhlIGxhbmd1YWdlIHBhY2thZ2UgYW5kIHRoZSBoaWdobGlnaHRlciksIGJ1dCBzdWNoIHRhZ3Mgd2lsbCBub3Rcbi8vLyBiZSBwaWNrZWQgdXAgYnkgcmVndWxhciBoaWdobGlnaHRlcnMgKHRob3VnaCB5b3UgY2FuIGRlcml2ZSB0aGVtXG4vLy8gZnJvbSBzdGFuZGFyZCB0YWdzIHRvIGFsbG93IGhpZ2hsaWdodGVycyB0byBmYWxsIGJhY2sgdG8gdGhvc2UpLlxuY2xhc3MgVGFnIHtcbiAgICAvLy8gQGludGVybmFsXG4gICAgY29uc3RydWN0b3IoXG4gICAgLy8vIFRoZSBzZXQgb2YgdGhpcyB0YWcgYW5kIGFsbCBpdHMgcGFyZW50IHRhZ3MsIHN0YXJ0aW5nIHdpdGhcbiAgICAvLy8gdGhpcyBvbmUgaXRzZWxmIGFuZCBzb3J0ZWQgaW4gb3JkZXIgb2YgZGVjcmVhc2luZyBzcGVjaWZpY2l0eS5cbiAgICBzZXQsIFxuICAgIC8vLyBUaGUgYmFzZSB1bm1vZGlmaWVkIHRhZyB0aGF0IHRoaXMgb25lIGlzIGJhc2VkIG9uLCBpZiBpdCdzXG4gICAgLy8vIG1vZGlmaWVkIEBpbnRlcm5hbFxuICAgIGJhc2UsIFxuICAgIC8vLyBUaGUgbW9kaWZpZXJzIGFwcGxpZWQgdG8gdGhpcy5iYXNlIEBpbnRlcm5hbFxuICAgIG1vZGlmaWVkKSB7XG4gICAgICAgIHRoaXMuc2V0ID0gc2V0O1xuICAgICAgICB0aGlzLmJhc2UgPSBiYXNlO1xuICAgICAgICB0aGlzLm1vZGlmaWVkID0gbW9kaWZpZWQ7XG4gICAgICAgIC8vLyBAaW50ZXJuYWxcbiAgICAgICAgdGhpcy5pZCA9IG5leHRUYWdJRCsrO1xuICAgIH1cbiAgICAvLy8gRGVmaW5lIGEgbmV3IHRhZy4gSWYgYHBhcmVudGAgaXMgZ2l2ZW4sIHRoZSB0YWcgaXMgdHJlYXRlZCBhcyBhXG4gICAgLy8vIHN1Yi10YWcgb2YgdGhhdCBwYXJlbnQsIGFuZFxuICAgIC8vLyBbaGlnaGxpZ2h0ZXJzXSgjaGlnaGxpZ2h0LnRhZ0hpZ2hsaWdodGVyKSB0aGF0IGRvbid0IG1lbnRpb25cbiAgICAvLy8gdGhpcyB0YWcgd2lsbCB0cnkgdG8gZmFsbCBiYWNrIHRvIHRoZSBwYXJlbnQgdGFnIChvciBncmFuZHBhcmVudFxuICAgIC8vLyB0YWcsIGV0YykuXG4gICAgc3RhdGljIGRlZmluZShwYXJlbnQpIHtcbiAgICAgICAgaWYgKHBhcmVudCA9PT0gbnVsbCB8fCBwYXJlbnQgPT09IHZvaWQgMCA/IHZvaWQgMCA6IHBhcmVudC5iYXNlKVxuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiQ2FuIG5vdCBkZXJpdmUgZnJvbSBhIG1vZGlmaWVkIHRhZ1wiKTtcbiAgICAgICAgbGV0IHRhZyA9IG5ldyBUYWcoW10sIG51bGwsIFtdKTtcbiAgICAgICAgdGFnLnNldC5wdXNoKHRhZyk7XG4gICAgICAgIGlmIChwYXJlbnQpXG4gICAgICAgICAgICBmb3IgKGxldCB0IG9mIHBhcmVudC5zZXQpXG4gICAgICAgICAgICAgICAgdGFnLnNldC5wdXNoKHQpO1xuICAgICAgICByZXR1cm4gdGFnO1xuICAgIH1cbiAgICAvLy8gRGVmaW5lIGEgdGFnIF9tb2RpZmllcl8sIHdoaWNoIGlzIGEgZnVuY3Rpb24gdGhhdCwgZ2l2ZW4gYSB0YWcsXG4gICAgLy8vIHdpbGwgcmV0dXJuIGEgdGFnIHRoYXQgaXMgYSBzdWJ0YWcgb2YgdGhlIG9yaWdpbmFsLiBBcHBseWluZyB0aGVcbiAgICAvLy8gc2FtZSBtb2RpZmllciB0byBhIHR3aWNlIHRhZyB3aWxsIHJldHVybiB0aGUgc2FtZSB2YWx1ZSAoYG0xKHQxKVxuICAgIC8vLyA9PSBtMSh0MSlgKSBhbmQgYXBwbHlpbmcgbXVsdGlwbGUgbW9kaWZpZXJzIHdpbGwsIHJlZ2FyZGxlc3Mgb3JcbiAgICAvLy8gb3JkZXIsIHByb2R1Y2UgdGhlIHNhbWUgdGFnIChgbTEobTIodDEpKSA9PSBtMihtMSh0MSkpYCkuXG4gICAgLy8vXG4gICAgLy8vIFdoZW4gbXVsdGlwbGUgbW9kaWZpZXJzIGFyZSBhcHBsaWVkIHRvIGEgZ2l2ZW4gYmFzZSB0YWcsIGVhY2hcbiAgICAvLy8gc21hbGxlciBzZXQgb2YgbW9kaWZpZXJzIGlzIHJlZ2lzdGVyZWQgYXMgYSBwYXJlbnQsIHNvIHRoYXQgZm9yXG4gICAgLy8vIGV4YW1wbGUgYG0xKG0yKG0zKHQxKSkpYCBpcyBhIHN1YnR5cGUgb2YgYG0xKG0yKHQxKSlgLFxuICAgIC8vLyBgbTEobTModDEpYCwgYW5kIHNvIG9uLlxuICAgIHN0YXRpYyBkZWZpbmVNb2RpZmllcigpIHtcbiAgICAgICAgbGV0IG1vZCA9IG5ldyBNb2RpZmllcjtcbiAgICAgICAgcmV0dXJuICh0YWcpID0+IHtcbiAgICAgICAgICAgIGlmICh0YWcubW9kaWZpZWQuaW5kZXhPZihtb2QpID4gLTEpXG4gICAgICAgICAgICAgICAgcmV0dXJuIHRhZztcbiAgICAgICAgICAgIHJldHVybiBNb2RpZmllci5nZXQodGFnLmJhc2UgfHwgdGFnLCB0YWcubW9kaWZpZWQuY29uY2F0KG1vZCkuc29ydCgoYSwgYikgPT4gYS5pZCAtIGIuaWQpKTtcbiAgICAgICAgfTtcbiAgICB9XG59XG5sZXQgbmV4dE1vZGlmaWVySUQgPSAwO1xuY2xhc3MgTW9kaWZpZXIge1xuICAgIGNvbnN0cnVjdG9yKCkge1xuICAgICAgICB0aGlzLmluc3RhbmNlcyA9IFtdO1xuICAgICAgICB0aGlzLmlkID0gbmV4dE1vZGlmaWVySUQrKztcbiAgICB9XG4gICAgc3RhdGljIGdldChiYXNlLCBtb2RzKSB7XG4gICAgICAgIGlmICghbW9kcy5sZW5ndGgpXG4gICAgICAgICAgICByZXR1cm4gYmFzZTtcbiAgICAgICAgbGV0IGV4aXN0cyA9IG1vZHNbMF0uaW5zdGFuY2VzLmZpbmQodCA9PiB0LmJhc2UgPT0gYmFzZSAmJiBzYW1lQXJyYXkobW9kcywgdC5tb2RpZmllZCkpO1xuICAgICAgICBpZiAoZXhpc3RzKVxuICAgICAgICAgICAgcmV0dXJuIGV4aXN0cztcbiAgICAgICAgbGV0IHNldCA9IFtdLCB0YWcgPSBuZXcgVGFnKHNldCwgYmFzZSwgbW9kcyk7XG4gICAgICAgIGZvciAobGV0IG0gb2YgbW9kcylcbiAgICAgICAgICAgIG0uaW5zdGFuY2VzLnB1c2godGFnKTtcbiAgICAgICAgbGV0IGNvbmZpZ3MgPSBwZXJtdXRlKG1vZHMpO1xuICAgICAgICBmb3IgKGxldCBwYXJlbnQgb2YgYmFzZS5zZXQpXG4gICAgICAgICAgICBmb3IgKGxldCBjb25maWcgb2YgY29uZmlncylcbiAgICAgICAgICAgICAgICBzZXQucHVzaChNb2RpZmllci5nZXQocGFyZW50LCBjb25maWcpKTtcbiAgICAgICAgcmV0dXJuIHRhZztcbiAgICB9XG59XG5mdW5jdGlvbiBzYW1lQXJyYXkoYSwgYikge1xuICAgIHJldHVybiBhLmxlbmd0aCA9PSBiLmxlbmd0aCAmJiBhLmV2ZXJ5KCh4LCBpKSA9PiB4ID09IGJbaV0pO1xufVxuZnVuY3Rpb24gcGVybXV0ZShhcnJheSkge1xuICAgIGxldCByZXN1bHQgPSBbYXJyYXldO1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgYXJyYXkubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgZm9yIChsZXQgYSBvZiBwZXJtdXRlKGFycmF5LnNsaWNlKDAsIGkpLmNvbmNhdChhcnJheS5zbGljZShpICsgMSkpKSlcbiAgICAgICAgICAgIHJlc3VsdC5wdXNoKGEpO1xuICAgIH1cbiAgICByZXR1cm4gcmVzdWx0O1xufVxuLy8vIFRoaXMgZnVuY3Rpb24gaXMgdXNlZCB0byBhZGQgYSBzZXQgb2YgdGFncyB0byBhIGxhbmd1YWdlIHN5bnRheFxuLy8vIHZpYSBbYE5vZGVTZXQuZXh0ZW5kYF0oI2NvbW1vbi5Ob2RlU2V0LmV4dGVuZCkgb3Jcbi8vLyBbYExSUGFyc2VyLmNvbmZpZ3VyZWBdKCNsci5MUlBhcnNlci5jb25maWd1cmUpLlxuLy8vXG4vLy8gVGhlIGFyZ3VtZW50IG9iamVjdCBtYXBzIG5vZGUgc2VsZWN0b3JzIHRvIFtoaWdobGlnaHRpbmdcbi8vLyB0YWdzXSgjaGlnaGxpZ2h0LlRhZykgb3IgYXJyYXlzIG9mIHRhZ3MuXG4vLy9cbi8vLyBOb2RlIHNlbGVjdG9ycyBtYXkgaG9sZCBvbmUgb3IgbW9yZSAoc3BhY2Utc2VwYXJhdGVkKSBub2RlIHBhdGhzLlxuLy8vIFN1Y2ggYSBwYXRoIGNhbiBiZSBhIFtub2RlIG5hbWVdKCNjb21tb24uTm9kZVR5cGUubmFtZSksIG9yXG4vLy8gbXVsdGlwbGUgbm9kZSBuYW1lcyAob3IgYCpgIHdpbGRjYXJkcykgc2VwYXJhdGVkIGJ5IHNsYXNoXG4vLy8gY2hhcmFjdGVycywgYXMgaW4gYFwiQmxvY2svRGVjbGFyYXRpb24vVmFyaWFibGVOYW1lXCJgLiBTdWNoIGEgcGF0aFxuLy8vIG1hdGNoZXMgdGhlIGZpbmFsIG5vZGUgYnV0IG9ubHkgaWYgaXRzIGRpcmVjdCBwYXJlbnQgbm9kZXMgYXJlIHRoZVxuLy8vIG90aGVyIG5vZGVzIG1lbnRpb25lZC4gQSBgKmAgaW4gc3VjaCBhIHBhdGggbWF0Y2hlcyBhbnkgcGFyZW50LFxuLy8vIGJ1dCBvbmx5IGEgc2luZ2xlIGxldmVs4oCUd2lsZGNhcmRzIHRoYXQgbWF0Y2ggbXVsdGlwbGUgcGFyZW50c1xuLy8vIGFyZW4ndCBzdXBwb3J0ZWQsIGJvdGggZm9yIGVmZmljaWVuY3kgcmVhc29ucyBhbmQgYmVjYXVzZSBMZXplclxuLy8vIHRyZWVzIG1ha2UgaXQgcmF0aGVyIGhhcmQgdG8gcmVhc29uIGFib3V0IHdoYXQgdGhleSB3b3VsZCBtYXRjaC4pXG4vLy9cbi8vLyBBIHBhdGggY2FuIGJlIGVuZGVkIHdpdGggYC8uLi5gIHRvIGluZGljYXRlIHRoYXQgdGhlIHRhZyBhc3NpZ25lZFxuLy8vIHRvIHRoZSBub2RlIHNob3VsZCBhbHNvIGFwcGx5IHRvIGFsbCBjaGlsZCBub2RlcywgZXZlbiBpZiB0aGV5XG4vLy8gbWF0Y2ggdGhlaXIgb3duIHN0eWxlIChieSBkZWZhdWx0LCBvbmx5IHRoZSBpbm5lcm1vc3Qgc3R5bGUgaXNcbi8vLyB1c2VkKS5cbi8vL1xuLy8vIFdoZW4gYSBwYXRoIGVuZHMgaW4gYCFgLCBhcyBpbiBgQXR0cmlidXRlIWAsIG5vIGZ1cnRoZXIgbWF0Y2hpbmdcbi8vLyBoYXBwZW5zIGZvciB0aGUgbm9kZSdzIGNoaWxkIG5vZGVzLCBhbmQgdGhlIGVudGlyZSBub2RlIGdldHMgdGhlXG4vLy8gZ2l2ZW4gc3R5bGUuXG4vLy9cbi8vLyBJbiB0aGlzIG5vdGF0aW9uLCBub2RlIG5hbWVzIHRoYXQgY29udGFpbiBgL2AsIGAhYCwgYCpgLCBvciBgLi4uYFxuLy8vIG11c3QgYmUgcXVvdGVkIGFzIEpTT04gc3RyaW5ncy5cbi8vL1xuLy8vIEZvciBleGFtcGxlOlxuLy8vXG4vLy8gYGBgamF2YXNjcmlwdFxuLy8vIHBhcnNlci53aXRoUHJvcHMoXG4vLy8gICBzdHlsZVRhZ3Moe1xuLy8vICAgICAvLyBTdHlsZSBOdW1iZXIgYW5kIEJpZ051bWJlciBub2Rlc1xuLy8vICAgICBcIk51bWJlciBCaWdOdW1iZXJcIjogdGFncy5udW1iZXIsXG4vLy8gICAgIC8vIFN0eWxlIEVzY2FwZSBub2RlcyB3aG9zZSBwYXJlbnQgaXMgU3RyaW5nXG4vLy8gICAgIFwiU3RyaW5nL0VzY2FwZVwiOiB0YWdzLmVzY2FwZSxcbi8vLyAgICAgLy8gU3R5bGUgYW55dGhpbmcgaW5zaWRlIEF0dHJpYnV0ZXMgbm9kZXNcbi8vLyAgICAgXCJBdHRyaWJ1dGVzIVwiOiB0YWdzLm1ldGEsXG4vLy8gICAgIC8vIEFkZCBhIHN0eWxlIHRvIGFsbCBjb250ZW50IGluc2lkZSBJdGFsaWMgbm9kZXNcbi8vLyAgICAgXCJJdGFsaWMvLi4uXCI6IHRhZ3MuZW1waGFzaXMsXG4vLy8gICAgIC8vIFN0eWxlIEludmFsaWRTdHJpbmcgbm9kZXMgYXMgYm90aCBgc3RyaW5nYCBhbmQgYGludmFsaWRgXG4vLy8gICAgIFwiSW52YWxpZFN0cmluZ1wiOiBbdGFncy5zdHJpbmcsIHRhZ3MuaW52YWxpZF0sXG4vLy8gICAgIC8vIFN0eWxlIHRoZSBub2RlIG5hbWVkIFwiL1wiIGFzIHB1bmN0dWF0aW9uXG4vLy8gICAgICdcIi9cIic6IHRhZ3MucHVuY3R1YXRpb25cbi8vLyAgIH0pXG4vLy8gKVxuLy8vIGBgYFxuZnVuY3Rpb24gc3R5bGVUYWdzKHNwZWMpIHtcbiAgICBsZXQgYnlOYW1lID0gT2JqZWN0LmNyZWF0ZShudWxsKTtcbiAgICBmb3IgKGxldCBwcm9wIGluIHNwZWMpIHtcbiAgICAgICAgbGV0IHRhZ3MgPSBzcGVjW3Byb3BdO1xuICAgICAgICBpZiAoIUFycmF5LmlzQXJyYXkodGFncykpXG4gICAgICAgICAgICB0YWdzID0gW3RhZ3NdO1xuICAgICAgICBmb3IgKGxldCBwYXJ0IG9mIHByb3Auc3BsaXQoXCIgXCIpKVxuICAgICAgICAgICAgaWYgKHBhcnQpIHtcbiAgICAgICAgICAgICAgICBsZXQgcGllY2VzID0gW10sIG1vZGUgPSAyIC8qIE5vcm1hbCAqLywgcmVzdCA9IHBhcnQ7XG4gICAgICAgICAgICAgICAgZm9yIChsZXQgcG9zID0gMDs7KSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChyZXN0ID09IFwiLi4uXCIgJiYgcG9zID4gMCAmJiBwb3MgKyAzID09IHBhcnQubGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBtb2RlID0gMSAvKiBJbmhlcml0ICovO1xuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgbGV0IG0gPSAvXlwiKD86W15cIlxcXFxdfFxcXFwuKSo/XCJ8W15cXC8hXSsvLmV4ZWMocmVzdCk7XG4gICAgICAgICAgICAgICAgICAgIGlmICghbSlcbiAgICAgICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBSYW5nZUVycm9yKFwiSW52YWxpZCBwYXRoOiBcIiArIHBhcnQpO1xuICAgICAgICAgICAgICAgICAgICBwaWVjZXMucHVzaChtWzBdID09IFwiKlwiID8gXCJcIiA6IG1bMF1bMF0gPT0gJ1wiJyA/IEpTT04ucGFyc2UobVswXSkgOiBtWzBdKTtcbiAgICAgICAgICAgICAgICAgICAgcG9zICs9IG1bMF0ubGVuZ3RoO1xuICAgICAgICAgICAgICAgICAgICBpZiAocG9zID09IHBhcnQubGVuZ3RoKVxuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgIGxldCBuZXh0ID0gcGFydFtwb3MrK107XG4gICAgICAgICAgICAgICAgICAgIGlmIChwb3MgPT0gcGFydC5sZW5ndGggJiYgbmV4dCA9PSBcIiFcIikge1xuICAgICAgICAgICAgICAgICAgICAgICAgbW9kZSA9IDAgLyogT3BhcXVlICovO1xuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgaWYgKG5leHQgIT0gXCIvXCIpXG4gICAgICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcihcIkludmFsaWQgcGF0aDogXCIgKyBwYXJ0KTtcbiAgICAgICAgICAgICAgICAgICAgcmVzdCA9IHBhcnQuc2xpY2UocG9zKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgbGV0IGxhc3QgPSBwaWVjZXMubGVuZ3RoIC0gMSwgaW5uZXIgPSBwaWVjZXNbbGFzdF07XG4gICAgICAgICAgICAgICAgaWYgKCFpbm5lcilcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoXCJJbnZhbGlkIHBhdGg6IFwiICsgcGFydCk7XG4gICAgICAgICAgICAgICAgbGV0IHJ1bGUgPSBuZXcgUnVsZSh0YWdzLCBtb2RlLCBsYXN0ID4gMCA/IHBpZWNlcy5zbGljZSgwLCBsYXN0KSA6IG51bGwpO1xuICAgICAgICAgICAgICAgIGJ5TmFtZVtpbm5lcl0gPSBydWxlLnNvcnQoYnlOYW1lW2lubmVyXSk7XG4gICAgICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiBydWxlTm9kZVByb3AuYWRkKGJ5TmFtZSk7XG59XG5jb25zdCBydWxlTm9kZVByb3AgPSBuZXcgY29tbW9uLk5vZGVQcm9wKCk7XG5jbGFzcyBSdWxlIHtcbiAgICBjb25zdHJ1Y3Rvcih0YWdzLCBtb2RlLCBjb250ZXh0LCBuZXh0KSB7XG4gICAgICAgIHRoaXMudGFncyA9IHRhZ3M7XG4gICAgICAgIHRoaXMubW9kZSA9IG1vZGU7XG4gICAgICAgIHRoaXMuY29udGV4dCA9IGNvbnRleHQ7XG4gICAgICAgIHRoaXMubmV4dCA9IG5leHQ7XG4gICAgfVxuICAgIHNvcnQob3RoZXIpIHtcbiAgICAgICAgaWYgKCFvdGhlciB8fCBvdGhlci5kZXB0aCA8IHRoaXMuZGVwdGgpIHtcbiAgICAgICAgICAgIHRoaXMubmV4dCA9IG90aGVyO1xuICAgICAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICAgIH1cbiAgICAgICAgb3RoZXIubmV4dCA9IHRoaXMuc29ydChvdGhlci5uZXh0KTtcbiAgICAgICAgcmV0dXJuIG90aGVyO1xuICAgIH1cbiAgICBnZXQgZGVwdGgoKSB7IHJldHVybiB0aGlzLmNvbnRleHQgPyB0aGlzLmNvbnRleHQubGVuZ3RoIDogMDsgfVxufVxuLy8vIERlZmluZSBhIFtoaWdobGlnaHRlcl0oI2hpZ2hsaWdodC5IaWdobGlnaHRlcikgZnJvbSBhbiBhcnJheSBvZlxuLy8vIHRhZy9jbGFzcyBwYWlycy4gQ2xhc3NlcyBhc3NvY2lhdGVkIHdpdGggbW9yZSBzcGVjaWZpYyB0YWdzIHdpbGxcbi8vLyB0YWtlIHByZWNlZGVuY2UuXG5mdW5jdGlvbiB0YWdIaWdobGlnaHRlcih0YWdzLCBvcHRpb25zKSB7XG4gICAgbGV0IG1hcCA9IE9iamVjdC5jcmVhdGUobnVsbCk7XG4gICAgZm9yIChsZXQgc3R5bGUgb2YgdGFncykge1xuICAgICAgICBpZiAoIUFycmF5LmlzQXJyYXkoc3R5bGUudGFnKSlcbiAgICAgICAgICAgIG1hcFtzdHlsZS50YWcuaWRdID0gc3R5bGUuY2xhc3M7XG4gICAgICAgIGVsc2VcbiAgICAgICAgICAgIGZvciAobGV0IHRhZyBvZiBzdHlsZS50YWcpXG4gICAgICAgICAgICAgICAgbWFwW3RhZy5pZF0gPSBzdHlsZS5jbGFzcztcbiAgICB9XG4gICAgbGV0IHsgc2NvcGUsIGFsbCA9IG51bGwgfSA9IG9wdGlvbnMgfHwge307XG4gICAgcmV0dXJuIHtcbiAgICAgICAgc3R5bGU6ICh0YWdzKSA9PiB7XG4gICAgICAgICAgICBsZXQgY2xzID0gYWxsO1xuICAgICAgICAgICAgZm9yIChsZXQgdGFnIG9mIHRhZ3MpIHtcbiAgICAgICAgICAgICAgICBmb3IgKGxldCBzdWIgb2YgdGFnLnNldCkge1xuICAgICAgICAgICAgICAgICAgICBsZXQgdGFnQ2xhc3MgPSBtYXBbc3ViLmlkXTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHRhZ0NsYXNzKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjbHMgPSBjbHMgPyBjbHMgKyBcIiBcIiArIHRhZ0NsYXNzIDogdGFnQ2xhc3M7XG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBjbHM7XG4gICAgICAgIH0sXG4gICAgICAgIHNjb3BlOiBzY29wZVxuICAgIH07XG59XG5mdW5jdGlvbiBoaWdobGlnaHRUYWdzKGhpZ2hsaWdodGVycywgdGFncykge1xuICAgIGxldCByZXN1bHQgPSBudWxsO1xuICAgIGZvciAobGV0IGhpZ2hsaWdodGVyIG9mIGhpZ2hsaWdodGVycykge1xuICAgICAgICBsZXQgdmFsdWUgPSBoaWdobGlnaHRlci5zdHlsZSh0YWdzKTtcbiAgICAgICAgaWYgKHZhbHVlKVxuICAgICAgICAgICAgcmVzdWx0ID0gcmVzdWx0ID8gcmVzdWx0ICsgXCIgXCIgKyB2YWx1ZSA6IHZhbHVlO1xuICAgIH1cbiAgICByZXR1cm4gcmVzdWx0O1xufVxuLy8vIEhpZ2hsaWdodCB0aGUgZ2l2ZW4gW3RyZWVdKCNjb21tb24uVHJlZSkgd2l0aCB0aGUgZ2l2ZW5cbi8vLyBbaGlnaGxpZ2h0ZXJdKCNoaWdobGlnaHQuSGlnaGxpZ2h0ZXIpLlxuZnVuY3Rpb24gaGlnaGxpZ2h0VHJlZSh0cmVlLCBoaWdobGlnaHRlciwgXG4vLy8gQXNzaWduIHN0eWxpbmcgdG8gYSByZWdpb24gb2YgdGhlIHRleHQuIFdpbGwgYmUgY2FsbGVkLCBpbiBvcmRlclxuLy8vIG9mIHBvc2l0aW9uLCBmb3IgYW55IHJhbmdlcyB3aGVyZSBtb3JlIHRoYW4gemVybyBjbGFzc2VzIGFwcGx5LlxuLy8vIGBjbGFzc2VzYCBpcyBhIHNwYWNlIHNlcGFyYXRlZCBzdHJpbmcgb2YgQ1NTIGNsYXNzZXMuXG5wdXRTdHlsZSwgXG4vLy8gVGhlIHN0YXJ0IG9mIHRoZSByYW5nZSB0byBoaWdobGlnaHQuXG5mcm9tID0gMCwgXG4vLy8gVGhlIGVuZCBvZiB0aGUgcmFuZ2UuXG50byA9IHRyZWUubGVuZ3RoKSB7XG4gICAgbGV0IGJ1aWxkZXIgPSBuZXcgSGlnaGxpZ2h0QnVpbGRlcihmcm9tLCBBcnJheS5pc0FycmF5KGhpZ2hsaWdodGVyKSA/IGhpZ2hsaWdodGVyIDogW2hpZ2hsaWdodGVyXSwgcHV0U3R5bGUpO1xuICAgIGJ1aWxkZXIuaGlnaGxpZ2h0UmFuZ2UodHJlZS5jdXJzb3IoKSwgZnJvbSwgdG8sIFwiXCIsIGJ1aWxkZXIuaGlnaGxpZ2h0ZXJzKTtcbiAgICBidWlsZGVyLmZsdXNoKHRvKTtcbn1cbmNsYXNzIEhpZ2hsaWdodEJ1aWxkZXIge1xuICAgIGNvbnN0cnVjdG9yKGF0LCBoaWdobGlnaHRlcnMsIHNwYW4pIHtcbiAgICAgICAgdGhpcy5hdCA9IGF0O1xuICAgICAgICB0aGlzLmhpZ2hsaWdodGVycyA9IGhpZ2hsaWdodGVycztcbiAgICAgICAgdGhpcy5zcGFuID0gc3BhbjtcbiAgICAgICAgdGhpcy5jbGFzcyA9IFwiXCI7XG4gICAgfVxuICAgIHN0YXJ0U3BhbihhdCwgY2xzKSB7XG4gICAgICAgIGlmIChjbHMgIT0gdGhpcy5jbGFzcykge1xuICAgICAgICAgICAgdGhpcy5mbHVzaChhdCk7XG4gICAgICAgICAgICBpZiAoYXQgPiB0aGlzLmF0KVxuICAgICAgICAgICAgICAgIHRoaXMuYXQgPSBhdDtcbiAgICAgICAgICAgIHRoaXMuY2xhc3MgPSBjbHM7XG4gICAgICAgIH1cbiAgICB9XG4gICAgZmx1c2godG8pIHtcbiAgICAgICAgaWYgKHRvID4gdGhpcy5hdCAmJiB0aGlzLmNsYXNzKVxuICAgICAgICAgICAgdGhpcy5zcGFuKHRoaXMuYXQsIHRvLCB0aGlzLmNsYXNzKTtcbiAgICB9XG4gICAgaGlnaGxpZ2h0UmFuZ2UoY3Vyc29yLCBmcm9tLCB0bywgaW5oZXJpdGVkQ2xhc3MsIGhpZ2hsaWdodGVycykge1xuICAgICAgICBsZXQgeyB0eXBlLCBmcm9tOiBzdGFydCwgdG86IGVuZCB9ID0gY3Vyc29yO1xuICAgICAgICBpZiAoc3RhcnQgPj0gdG8gfHwgZW5kIDw9IGZyb20pXG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIGlmICh0eXBlLmlzVG9wKVxuICAgICAgICAgICAgaGlnaGxpZ2h0ZXJzID0gdGhpcy5oaWdobGlnaHRlcnMuZmlsdGVyKGggPT4gIWguc2NvcGUgfHwgaC5zY29wZSh0eXBlKSk7XG4gICAgICAgIGxldCBjbHMgPSBpbmhlcml0ZWRDbGFzcztcbiAgICAgICAgbGV0IHJ1bGUgPSB0eXBlLnByb3AocnVsZU5vZGVQcm9wKSwgb3BhcXVlID0gZmFsc2U7XG4gICAgICAgIHdoaWxlIChydWxlKSB7XG4gICAgICAgICAgICBpZiAoIXJ1bGUuY29udGV4dCB8fCBjdXJzb3IubWF0Y2hDb250ZXh0KHJ1bGUuY29udGV4dCkpIHtcbiAgICAgICAgICAgICAgICBsZXQgdGFnQ2xzID0gaGlnaGxpZ2h0VGFncyhoaWdobGlnaHRlcnMsIHJ1bGUudGFncyk7XG4gICAgICAgICAgICAgICAgaWYgKHRhZ0Nscykge1xuICAgICAgICAgICAgICAgICAgICBpZiAoY2xzKVxuICAgICAgICAgICAgICAgICAgICAgICAgY2xzICs9IFwiIFwiO1xuICAgICAgICAgICAgICAgICAgICBjbHMgKz0gdGFnQ2xzO1xuICAgICAgICAgICAgICAgICAgICBpZiAocnVsZS5tb2RlID09IDEgLyogSW5oZXJpdCAqLylcbiAgICAgICAgICAgICAgICAgICAgICAgIGluaGVyaXRlZENsYXNzICs9IChpbmhlcml0ZWRDbGFzcyA/IFwiIFwiIDogXCJcIikgKyB0YWdDbHM7XG4gICAgICAgICAgICAgICAgICAgIGVsc2UgaWYgKHJ1bGUubW9kZSA9PSAwIC8qIE9wYXF1ZSAqLylcbiAgICAgICAgICAgICAgICAgICAgICAgIG9wYXF1ZSA9IHRydWU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcnVsZSA9IHJ1bGUubmV4dDtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLnN0YXJ0U3BhbihjdXJzb3IuZnJvbSwgY2xzKTtcbiAgICAgICAgaWYgKG9wYXF1ZSlcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgbGV0IG1vdW50ZWQgPSBjdXJzb3IudHJlZSAmJiBjdXJzb3IudHJlZS5wcm9wKGNvbW1vbi5Ob2RlUHJvcC5tb3VudGVkKTtcbiAgICAgICAgaWYgKG1vdW50ZWQgJiYgbW91bnRlZC5vdmVybGF5KSB7XG4gICAgICAgICAgICBsZXQgaW5uZXIgPSBjdXJzb3Iubm9kZS5lbnRlcihtb3VudGVkLm92ZXJsYXlbMF0uZnJvbSArIHN0YXJ0LCAxKTtcbiAgICAgICAgICAgIGxldCBpbm5lckhpZ2hsaWdodGVycyA9IHRoaXMuaGlnaGxpZ2h0ZXJzLmZpbHRlcihoID0+ICFoLnNjb3BlIHx8IGguc2NvcGUobW91bnRlZC50cmVlLnR5cGUpKTtcbiAgICAgICAgICAgIGxldCBoYXNDaGlsZCA9IGN1cnNvci5maXJzdENoaWxkKCk7XG4gICAgICAgICAgICBmb3IgKGxldCBpID0gMCwgcG9zID0gc3RhcnQ7OyBpKyspIHtcbiAgICAgICAgICAgICAgICBsZXQgbmV4dCA9IGkgPCBtb3VudGVkLm92ZXJsYXkubGVuZ3RoID8gbW91bnRlZC5vdmVybGF5W2ldIDogbnVsbDtcbiAgICAgICAgICAgICAgICBsZXQgbmV4dFBvcyA9IG5leHQgPyBuZXh0LmZyb20gKyBzdGFydCA6IGVuZDtcbiAgICAgICAgICAgICAgICBsZXQgcmFuZ2VGcm9tID0gTWF0aC5tYXgoZnJvbSwgcG9zKSwgcmFuZ2VUbyA9IE1hdGgubWluKHRvLCBuZXh0UG9zKTtcbiAgICAgICAgICAgICAgICBpZiAocmFuZ2VGcm9tIDwgcmFuZ2VUbyAmJiBoYXNDaGlsZCkge1xuICAgICAgICAgICAgICAgICAgICB3aGlsZSAoY3Vyc29yLmZyb20gPCByYW5nZVRvKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLmhpZ2hsaWdodFJhbmdlKGN1cnNvciwgcmFuZ2VGcm9tLCByYW5nZVRvLCBpbmhlcml0ZWRDbGFzcywgaGlnaGxpZ2h0ZXJzKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuc3RhcnRTcGFuKE1hdGgubWluKHRvLCBjdXJzb3IudG8pLCBjbHMpO1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGN1cnNvci50byA+PSBuZXh0UG9zIHx8ICFjdXJzb3IubmV4dFNpYmxpbmcoKSlcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAoIW5leHQgfHwgbmV4dFBvcyA+IHRvKVxuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBwb3MgPSBuZXh0LnRvICsgc3RhcnQ7XG4gICAgICAgICAgICAgICAgaWYgKHBvcyA+IGZyb20pIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5oaWdobGlnaHRSYW5nZShpbm5lci5jdXJzb3IoKSwgTWF0aC5tYXgoZnJvbSwgbmV4dC5mcm9tICsgc3RhcnQpLCBNYXRoLm1pbih0bywgcG9zKSwgaW5oZXJpdGVkQ2xhc3MsIGlubmVySGlnaGxpZ2h0ZXJzKTtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5zdGFydFNwYW4ocG9zLCBjbHMpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChoYXNDaGlsZClcbiAgICAgICAgICAgICAgICBjdXJzb3IucGFyZW50KCk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoY3Vyc29yLmZpcnN0Q2hpbGQoKSkge1xuICAgICAgICAgICAgZG8ge1xuICAgICAgICAgICAgICAgIGlmIChjdXJzb3IudG8gPD0gZnJvbSlcbiAgICAgICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICAgICAgaWYgKGN1cnNvci5mcm9tID49IHRvKVxuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICB0aGlzLmhpZ2hsaWdodFJhbmdlKGN1cnNvciwgZnJvbSwgdG8sIGluaGVyaXRlZENsYXNzLCBoaWdobGlnaHRlcnMpO1xuICAgICAgICAgICAgICAgIHRoaXMuc3RhcnRTcGFuKE1hdGgubWluKHRvLCBjdXJzb3IudG8pLCBjbHMpO1xuICAgICAgICAgICAgfSB3aGlsZSAoY3Vyc29yLm5leHRTaWJsaW5nKCkpO1xuICAgICAgICAgICAgY3Vyc29yLnBhcmVudCgpO1xuICAgICAgICB9XG4gICAgfVxufVxuY29uc3QgdCA9IFRhZy5kZWZpbmU7XG5jb25zdCBjb21tZW50ID0gdCgpLCBuYW1lID0gdCgpLCB0eXBlTmFtZSA9IHQobmFtZSksIHByb3BlcnR5TmFtZSA9IHQobmFtZSksIGxpdGVyYWwgPSB0KCksIHN0cmluZyA9IHQobGl0ZXJhbCksIG51bWJlciA9IHQobGl0ZXJhbCksIGNvbnRlbnQgPSB0KCksIGhlYWRpbmcgPSB0KGNvbnRlbnQpLCBrZXl3b3JkID0gdCgpLCBvcGVyYXRvciA9IHQoKSwgcHVuY3R1YXRpb24gPSB0KCksIGJyYWNrZXQgPSB0KHB1bmN0dWF0aW9uKSwgbWV0YSA9IHQoKTtcbi8vLyBUaGUgZGVmYXVsdCBzZXQgb2YgaGlnaGxpZ2h0aW5nIFt0YWdzXSgjaGlnaGxpZ2h0LlRhZykuXG4vLy9cbi8vLyBUaGlzIGNvbGxlY3Rpb24gaXMgaGVhdmlseSBiaWFzZWQgdG93YXJkcyBwcm9ncmFtbWluZyBsYW5ndWFnZXMsXG4vLy8gYW5kIG5lY2Vzc2FyaWx5IGluY29tcGxldGUuIEEgZnVsbCBvbnRvbG9neSBvZiBzeW50YWN0aWNcbi8vLyBjb25zdHJ1Y3RzIHdvdWxkIGZpbGwgYSBzdGFjayBvZiBib29rcywgYW5kIGJlIGltcHJhY3RpY2FsIHRvXG4vLy8gd3JpdGUgdGhlbWVzIGZvci4gU28gdHJ5IHRvIG1ha2UgZG8gd2l0aCB0aGlzIHNldC4gSWYgYWxsIGVsc2Vcbi8vLyBmYWlscywgW29wZW4gYW5cbi8vLyBpc3N1ZV0oaHR0cHM6Ly9naXRodWIuY29tL2NvZGVtaXJyb3IvY29kZW1pcnJvci5uZXh0KSB0byBwcm9wb3NlIGFcbi8vLyBuZXcgdGFnLCBvciBbZGVmaW5lXSgjaGlnaGxpZ2h0LlRhZ15kZWZpbmUpIGEgbG9jYWwgY3VzdG9tIHRhZyBmb3Jcbi8vLyB5b3VyIHVzZSBjYXNlLlxuLy8vXG4vLy8gTm90ZSB0aGF0IGl0IGlzIG5vdCBvYmxpZ2F0b3J5IHRvIGFsd2F5cyBhdHRhY2ggdGhlIG1vc3Qgc3BlY2lmaWNcbi8vLyB0YWcgcG9zc2libGUgdG8gYW4gZWxlbWVudOKAlGlmIHlvdXIgZ3JhbW1hciBjYW4ndCBlYXNpbHlcbi8vLyBkaXN0aW5ndWlzaCBhIGNlcnRhaW4gdHlwZSBvZiBlbGVtZW50IChzdWNoIGFzIGEgbG9jYWwgdmFyaWFibGUpLFxuLy8vIGl0IGlzIG9rYXkgdG8gc3R5bGUgaXQgYXMgaXRzIG1vcmUgZ2VuZXJhbCB2YXJpYW50IChhIHZhcmlhYmxlKS5cbi8vLyBcbi8vLyBGb3IgdGFncyB0aGF0IGV4dGVuZCBzb21lIHBhcmVudCB0YWcsIHRoZSBkb2N1bWVudGF0aW9uIGxpbmtzIHRvXG4vLy8gdGhlIHBhcmVudC5cbmNvbnN0IHRhZ3MgPSB7XG4gICAgLy8vIEEgY29tbWVudC5cbiAgICBjb21tZW50LFxuICAgIC8vLyBBIGxpbmUgW2NvbW1lbnRdKCNoaWdobGlnaHQudGFncy5jb21tZW50KS5cbiAgICBsaW5lQ29tbWVudDogdChjb21tZW50KSxcbiAgICAvLy8gQSBibG9jayBbY29tbWVudF0oI2hpZ2hsaWdodC50YWdzLmNvbW1lbnQpLlxuICAgIGJsb2NrQ29tbWVudDogdChjb21tZW50KSxcbiAgICAvLy8gQSBkb2N1bWVudGF0aW9uIFtjb21tZW50XSgjaGlnaGxpZ2h0LnRhZ3MuY29tbWVudCkuXG4gICAgZG9jQ29tbWVudDogdChjb21tZW50KSxcbiAgICAvLy8gQW55IGtpbmQgb2YgaWRlbnRpZmllci5cbiAgICBuYW1lLFxuICAgIC8vLyBUaGUgW25hbWVdKCNoaWdobGlnaHQudGFncy5uYW1lKSBvZiBhIHZhcmlhYmxlLlxuICAgIHZhcmlhYmxlTmFtZTogdChuYW1lKSxcbiAgICAvLy8gQSB0eXBlIFtuYW1lXSgjaGlnaGxpZ2h0LnRhZ3MubmFtZSkuXG4gICAgdHlwZU5hbWU6IHR5cGVOYW1lLFxuICAgIC8vLyBBIHRhZyBuYW1lIChzdWJ0YWcgb2YgW2B0eXBlTmFtZWBdKCNoaWdobGlnaHQudGFncy50eXBlTmFtZSkpLlxuICAgIHRhZ05hbWU6IHQodHlwZU5hbWUpLFxuICAgIC8vLyBBIHByb3BlcnR5IG9yIGZpZWxkIFtuYW1lXSgjaGlnaGxpZ2h0LnRhZ3MubmFtZSkuXG4gICAgcHJvcGVydHlOYW1lOiBwcm9wZXJ0eU5hbWUsXG4gICAgLy8vIEFuIGF0dHJpYnV0ZSBuYW1lIChzdWJ0YWcgb2YgW2Bwcm9wZXJ0eU5hbWVgXSgjaGlnaGxpZ2h0LnRhZ3MucHJvcGVydHlOYW1lKSkuXG4gICAgYXR0cmlidXRlTmFtZTogdChwcm9wZXJ0eU5hbWUpLFxuICAgIC8vLyBUaGUgW25hbWVdKCNoaWdobGlnaHQudGFncy5uYW1lKSBvZiBhIGNsYXNzLlxuICAgIGNsYXNzTmFtZTogdChuYW1lKSxcbiAgICAvLy8gQSBsYWJlbCBbbmFtZV0oI2hpZ2hsaWdodC50YWdzLm5hbWUpLlxuICAgIGxhYmVsTmFtZTogdChuYW1lKSxcbiAgICAvLy8gQSBuYW1lc3BhY2UgW25hbWVdKCNoaWdobGlnaHQudGFncy5uYW1lKS5cbiAgICBuYW1lc3BhY2U6IHQobmFtZSksXG4gICAgLy8vIFRoZSBbbmFtZV0oI2hpZ2hsaWdodC50YWdzLm5hbWUpIG9mIGEgbWFjcm8uXG4gICAgbWFjcm9OYW1lOiB0KG5hbWUpLFxuICAgIC8vLyBBIGxpdGVyYWwgdmFsdWUuXG4gICAgbGl0ZXJhbCxcbiAgICAvLy8gQSBzdHJpbmcgW2xpdGVyYWxdKCNoaWdobGlnaHQudGFncy5saXRlcmFsKS5cbiAgICBzdHJpbmcsXG4gICAgLy8vIEEgZG9jdW1lbnRhdGlvbiBbc3RyaW5nXSgjaGlnaGxpZ2h0LnRhZ3Muc3RyaW5nKS5cbiAgICBkb2NTdHJpbmc6IHQoc3RyaW5nKSxcbiAgICAvLy8gQSBjaGFyYWN0ZXIgbGl0ZXJhbCAoc3VidGFnIG9mIFtzdHJpbmddKCNoaWdobGlnaHQudGFncy5zdHJpbmcpKS5cbiAgICBjaGFyYWN0ZXI6IHQoc3RyaW5nKSxcbiAgICAvLy8gQW4gYXR0cmlidXRlIHZhbHVlIChzdWJ0YWcgb2YgW3N0cmluZ10oI2hpZ2hsaWdodC50YWdzLnN0cmluZykpLlxuICAgIGF0dHJpYnV0ZVZhbHVlOiB0KHN0cmluZyksXG4gICAgLy8vIEEgbnVtYmVyIFtsaXRlcmFsXSgjaGlnaGxpZ2h0LnRhZ3MubGl0ZXJhbCkuXG4gICAgbnVtYmVyLFxuICAgIC8vLyBBbiBpbnRlZ2VyIFtudW1iZXJdKCNoaWdobGlnaHQudGFncy5udW1iZXIpIGxpdGVyYWwuXG4gICAgaW50ZWdlcjogdChudW1iZXIpLFxuICAgIC8vLyBBIGZsb2F0aW5nLXBvaW50IFtudW1iZXJdKCNoaWdobGlnaHQudGFncy5udW1iZXIpIGxpdGVyYWwuXG4gICAgZmxvYXQ6IHQobnVtYmVyKSxcbiAgICAvLy8gQSBib29sZWFuIFtsaXRlcmFsXSgjaGlnaGxpZ2h0LnRhZ3MubGl0ZXJhbCkuXG4gICAgYm9vbDogdChsaXRlcmFsKSxcbiAgICAvLy8gUmVndWxhciBleHByZXNzaW9uIFtsaXRlcmFsXSgjaGlnaGxpZ2h0LnRhZ3MubGl0ZXJhbCkuXG4gICAgcmVnZXhwOiB0KGxpdGVyYWwpLFxuICAgIC8vLyBBbiBlc2NhcGUgW2xpdGVyYWxdKCNoaWdobGlnaHQudGFncy5saXRlcmFsKSwgZm9yIGV4YW1wbGUgYVxuICAgIC8vLyBiYWNrc2xhc2ggZXNjYXBlIGluIGEgc3RyaW5nLlxuICAgIGVzY2FwZTogdChsaXRlcmFsKSxcbiAgICAvLy8gQSBjb2xvciBbbGl0ZXJhbF0oI2hpZ2hsaWdodC50YWdzLmxpdGVyYWwpLlxuICAgIGNvbG9yOiB0KGxpdGVyYWwpLFxuICAgIC8vLyBBIFVSTCBbbGl0ZXJhbF0oI2hpZ2hsaWdodC50YWdzLmxpdGVyYWwpLlxuICAgIHVybDogdChsaXRlcmFsKSxcbiAgICAvLy8gQSBsYW5ndWFnZSBrZXl3b3JkLlxuICAgIGtleXdvcmQsXG4gICAgLy8vIFRoZSBba2V5d29yZF0oI2hpZ2hsaWdodC50YWdzLmtleXdvcmQpIGZvciB0aGUgc2VsZiBvciB0aGlzXG4gICAgLy8vIG9iamVjdC5cbiAgICBzZWxmOiB0KGtleXdvcmQpLFxuICAgIC8vLyBUaGUgW2tleXdvcmRdKCNoaWdobGlnaHQudGFncy5rZXl3b3JkKSBmb3IgbnVsbC5cbiAgICBudWxsOiB0KGtleXdvcmQpLFxuICAgIC8vLyBBIFtrZXl3b3JkXSgjaGlnaGxpZ2h0LnRhZ3Mua2V5d29yZCkgZGVub3Rpbmcgc29tZSBhdG9taWMgdmFsdWUuXG4gICAgYXRvbTogdChrZXl3b3JkKSxcbiAgICAvLy8gQSBba2V5d29yZF0oI2hpZ2hsaWdodC50YWdzLmtleXdvcmQpIHRoYXQgcmVwcmVzZW50cyBhIHVuaXQuXG4gICAgdW5pdDogdChrZXl3b3JkKSxcbiAgICAvLy8gQSBtb2RpZmllciBba2V5d29yZF0oI2hpZ2hsaWdodC50YWdzLmtleXdvcmQpLlxuICAgIG1vZGlmaWVyOiB0KGtleXdvcmQpLFxuICAgIC8vLyBBIFtrZXl3b3JkXSgjaGlnaGxpZ2h0LnRhZ3Mua2V5d29yZCkgdGhhdCBhY3RzIGFzIGFuIG9wZXJhdG9yLlxuICAgIG9wZXJhdG9yS2V5d29yZDogdChrZXl3b3JkKSxcbiAgICAvLy8gQSBjb250cm9sLWZsb3cgcmVsYXRlZCBba2V5d29yZF0oI2hpZ2hsaWdodC50YWdzLmtleXdvcmQpLlxuICAgIGNvbnRyb2xLZXl3b3JkOiB0KGtleXdvcmQpLFxuICAgIC8vLyBBIFtrZXl3b3JkXSgjaGlnaGxpZ2h0LnRhZ3Mua2V5d29yZCkgdGhhdCBkZWZpbmVzIHNvbWV0aGluZy5cbiAgICBkZWZpbml0aW9uS2V5d29yZDogdChrZXl3b3JkKSxcbiAgICAvLy8gQSBba2V5d29yZF0oI2hpZ2hsaWdodC50YWdzLmtleXdvcmQpIHJlbGF0ZWQgdG8gZGVmaW5pbmcgb3JcbiAgICAvLy8gaW50ZXJmYWNpbmcgd2l0aCBtb2R1bGVzLlxuICAgIG1vZHVsZUtleXdvcmQ6IHQoa2V5d29yZCksXG4gICAgLy8vIEFuIG9wZXJhdG9yLlxuICAgIG9wZXJhdG9yLFxuICAgIC8vLyBBbiBbb3BlcmF0b3JdKCNoaWdobGlnaHQudGFncy5vcGVyYXRvcikgdGhhdCBkZWZpbmVzIHNvbWV0aGluZy5cbiAgICBkZXJlZk9wZXJhdG9yOiB0KG9wZXJhdG9yKSxcbiAgICAvLy8gQXJpdGhtZXRpYy1yZWxhdGVkIFtvcGVyYXRvcl0oI2hpZ2hsaWdodC50YWdzLm9wZXJhdG9yKS5cbiAgICBhcml0aG1ldGljT3BlcmF0b3I6IHQob3BlcmF0b3IpLFxuICAgIC8vLyBMb2dpY2FsIFtvcGVyYXRvcl0oI2hpZ2hsaWdodC50YWdzLm9wZXJhdG9yKS5cbiAgICBsb2dpY09wZXJhdG9yOiB0KG9wZXJhdG9yKSxcbiAgICAvLy8gQml0IFtvcGVyYXRvcl0oI2hpZ2hsaWdodC50YWdzLm9wZXJhdG9yKS5cbiAgICBiaXR3aXNlT3BlcmF0b3I6IHQob3BlcmF0b3IpLFxuICAgIC8vLyBDb21wYXJpc29uIFtvcGVyYXRvcl0oI2hpZ2hsaWdodC50YWdzLm9wZXJhdG9yKS5cbiAgICBjb21wYXJlT3BlcmF0b3I6IHQob3BlcmF0b3IpLFxuICAgIC8vLyBbT3BlcmF0b3JdKCNoaWdobGlnaHQudGFncy5vcGVyYXRvcikgdGhhdCB1cGRhdGVzIGl0cyBvcGVyYW5kLlxuICAgIHVwZGF0ZU9wZXJhdG9yOiB0KG9wZXJhdG9yKSxcbiAgICAvLy8gW09wZXJhdG9yXSgjaGlnaGxpZ2h0LnRhZ3Mub3BlcmF0b3IpIHRoYXQgZGVmaW5lcyBzb21ldGhpbmcuXG4gICAgZGVmaW5pdGlvbk9wZXJhdG9yOiB0KG9wZXJhdG9yKSxcbiAgICAvLy8gVHlwZS1yZWxhdGVkIFtvcGVyYXRvcl0oI2hpZ2hsaWdodC50YWdzLm9wZXJhdG9yKS5cbiAgICB0eXBlT3BlcmF0b3I6IHQob3BlcmF0b3IpLFxuICAgIC8vLyBDb250cm9sLWZsb3cgW29wZXJhdG9yXSgjaGlnaGxpZ2h0LnRhZ3Mub3BlcmF0b3IpLlxuICAgIGNvbnRyb2xPcGVyYXRvcjogdChvcGVyYXRvciksXG4gICAgLy8vIFByb2dyYW0gb3IgbWFya3VwIHB1bmN0dWF0aW9uLlxuICAgIHB1bmN0dWF0aW9uLFxuICAgIC8vLyBbUHVuY3R1YXRpb25dKCNoaWdobGlnaHQudGFncy5wdW5jdHVhdGlvbikgdGhhdCBzZXBhcmF0ZXNcbiAgICAvLy8gdGhpbmdzLlxuICAgIHNlcGFyYXRvcjogdChwdW5jdHVhdGlvbiksXG4gICAgLy8vIEJyYWNrZXQtc3R5bGUgW3B1bmN0dWF0aW9uXSgjaGlnaGxpZ2h0LnRhZ3MucHVuY3R1YXRpb24pLlxuICAgIGJyYWNrZXQsXG4gICAgLy8vIEFuZ2xlIFticmFja2V0c10oI2hpZ2hsaWdodC50YWdzLmJyYWNrZXQpICh1c3VhbGx5IGA8YCBhbmQgYD5gXG4gICAgLy8vIHRva2VucykuXG4gICAgYW5nbGVCcmFja2V0OiB0KGJyYWNrZXQpLFxuICAgIC8vLyBTcXVhcmUgW2JyYWNrZXRzXSgjaGlnaGxpZ2h0LnRhZ3MuYnJhY2tldCkgKHVzdWFsbHkgYFtgIGFuZCBgXWBcbiAgICAvLy8gdG9rZW5zKS5cbiAgICBzcXVhcmVCcmFja2V0OiB0KGJyYWNrZXQpLFxuICAgIC8vLyBQYXJlbnRoZXNlcyAodXN1YWxseSBgKGAgYW5kIGApYCB0b2tlbnMpLiBTdWJ0YWcgb2ZcbiAgICAvLy8gW2JyYWNrZXRdKCNoaWdobGlnaHQudGFncy5icmFja2V0KS5cbiAgICBwYXJlbjogdChicmFja2V0KSxcbiAgICAvLy8gQnJhY2VzICh1c3VhbGx5IGB7YCBhbmQgYH1gIHRva2VucykuIFN1YnRhZyBvZlxuICAgIC8vLyBbYnJhY2tldF0oI2hpZ2hsaWdodC50YWdzLmJyYWNrZXQpLlxuICAgIGJyYWNlOiB0KGJyYWNrZXQpLFxuICAgIC8vLyBDb250ZW50LCBmb3IgZXhhbXBsZSBwbGFpbiB0ZXh0IGluIFhNTCBvciBtYXJrdXAgZG9jdW1lbnRzLlxuICAgIGNvbnRlbnQsXG4gICAgLy8vIFtDb250ZW50XSgjaGlnaGxpZ2h0LnRhZ3MuY29udGVudCkgdGhhdCByZXByZXNlbnRzIGEgaGVhZGluZy5cbiAgICBoZWFkaW5nLFxuICAgIC8vLyBBIGxldmVsIDEgW2hlYWRpbmddKCNoaWdobGlnaHQudGFncy5oZWFkaW5nKS5cbiAgICBoZWFkaW5nMTogdChoZWFkaW5nKSxcbiAgICAvLy8gQSBsZXZlbCAyIFtoZWFkaW5nXSgjaGlnaGxpZ2h0LnRhZ3MuaGVhZGluZykuXG4gICAgaGVhZGluZzI6IHQoaGVhZGluZyksXG4gICAgLy8vIEEgbGV2ZWwgMyBbaGVhZGluZ10oI2hpZ2hsaWdodC50YWdzLmhlYWRpbmcpLlxuICAgIGhlYWRpbmczOiB0KGhlYWRpbmcpLFxuICAgIC8vLyBBIGxldmVsIDQgW2hlYWRpbmddKCNoaWdobGlnaHQudGFncy5oZWFkaW5nKS5cbiAgICBoZWFkaW5nNDogdChoZWFkaW5nKSxcbiAgICAvLy8gQSBsZXZlbCA1IFtoZWFkaW5nXSgjaGlnaGxpZ2h0LnRhZ3MuaGVhZGluZykuXG4gICAgaGVhZGluZzU6IHQoaGVhZGluZyksXG4gICAgLy8vIEEgbGV2ZWwgNiBbaGVhZGluZ10oI2hpZ2hsaWdodC50YWdzLmhlYWRpbmcpLlxuICAgIGhlYWRpbmc2OiB0KGhlYWRpbmcpLFxuICAgIC8vLyBBIHByb3NlIHNlcGFyYXRvciAoc3VjaCBhcyBhIGhvcml6b250YWwgcnVsZSkuXG4gICAgY29udGVudFNlcGFyYXRvcjogdChjb250ZW50KSxcbiAgICAvLy8gW0NvbnRlbnRdKCNoaWdobGlnaHQudGFncy5jb250ZW50KSB0aGF0IHJlcHJlc2VudHMgYSBsaXN0LlxuICAgIGxpc3Q6IHQoY29udGVudCksXG4gICAgLy8vIFtDb250ZW50XSgjaGlnaGxpZ2h0LnRhZ3MuY29udGVudCkgdGhhdCByZXByZXNlbnRzIGEgcXVvdGUuXG4gICAgcXVvdGU6IHQoY29udGVudCksXG4gICAgLy8vIFtDb250ZW50XSgjaGlnaGxpZ2h0LnRhZ3MuY29udGVudCkgdGhhdCBpcyBlbXBoYXNpemVkLlxuICAgIGVtcGhhc2lzOiB0KGNvbnRlbnQpLFxuICAgIC8vLyBbQ29udGVudF0oI2hpZ2hsaWdodC50YWdzLmNvbnRlbnQpIHRoYXQgaXMgc3R5bGVkIHN0cm9uZy5cbiAgICBzdHJvbmc6IHQoY29udGVudCksXG4gICAgLy8vIFtDb250ZW50XSgjaGlnaGxpZ2h0LnRhZ3MuY29udGVudCkgdGhhdCBpcyBwYXJ0IG9mIGEgbGluay5cbiAgICBsaW5rOiB0KGNvbnRlbnQpLFxuICAgIC8vLyBbQ29udGVudF0oI2hpZ2hsaWdodC50YWdzLmNvbnRlbnQpIHRoYXQgaXMgc3R5bGVkIGFzIGNvZGUgb3JcbiAgICAvLy8gbW9ub3NwYWNlLlxuICAgIG1vbm9zcGFjZTogdChjb250ZW50KSxcbiAgICAvLy8gW0NvbnRlbnRdKCNoaWdobGlnaHQudGFncy5jb250ZW50KSB0aGF0IGhhcyBhIHN0cmlrZS10aHJvdWdoXG4gICAgLy8vIHN0eWxlLlxuICAgIHN0cmlrZXRocm91Z2g6IHQoY29udGVudCksXG4gICAgLy8vIEluc2VydGVkIHRleHQgaW4gYSBjaGFuZ2UtdHJhY2tpbmcgZm9ybWF0LlxuICAgIGluc2VydGVkOiB0KCksXG4gICAgLy8vIERlbGV0ZWQgdGV4dC5cbiAgICBkZWxldGVkOiB0KCksXG4gICAgLy8vIENoYW5nZWQgdGV4dC5cbiAgICBjaGFuZ2VkOiB0KCksXG4gICAgLy8vIEFuIGludmFsaWQgb3IgdW5zeW50YWN0aWMgZWxlbWVudC5cbiAgICBpbnZhbGlkOiB0KCksXG4gICAgLy8vIE1ldGFkYXRhIG9yIG1ldGEtaW5zdHJ1Y3Rpb24uXG4gICAgbWV0YSxcbiAgICAvLy8gW01ldGFkYXRhXSgjaGlnaGxpZ2h0LnRhZ3MubWV0YSkgdGhhdCBhcHBsaWVzIHRvIHRoZSBlbnRpcmVcbiAgICAvLy8gZG9jdW1lbnQuXG4gICAgZG9jdW1lbnRNZXRhOiB0KG1ldGEpLFxuICAgIC8vLyBbTWV0YWRhdGFdKCNoaWdobGlnaHQudGFncy5tZXRhKSB0aGF0IGFubm90YXRlcyBvciBhZGRzXG4gICAgLy8vIGF0dHJpYnV0ZXMgdG8gYSBnaXZlbiBzeW50YWN0aWMgZWxlbWVudC5cbiAgICBhbm5vdGF0aW9uOiB0KG1ldGEpLFxuICAgIC8vLyBQcm9jZXNzaW5nIGluc3RydWN0aW9uIG9yIHByZXByb2Nlc3NvciBkaXJlY3RpdmUuIFN1YnRhZyBvZlxuICAgIC8vLyBbbWV0YV0oI2hpZ2hsaWdodC50YWdzLm1ldGEpLlxuICAgIHByb2Nlc3NpbmdJbnN0cnVjdGlvbjogdChtZXRhKSxcbiAgICAvLy8gW01vZGlmaWVyXSgjaGlnaGxpZ2h0LlRhZ15kZWZpbmVNb2RpZmllcikgdGhhdCBpbmRpY2F0ZXMgdGhhdCBhXG4gICAgLy8vIGdpdmVuIGVsZW1lbnQgaXMgYmVpbmcgZGVmaW5lZC4gRXhwZWN0ZWQgdG8gYmUgdXNlZCB3aXRoIHRoZVxuICAgIC8vLyB2YXJpb3VzIFtuYW1lXSgjaGlnaGxpZ2h0LnRhZ3MubmFtZSkgdGFncy5cbiAgICBkZWZpbml0aW9uOiBUYWcuZGVmaW5lTW9kaWZpZXIoKSxcbiAgICAvLy8gW01vZGlmaWVyXSgjaGlnaGxpZ2h0LlRhZ15kZWZpbmVNb2RpZmllcikgdGhhdCBpbmRpY2F0ZXMgdGhhdFxuICAgIC8vLyBzb21ldGhpbmcgaXMgY29uc3RhbnQuIE1vc3RseSBleHBlY3RlZCB0byBiZSB1c2VkIHdpdGhcbiAgICAvLy8gW3ZhcmlhYmxlIG5hbWVzXSgjaGlnaGxpZ2h0LnRhZ3MudmFyaWFibGVOYW1lKS5cbiAgICBjb25zdGFudDogVGFnLmRlZmluZU1vZGlmaWVyKCksXG4gICAgLy8vIFtNb2RpZmllcl0oI2hpZ2hsaWdodC5UYWdeZGVmaW5lTW9kaWZpZXIpIHVzZWQgdG8gaW5kaWNhdGUgdGhhdFxuICAgIC8vLyBhIFt2YXJpYWJsZV0oI2hpZ2hsaWdodC50YWdzLnZhcmlhYmxlTmFtZSkgb3IgW3Byb3BlcnR5XG4gICAgLy8vIG5hbWVdKCNoaWdobGlnaHQudGFncy5wcm9wZXJ0eU5hbWUpIGlzIGJlaW5nIGNhbGxlZCBvciBkZWZpbmVkXG4gICAgLy8vIGFzIGEgZnVuY3Rpb24uXG4gICAgZnVuY3Rpb246IFRhZy5kZWZpbmVNb2RpZmllcigpLFxuICAgIC8vLyBbTW9kaWZpZXJdKCNoaWdobGlnaHQuVGFnXmRlZmluZU1vZGlmaWVyKSB0aGF0IGNhbiBiZSBhcHBsaWVkIHRvXG4gICAgLy8vIFtuYW1lc10oI2hpZ2hsaWdodC50YWdzLm5hbWUpIHRvIGluZGljYXRlIHRoYXQgdGhleSBiZWxvbmcgdG9cbiAgICAvLy8gdGhlIGxhbmd1YWdlJ3Mgc3RhbmRhcmQgZW52aXJvbm1lbnQuXG4gICAgc3RhbmRhcmQ6IFRhZy5kZWZpbmVNb2RpZmllcigpLFxuICAgIC8vLyBbTW9kaWZpZXJdKCNoaWdobGlnaHQuVGFnXmRlZmluZU1vZGlmaWVyKSB0aGF0IGluZGljYXRlcyBhIGdpdmVuXG4gICAgLy8vIFtuYW1lc10oI2hpZ2hsaWdodC50YWdzLm5hbWUpIGlzIGxvY2FsIHRvIHNvbWUgc2NvcGUuXG4gICAgbG9jYWw6IFRhZy5kZWZpbmVNb2RpZmllcigpLFxuICAgIC8vLyBBIGdlbmVyaWMgdmFyaWFudCBbbW9kaWZpZXJdKCNoaWdobGlnaHQuVGFnXmRlZmluZU1vZGlmaWVyKSB0aGF0XG4gICAgLy8vIGNhbiBiZSB1c2VkIHRvIHRhZyBsYW5ndWFnZS1zcGVjaWZpYyBhbHRlcm5hdGl2ZSB2YXJpYW50cyBvZlxuICAgIC8vLyBzb21lIGNvbW1vbiB0YWcuIEl0IGlzIHJlY29tbWVuZGVkIGZvciB0aGVtZXMgdG8gZGVmaW5lIHNwZWNpYWxcbiAgICAvLy8gZm9ybXMgb2YgYXQgbGVhc3QgdGhlIFtzdHJpbmddKCNoaWdobGlnaHQudGFncy5zdHJpbmcpIGFuZFxuICAgIC8vLyBbdmFyaWFibGUgbmFtZV0oI2hpZ2hsaWdodC50YWdzLnZhcmlhYmxlTmFtZSkgdGFncywgc2luY2UgdGhvc2VcbiAgICAvLy8gY29tZSB1cCBhIGxvdC5cbiAgICBzcGVjaWFsOiBUYWcuZGVmaW5lTW9kaWZpZXIoKVxufTtcbi8vLyBUaGlzIGlzIGEgaGlnaGxpZ2h0ZXIgdGhhdCBhZGRzIHN0YWJsZSwgcHJlZGljdGFibGUgY2xhc3NlcyB0b1xuLy8vIHRva2VucywgZm9yIHN0eWxpbmcgd2l0aCBleHRlcm5hbCBDU1MuXG4vLy9cbi8vLyBUaGUgZm9sbG93aW5nIHRhZ3MgYXJlIG1hcHBlZCB0byB0aGVpciBuYW1lIHByZWZpeGVkIHdpdGggYFwidG9rLVwiYFxuLy8vIChmb3IgZXhhbXBsZSBgXCJ0b2stY29tbWVudFwiYCk6XG4vLy9cbi8vLyAqIFtgbGlua2BdKCNoaWdobGlnaHQudGFncy5saW5rKVxuLy8vICogW2BoZWFkaW5nYF0oI2hpZ2hsaWdodC50YWdzLmhlYWRpbmcpXG4vLy8gKiBbYGVtcGhhc2lzYF0oI2hpZ2hsaWdodC50YWdzLmVtcGhhc2lzKVxuLy8vICogW2BzdHJvbmdgXSgjaGlnaGxpZ2h0LnRhZ3Muc3Ryb25nKVxuLy8vICogW2BrZXl3b3JkYF0oI2hpZ2hsaWdodC50YWdzLmtleXdvcmQpXG4vLy8gKiBbYGF0b21gXSgjaGlnaGxpZ2h0LnRhZ3MuYXRvbSkgW2Bib29sYF0oI2hpZ2hsaWdodC50YWdzLmJvb2wpXG4vLy8gKiBbYHVybGBdKCNoaWdobGlnaHQudGFncy51cmwpXG4vLy8gKiBbYGxhYmVsTmFtZWBdKCNoaWdobGlnaHQudGFncy5sYWJlbE5hbWUpXG4vLy8gKiBbYGluc2VydGVkYF0oI2hpZ2hsaWdodC50YWdzLmluc2VydGVkKVxuLy8vICogW2BkZWxldGVkYF0oI2hpZ2hsaWdodC50YWdzLmRlbGV0ZWQpXG4vLy8gKiBbYGxpdGVyYWxgXSgjaGlnaGxpZ2h0LnRhZ3MubGl0ZXJhbClcbi8vLyAqIFtgc3RyaW5nYF0oI2hpZ2hsaWdodC50YWdzLnN0cmluZylcbi8vLyAqIFtgbnVtYmVyYF0oI2hpZ2hsaWdodC50YWdzLm51bWJlcilcbi8vLyAqIFtgdmFyaWFibGVOYW1lYF0oI2hpZ2hsaWdodC50YWdzLnZhcmlhYmxlTmFtZSlcbi8vLyAqIFtgdHlwZU5hbWVgXSgjaGlnaGxpZ2h0LnRhZ3MudHlwZU5hbWUpXG4vLy8gKiBbYG5hbWVzcGFjZWBdKCNoaWdobGlnaHQudGFncy5uYW1lc3BhY2UpXG4vLy8gKiBbYGNsYXNzTmFtZWBdKCNoaWdobGlnaHQudGFncy5jbGFzc05hbWUpXG4vLy8gKiBbYG1hY3JvTmFtZWBdKCNoaWdobGlnaHQudGFncy5tYWNyb05hbWUpXG4vLy8gKiBbYHByb3BlcnR5TmFtZWBdKCNoaWdobGlnaHQudGFncy5wcm9wZXJ0eU5hbWUpXG4vLy8gKiBbYG9wZXJhdG9yYF0oI2hpZ2hsaWdodC50YWdzLm9wZXJhdG9yKVxuLy8vICogW2Bjb21tZW50YF0oI2hpZ2hsaWdodC50YWdzLmNvbW1lbnQpXG4vLy8gKiBbYG1ldGFgXSgjaGlnaGxpZ2h0LnRhZ3MubWV0YSlcbi8vLyAqIFtgcHVuY3R1YXRpb25gXSgjaGlnaGxpZ2h0LnRhZ3MucHVuY3R1YXRpb24pXG4vLy8gKiBbYGludmFsaWRgXSgjaGlnaGxpZ2h0LnRhZ3MuaW52YWxpZClcbi8vL1xuLy8vIEluIGFkZGl0aW9uLCB0aGVzZSBtYXBwaW5ncyBhcmUgcHJvdmlkZWQ6XG4vLy9cbi8vLyAqIFtgcmVnZXhwYF0oI2hpZ2hsaWdodC50YWdzLnJlZ2V4cCksXG4vLy8gICBbYGVzY2FwZWBdKCNoaWdobGlnaHQudGFncy5lc2NhcGUpLCBhbmRcbi8vLyAgIFtgc3BlY2lhbGBdKCNoaWdobGlnaHQudGFncy5zcGVjaWFsKVtgKHN0cmluZylgXSgjaGlnaGxpZ2h0LnRhZ3Muc3RyaW5nKVxuLy8vICAgYXJlIG1hcHBlZCB0byBgXCJ0b2stc3RyaW5nMlwiYFxuLy8vICogW2BzcGVjaWFsYF0oI2hpZ2hsaWdodC50YWdzLnNwZWNpYWwpW2AodmFyaWFibGVOYW1lKWBdKCNoaWdobGlnaHQudGFncy52YXJpYWJsZU5hbWUpXG4vLy8gICB0byBgXCJ0b2stdmFyaWFibGVOYW1lMlwiYFxuLy8vICogW2Bsb2NhbGBdKCNoaWdobGlnaHQudGFncy5sb2NhbClbYCh2YXJpYWJsZU5hbWUpYF0oI2hpZ2hsaWdodC50YWdzLnZhcmlhYmxlTmFtZSlcbi8vLyAgIHRvIGBcInRvay12YXJpYWJsZU5hbWUgdG9rLWxvY2FsXCJgXG4vLy8gKiBbYGRlZmluaXRpb25gXSgjaGlnaGxpZ2h0LnRhZ3MuZGVmaW5pdGlvbilbYCh2YXJpYWJsZU5hbWUpYF0oI2hpZ2hsaWdodC50YWdzLnZhcmlhYmxlTmFtZSlcbi8vLyAgIHRvIGBcInRvay12YXJpYWJsZU5hbWUgdG9rLWRlZmluaXRpb25cImBcbi8vLyAqIFtgZGVmaW5pdGlvbmBdKCNoaWdobGlnaHQudGFncy5kZWZpbml0aW9uKVtgKHByb3BlcnR5TmFtZSlgXSgjaGlnaGxpZ2h0LnRhZ3MucHJvcGVydHlOYW1lKVxuLy8vICAgdG8gYFwidG9rLXByb3BlcnR5TmFtZSB0b2stZGVmaW5pdGlvblwiYFxuY29uc3QgY2xhc3NIaWdobGlnaHRlciA9IHRhZ0hpZ2hsaWdodGVyKFtcbiAgICB7IHRhZzogdGFncy5saW5rLCBjbGFzczogXCJ0b2stbGlua1wiIH0sXG4gICAgeyB0YWc6IHRhZ3MuaGVhZGluZywgY2xhc3M6IFwidG9rLWhlYWRpbmdcIiB9LFxuICAgIHsgdGFnOiB0YWdzLmVtcGhhc2lzLCBjbGFzczogXCJ0b2stZW1waGFzaXNcIiB9LFxuICAgIHsgdGFnOiB0YWdzLnN0cm9uZywgY2xhc3M6IFwidG9rLXN0cm9uZ1wiIH0sXG4gICAgeyB0YWc6IHRhZ3Mua2V5d29yZCwgY2xhc3M6IFwidG9rLWtleXdvcmRcIiB9LFxuICAgIHsgdGFnOiB0YWdzLmF0b20sIGNsYXNzOiBcInRvay1hdG9tXCIgfSxcbiAgICB7IHRhZzogdGFncy5ib29sLCBjbGFzczogXCJ0b2stYm9vbFwiIH0sXG4gICAgeyB0YWc6IHRhZ3MudXJsLCBjbGFzczogXCJ0b2stdXJsXCIgfSxcbiAgICB7IHRhZzogdGFncy5sYWJlbE5hbWUsIGNsYXNzOiBcInRvay1sYWJlbE5hbWVcIiB9LFxuICAgIHsgdGFnOiB0YWdzLmluc2VydGVkLCBjbGFzczogXCJ0b2staW5zZXJ0ZWRcIiB9LFxuICAgIHsgdGFnOiB0YWdzLmRlbGV0ZWQsIGNsYXNzOiBcInRvay1kZWxldGVkXCIgfSxcbiAgICB7IHRhZzogdGFncy5saXRlcmFsLCBjbGFzczogXCJ0b2stbGl0ZXJhbFwiIH0sXG4gICAgeyB0YWc6IHRhZ3Muc3RyaW5nLCBjbGFzczogXCJ0b2stc3RyaW5nXCIgfSxcbiAgICB7IHRhZzogdGFncy5udW1iZXIsIGNsYXNzOiBcInRvay1udW1iZXJcIiB9LFxuICAgIHsgdGFnOiBbdGFncy5yZWdleHAsIHRhZ3MuZXNjYXBlLCB0YWdzLnNwZWNpYWwodGFncy5zdHJpbmcpXSwgY2xhc3M6IFwidG9rLXN0cmluZzJcIiB9LFxuICAgIHsgdGFnOiB0YWdzLnZhcmlhYmxlTmFtZSwgY2xhc3M6IFwidG9rLXZhcmlhYmxlTmFtZVwiIH0sXG4gICAgeyB0YWc6IHRhZ3MubG9jYWwodGFncy52YXJpYWJsZU5hbWUpLCBjbGFzczogXCJ0b2stdmFyaWFibGVOYW1lIHRvay1sb2NhbFwiIH0sXG4gICAgeyB0YWc6IHRhZ3MuZGVmaW5pdGlvbih0YWdzLnZhcmlhYmxlTmFtZSksIGNsYXNzOiBcInRvay12YXJpYWJsZU5hbWUgdG9rLWRlZmluaXRpb25cIiB9LFxuICAgIHsgdGFnOiB0YWdzLnNwZWNpYWwodGFncy52YXJpYWJsZU5hbWUpLCBjbGFzczogXCJ0b2stdmFyaWFibGVOYW1lMlwiIH0sXG4gICAgeyB0YWc6IHRhZ3MuZGVmaW5pdGlvbih0YWdzLnByb3BlcnR5TmFtZSksIGNsYXNzOiBcInRvay1wcm9wZXJ0eU5hbWUgdG9rLWRlZmluaXRpb25cIiB9LFxuICAgIHsgdGFnOiB0YWdzLnR5cGVOYW1lLCBjbGFzczogXCJ0b2stdHlwZU5hbWVcIiB9LFxuICAgIHsgdGFnOiB0YWdzLm5hbWVzcGFjZSwgY2xhc3M6IFwidG9rLW5hbWVzcGFjZVwiIH0sXG4gICAgeyB0YWc6IHRhZ3MuY2xhc3NOYW1lLCBjbGFzczogXCJ0b2stY2xhc3NOYW1lXCIgfSxcbiAgICB7IHRhZzogdGFncy5tYWNyb05hbWUsIGNsYXNzOiBcInRvay1tYWNyb05hbWVcIiB9LFxuICAgIHsgdGFnOiB0YWdzLnByb3BlcnR5TmFtZSwgY2xhc3M6IFwidG9rLXByb3BlcnR5TmFtZVwiIH0sXG4gICAgeyB0YWc6IHRhZ3Mub3BlcmF0b3IsIGNsYXNzOiBcInRvay1vcGVyYXRvclwiIH0sXG4gICAgeyB0YWc6IHRhZ3MuY29tbWVudCwgY2xhc3M6IFwidG9rLWNvbW1lbnRcIiB9LFxuICAgIHsgdGFnOiB0YWdzLm1ldGEsIGNsYXNzOiBcInRvay1tZXRhXCIgfSxcbiAgICB7IHRhZzogdGFncy5pbnZhbGlkLCBjbGFzczogXCJ0b2staW52YWxpZFwiIH0sXG4gICAgeyB0YWc6IHRhZ3MucHVuY3R1YXRpb24sIGNsYXNzOiBcInRvay1wdW5jdHVhdGlvblwiIH1cbl0pO1xuXG5leHBvcnRzLlRhZyA9IFRhZztcbmV4cG9ydHMuY2xhc3NIaWdobGlnaHRlciA9IGNsYXNzSGlnaGxpZ2h0ZXI7XG5leHBvcnRzLmhpZ2hsaWdodFRhZ3MgPSBoaWdobGlnaHRUYWdzO1xuZXhwb3J0cy5oaWdobGlnaHRUcmVlID0gaGlnaGxpZ2h0VHJlZTtcbmV4cG9ydHMuc3R5bGVUYWdzID0gc3R5bGVUYWdzO1xuZXhwb3J0cy50YWdIaWdobGlnaHRlciA9IHRhZ0hpZ2hsaWdodGVyO1xuZXhwb3J0cy50YWdzID0gdGFncztcbiIsIid1c2Ugc3RyaWN0JztcblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsICdfX2VzTW9kdWxlJywgeyB2YWx1ZTogdHJ1ZSB9KTtcblxudmFyIGNvbW1vbiA9IHJlcXVpcmUoJ0BsZXplci9jb21tb24nKTtcblxuLy8vIEEgcGFyc2Ugc3RhY2suIFRoZXNlIGFyZSB1c2VkIGludGVybmFsbHkgYnkgdGhlIHBhcnNlciB0byB0cmFja1xuLy8vIHBhcnNpbmcgcHJvZ3Jlc3MuIFRoZXkgYWxzbyBwcm92aWRlIHNvbWUgcHJvcGVydGllcyBhbmQgbWV0aG9kc1xuLy8vIHRoYXQgZXh0ZXJuYWwgY29kZSBzdWNoIGFzIGEgdG9rZW5pemVyIGNhbiB1c2UgdG8gZ2V0IGluZm9ybWF0aW9uXG4vLy8gYWJvdXQgdGhlIHBhcnNlIHN0YXRlLlxuY2xhc3MgU3RhY2sge1xuICAgIC8vLyBAaW50ZXJuYWxcbiAgICBjb25zdHJ1Y3RvcihcbiAgICAvLy8gVGhlIHBhcnNlIHRoYXQgdGhpcyBzdGFjayBpcyBwYXJ0IG9mIEBpbnRlcm5hbFxuICAgIHAsIFxuICAgIC8vLyBIb2xkcyBzdGF0ZSwgaW5wdXQgcG9zLCBidWZmZXIgaW5kZXggdHJpcGxldHMgZm9yIGFsbCBidXQgdGhlXG4gICAgLy8vIHRvcCBzdGF0ZSBAaW50ZXJuYWxcbiAgICBzdGFjaywgXG4gICAgLy8vIFRoZSBjdXJyZW50IHBhcnNlIHN0YXRlIEBpbnRlcm5hbFxuICAgIHN0YXRlLCBcbiAgICAvLyBUaGUgcG9zaXRpb24gYXQgd2hpY2ggdGhlIG5leHQgcmVkdWNlIHNob3VsZCB0YWtlIHBsYWNlLiBUaGlzXG4gICAgLy8gY2FuIGJlIGxlc3MgdGhhbiBgdGhpcy5wb3NgIHdoZW4gc2tpcHBlZCBleHByZXNzaW9ucyBoYXZlIGJlZW5cbiAgICAvLyBhZGRlZCB0byB0aGUgc3RhY2sgKHdoaWNoIHNob3VsZCBiZSBtb3ZlZCBvdXRzaWRlIG9mIHRoZSBuZXh0XG4gICAgLy8gcmVkdWN0aW9uKVxuICAgIC8vLyBAaW50ZXJuYWxcbiAgICByZWR1Y2VQb3MsIFxuICAgIC8vLyBUaGUgaW5wdXQgcG9zaXRpb24gdXAgdG8gd2hpY2ggdGhpcyBzdGFjayBoYXMgcGFyc2VkLlxuICAgIHBvcywgXG4gICAgLy8vIFRoZSBkeW5hbWljIHNjb3JlIG9mIHRoZSBzdGFjaywgaW5jbHVkaW5nIGR5bmFtaWMgcHJlY2VkZW5jZVxuICAgIC8vLyBhbmQgZXJyb3ItcmVjb3ZlcnkgcGVuYWx0aWVzXG4gICAgLy8vIEBpbnRlcm5hbFxuICAgIHNjb3JlLCBcbiAgICAvLyBUaGUgb3V0cHV0IGJ1ZmZlci4gSG9sZHMgKHR5cGUsIHN0YXJ0LCBlbmQsIHNpemUpIHF1YWRzXG4gICAgLy8gcmVwcmVzZW50aW5nIG5vZGVzIGNyZWF0ZWQgYnkgdGhlIHBhcnNlciwgd2hlcmUgYHNpemVgIGlzXG4gICAgLy8gYW1vdW50IG9mIGJ1ZmZlciBhcnJheSBlbnRyaWVzIGNvdmVyZWQgYnkgdGhpcyBub2RlLlxuICAgIC8vLyBAaW50ZXJuYWxcbiAgICBidWZmZXIsIFxuICAgIC8vIFRoZSBiYXNlIG9mZnNldCBvZiB0aGUgYnVmZmVyLiBXaGVuIHN0YWNrcyBhcmUgc3BsaXQsIHRoZSBzcGxpdFxuICAgIC8vIGluc3RhbmNlIHNoYXJlZCB0aGUgYnVmZmVyIGhpc3Rvcnkgd2l0aCBpdHMgcGFyZW50IHVwIHRvXG4gICAgLy8gYGJ1ZmZlckJhc2VgLCB3aGljaCBpcyB0aGUgYWJzb2x1dGUgb2Zmc2V0IChpbmNsdWRpbmcgdGhlXG4gICAgLy8gb2Zmc2V0IG9mIHByZXZpb3VzIHNwbGl0cykgaW50byB0aGUgYnVmZmVyIGF0IHdoaWNoIHRoaXMgc3RhY2tcbiAgICAvLyBzdGFydHMgd3JpdGluZy5cbiAgICAvLy8gQGludGVybmFsXG4gICAgYnVmZmVyQmFzZSwgXG4gICAgLy8vIEBpbnRlcm5hbFxuICAgIGN1ckNvbnRleHQsIFxuICAgIC8vLyBAaW50ZXJuYWxcbiAgICBsb29rQWhlYWQgPSAwLCBcbiAgICAvLyBBIHBhcmVudCBzdGFjayBmcm9tIHdoaWNoIHRoaXMgd2FzIHNwbGl0IG9mZiwgaWYgYW55LiBUaGlzIGlzXG4gICAgLy8gc2V0IHVwIHNvIHRoYXQgaXQgYWx3YXlzIHBvaW50cyB0byBhIHN0YWNrIHRoYXQgaGFzIHNvbWVcbiAgICAvLyBhZGRpdGlvbmFsIGJ1ZmZlciBjb250ZW50LCBuZXZlciB0byBhIHN0YWNrIHdpdGggYW4gZXF1YWxcbiAgICAvLyBgYnVmZmVyQmFzZWAuXG4gICAgLy8vIEBpbnRlcm5hbFxuICAgIHBhcmVudCkge1xuICAgICAgICB0aGlzLnAgPSBwO1xuICAgICAgICB0aGlzLnN0YWNrID0gc3RhY2s7XG4gICAgICAgIHRoaXMuc3RhdGUgPSBzdGF0ZTtcbiAgICAgICAgdGhpcy5yZWR1Y2VQb3MgPSByZWR1Y2VQb3M7XG4gICAgICAgIHRoaXMucG9zID0gcG9zO1xuICAgICAgICB0aGlzLnNjb3JlID0gc2NvcmU7XG4gICAgICAgIHRoaXMuYnVmZmVyID0gYnVmZmVyO1xuICAgICAgICB0aGlzLmJ1ZmZlckJhc2UgPSBidWZmZXJCYXNlO1xuICAgICAgICB0aGlzLmN1ckNvbnRleHQgPSBjdXJDb250ZXh0O1xuICAgICAgICB0aGlzLmxvb2tBaGVhZCA9IGxvb2tBaGVhZDtcbiAgICAgICAgdGhpcy5wYXJlbnQgPSBwYXJlbnQ7XG4gICAgfVxuICAgIC8vLyBAaW50ZXJuYWxcbiAgICB0b1N0cmluZygpIHtcbiAgICAgICAgcmV0dXJuIGBbJHt0aGlzLnN0YWNrLmZpbHRlcigoXywgaSkgPT4gaSAlIDMgPT0gMCkuY29uY2F0KHRoaXMuc3RhdGUpfV1AJHt0aGlzLnBvc30ke3RoaXMuc2NvcmUgPyBcIiFcIiArIHRoaXMuc2NvcmUgOiBcIlwifWA7XG4gICAgfVxuICAgIC8vIFN0YXJ0IGFuIGVtcHR5IHN0YWNrXG4gICAgLy8vIEBpbnRlcm5hbFxuICAgIHN0YXRpYyBzdGFydChwLCBzdGF0ZSwgcG9zID0gMCkge1xuICAgICAgICBsZXQgY3ggPSBwLnBhcnNlci5jb250ZXh0O1xuICAgICAgICByZXR1cm4gbmV3IFN0YWNrKHAsIFtdLCBzdGF0ZSwgcG9zLCBwb3MsIDAsIFtdLCAwLCBjeCA/IG5ldyBTdGFja0NvbnRleHQoY3gsIGN4LnN0YXJ0KSA6IG51bGwsIDAsIG51bGwpO1xuICAgIH1cbiAgICAvLy8gVGhlIHN0YWNrJ3MgY3VycmVudCBbY29udGV4dF0oI2xyLkNvbnRleHRUcmFja2VyKSB2YWx1ZSwgaWZcbiAgICAvLy8gYW55LiBJdHMgdHlwZSB3aWxsIGRlcGVuZCBvbiB0aGUgY29udGV4dCB0cmFja2VyJ3MgdHlwZVxuICAgIC8vLyBwYXJhbWV0ZXIsIG9yIGl0IHdpbGwgYmUgYG51bGxgIGlmIHRoZXJlIGlzIG5vIGNvbnRleHRcbiAgICAvLy8gdHJhY2tlci5cbiAgICBnZXQgY29udGV4dCgpIHsgcmV0dXJuIHRoaXMuY3VyQ29udGV4dCA/IHRoaXMuY3VyQ29udGV4dC5jb250ZXh0IDogbnVsbDsgfVxuICAgIC8vIFB1c2ggYSBzdGF0ZSBvbnRvIHRoZSBzdGFjaywgdHJhY2tpbmcgaXRzIHN0YXJ0IHBvc2l0aW9uIGFzIHdlbGxcbiAgICAvLyBhcyB0aGUgYnVmZmVyIGJhc2UgYXQgdGhhdCBwb2ludC5cbiAgICAvLy8gQGludGVybmFsXG4gICAgcHVzaFN0YXRlKHN0YXRlLCBzdGFydCkge1xuICAgICAgICB0aGlzLnN0YWNrLnB1c2godGhpcy5zdGF0ZSwgc3RhcnQsIHRoaXMuYnVmZmVyQmFzZSArIHRoaXMuYnVmZmVyLmxlbmd0aCk7XG4gICAgICAgIHRoaXMuc3RhdGUgPSBzdGF0ZTtcbiAgICB9XG4gICAgLy8gQXBwbHkgYSByZWR1Y2UgYWN0aW9uXG4gICAgLy8vIEBpbnRlcm5hbFxuICAgIHJlZHVjZShhY3Rpb24pIHtcbiAgICAgICAgbGV0IGRlcHRoID0gYWN0aW9uID4+IDE5IC8qIFJlZHVjZURlcHRoU2hpZnQgKi8sIHR5cGUgPSBhY3Rpb24gJiA2NTUzNSAvKiBWYWx1ZU1hc2sgKi87XG4gICAgICAgIGxldCB7IHBhcnNlciB9ID0gdGhpcy5wO1xuICAgICAgICBsZXQgZFByZWMgPSBwYXJzZXIuZHluYW1pY1ByZWNlZGVuY2UodHlwZSk7XG4gICAgICAgIGlmIChkUHJlYylcbiAgICAgICAgICAgIHRoaXMuc2NvcmUgKz0gZFByZWM7XG4gICAgICAgIGlmIChkZXB0aCA9PSAwKSB7XG4gICAgICAgICAgICB0aGlzLnB1c2hTdGF0ZShwYXJzZXIuZ2V0R290byh0aGlzLnN0YXRlLCB0eXBlLCB0cnVlKSwgdGhpcy5yZWR1Y2VQb3MpO1xuICAgICAgICAgICAgLy8gWmVyby1kZXB0aCByZWR1Y3Rpb25zIGFyZSBhIHNwZWNpYWwgY2FzZeKAlHRoZXkgYWRkIHN0dWZmIHRvXG4gICAgICAgICAgICAvLyB0aGUgc3RhY2sgd2l0aG91dCBwb3BwaW5nIGFueXRoaW5nIG9mZi5cbiAgICAgICAgICAgIGlmICh0eXBlIDwgcGFyc2VyLm1pblJlcGVhdFRlcm0pXG4gICAgICAgICAgICAgICAgdGhpcy5zdG9yZU5vZGUodHlwZSwgdGhpcy5yZWR1Y2VQb3MsIHRoaXMucmVkdWNlUG9zLCA0LCB0cnVlKTtcbiAgICAgICAgICAgIHRoaXMucmVkdWNlQ29udGV4dCh0eXBlLCB0aGlzLnJlZHVjZVBvcyk7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgLy8gRmluZCB0aGUgYmFzZSBpbmRleCBpbnRvIGB0aGlzLnN0YWNrYCwgY29udGVudCBhZnRlciB3aGljaCB3aWxsXG4gICAgICAgIC8vIGJlIGRyb3BwZWQuIE5vdGUgdGhhdCB3aXRoIGBTdGF5RmxhZ2AgcmVkdWN0aW9ucyB3ZSBuZWVkIHRvXG4gICAgICAgIC8vIGNvbnN1bWUgdHdvIGV4dHJhIGZyYW1lcyAodGhlIGR1bW15IHBhcmVudCBub2RlIGZvciB0aGUgc2tpcHBlZFxuICAgICAgICAvLyBleHByZXNzaW9uIGFuZCB0aGUgc3RhdGUgdGhhdCB3ZSdsbCBiZSBzdGF5aW5nIGluLCB3aGljaCBzaG91bGRcbiAgICAgICAgLy8gYmUgbW92ZWQgdG8gYHRoaXMuc3RhdGVgKS5cbiAgICAgICAgbGV0IGJhc2UgPSB0aGlzLnN0YWNrLmxlbmd0aCAtICgoZGVwdGggLSAxKSAqIDMpIC0gKGFjdGlvbiAmIDI2MjE0NCAvKiBTdGF5RmxhZyAqLyA/IDYgOiAwKTtcbiAgICAgICAgbGV0IHN0YXJ0ID0gdGhpcy5zdGFja1tiYXNlIC0gMl07XG4gICAgICAgIGxldCBidWZmZXJCYXNlID0gdGhpcy5zdGFja1tiYXNlIC0gMV0sIGNvdW50ID0gdGhpcy5idWZmZXJCYXNlICsgdGhpcy5idWZmZXIubGVuZ3RoIC0gYnVmZmVyQmFzZTtcbiAgICAgICAgLy8gU3RvcmUgbm9ybWFsIHRlcm1zIG9yIGBSIC0+IFIgUmAgcmVwZWF0IHJlZHVjdGlvbnNcbiAgICAgICAgaWYgKHR5cGUgPCBwYXJzZXIubWluUmVwZWF0VGVybSB8fCAoYWN0aW9uICYgMTMxMDcyIC8qIFJlcGVhdEZsYWcgKi8pKSB7XG4gICAgICAgICAgICBsZXQgcG9zID0gcGFyc2VyLnN0YXRlRmxhZyh0aGlzLnN0YXRlLCAxIC8qIFNraXBwZWQgKi8pID8gdGhpcy5wb3MgOiB0aGlzLnJlZHVjZVBvcztcbiAgICAgICAgICAgIHRoaXMuc3RvcmVOb2RlKHR5cGUsIHN0YXJ0LCBwb3MsIGNvdW50ICsgNCwgdHJ1ZSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGFjdGlvbiAmIDI2MjE0NCAvKiBTdGF5RmxhZyAqLykge1xuICAgICAgICAgICAgdGhpcy5zdGF0ZSA9IHRoaXMuc3RhY2tbYmFzZV07XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBsZXQgYmFzZVN0YXRlSUQgPSB0aGlzLnN0YWNrW2Jhc2UgLSAzXTtcbiAgICAgICAgICAgIHRoaXMuc3RhdGUgPSBwYXJzZXIuZ2V0R290byhiYXNlU3RhdGVJRCwgdHlwZSwgdHJ1ZSk7XG4gICAgICAgIH1cbiAgICAgICAgd2hpbGUgKHRoaXMuc3RhY2subGVuZ3RoID4gYmFzZSlcbiAgICAgICAgICAgIHRoaXMuc3RhY2sucG9wKCk7XG4gICAgICAgIHRoaXMucmVkdWNlQ29udGV4dCh0eXBlLCBzdGFydCk7XG4gICAgfVxuICAgIC8vIFNoaWZ0IGEgdmFsdWUgaW50byB0aGUgYnVmZmVyXG4gICAgLy8vIEBpbnRlcm5hbFxuICAgIHN0b3JlTm9kZSh0ZXJtLCBzdGFydCwgZW5kLCBzaXplID0gNCwgaXNSZWR1Y2UgPSBmYWxzZSkge1xuICAgICAgICBpZiAodGVybSA9PSAwIC8qIEVyciAqLyAmJlxuICAgICAgICAgICAgKCF0aGlzLnN0YWNrLmxlbmd0aCB8fCB0aGlzLnN0YWNrW3RoaXMuc3RhY2subGVuZ3RoIC0gMV0gPCB0aGlzLmJ1ZmZlci5sZW5ndGggKyB0aGlzLmJ1ZmZlckJhc2UpKSB7XG4gICAgICAgICAgICAvLyBUcnkgdG8gb21pdC9tZXJnZSBhZGphY2VudCBlcnJvciBub2Rlc1xuICAgICAgICAgICAgbGV0IGN1ciA9IHRoaXMsIHRvcCA9IHRoaXMuYnVmZmVyLmxlbmd0aDtcbiAgICAgICAgICAgIGlmICh0b3AgPT0gMCAmJiBjdXIucGFyZW50KSB7XG4gICAgICAgICAgICAgICAgdG9wID0gY3VyLmJ1ZmZlckJhc2UgLSBjdXIucGFyZW50LmJ1ZmZlckJhc2U7XG4gICAgICAgICAgICAgICAgY3VyID0gY3VyLnBhcmVudDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICh0b3AgPiAwICYmIGN1ci5idWZmZXJbdG9wIC0gNF0gPT0gMCAvKiBFcnIgKi8gJiYgY3VyLmJ1ZmZlclt0b3AgLSAxXSA+IC0xKSB7XG4gICAgICAgICAgICAgICAgaWYgKHN0YXJ0ID09IGVuZClcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICAgIGlmIChjdXIuYnVmZmVyW3RvcCAtIDJdID49IHN0YXJ0KSB7XG4gICAgICAgICAgICAgICAgICAgIGN1ci5idWZmZXJbdG9wIC0gMl0gPSBlbmQ7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCFpc1JlZHVjZSB8fCB0aGlzLnBvcyA9PSBlbmQpIHsgLy8gU2ltcGxlIGNhc2UsIGp1c3QgYXBwZW5kXG4gICAgICAgICAgICB0aGlzLmJ1ZmZlci5wdXNoKHRlcm0sIHN0YXJ0LCBlbmQsIHNpemUpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgeyAvLyBUaGVyZSBtYXkgYmUgc2tpcHBlZCBub2RlcyB0aGF0IGhhdmUgdG8gYmUgbW92ZWQgZm9yd2FyZFxuICAgICAgICAgICAgbGV0IGluZGV4ID0gdGhpcy5idWZmZXIubGVuZ3RoO1xuICAgICAgICAgICAgaWYgKGluZGV4ID4gMCAmJiB0aGlzLmJ1ZmZlcltpbmRleCAtIDRdICE9IDAgLyogRXJyICovKVxuICAgICAgICAgICAgICAgIHdoaWxlIChpbmRleCA+IDAgJiYgdGhpcy5idWZmZXJbaW5kZXggLSAyXSA+IGVuZCkge1xuICAgICAgICAgICAgICAgICAgICAvLyBNb3ZlIHRoaXMgcmVjb3JkIGZvcndhcmRcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5idWZmZXJbaW5kZXhdID0gdGhpcy5idWZmZXJbaW5kZXggLSA0XTtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5idWZmZXJbaW5kZXggKyAxXSA9IHRoaXMuYnVmZmVyW2luZGV4IC0gM107XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuYnVmZmVyW2luZGV4ICsgMl0gPSB0aGlzLmJ1ZmZlcltpbmRleCAtIDJdO1xuICAgICAgICAgICAgICAgICAgICB0aGlzLmJ1ZmZlcltpbmRleCArIDNdID0gdGhpcy5idWZmZXJbaW5kZXggLSAxXTtcbiAgICAgICAgICAgICAgICAgICAgaW5kZXggLT0gNDtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHNpemUgPiA0KVxuICAgICAgICAgICAgICAgICAgICAgICAgc2l6ZSAtPSA0O1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRoaXMuYnVmZmVyW2luZGV4XSA9IHRlcm07XG4gICAgICAgICAgICB0aGlzLmJ1ZmZlcltpbmRleCArIDFdID0gc3RhcnQ7XG4gICAgICAgICAgICB0aGlzLmJ1ZmZlcltpbmRleCArIDJdID0gZW5kO1xuICAgICAgICAgICAgdGhpcy5idWZmZXJbaW5kZXggKyAzXSA9IHNpemU7XG4gICAgICAgIH1cbiAgICB9XG4gICAgLy8gQXBwbHkgYSBzaGlmdCBhY3Rpb25cbiAgICAvLy8gQGludGVybmFsXG4gICAgc2hpZnQoYWN0aW9uLCBuZXh0LCBuZXh0RW5kKSB7XG4gICAgICAgIGxldCBzdGFydCA9IHRoaXMucG9zO1xuICAgICAgICBpZiAoYWN0aW9uICYgMTMxMDcyIC8qIEdvdG9GbGFnICovKSB7XG4gICAgICAgICAgICB0aGlzLnB1c2hTdGF0ZShhY3Rpb24gJiA2NTUzNSAvKiBWYWx1ZU1hc2sgKi8sIHRoaXMucG9zKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmICgoYWN0aW9uICYgMjYyMTQ0IC8qIFN0YXlGbGFnICovKSA9PSAwKSB7IC8vIFJlZ3VsYXIgc2hpZnRcbiAgICAgICAgICAgIGxldCBuZXh0U3RhdGUgPSBhY3Rpb24sIHsgcGFyc2VyIH0gPSB0aGlzLnA7XG4gICAgICAgICAgICBpZiAobmV4dEVuZCA+IHRoaXMucG9zIHx8IG5leHQgPD0gcGFyc2VyLm1heE5vZGUpIHtcbiAgICAgICAgICAgICAgICB0aGlzLnBvcyA9IG5leHRFbmQ7XG4gICAgICAgICAgICAgICAgaWYgKCFwYXJzZXIuc3RhdGVGbGFnKG5leHRTdGF0ZSwgMSAvKiBTa2lwcGVkICovKSlcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5yZWR1Y2VQb3MgPSBuZXh0RW5kO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhpcy5wdXNoU3RhdGUobmV4dFN0YXRlLCBzdGFydCk7XG4gICAgICAgICAgICB0aGlzLnNoaWZ0Q29udGV4dChuZXh0LCBzdGFydCk7XG4gICAgICAgICAgICBpZiAobmV4dCA8PSBwYXJzZXIubWF4Tm9kZSlcbiAgICAgICAgICAgICAgICB0aGlzLmJ1ZmZlci5wdXNoKG5leHQsIHN0YXJ0LCBuZXh0RW5kLCA0KTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHsgLy8gU2hpZnQtYW5kLXN0YXksIHdoaWNoIG1lYW5zIHRoaXMgaXMgYSBza2lwcGVkIHRva2VuXG4gICAgICAgICAgICB0aGlzLnBvcyA9IG5leHRFbmQ7XG4gICAgICAgICAgICB0aGlzLnNoaWZ0Q29udGV4dChuZXh0LCBzdGFydCk7XG4gICAgICAgICAgICBpZiAobmV4dCA8PSB0aGlzLnAucGFyc2VyLm1heE5vZGUpXG4gICAgICAgICAgICAgICAgdGhpcy5idWZmZXIucHVzaChuZXh0LCBzdGFydCwgbmV4dEVuZCwgNCk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgLy8gQXBwbHkgYW4gYWN0aW9uXG4gICAgLy8vIEBpbnRlcm5hbFxuICAgIGFwcGx5KGFjdGlvbiwgbmV4dCwgbmV4dEVuZCkge1xuICAgICAgICBpZiAoYWN0aW9uICYgNjU1MzYgLyogUmVkdWNlRmxhZyAqLylcbiAgICAgICAgICAgIHRoaXMucmVkdWNlKGFjdGlvbik7XG4gICAgICAgIGVsc2VcbiAgICAgICAgICAgIHRoaXMuc2hpZnQoYWN0aW9uLCBuZXh0LCBuZXh0RW5kKTtcbiAgICB9XG4gICAgLy8gQWRkIGEgcHJlYnVpbHQgKHJldXNlZCkgbm9kZSBpbnRvIHRoZSBidWZmZXIuXG4gICAgLy8vIEBpbnRlcm5hbFxuICAgIHVzZU5vZGUodmFsdWUsIG5leHQpIHtcbiAgICAgICAgbGV0IGluZGV4ID0gdGhpcy5wLnJldXNlZC5sZW5ndGggLSAxO1xuICAgICAgICBpZiAoaW5kZXggPCAwIHx8IHRoaXMucC5yZXVzZWRbaW5kZXhdICE9IHZhbHVlKSB7XG4gICAgICAgICAgICB0aGlzLnAucmV1c2VkLnB1c2godmFsdWUpO1xuICAgICAgICAgICAgaW5kZXgrKztcbiAgICAgICAgfVxuICAgICAgICBsZXQgc3RhcnQgPSB0aGlzLnBvcztcbiAgICAgICAgdGhpcy5yZWR1Y2VQb3MgPSB0aGlzLnBvcyA9IHN0YXJ0ICsgdmFsdWUubGVuZ3RoO1xuICAgICAgICB0aGlzLnB1c2hTdGF0ZShuZXh0LCBzdGFydCk7XG4gICAgICAgIHRoaXMuYnVmZmVyLnB1c2goaW5kZXgsIHN0YXJ0LCB0aGlzLnJlZHVjZVBvcywgLTEgLyogc2l6ZSA9PSAtMSBtZWFucyB0aGlzIGlzIGEgcmV1c2VkIHZhbHVlICovKTtcbiAgICAgICAgaWYgKHRoaXMuY3VyQ29udGV4dClcbiAgICAgICAgICAgIHRoaXMudXBkYXRlQ29udGV4dCh0aGlzLmN1ckNvbnRleHQudHJhY2tlci5yZXVzZSh0aGlzLmN1ckNvbnRleHQuY29udGV4dCwgdmFsdWUsIHRoaXMsIHRoaXMucC5zdHJlYW0ucmVzZXQodGhpcy5wb3MgLSB2YWx1ZS5sZW5ndGgpKSk7XG4gICAgfVxuICAgIC8vIFNwbGl0IHRoZSBzdGFjay4gRHVlIHRvIHRoZSBidWZmZXIgc2hhcmluZyBhbmQgdGhlIGZhY3RcbiAgICAvLyB0aGF0IGB0aGlzLnN0YWNrYCB0ZW5kcyB0byBzdGF5IHF1aXRlIHNoYWxsb3csIHRoaXMgaXNuJ3QgdmVyeVxuICAgIC8vIGV4cGVuc2l2ZS5cbiAgICAvLy8gQGludGVybmFsXG4gICAgc3BsaXQoKSB7XG4gICAgICAgIGxldCBwYXJlbnQgPSB0aGlzO1xuICAgICAgICBsZXQgb2ZmID0gcGFyZW50LmJ1ZmZlci5sZW5ndGg7XG4gICAgICAgIC8vIEJlY2F1c2UgdGhlIHRvcCBvZiB0aGUgYnVmZmVyIChhZnRlciB0aGlzLnBvcykgbWF5IGJlIG11dGF0ZWRcbiAgICAgICAgLy8gdG8gcmVvcmRlciByZWR1Y3Rpb25zIGFuZCBza2lwcGVkIHRva2VucywgYW5kIHNoYXJlZCBidWZmZXJzXG4gICAgICAgIC8vIHNob3VsZCBiZSBpbW11dGFibGUsIHRoaXMgY29waWVzIGFueSBvdXRzdGFuZGluZyBza2lwcGVkIHRva2Vuc1xuICAgICAgICAvLyB0byB0aGUgbmV3IGJ1ZmZlciwgYW5kIHB1dHMgdGhlIGJhc2UgcG9pbnRlciBiZWZvcmUgdGhlbS5cbiAgICAgICAgd2hpbGUgKG9mZiA+IDAgJiYgcGFyZW50LmJ1ZmZlcltvZmYgLSAyXSA+IHBhcmVudC5yZWR1Y2VQb3MpXG4gICAgICAgICAgICBvZmYgLT0gNDtcbiAgICAgICAgbGV0IGJ1ZmZlciA9IHBhcmVudC5idWZmZXIuc2xpY2Uob2ZmKSwgYmFzZSA9IHBhcmVudC5idWZmZXJCYXNlICsgb2ZmO1xuICAgICAgICAvLyBNYWtlIHN1cmUgcGFyZW50IHBvaW50cyB0byBhbiBhY3R1YWwgcGFyZW50IHdpdGggY29udGVudCwgaWYgdGhlcmUgaXMgc3VjaCBhIHBhcmVudC5cbiAgICAgICAgd2hpbGUgKHBhcmVudCAmJiBiYXNlID09IHBhcmVudC5idWZmZXJCYXNlKVxuICAgICAgICAgICAgcGFyZW50ID0gcGFyZW50LnBhcmVudDtcbiAgICAgICAgcmV0dXJuIG5ldyBTdGFjayh0aGlzLnAsIHRoaXMuc3RhY2suc2xpY2UoKSwgdGhpcy5zdGF0ZSwgdGhpcy5yZWR1Y2VQb3MsIHRoaXMucG9zLCB0aGlzLnNjb3JlLCBidWZmZXIsIGJhc2UsIHRoaXMuY3VyQ29udGV4dCwgdGhpcy5sb29rQWhlYWQsIHBhcmVudCk7XG4gICAgfVxuICAgIC8vIFRyeSB0byByZWNvdmVyIGZyb20gYW4gZXJyb3IgYnkgJ2RlbGV0aW5nJyAoaWdub3JpbmcpIG9uZSB0b2tlbi5cbiAgICAvLy8gQGludGVybmFsXG4gICAgcmVjb3ZlckJ5RGVsZXRlKG5leHQsIG5leHRFbmQpIHtcbiAgICAgICAgbGV0IGlzTm9kZSA9IG5leHQgPD0gdGhpcy5wLnBhcnNlci5tYXhOb2RlO1xuICAgICAgICBpZiAoaXNOb2RlKVxuICAgICAgICAgICAgdGhpcy5zdG9yZU5vZGUobmV4dCwgdGhpcy5wb3MsIG5leHRFbmQsIDQpO1xuICAgICAgICB0aGlzLnN0b3JlTm9kZSgwIC8qIEVyciAqLywgdGhpcy5wb3MsIG5leHRFbmQsIGlzTm9kZSA/IDggOiA0KTtcbiAgICAgICAgdGhpcy5wb3MgPSB0aGlzLnJlZHVjZVBvcyA9IG5leHRFbmQ7XG4gICAgICAgIHRoaXMuc2NvcmUgLT0gMTkwIC8qIERlbGV0ZSAqLztcbiAgICB9XG4gICAgLy8vIENoZWNrIGlmIHRoZSBnaXZlbiB0ZXJtIHdvdWxkIGJlIGFibGUgdG8gYmUgc2hpZnRlZCAob3B0aW9uYWxseVxuICAgIC8vLyBhZnRlciBzb21lIHJlZHVjdGlvbnMpIG9uIHRoaXMgc3RhY2suIFRoaXMgY2FuIGJlIHVzZWZ1bCBmb3JcbiAgICAvLy8gZXh0ZXJuYWwgdG9rZW5pemVycyB0aGF0IHdhbnQgdG8gbWFrZSBzdXJlIHRoZXkgb25seSBwcm92aWRlIGFcbiAgICAvLy8gZ2l2ZW4gdG9rZW4gd2hlbiBpdCBhcHBsaWVzLlxuICAgIGNhblNoaWZ0KHRlcm0pIHtcbiAgICAgICAgZm9yIChsZXQgc2ltID0gbmV3IFNpbXVsYXRlZFN0YWNrKHRoaXMpOzspIHtcbiAgICAgICAgICAgIGxldCBhY3Rpb24gPSB0aGlzLnAucGFyc2VyLnN0YXRlU2xvdChzaW0uc3RhdGUsIDQgLyogRGVmYXVsdFJlZHVjZSAqLykgfHwgdGhpcy5wLnBhcnNlci5oYXNBY3Rpb24oc2ltLnN0YXRlLCB0ZXJtKTtcbiAgICAgICAgICAgIGlmICgoYWN0aW9uICYgNjU1MzYgLyogUmVkdWNlRmxhZyAqLykgPT0gMClcbiAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgICAgIGlmIChhY3Rpb24gPT0gMClcbiAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICBzaW0ucmVkdWNlKGFjdGlvbik7XG4gICAgICAgIH1cbiAgICB9XG4gICAgLy8gQXBwbHkgdXAgdG8gUmVjb3Zlci5NYXhOZXh0IHJlY292ZXJ5IGFjdGlvbnMgdGhhdCBjb25jZXB0dWFsbHlcbiAgICAvLyBpbnNlcnRzIHNvbWUgbWlzc2luZyB0b2tlbiBvciBydWxlLlxuICAgIC8vLyBAaW50ZXJuYWxcbiAgICByZWNvdmVyQnlJbnNlcnQobmV4dCkge1xuICAgICAgICBpZiAodGhpcy5zdGFjay5sZW5ndGggPj0gMzAwIC8qIE1heEluc2VydFN0YWNrRGVwdGggKi8pXG4gICAgICAgICAgICByZXR1cm4gW107XG4gICAgICAgIGxldCBuZXh0U3RhdGVzID0gdGhpcy5wLnBhcnNlci5uZXh0U3RhdGVzKHRoaXMuc3RhdGUpO1xuICAgICAgICBpZiAobmV4dFN0YXRlcy5sZW5ndGggPiA0IC8qIE1heE5leHQgKi8gPDwgMSB8fCB0aGlzLnN0YWNrLmxlbmd0aCA+PSAxMjAgLyogRGFtcGVuSW5zZXJ0U3RhY2tEZXB0aCAqLykge1xuICAgICAgICAgICAgbGV0IGJlc3QgPSBbXTtcbiAgICAgICAgICAgIGZvciAobGV0IGkgPSAwLCBzOyBpIDwgbmV4dFN0YXRlcy5sZW5ndGg7IGkgKz0gMikge1xuICAgICAgICAgICAgICAgIGlmICgocyA9IG5leHRTdGF0ZXNbaSArIDFdKSAhPSB0aGlzLnN0YXRlICYmIHRoaXMucC5wYXJzZXIuaGFzQWN0aW9uKHMsIG5leHQpKVxuICAgICAgICAgICAgICAgICAgICBiZXN0LnB1c2gobmV4dFN0YXRlc1tpXSwgcyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAodGhpcy5zdGFjay5sZW5ndGggPCAxMjAgLyogRGFtcGVuSW5zZXJ0U3RhY2tEZXB0aCAqLylcbiAgICAgICAgICAgICAgICBmb3IgKGxldCBpID0gMDsgYmVzdC5sZW5ndGggPCA0IC8qIE1heE5leHQgKi8gPDwgMSAmJiBpIDwgbmV4dFN0YXRlcy5sZW5ndGg7IGkgKz0gMikge1xuICAgICAgICAgICAgICAgICAgICBsZXQgcyA9IG5leHRTdGF0ZXNbaSArIDFdO1xuICAgICAgICAgICAgICAgICAgICBpZiAoIWJlc3Quc29tZSgodiwgaSkgPT4gKGkgJiAxKSAmJiB2ID09IHMpKVxuICAgICAgICAgICAgICAgICAgICAgICAgYmVzdC5wdXNoKG5leHRTdGF0ZXNbaV0sIHMpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIG5leHRTdGF0ZXMgPSBiZXN0O1xuICAgICAgICB9XG4gICAgICAgIGxldCByZXN1bHQgPSBbXTtcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBuZXh0U3RhdGVzLmxlbmd0aCAmJiByZXN1bHQubGVuZ3RoIDwgNCAvKiBNYXhOZXh0ICovOyBpICs9IDIpIHtcbiAgICAgICAgICAgIGxldCBzID0gbmV4dFN0YXRlc1tpICsgMV07XG4gICAgICAgICAgICBpZiAocyA9PSB0aGlzLnN0YXRlKVxuICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgbGV0IHN0YWNrID0gdGhpcy5zcGxpdCgpO1xuICAgICAgICAgICAgc3RhY2sucHVzaFN0YXRlKHMsIHRoaXMucG9zKTtcbiAgICAgICAgICAgIHN0YWNrLnN0b3JlTm9kZSgwIC8qIEVyciAqLywgc3RhY2sucG9zLCBzdGFjay5wb3MsIDQsIHRydWUpO1xuICAgICAgICAgICAgc3RhY2suc2hpZnRDb250ZXh0KG5leHRTdGF0ZXNbaV0sIHRoaXMucG9zKTtcbiAgICAgICAgICAgIHN0YWNrLnNjb3JlIC09IDIwMCAvKiBJbnNlcnQgKi87XG4gICAgICAgICAgICByZXN1bHQucHVzaChzdGFjayk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG4gICAgLy8gRm9yY2UgYSByZWR1Y2UsIGlmIHBvc3NpYmxlLiBSZXR1cm4gZmFsc2UgaWYgdGhhdCBjYW4ndFxuICAgIC8vIGJlIGRvbmUuXG4gICAgLy8vIEBpbnRlcm5hbFxuICAgIGZvcmNlUmVkdWNlKCkge1xuICAgICAgICBsZXQgcmVkdWNlID0gdGhpcy5wLnBhcnNlci5zdGF0ZVNsb3QodGhpcy5zdGF0ZSwgNSAvKiBGb3JjZWRSZWR1Y2UgKi8pO1xuICAgICAgICBpZiAoKHJlZHVjZSAmIDY1NTM2IC8qIFJlZHVjZUZsYWcgKi8pID09IDApXG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIGxldCB7IHBhcnNlciB9ID0gdGhpcy5wO1xuICAgICAgICBpZiAoIXBhcnNlci52YWxpZEFjdGlvbih0aGlzLnN0YXRlLCByZWR1Y2UpKSB7XG4gICAgICAgICAgICBsZXQgZGVwdGggPSByZWR1Y2UgPj4gMTkgLyogUmVkdWNlRGVwdGhTaGlmdCAqLywgdGVybSA9IHJlZHVjZSAmIDY1NTM1IC8qIFZhbHVlTWFzayAqLztcbiAgICAgICAgICAgIGxldCB0YXJnZXQgPSB0aGlzLnN0YWNrLmxlbmd0aCAtIGRlcHRoICogMztcbiAgICAgICAgICAgIGlmICh0YXJnZXQgPCAwIHx8IHBhcnNlci5nZXRHb3RvKHRoaXMuc3RhY2tbdGFyZ2V0XSwgdGVybSwgZmFsc2UpIDwgMClcbiAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICB0aGlzLnN0b3JlTm9kZSgwIC8qIEVyciAqLywgdGhpcy5yZWR1Y2VQb3MsIHRoaXMucmVkdWNlUG9zLCA0LCB0cnVlKTtcbiAgICAgICAgICAgIHRoaXMuc2NvcmUgLT0gMTAwIC8qIFJlZHVjZSAqLztcbiAgICAgICAgfVxuICAgICAgICB0aGlzLnJlZHVjZVBvcyA9IHRoaXMucG9zO1xuICAgICAgICB0aGlzLnJlZHVjZShyZWR1Y2UpO1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gICAgLy8vIEBpbnRlcm5hbFxuICAgIGZvcmNlQWxsKCkge1xuICAgICAgICB3aGlsZSAoIXRoaXMucC5wYXJzZXIuc3RhdGVGbGFnKHRoaXMuc3RhdGUsIDIgLyogQWNjZXB0aW5nICovKSkge1xuICAgICAgICAgICAgaWYgKCF0aGlzLmZvcmNlUmVkdWNlKCkpIHtcbiAgICAgICAgICAgICAgICB0aGlzLnN0b3JlTm9kZSgwIC8qIEVyciAqLywgdGhpcy5wb3MsIHRoaXMucG9zLCA0LCB0cnVlKTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9XG4gICAgLy8vIENoZWNrIHdoZXRoZXIgdGhpcyBzdGF0ZSBoYXMgbm8gZnVydGhlciBhY3Rpb25zIChhc3N1bWVkIHRvIGJlIGEgZGlyZWN0IGRlc2NlbmRhbnQgb2YgdGhlXG4gICAgLy8vIHRvcCBzdGF0ZSwgc2luY2UgYW55IG90aGVyIHN0YXRlcyBtdXN0IGJlIGFibGUgdG8gY29udGludWVcbiAgICAvLy8gc29tZWhvdykuIEBpbnRlcm5hbFxuICAgIGdldCBkZWFkRW5kKCkge1xuICAgICAgICBpZiAodGhpcy5zdGFjay5sZW5ndGggIT0gMylcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgbGV0IHsgcGFyc2VyIH0gPSB0aGlzLnA7XG4gICAgICAgIHJldHVybiBwYXJzZXIuZGF0YVtwYXJzZXIuc3RhdGVTbG90KHRoaXMuc3RhdGUsIDEgLyogQWN0aW9ucyAqLyldID09IDY1NTM1IC8qIEVuZCAqLyAmJlxuICAgICAgICAgICAgIXBhcnNlci5zdGF0ZVNsb3QodGhpcy5zdGF0ZSwgNCAvKiBEZWZhdWx0UmVkdWNlICovKTtcbiAgICB9XG4gICAgLy8vIFJlc3RhcnQgdGhlIHN0YWNrIChwdXQgaXQgYmFjayBpbiBpdHMgc3RhcnQgc3RhdGUpLiBPbmx5IHNhZmVcbiAgICAvLy8gd2hlbiB0aGlzLnN0YWNrLmxlbmd0aCA9PSAzIChzdGF0ZSBpcyBkaXJlY3RseSBiZWxvdyB0aGUgdG9wXG4gICAgLy8vIHN0YXRlKS4gQGludGVybmFsXG4gICAgcmVzdGFydCgpIHtcbiAgICAgICAgdGhpcy5zdGF0ZSA9IHRoaXMuc3RhY2tbMF07XG4gICAgICAgIHRoaXMuc3RhY2subGVuZ3RoID0gMDtcbiAgICB9XG4gICAgLy8vIEBpbnRlcm5hbFxuICAgIHNhbWVTdGF0ZShvdGhlcikge1xuICAgICAgICBpZiAodGhpcy5zdGF0ZSAhPSBvdGhlci5zdGF0ZSB8fCB0aGlzLnN0YWNrLmxlbmd0aCAhPSBvdGhlci5zdGFjay5sZW5ndGgpXG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgdGhpcy5zdGFjay5sZW5ndGg7IGkgKz0gMylcbiAgICAgICAgICAgIGlmICh0aGlzLnN0YWNrW2ldICE9IG90aGVyLnN0YWNrW2ldKVxuICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICAgIC8vLyBHZXQgdGhlIHBhcnNlciB1c2VkIGJ5IHRoaXMgc3RhY2suXG4gICAgZ2V0IHBhcnNlcigpIHsgcmV0dXJuIHRoaXMucC5wYXJzZXI7IH1cbiAgICAvLy8gVGVzdCB3aGV0aGVyIGEgZ2l2ZW4gZGlhbGVjdCAoYnkgbnVtZXJpYyBJRCwgYXMgZXhwb3J0ZWQgZnJvbVxuICAgIC8vLyB0aGUgdGVybXMgZmlsZSkgaXMgZW5hYmxlZC5cbiAgICBkaWFsZWN0RW5hYmxlZChkaWFsZWN0SUQpIHsgcmV0dXJuIHRoaXMucC5wYXJzZXIuZGlhbGVjdC5mbGFnc1tkaWFsZWN0SURdOyB9XG4gICAgc2hpZnRDb250ZXh0KHRlcm0sIHN0YXJ0KSB7XG4gICAgICAgIGlmICh0aGlzLmN1ckNvbnRleHQpXG4gICAgICAgICAgICB0aGlzLnVwZGF0ZUNvbnRleHQodGhpcy5jdXJDb250ZXh0LnRyYWNrZXIuc2hpZnQodGhpcy5jdXJDb250ZXh0LmNvbnRleHQsIHRlcm0sIHRoaXMsIHRoaXMucC5zdHJlYW0ucmVzZXQoc3RhcnQpKSk7XG4gICAgfVxuICAgIHJlZHVjZUNvbnRleHQodGVybSwgc3RhcnQpIHtcbiAgICAgICAgaWYgKHRoaXMuY3VyQ29udGV4dClcbiAgICAgICAgICAgIHRoaXMudXBkYXRlQ29udGV4dCh0aGlzLmN1ckNvbnRleHQudHJhY2tlci5yZWR1Y2UodGhpcy5jdXJDb250ZXh0LmNvbnRleHQsIHRlcm0sIHRoaXMsIHRoaXMucC5zdHJlYW0ucmVzZXQoc3RhcnQpKSk7XG4gICAgfVxuICAgIC8vLyBAaW50ZXJuYWxcbiAgICBlbWl0Q29udGV4dCgpIHtcbiAgICAgICAgbGV0IGxhc3QgPSB0aGlzLmJ1ZmZlci5sZW5ndGggLSAxO1xuICAgICAgICBpZiAobGFzdCA8IDAgfHwgdGhpcy5idWZmZXJbbGFzdF0gIT0gLTMpXG4gICAgICAgICAgICB0aGlzLmJ1ZmZlci5wdXNoKHRoaXMuY3VyQ29udGV4dC5oYXNoLCB0aGlzLnJlZHVjZVBvcywgdGhpcy5yZWR1Y2VQb3MsIC0zKTtcbiAgICB9XG4gICAgLy8vIEBpbnRlcm5hbFxuICAgIGVtaXRMb29rQWhlYWQoKSB7XG4gICAgICAgIGxldCBsYXN0ID0gdGhpcy5idWZmZXIubGVuZ3RoIC0gMTtcbiAgICAgICAgaWYgKGxhc3QgPCAwIHx8IHRoaXMuYnVmZmVyW2xhc3RdICE9IC00KVxuICAgICAgICAgICAgdGhpcy5idWZmZXIucHVzaCh0aGlzLmxvb2tBaGVhZCwgdGhpcy5yZWR1Y2VQb3MsIHRoaXMucmVkdWNlUG9zLCAtNCk7XG4gICAgfVxuICAgIHVwZGF0ZUNvbnRleHQoY29udGV4dCkge1xuICAgICAgICBpZiAoY29udGV4dCAhPSB0aGlzLmN1ckNvbnRleHQuY29udGV4dCkge1xuICAgICAgICAgICAgbGV0IG5ld0N4ID0gbmV3IFN0YWNrQ29udGV4dCh0aGlzLmN1ckNvbnRleHQudHJhY2tlciwgY29udGV4dCk7XG4gICAgICAgICAgICBpZiAobmV3Q3guaGFzaCAhPSB0aGlzLmN1ckNvbnRleHQuaGFzaClcbiAgICAgICAgICAgICAgICB0aGlzLmVtaXRDb250ZXh0KCk7XG4gICAgICAgICAgICB0aGlzLmN1ckNvbnRleHQgPSBuZXdDeDtcbiAgICAgICAgfVxuICAgIH1cbiAgICAvLy8gQGludGVybmFsXG4gICAgc2V0TG9va0FoZWFkKGxvb2tBaGVhZCkge1xuICAgICAgICBpZiAobG9va0FoZWFkID4gdGhpcy5sb29rQWhlYWQpIHtcbiAgICAgICAgICAgIHRoaXMuZW1pdExvb2tBaGVhZCgpO1xuICAgICAgICAgICAgdGhpcy5sb29rQWhlYWQgPSBsb29rQWhlYWQ7XG4gICAgICAgIH1cbiAgICB9XG4gICAgLy8vIEBpbnRlcm5hbFxuICAgIGNsb3NlKCkge1xuICAgICAgICBpZiAodGhpcy5jdXJDb250ZXh0ICYmIHRoaXMuY3VyQ29udGV4dC50cmFja2VyLnN0cmljdClcbiAgICAgICAgICAgIHRoaXMuZW1pdENvbnRleHQoKTtcbiAgICAgICAgaWYgKHRoaXMubG9va0FoZWFkID4gMClcbiAgICAgICAgICAgIHRoaXMuZW1pdExvb2tBaGVhZCgpO1xuICAgIH1cbn1cbmNsYXNzIFN0YWNrQ29udGV4dCB7XG4gICAgY29uc3RydWN0b3IodHJhY2tlciwgY29udGV4dCkge1xuICAgICAgICB0aGlzLnRyYWNrZXIgPSB0cmFja2VyO1xuICAgICAgICB0aGlzLmNvbnRleHQgPSBjb250ZXh0O1xuICAgICAgICB0aGlzLmhhc2ggPSB0cmFja2VyLnN0cmljdCA/IHRyYWNrZXIuaGFzaChjb250ZXh0KSA6IDA7XG4gICAgfVxufVxudmFyIFJlY292ZXI7XG4oZnVuY3Rpb24gKFJlY292ZXIpIHtcbiAgICBSZWNvdmVyW1JlY292ZXJbXCJJbnNlcnRcIl0gPSAyMDBdID0gXCJJbnNlcnRcIjtcbiAgICBSZWNvdmVyW1JlY292ZXJbXCJEZWxldGVcIl0gPSAxOTBdID0gXCJEZWxldGVcIjtcbiAgICBSZWNvdmVyW1JlY292ZXJbXCJSZWR1Y2VcIl0gPSAxMDBdID0gXCJSZWR1Y2VcIjtcbiAgICBSZWNvdmVyW1JlY292ZXJbXCJNYXhOZXh0XCJdID0gNF0gPSBcIk1heE5leHRcIjtcbiAgICBSZWNvdmVyW1JlY292ZXJbXCJNYXhJbnNlcnRTdGFja0RlcHRoXCJdID0gMzAwXSA9IFwiTWF4SW5zZXJ0U3RhY2tEZXB0aFwiO1xuICAgIFJlY292ZXJbUmVjb3ZlcltcIkRhbXBlbkluc2VydFN0YWNrRGVwdGhcIl0gPSAxMjBdID0gXCJEYW1wZW5JbnNlcnRTdGFja0RlcHRoXCI7XG59KShSZWNvdmVyIHx8IChSZWNvdmVyID0ge30pKTtcbi8vIFVzZWQgdG8gY2hlYXBseSBydW4gc29tZSByZWR1Y3Rpb25zIHRvIHNjYW4gYWhlYWQgd2l0aG91dCBtdXRhdGluZ1xuLy8gYW4gZW50aXJlIHN0YWNrXG5jbGFzcyBTaW11bGF0ZWRTdGFjayB7XG4gICAgY29uc3RydWN0b3Ioc3RhcnQpIHtcbiAgICAgICAgdGhpcy5zdGFydCA9IHN0YXJ0O1xuICAgICAgICB0aGlzLnN0YXRlID0gc3RhcnQuc3RhdGU7XG4gICAgICAgIHRoaXMuc3RhY2sgPSBzdGFydC5zdGFjaztcbiAgICAgICAgdGhpcy5iYXNlID0gdGhpcy5zdGFjay5sZW5ndGg7XG4gICAgfVxuICAgIHJlZHVjZShhY3Rpb24pIHtcbiAgICAgICAgbGV0IHRlcm0gPSBhY3Rpb24gJiA2NTUzNSAvKiBWYWx1ZU1hc2sgKi8sIGRlcHRoID0gYWN0aW9uID4+IDE5IC8qIFJlZHVjZURlcHRoU2hpZnQgKi87XG4gICAgICAgIGlmIChkZXB0aCA9PSAwKSB7XG4gICAgICAgICAgICBpZiAodGhpcy5zdGFjayA9PSB0aGlzLnN0YXJ0LnN0YWNrKVxuICAgICAgICAgICAgICAgIHRoaXMuc3RhY2sgPSB0aGlzLnN0YWNrLnNsaWNlKCk7XG4gICAgICAgICAgICB0aGlzLnN0YWNrLnB1c2godGhpcy5zdGF0ZSwgMCwgMCk7XG4gICAgICAgICAgICB0aGlzLmJhc2UgKz0gMztcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMuYmFzZSAtPSAoZGVwdGggLSAxKSAqIDM7XG4gICAgICAgIH1cbiAgICAgICAgbGV0IGdvdG8gPSB0aGlzLnN0YXJ0LnAucGFyc2VyLmdldEdvdG8odGhpcy5zdGFja1t0aGlzLmJhc2UgLSAzXSwgdGVybSwgdHJ1ZSk7XG4gICAgICAgIHRoaXMuc3RhdGUgPSBnb3RvO1xuICAgIH1cbn1cbi8vIFRoaXMgaXMgZ2l2ZW4gdG8gYFRyZWUuYnVpbGRgIHRvIGJ1aWxkIGEgYnVmZmVyLCBhbmQgZW5jYXBzdWxhdGVzXG4vLyB0aGUgcGFyZW50LXN0YWNrLXdhbGtpbmcgbmVjZXNzYXJ5IHRvIHJlYWQgdGhlIG5vZGVzLlxuY2xhc3MgU3RhY2tCdWZmZXJDdXJzb3Ige1xuICAgIGNvbnN0cnVjdG9yKHN0YWNrLCBwb3MsIGluZGV4KSB7XG4gICAgICAgIHRoaXMuc3RhY2sgPSBzdGFjaztcbiAgICAgICAgdGhpcy5wb3MgPSBwb3M7XG4gICAgICAgIHRoaXMuaW5kZXggPSBpbmRleDtcbiAgICAgICAgdGhpcy5idWZmZXIgPSBzdGFjay5idWZmZXI7XG4gICAgICAgIGlmICh0aGlzLmluZGV4ID09IDApXG4gICAgICAgICAgICB0aGlzLm1heWJlTmV4dCgpO1xuICAgIH1cbiAgICBzdGF0aWMgY3JlYXRlKHN0YWNrLCBwb3MgPSBzdGFjay5idWZmZXJCYXNlICsgc3RhY2suYnVmZmVyLmxlbmd0aCkge1xuICAgICAgICByZXR1cm4gbmV3IFN0YWNrQnVmZmVyQ3Vyc29yKHN0YWNrLCBwb3MsIHBvcyAtIHN0YWNrLmJ1ZmZlckJhc2UpO1xuICAgIH1cbiAgICBtYXliZU5leHQoKSB7XG4gICAgICAgIGxldCBuZXh0ID0gdGhpcy5zdGFjay5wYXJlbnQ7XG4gICAgICAgIGlmIChuZXh0ICE9IG51bGwpIHtcbiAgICAgICAgICAgIHRoaXMuaW5kZXggPSB0aGlzLnN0YWNrLmJ1ZmZlckJhc2UgLSBuZXh0LmJ1ZmZlckJhc2U7XG4gICAgICAgICAgICB0aGlzLnN0YWNrID0gbmV4dDtcbiAgICAgICAgICAgIHRoaXMuYnVmZmVyID0gbmV4dC5idWZmZXI7XG4gICAgICAgIH1cbiAgICB9XG4gICAgZ2V0IGlkKCkgeyByZXR1cm4gdGhpcy5idWZmZXJbdGhpcy5pbmRleCAtIDRdOyB9XG4gICAgZ2V0IHN0YXJ0KCkgeyByZXR1cm4gdGhpcy5idWZmZXJbdGhpcy5pbmRleCAtIDNdOyB9XG4gICAgZ2V0IGVuZCgpIHsgcmV0dXJuIHRoaXMuYnVmZmVyW3RoaXMuaW5kZXggLSAyXTsgfVxuICAgIGdldCBzaXplKCkgeyByZXR1cm4gdGhpcy5idWZmZXJbdGhpcy5pbmRleCAtIDFdOyB9XG4gICAgbmV4dCgpIHtcbiAgICAgICAgdGhpcy5pbmRleCAtPSA0O1xuICAgICAgICB0aGlzLnBvcyAtPSA0O1xuICAgICAgICBpZiAodGhpcy5pbmRleCA9PSAwKVxuICAgICAgICAgICAgdGhpcy5tYXliZU5leHQoKTtcbiAgICB9XG4gICAgZm9yaygpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBTdGFja0J1ZmZlckN1cnNvcih0aGlzLnN0YWNrLCB0aGlzLnBvcywgdGhpcy5pbmRleCk7XG4gICAgfVxufVxuXG5jbGFzcyBDYWNoZWRUb2tlbiB7XG4gICAgY29uc3RydWN0b3IoKSB7XG4gICAgICAgIHRoaXMuc3RhcnQgPSAtMTtcbiAgICAgICAgdGhpcy52YWx1ZSA9IC0xO1xuICAgICAgICB0aGlzLmVuZCA9IC0xO1xuICAgICAgICB0aGlzLmV4dGVuZGVkID0gLTE7XG4gICAgICAgIHRoaXMubG9va0FoZWFkID0gMDtcbiAgICAgICAgdGhpcy5tYXNrID0gMDtcbiAgICAgICAgdGhpcy5jb250ZXh0ID0gMDtcbiAgICB9XG59XG5jb25zdCBudWxsVG9rZW4gPSBuZXcgQ2FjaGVkVG9rZW47XG4vLy8gW1Rva2VuaXplcnNdKCNsci5FeHRlcm5hbFRva2VuaXplcikgaW50ZXJhY3Qgd2l0aCB0aGUgaW5wdXRcbi8vLyB0aHJvdWdoIHRoaXMgaW50ZXJmYWNlLiBJdCBwcmVzZW50cyB0aGUgaW5wdXQgYXMgYSBzdHJlYW0gb2Zcbi8vLyBjaGFyYWN0ZXJzLCB0cmFja2luZyBsb29rYWhlYWQgYW5kIGhpZGluZyB0aGUgY29tcGxleGl0eSBvZlxuLy8vIFtyYW5nZXNdKCNjb21tb24uUGFyc2VyLnBhcnNlXnJhbmdlcykgZnJvbSB0b2tlbml6ZXIgY29kZS5cbmNsYXNzIElucHV0U3RyZWFtIHtcbiAgICAvLy8gQGludGVybmFsXG4gICAgY29uc3RydWN0b3IoXG4gICAgLy8vIEBpbnRlcm5hbFxuICAgIGlucHV0LCBcbiAgICAvLy8gQGludGVybmFsXG4gICAgcmFuZ2VzKSB7XG4gICAgICAgIHRoaXMuaW5wdXQgPSBpbnB1dDtcbiAgICAgICAgdGhpcy5yYW5nZXMgPSByYW5nZXM7XG4gICAgICAgIC8vLyBAaW50ZXJuYWxcbiAgICAgICAgdGhpcy5jaHVuayA9IFwiXCI7XG4gICAgICAgIC8vLyBAaW50ZXJuYWxcbiAgICAgICAgdGhpcy5jaHVua09mZiA9IDA7XG4gICAgICAgIC8vLyBCYWNrdXAgY2h1bmtcbiAgICAgICAgdGhpcy5jaHVuazIgPSBcIlwiO1xuICAgICAgICB0aGlzLmNodW5rMlBvcyA9IDA7XG4gICAgICAgIC8vLyBUaGUgY2hhcmFjdGVyIGNvZGUgb2YgdGhlIG5leHQgY29kZSB1bml0IGluIHRoZSBpbnB1dCwgb3IgLTFcbiAgICAgICAgLy8vIHdoZW4gdGhlIHN0cmVhbSBpcyBhdCB0aGUgZW5kIG9mIHRoZSBpbnB1dC5cbiAgICAgICAgdGhpcy5uZXh0ID0gLTE7XG4gICAgICAgIC8vLyBAaW50ZXJuYWxcbiAgICAgICAgdGhpcy50b2tlbiA9IG51bGxUb2tlbjtcbiAgICAgICAgdGhpcy5yYW5nZUluZGV4ID0gMDtcbiAgICAgICAgdGhpcy5wb3MgPSB0aGlzLmNodW5rUG9zID0gcmFuZ2VzWzBdLmZyb207XG4gICAgICAgIHRoaXMucmFuZ2UgPSByYW5nZXNbMF07XG4gICAgICAgIHRoaXMuZW5kID0gcmFuZ2VzW3Jhbmdlcy5sZW5ndGggLSAxXS50bztcbiAgICAgICAgdGhpcy5yZWFkTmV4dCgpO1xuICAgIH1cbiAgICByZXNvbHZlT2Zmc2V0KG9mZnNldCwgYXNzb2MpIHtcbiAgICAgICAgbGV0IHJhbmdlID0gdGhpcy5yYW5nZSwgaW5kZXggPSB0aGlzLnJhbmdlSW5kZXg7XG4gICAgICAgIGxldCBwb3MgPSB0aGlzLnBvcyArIG9mZnNldDtcbiAgICAgICAgd2hpbGUgKHBvcyA8IHJhbmdlLmZyb20pIHtcbiAgICAgICAgICAgIGlmICghaW5kZXgpXG4gICAgICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgICAgICBsZXQgbmV4dCA9IHRoaXMucmFuZ2VzWy0taW5kZXhdO1xuICAgICAgICAgICAgcG9zIC09IHJhbmdlLmZyb20gLSBuZXh0LnRvO1xuICAgICAgICAgICAgcmFuZ2UgPSBuZXh0O1xuICAgICAgICB9XG4gICAgICAgIHdoaWxlIChhc3NvYyA8IDAgPyBwb3MgPiByYW5nZS50byA6IHBvcyA+PSByYW5nZS50bykge1xuICAgICAgICAgICAgaWYgKGluZGV4ID09IHRoaXMucmFuZ2VzLmxlbmd0aCAtIDEpXG4gICAgICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgICAgICBsZXQgbmV4dCA9IHRoaXMucmFuZ2VzWysraW5kZXhdO1xuICAgICAgICAgICAgcG9zICs9IG5leHQuZnJvbSAtIHJhbmdlLnRvO1xuICAgICAgICAgICAgcmFuZ2UgPSBuZXh0O1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBwb3M7XG4gICAgfVxuICAgIC8vLyBMb29rIGF0IGEgY29kZSB1bml0IG5lYXIgdGhlIHN0cmVhbSBwb3NpdGlvbi4gYC5wZWVrKDApYCBlcXVhbHNcbiAgICAvLy8gYC5uZXh0YCwgYC5wZWVrKC0xKWAgZ2l2ZXMgeW91IHRoZSBwcmV2aW91cyBjaGFyYWN0ZXIsIGFuZCBzb1xuICAgIC8vLyBvbi5cbiAgICAvLy9cbiAgICAvLy8gTm90ZSB0aGF0IGxvb2tpbmcgYXJvdW5kIGR1cmluZyB0b2tlbml6aW5nIGNyZWF0ZXMgZGVwZW5kZW5jaWVzXG4gICAgLy8vIG9uIHBvdGVudGlhbGx5IGZhci1hd2F5IGNvbnRlbnQsIHdoaWNoIG1heSByZWR1Y2UgdGhlXG4gICAgLy8vIGVmZmVjdGl2ZW5lc3MgaW5jcmVtZW50YWwgcGFyc2luZ+KAlHdoZW4gbG9va2luZyBmb3J3YXJk4oCUb3IgZXZlblxuICAgIC8vLyBjYXVzZSBpbnZhbGlkIHJlcGFyc2VzIHdoZW4gbG9va2luZyBiYWNrd2FyZCBtb3JlIHRoYW4gMjUgY29kZVxuICAgIC8vLyB1bml0cywgc2luY2UgdGhlIGxpYnJhcnkgZG9lcyBub3QgdHJhY2sgbG9va2JlaGluZC5cbiAgICBwZWVrKG9mZnNldCkge1xuICAgICAgICBsZXQgaWR4ID0gdGhpcy5jaHVua09mZiArIG9mZnNldCwgcG9zLCByZXN1bHQ7XG4gICAgICAgIGlmIChpZHggPj0gMCAmJiBpZHggPCB0aGlzLmNodW5rLmxlbmd0aCkge1xuICAgICAgICAgICAgcG9zID0gdGhpcy5wb3MgKyBvZmZzZXQ7XG4gICAgICAgICAgICByZXN1bHQgPSB0aGlzLmNodW5rLmNoYXJDb2RlQXQoaWR4KTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGxldCByZXNvbHZlZCA9IHRoaXMucmVzb2x2ZU9mZnNldChvZmZzZXQsIDEpO1xuICAgICAgICAgICAgaWYgKHJlc29sdmVkID09IG51bGwpXG4gICAgICAgICAgICAgICAgcmV0dXJuIC0xO1xuICAgICAgICAgICAgcG9zID0gcmVzb2x2ZWQ7XG4gICAgICAgICAgICBpZiAocG9zID49IHRoaXMuY2h1bmsyUG9zICYmIHBvcyA8IHRoaXMuY2h1bmsyUG9zICsgdGhpcy5jaHVuazIubGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgcmVzdWx0ID0gdGhpcy5jaHVuazIuY2hhckNvZGVBdChwb3MgLSB0aGlzLmNodW5rMlBvcyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBsZXQgaSA9IHRoaXMucmFuZ2VJbmRleCwgcmFuZ2UgPSB0aGlzLnJhbmdlO1xuICAgICAgICAgICAgICAgIHdoaWxlIChyYW5nZS50byA8PSBwb3MpXG4gICAgICAgICAgICAgICAgICAgIHJhbmdlID0gdGhpcy5yYW5nZXNbKytpXTtcbiAgICAgICAgICAgICAgICB0aGlzLmNodW5rMiA9IHRoaXMuaW5wdXQuY2h1bmsodGhpcy5jaHVuazJQb3MgPSBwb3MpO1xuICAgICAgICAgICAgICAgIGlmIChwb3MgKyB0aGlzLmNodW5rMi5sZW5ndGggPiByYW5nZS50bylcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5jaHVuazIgPSB0aGlzLmNodW5rMi5zbGljZSgwLCByYW5nZS50byAtIHBvcyk7XG4gICAgICAgICAgICAgICAgcmVzdWx0ID0gdGhpcy5jaHVuazIuY2hhckNvZGVBdCgwKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBpZiAocG9zID49IHRoaXMudG9rZW4ubG9va0FoZWFkKVxuICAgICAgICAgICAgdGhpcy50b2tlbi5sb29rQWhlYWQgPSBwb3MgKyAxO1xuICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH1cbiAgICAvLy8gQWNjZXB0IGEgdG9rZW4uIEJ5IGRlZmF1bHQsIHRoZSBlbmQgb2YgdGhlIHRva2VuIGlzIHNldCB0byB0aGVcbiAgICAvLy8gY3VycmVudCBzdHJlYW0gcG9zaXRpb24sIGJ1dCB5b3UgY2FuIHBhc3MgYW4gb2Zmc2V0IChyZWxhdGl2ZSB0b1xuICAgIC8vLyB0aGUgc3RyZWFtIHBvc2l0aW9uKSB0byBjaGFuZ2UgdGhhdC5cbiAgICBhY2NlcHRUb2tlbih0b2tlbiwgZW5kT2Zmc2V0ID0gMCkge1xuICAgICAgICBsZXQgZW5kID0gZW5kT2Zmc2V0ID8gdGhpcy5yZXNvbHZlT2Zmc2V0KGVuZE9mZnNldCwgLTEpIDogdGhpcy5wb3M7XG4gICAgICAgIGlmIChlbmQgPT0gbnVsbCB8fCBlbmQgPCB0aGlzLnRva2VuLnN0YXJ0KVxuICAgICAgICAgICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoXCJUb2tlbiBlbmQgb3V0IG9mIGJvdW5kc1wiKTtcbiAgICAgICAgdGhpcy50b2tlbi52YWx1ZSA9IHRva2VuO1xuICAgICAgICB0aGlzLnRva2VuLmVuZCA9IGVuZDtcbiAgICB9XG4gICAgZ2V0Q2h1bmsoKSB7XG4gICAgICAgIGlmICh0aGlzLnBvcyA+PSB0aGlzLmNodW5rMlBvcyAmJiB0aGlzLnBvcyA8IHRoaXMuY2h1bmsyUG9zICsgdGhpcy5jaHVuazIubGVuZ3RoKSB7XG4gICAgICAgICAgICBsZXQgeyBjaHVuaywgY2h1bmtQb3MgfSA9IHRoaXM7XG4gICAgICAgICAgICB0aGlzLmNodW5rID0gdGhpcy5jaHVuazI7XG4gICAgICAgICAgICB0aGlzLmNodW5rUG9zID0gdGhpcy5jaHVuazJQb3M7XG4gICAgICAgICAgICB0aGlzLmNodW5rMiA9IGNodW5rO1xuICAgICAgICAgICAgdGhpcy5jaHVuazJQb3MgPSBjaHVua1BvcztcbiAgICAgICAgICAgIHRoaXMuY2h1bmtPZmYgPSB0aGlzLnBvcyAtIHRoaXMuY2h1bmtQb3M7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB0aGlzLmNodW5rMiA9IHRoaXMuY2h1bms7XG4gICAgICAgICAgICB0aGlzLmNodW5rMlBvcyA9IHRoaXMuY2h1bmtQb3M7XG4gICAgICAgICAgICBsZXQgbmV4dENodW5rID0gdGhpcy5pbnB1dC5jaHVuayh0aGlzLnBvcyk7XG4gICAgICAgICAgICBsZXQgZW5kID0gdGhpcy5wb3MgKyBuZXh0Q2h1bmsubGVuZ3RoO1xuICAgICAgICAgICAgdGhpcy5jaHVuayA9IGVuZCA+IHRoaXMucmFuZ2UudG8gPyBuZXh0Q2h1bmsuc2xpY2UoMCwgdGhpcy5yYW5nZS50byAtIHRoaXMucG9zKSA6IG5leHRDaHVuaztcbiAgICAgICAgICAgIHRoaXMuY2h1bmtQb3MgPSB0aGlzLnBvcztcbiAgICAgICAgICAgIHRoaXMuY2h1bmtPZmYgPSAwO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJlYWROZXh0KCkge1xuICAgICAgICBpZiAodGhpcy5jaHVua09mZiA+PSB0aGlzLmNodW5rLmxlbmd0aCkge1xuICAgICAgICAgICAgdGhpcy5nZXRDaHVuaygpO1xuICAgICAgICAgICAgaWYgKHRoaXMuY2h1bmtPZmYgPT0gdGhpcy5jaHVuay5sZW5ndGgpXG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMubmV4dCA9IC0xO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aGlzLm5leHQgPSB0aGlzLmNodW5rLmNoYXJDb2RlQXQodGhpcy5jaHVua09mZik7XG4gICAgfVxuICAgIC8vLyBNb3ZlIHRoZSBzdHJlYW0gZm9yd2FyZCBOIChkZWZhdWx0cyB0byAxKSBjb2RlIHVuaXRzLiBSZXR1cm5zXG4gICAgLy8vIHRoZSBuZXcgdmFsdWUgb2YgW2BuZXh0YF0oI2xyLklucHV0U3RyZWFtLm5leHQpLlxuICAgIGFkdmFuY2UobiA9IDEpIHtcbiAgICAgICAgdGhpcy5jaHVua09mZiArPSBuO1xuICAgICAgICB3aGlsZSAodGhpcy5wb3MgKyBuID49IHRoaXMucmFuZ2UudG8pIHtcbiAgICAgICAgICAgIGlmICh0aGlzLnJhbmdlSW5kZXggPT0gdGhpcy5yYW5nZXMubGVuZ3RoIC0gMSlcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5zZXREb25lKCk7XG4gICAgICAgICAgICBuIC09IHRoaXMucmFuZ2UudG8gLSB0aGlzLnBvcztcbiAgICAgICAgICAgIHRoaXMucmFuZ2UgPSB0aGlzLnJhbmdlc1srK3RoaXMucmFuZ2VJbmRleF07XG4gICAgICAgICAgICB0aGlzLnBvcyA9IHRoaXMucmFuZ2UuZnJvbTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLnBvcyArPSBuO1xuICAgICAgICBpZiAodGhpcy5wb3MgPj0gdGhpcy50b2tlbi5sb29rQWhlYWQpXG4gICAgICAgICAgICB0aGlzLnRva2VuLmxvb2tBaGVhZCA9IHRoaXMucG9zICsgMTtcbiAgICAgICAgcmV0dXJuIHRoaXMucmVhZE5leHQoKTtcbiAgICB9XG4gICAgc2V0RG9uZSgpIHtcbiAgICAgICAgdGhpcy5wb3MgPSB0aGlzLmNodW5rUG9zID0gdGhpcy5lbmQ7XG4gICAgICAgIHRoaXMucmFuZ2UgPSB0aGlzLnJhbmdlc1t0aGlzLnJhbmdlSW5kZXggPSB0aGlzLnJhbmdlcy5sZW5ndGggLSAxXTtcbiAgICAgICAgdGhpcy5jaHVuayA9IFwiXCI7XG4gICAgICAgIHJldHVybiB0aGlzLm5leHQgPSAtMTtcbiAgICB9XG4gICAgLy8vIEBpbnRlcm5hbFxuICAgIHJlc2V0KHBvcywgdG9rZW4pIHtcbiAgICAgICAgaWYgKHRva2VuKSB7XG4gICAgICAgICAgICB0aGlzLnRva2VuID0gdG9rZW47XG4gICAgICAgICAgICB0b2tlbi5zdGFydCA9IHBvcztcbiAgICAgICAgICAgIHRva2VuLmxvb2tBaGVhZCA9IHBvcyArIDE7XG4gICAgICAgICAgICB0b2tlbi52YWx1ZSA9IHRva2VuLmV4dGVuZGVkID0gLTE7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB0aGlzLnRva2VuID0gbnVsbFRva2VuO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0aGlzLnBvcyAhPSBwb3MpIHtcbiAgICAgICAgICAgIHRoaXMucG9zID0gcG9zO1xuICAgICAgICAgICAgaWYgKHBvcyA9PSB0aGlzLmVuZCkge1xuICAgICAgICAgICAgICAgIHRoaXMuc2V0RG9uZSgpO1xuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgd2hpbGUgKHBvcyA8IHRoaXMucmFuZ2UuZnJvbSlcbiAgICAgICAgICAgICAgICB0aGlzLnJhbmdlID0gdGhpcy5yYW5nZXNbLS10aGlzLnJhbmdlSW5kZXhdO1xuICAgICAgICAgICAgd2hpbGUgKHBvcyA+PSB0aGlzLnJhbmdlLnRvKVxuICAgICAgICAgICAgICAgIHRoaXMucmFuZ2UgPSB0aGlzLnJhbmdlc1srK3RoaXMucmFuZ2VJbmRleF07XG4gICAgICAgICAgICBpZiAocG9zID49IHRoaXMuY2h1bmtQb3MgJiYgcG9zIDwgdGhpcy5jaHVua1BvcyArIHRoaXMuY2h1bmsubGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5jaHVua09mZiA9IHBvcyAtIHRoaXMuY2h1bmtQb3M7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICB0aGlzLmNodW5rID0gXCJcIjtcbiAgICAgICAgICAgICAgICB0aGlzLmNodW5rT2ZmID0gMDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRoaXMucmVhZE5leHQoKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9XG4gICAgLy8vIEBpbnRlcm5hbFxuICAgIHJlYWQoZnJvbSwgdG8pIHtcbiAgICAgICAgaWYgKGZyb20gPj0gdGhpcy5jaHVua1BvcyAmJiB0byA8PSB0aGlzLmNodW5rUG9zICsgdGhpcy5jaHVuay5sZW5ndGgpXG4gICAgICAgICAgICByZXR1cm4gdGhpcy5jaHVuay5zbGljZShmcm9tIC0gdGhpcy5jaHVua1BvcywgdG8gLSB0aGlzLmNodW5rUG9zKTtcbiAgICAgICAgaWYgKGZyb20gPj0gdGhpcy5jaHVuazJQb3MgJiYgdG8gPD0gdGhpcy5jaHVuazJQb3MgKyB0aGlzLmNodW5rMi5sZW5ndGgpXG4gICAgICAgICAgICByZXR1cm4gdGhpcy5jaHVuazIuc2xpY2UoZnJvbSAtIHRoaXMuY2h1bmsyUG9zLCB0byAtIHRoaXMuY2h1bmsyUG9zKTtcbiAgICAgICAgaWYgKGZyb20gPj0gdGhpcy5yYW5nZS5mcm9tICYmIHRvIDw9IHRoaXMucmFuZ2UudG8pXG4gICAgICAgICAgICByZXR1cm4gdGhpcy5pbnB1dC5yZWFkKGZyb20sIHRvKTtcbiAgICAgICAgbGV0IHJlc3VsdCA9IFwiXCI7XG4gICAgICAgIGZvciAobGV0IHIgb2YgdGhpcy5yYW5nZXMpIHtcbiAgICAgICAgICAgIGlmIChyLmZyb20gPj0gdG8pXG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBpZiAoci50byA+IGZyb20pXG4gICAgICAgICAgICAgICAgcmVzdWx0ICs9IHRoaXMuaW5wdXQucmVhZChNYXRoLm1heChyLmZyb20sIGZyb20pLCBNYXRoLm1pbihyLnRvLCB0bykpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxufVxuLy8vIEBpbnRlcm5hbFxuY2xhc3MgVG9rZW5Hcm91cCB7XG4gICAgY29uc3RydWN0b3IoZGF0YSwgaWQpIHtcbiAgICAgICAgdGhpcy5kYXRhID0gZGF0YTtcbiAgICAgICAgdGhpcy5pZCA9IGlkO1xuICAgIH1cbiAgICB0b2tlbihpbnB1dCwgc3RhY2spIHsgcmVhZFRva2VuKHRoaXMuZGF0YSwgaW5wdXQsIHN0YWNrLCB0aGlzLmlkKTsgfVxufVxuVG9rZW5Hcm91cC5wcm90b3R5cGUuY29udGV4dHVhbCA9IFRva2VuR3JvdXAucHJvdG90eXBlLmZhbGxiYWNrID0gVG9rZW5Hcm91cC5wcm90b3R5cGUuZXh0ZW5kID0gZmFsc2U7XG4vLy8gYEBleHRlcm5hbCB0b2tlbnNgIGRlY2xhcmF0aW9ucyBpbiB0aGUgZ3JhbW1hciBzaG91bGQgcmVzb2x2ZSB0b1xuLy8vIGFuIGluc3RhbmNlIG9mIHRoaXMgY2xhc3MuXG5jbGFzcyBFeHRlcm5hbFRva2VuaXplciB7XG4gICAgLy8vIENyZWF0ZSBhIHRva2VuaXplci4gVGhlIGZpcnN0IGFyZ3VtZW50IGlzIHRoZSBmdW5jdGlvbiB0aGF0LFxuICAgIC8vLyBnaXZlbiBhbiBpbnB1dCBzdHJlYW0sIHNjYW5zIGZvciB0aGUgdHlwZXMgb2YgdG9rZW5zIGl0XG4gICAgLy8vIHJlY29nbml6ZXMgYXQgdGhlIHN0cmVhbSdzIHBvc2l0aW9uLCBhbmQgY2FsbHNcbiAgICAvLy8gW2BhY2NlcHRUb2tlbmBdKCNsci5JbnB1dFN0cmVhbS5hY2NlcHRUb2tlbikgd2hlbiBpdCBmaW5kc1xuICAgIC8vLyBvbmUuXG4gICAgY29uc3RydWN0b3IoXG4gICAgLy8vIEBpbnRlcm5hbFxuICAgIHRva2VuLCBvcHRpb25zID0ge30pIHtcbiAgICAgICAgdGhpcy50b2tlbiA9IHRva2VuO1xuICAgICAgICB0aGlzLmNvbnRleHR1YWwgPSAhIW9wdGlvbnMuY29udGV4dHVhbDtcbiAgICAgICAgdGhpcy5mYWxsYmFjayA9ICEhb3B0aW9ucy5mYWxsYmFjaztcbiAgICAgICAgdGhpcy5leHRlbmQgPSAhIW9wdGlvbnMuZXh0ZW5kO1xuICAgIH1cbn1cbi8vIFRva2VuaXplciBkYXRhIGlzIHN0b3JlZCBhIGJpZyB1aW50MTYgYXJyYXkgY29udGFpbmluZywgZm9yIGVhY2hcbi8vIHN0YXRlOlxuLy9cbi8vICAtIEEgZ3JvdXAgYml0bWFzaywgaW5kaWNhdGluZyB3aGF0IHRva2VuIGdyb3VwcyBhcmUgcmVhY2hhYmxlIGZyb21cbi8vICAgIHRoaXMgc3RhdGUsIHNvIHRoYXQgcGF0aHMgdGhhdCBjYW4gb25seSBsZWFkIHRvIHRva2VucyBub3QgaW5cbi8vICAgIGFueSBvZiB0aGUgY3VycmVudCBncm91cHMgY2FuIGJlIGN1dCBvZmYgZWFybHkuXG4vL1xuLy8gIC0gVGhlIHBvc2l0aW9uIG9mIHRoZSBlbmQgb2YgdGhlIHN0YXRlJ3Mgc2VxdWVuY2Ugb2YgYWNjZXB0aW5nXG4vLyAgICB0b2tlbnNcbi8vXG4vLyAgLSBUaGUgbnVtYmVyIG9mIG91dGdvaW5nIGVkZ2VzIGZvciB0aGUgc3RhdGVcbi8vXG4vLyAgLSBUaGUgYWNjZXB0aW5nIHRva2VucywgYXMgKHRva2VuIGlkLCBncm91cCBtYXNrKSBwYWlyc1xuLy9cbi8vICAtIFRoZSBvdXRnb2luZyBlZGdlcywgYXMgKHN0YXJ0IGNoYXJhY3RlciwgZW5kIGNoYXJhY3Rlciwgc3RhdGVcbi8vICAgIGluZGV4KSB0cmlwbGVzLCB3aXRoIGVuZCBjaGFyYWN0ZXIgYmVpbmcgZXhjbHVzaXZlXG4vL1xuLy8gVGhpcyBmdW5jdGlvbiBpbnRlcnByZXRzIHRoYXQgZGF0YSwgcnVubmluZyB0aHJvdWdoIGEgc3RyZWFtIGFzXG4vLyBsb25nIGFzIG5ldyBzdGF0ZXMgd2l0aCB0aGUgYSBtYXRjaGluZyBncm91cCBtYXNrIGNhbiBiZSByZWFjaGVkLFxuLy8gYW5kIHVwZGF0aW5nIGB0b2tlbmAgd2hlbiBpdCBtYXRjaGVzIGEgdG9rZW4uXG5mdW5jdGlvbiByZWFkVG9rZW4oZGF0YSwgaW5wdXQsIHN0YWNrLCBncm91cCkge1xuICAgIGxldCBzdGF0ZSA9IDAsIGdyb3VwTWFzayA9IDEgPDwgZ3JvdXAsIHsgcGFyc2VyIH0gPSBzdGFjay5wLCB7IGRpYWxlY3QgfSA9IHBhcnNlcjtcbiAgICBzY2FuOiBmb3IgKDs7KSB7XG4gICAgICAgIGlmICgoZ3JvdXBNYXNrICYgZGF0YVtzdGF0ZV0pID09IDApXG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgbGV0IGFjY0VuZCA9IGRhdGFbc3RhdGUgKyAxXTtcbiAgICAgICAgLy8gQ2hlY2sgd2hldGhlciB0aGlzIHN0YXRlIGNhbiBsZWFkIHRvIGEgdG9rZW4gaW4gdGhlIGN1cnJlbnQgZ3JvdXBcbiAgICAgICAgLy8gQWNjZXB0IHRva2VucyBpbiB0aGlzIHN0YXRlLCBwb3NzaWJseSBvdmVyd3JpdGluZ1xuICAgICAgICAvLyBsb3dlci1wcmVjZWRlbmNlIC8gc2hvcnRlciB0b2tlbnNcbiAgICAgICAgZm9yIChsZXQgaSA9IHN0YXRlICsgMzsgaSA8IGFjY0VuZDsgaSArPSAyKVxuICAgICAgICAgICAgaWYgKChkYXRhW2kgKyAxXSAmIGdyb3VwTWFzaykgPiAwKSB7XG4gICAgICAgICAgICAgICAgbGV0IHRlcm0gPSBkYXRhW2ldO1xuICAgICAgICAgICAgICAgIGlmIChkaWFsZWN0LmFsbG93cyh0ZXJtKSAmJlxuICAgICAgICAgICAgICAgICAgICAoaW5wdXQudG9rZW4udmFsdWUgPT0gLTEgfHwgaW5wdXQudG9rZW4udmFsdWUgPT0gdGVybSB8fCBwYXJzZXIub3ZlcnJpZGVzKHRlcm0sIGlucHV0LnRva2VuLnZhbHVlKSkpIHtcbiAgICAgICAgICAgICAgICAgICAgaW5wdXQuYWNjZXB0VG9rZW4odGVybSk7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgLy8gRG8gYSBiaW5hcnkgc2VhcmNoIG9uIHRoZSBzdGF0ZSdzIGVkZ2VzXG4gICAgICAgIGZvciAobGV0IG5leHQgPSBpbnB1dC5uZXh0LCBsb3cgPSAwLCBoaWdoID0gZGF0YVtzdGF0ZSArIDJdOyBsb3cgPCBoaWdoOykge1xuICAgICAgICAgICAgbGV0IG1pZCA9IChsb3cgKyBoaWdoKSA+PiAxO1xuICAgICAgICAgICAgbGV0IGluZGV4ID0gYWNjRW5kICsgbWlkICsgKG1pZCA8PCAxKTtcbiAgICAgICAgICAgIGxldCBmcm9tID0gZGF0YVtpbmRleF0sIHRvID0gZGF0YVtpbmRleCArIDFdO1xuICAgICAgICAgICAgaWYgKG5leHQgPCBmcm9tKVxuICAgICAgICAgICAgICAgIGhpZ2ggPSBtaWQ7XG4gICAgICAgICAgICBlbHNlIGlmIChuZXh0ID49IHRvKVxuICAgICAgICAgICAgICAgIGxvdyA9IG1pZCArIDE7XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBzdGF0ZSA9IGRhdGFbaW5kZXggKyAyXTtcbiAgICAgICAgICAgICAgICBpbnB1dC5hZHZhbmNlKCk7XG4gICAgICAgICAgICAgICAgY29udGludWUgc2NhbjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBicmVhaztcbiAgICB9XG59XG5cbi8vIFNlZSBsZXplci1nZW5lcmF0b3Ivc3JjL2VuY29kZS50cyBmb3IgY29tbWVudHMgYWJvdXQgdGhlIGVuY29kaW5nXG4vLyB1c2VkIGhlcmVcbmZ1bmN0aW9uIGRlY29kZUFycmF5KGlucHV0LCBUeXBlID0gVWludDE2QXJyYXkpIHtcbiAgICBpZiAodHlwZW9mIGlucHV0ICE9IFwic3RyaW5nXCIpXG4gICAgICAgIHJldHVybiBpbnB1dDtcbiAgICBsZXQgYXJyYXkgPSBudWxsO1xuICAgIGZvciAobGV0IHBvcyA9IDAsIG91dCA9IDA7IHBvcyA8IGlucHV0Lmxlbmd0aDspIHtcbiAgICAgICAgbGV0IHZhbHVlID0gMDtcbiAgICAgICAgZm9yICg7Oykge1xuICAgICAgICAgICAgbGV0IG5leHQgPSBpbnB1dC5jaGFyQ29kZUF0KHBvcysrKSwgc3RvcCA9IGZhbHNlO1xuICAgICAgICAgICAgaWYgKG5leHQgPT0gMTI2IC8qIEJpZ1ZhbENvZGUgKi8pIHtcbiAgICAgICAgICAgICAgICB2YWx1ZSA9IDY1NTM1IC8qIEJpZ1ZhbCAqLztcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChuZXh0ID49IDkyIC8qIEdhcDIgKi8pXG4gICAgICAgICAgICAgICAgbmV4dC0tO1xuICAgICAgICAgICAgaWYgKG5leHQgPj0gMzQgLyogR2FwMSAqLylcbiAgICAgICAgICAgICAgICBuZXh0LS07XG4gICAgICAgICAgICBsZXQgZGlnaXQgPSBuZXh0IC0gMzIgLyogU3RhcnQgKi87XG4gICAgICAgICAgICBpZiAoZGlnaXQgPj0gNDYgLyogQmFzZSAqLykge1xuICAgICAgICAgICAgICAgIGRpZ2l0IC09IDQ2IC8qIEJhc2UgKi87XG4gICAgICAgICAgICAgICAgc3RvcCA9IHRydWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB2YWx1ZSArPSBkaWdpdDtcbiAgICAgICAgICAgIGlmIChzdG9wKVxuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgdmFsdWUgKj0gNDYgLyogQmFzZSAqLztcbiAgICAgICAgfVxuICAgICAgICBpZiAoYXJyYXkpXG4gICAgICAgICAgICBhcnJheVtvdXQrK10gPSB2YWx1ZTtcbiAgICAgICAgZWxzZVxuICAgICAgICAgICAgYXJyYXkgPSBuZXcgVHlwZSh2YWx1ZSk7XG4gICAgfVxuICAgIHJldHVybiBhcnJheTtcbn1cblxuLy8gRW52aXJvbm1lbnQgdmFyaWFibGUgdXNlZCB0byBjb250cm9sIGNvbnNvbGUgb3V0cHV0XG5jb25zdCB2ZXJib3NlID0gdHlwZW9mIHByb2Nlc3MgIT0gXCJ1bmRlZmluZWRcIiAmJiBwcm9jZXNzLmVudiAmJiAvXFxicGFyc2VcXGIvLnRlc3QocHJvY2Vzcy5lbnYuTE9HKTtcbmxldCBzdGFja0lEcyA9IG51bGw7XG52YXIgU2FmZXR5O1xuKGZ1bmN0aW9uIChTYWZldHkpIHtcbiAgICBTYWZldHlbU2FmZXR5W1wiTWFyZ2luXCJdID0gMjVdID0gXCJNYXJnaW5cIjtcbn0pKFNhZmV0eSB8fCAoU2FmZXR5ID0ge30pKTtcbmZ1bmN0aW9uIGN1dEF0KHRyZWUsIHBvcywgc2lkZSkge1xuICAgIGxldCBjdXJzb3IgPSB0cmVlLmN1cnNvcihjb21tb24uSXRlck1vZGUuSW5jbHVkZUFub255bW91cyk7XG4gICAgY3Vyc29yLm1vdmVUbyhwb3MpO1xuICAgIGZvciAoOzspIHtcbiAgICAgICAgaWYgKCEoc2lkZSA8IDAgPyBjdXJzb3IuY2hpbGRCZWZvcmUocG9zKSA6IGN1cnNvci5jaGlsZEFmdGVyKHBvcykpKVxuICAgICAgICAgICAgZm9yICg7Oykge1xuICAgICAgICAgICAgICAgIGlmICgoc2lkZSA8IDAgPyBjdXJzb3IudG8gPCBwb3MgOiBjdXJzb3IuZnJvbSA+IHBvcykgJiYgIWN1cnNvci50eXBlLmlzRXJyb3IpXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBzaWRlIDwgMCA/IE1hdGgubWF4KDAsIE1hdGgubWluKGN1cnNvci50byAtIDEsIHBvcyAtIDI1IC8qIE1hcmdpbiAqLykpXG4gICAgICAgICAgICAgICAgICAgICAgICA6IE1hdGgubWluKHRyZWUubGVuZ3RoLCBNYXRoLm1heChjdXJzb3IuZnJvbSArIDEsIHBvcyArIDI1IC8qIE1hcmdpbiAqLykpO1xuICAgICAgICAgICAgICAgIGlmIChzaWRlIDwgMCA/IGN1cnNvci5wcmV2U2libGluZygpIDogY3Vyc29yLm5leHRTaWJsaW5nKCkpXG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGlmICghY3Vyc29yLnBhcmVudCgpKVxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gc2lkZSA8IDAgPyAwIDogdHJlZS5sZW5ndGg7XG4gICAgICAgICAgICB9XG4gICAgfVxufVxuY2xhc3MgRnJhZ21lbnRDdXJzb3Ige1xuICAgIGNvbnN0cnVjdG9yKGZyYWdtZW50cywgbm9kZVNldCkge1xuICAgICAgICB0aGlzLmZyYWdtZW50cyA9IGZyYWdtZW50cztcbiAgICAgICAgdGhpcy5ub2RlU2V0ID0gbm9kZVNldDtcbiAgICAgICAgdGhpcy5pID0gMDtcbiAgICAgICAgdGhpcy5mcmFnbWVudCA9IG51bGw7XG4gICAgICAgIHRoaXMuc2FmZUZyb20gPSAtMTtcbiAgICAgICAgdGhpcy5zYWZlVG8gPSAtMTtcbiAgICAgICAgdGhpcy50cmVlcyA9IFtdO1xuICAgICAgICB0aGlzLnN0YXJ0ID0gW107XG4gICAgICAgIHRoaXMuaW5kZXggPSBbXTtcbiAgICAgICAgdGhpcy5uZXh0RnJhZ21lbnQoKTtcbiAgICB9XG4gICAgbmV4dEZyYWdtZW50KCkge1xuICAgICAgICBsZXQgZnIgPSB0aGlzLmZyYWdtZW50ID0gdGhpcy5pID09IHRoaXMuZnJhZ21lbnRzLmxlbmd0aCA/IG51bGwgOiB0aGlzLmZyYWdtZW50c1t0aGlzLmkrK107XG4gICAgICAgIGlmIChmcikge1xuICAgICAgICAgICAgdGhpcy5zYWZlRnJvbSA9IGZyLm9wZW5TdGFydCA/IGN1dEF0KGZyLnRyZWUsIGZyLmZyb20gKyBmci5vZmZzZXQsIDEpIC0gZnIub2Zmc2V0IDogZnIuZnJvbTtcbiAgICAgICAgICAgIHRoaXMuc2FmZVRvID0gZnIub3BlbkVuZCA/IGN1dEF0KGZyLnRyZWUsIGZyLnRvICsgZnIub2Zmc2V0LCAtMSkgLSBmci5vZmZzZXQgOiBmci50bztcbiAgICAgICAgICAgIHdoaWxlICh0aGlzLnRyZWVzLmxlbmd0aCkge1xuICAgICAgICAgICAgICAgIHRoaXMudHJlZXMucG9wKCk7XG4gICAgICAgICAgICAgICAgdGhpcy5zdGFydC5wb3AoKTtcbiAgICAgICAgICAgICAgICB0aGlzLmluZGV4LnBvcCgpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhpcy50cmVlcy5wdXNoKGZyLnRyZWUpO1xuICAgICAgICAgICAgdGhpcy5zdGFydC5wdXNoKC1mci5vZmZzZXQpO1xuICAgICAgICAgICAgdGhpcy5pbmRleC5wdXNoKDApO1xuICAgICAgICAgICAgdGhpcy5uZXh0U3RhcnQgPSB0aGlzLnNhZmVGcm9tO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgdGhpcy5uZXh0U3RhcnQgPSAxZTk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgLy8gYHBvc2AgbXVzdCBiZSA+PSBhbnkgcHJldmlvdXNseSBnaXZlbiBgcG9zYCBmb3IgdGhpcyBjdXJzb3JcbiAgICBub2RlQXQocG9zKSB7XG4gICAgICAgIGlmIChwb3MgPCB0aGlzLm5leHRTdGFydClcbiAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICB3aGlsZSAodGhpcy5mcmFnbWVudCAmJiB0aGlzLnNhZmVUbyA8PSBwb3MpXG4gICAgICAgICAgICB0aGlzLm5leHRGcmFnbWVudCgpO1xuICAgICAgICBpZiAoIXRoaXMuZnJhZ21lbnQpXG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgZm9yICg7Oykge1xuICAgICAgICAgICAgbGV0IGxhc3QgPSB0aGlzLnRyZWVzLmxlbmd0aCAtIDE7XG4gICAgICAgICAgICBpZiAobGFzdCA8IDApIHsgLy8gRW5kIG9mIHRyZWVcbiAgICAgICAgICAgICAgICB0aGlzLm5leHRGcmFnbWVudCgpO1xuICAgICAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgbGV0IHRvcCA9IHRoaXMudHJlZXNbbGFzdF0sIGluZGV4ID0gdGhpcy5pbmRleFtsYXN0XTtcbiAgICAgICAgICAgIGlmIChpbmRleCA9PSB0b3AuY2hpbGRyZW4ubGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgdGhpcy50cmVlcy5wb3AoKTtcbiAgICAgICAgICAgICAgICB0aGlzLnN0YXJ0LnBvcCgpO1xuICAgICAgICAgICAgICAgIHRoaXMuaW5kZXgucG9wKCk7XG4gICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBsZXQgbmV4dCA9IHRvcC5jaGlsZHJlbltpbmRleF07XG4gICAgICAgICAgICBsZXQgc3RhcnQgPSB0aGlzLnN0YXJ0W2xhc3RdICsgdG9wLnBvc2l0aW9uc1tpbmRleF07XG4gICAgICAgICAgICBpZiAoc3RhcnQgPiBwb3MpIHtcbiAgICAgICAgICAgICAgICB0aGlzLm5leHRTdGFydCA9IHN0YXJ0O1xuICAgICAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKG5leHQgaW5zdGFuY2VvZiBjb21tb24uVHJlZSkge1xuICAgICAgICAgICAgICAgIGlmIChzdGFydCA9PSBwb3MpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHN0YXJ0IDwgdGhpcy5zYWZlRnJvbSlcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICAgICAgICAgICAgICBsZXQgZW5kID0gc3RhcnQgKyBuZXh0Lmxlbmd0aDtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGVuZCA8PSB0aGlzLnNhZmVUbykge1xuICAgICAgICAgICAgICAgICAgICAgICAgbGV0IGxvb2tBaGVhZCA9IG5leHQucHJvcChjb21tb24uTm9kZVByb3AubG9va0FoZWFkKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICghbG9va0FoZWFkIHx8IGVuZCArIGxvb2tBaGVhZCA8IHRoaXMuZnJhZ21lbnQudG8pXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG5leHQ7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgdGhpcy5pbmRleFtsYXN0XSsrO1xuICAgICAgICAgICAgICAgIGlmIChzdGFydCArIG5leHQubGVuZ3RoID49IE1hdGgubWF4KHRoaXMuc2FmZUZyb20sIHBvcykpIHsgLy8gRW50ZXIgdGhpcyBub2RlXG4gICAgICAgICAgICAgICAgICAgIHRoaXMudHJlZXMucHVzaChuZXh0KTtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5zdGFydC5wdXNoKHN0YXJ0KTtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5pbmRleC5wdXNoKDApO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHRoaXMuaW5kZXhbbGFzdF0rKztcbiAgICAgICAgICAgICAgICB0aGlzLm5leHRTdGFydCA9IHN0YXJ0ICsgbmV4dC5sZW5ndGg7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG59XG5jbGFzcyBUb2tlbkNhY2hlIHtcbiAgICBjb25zdHJ1Y3RvcihwYXJzZXIsIHN0cmVhbSkge1xuICAgICAgICB0aGlzLnN0cmVhbSA9IHN0cmVhbTtcbiAgICAgICAgdGhpcy50b2tlbnMgPSBbXTtcbiAgICAgICAgdGhpcy5tYWluVG9rZW4gPSBudWxsO1xuICAgICAgICB0aGlzLmFjdGlvbnMgPSBbXTtcbiAgICAgICAgdGhpcy50b2tlbnMgPSBwYXJzZXIudG9rZW5pemVycy5tYXAoXyA9PiBuZXcgQ2FjaGVkVG9rZW4pO1xuICAgIH1cbiAgICBnZXRBY3Rpb25zKHN0YWNrKSB7XG4gICAgICAgIGxldCBhY3Rpb25JbmRleCA9IDA7XG4gICAgICAgIGxldCBtYWluID0gbnVsbDtcbiAgICAgICAgbGV0IHsgcGFyc2VyIH0gPSBzdGFjay5wLCB7IHRva2VuaXplcnMgfSA9IHBhcnNlcjtcbiAgICAgICAgbGV0IG1hc2sgPSBwYXJzZXIuc3RhdGVTbG90KHN0YWNrLnN0YXRlLCAzIC8qIFRva2VuaXplck1hc2sgKi8pO1xuICAgICAgICBsZXQgY29udGV4dCA9IHN0YWNrLmN1ckNvbnRleHQgPyBzdGFjay5jdXJDb250ZXh0Lmhhc2ggOiAwO1xuICAgICAgICBsZXQgbG9va0FoZWFkID0gMDtcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCB0b2tlbml6ZXJzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICBpZiAoKCgxIDw8IGkpICYgbWFzaykgPT0gMClcbiAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgIGxldCB0b2tlbml6ZXIgPSB0b2tlbml6ZXJzW2ldLCB0b2tlbiA9IHRoaXMudG9rZW5zW2ldO1xuICAgICAgICAgICAgaWYgKG1haW4gJiYgIXRva2VuaXplci5mYWxsYmFjaylcbiAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgIGlmICh0b2tlbml6ZXIuY29udGV4dHVhbCB8fCB0b2tlbi5zdGFydCAhPSBzdGFjay5wb3MgfHwgdG9rZW4ubWFzayAhPSBtYXNrIHx8IHRva2VuLmNvbnRleHQgIT0gY29udGV4dCkge1xuICAgICAgICAgICAgICAgIHRoaXMudXBkYXRlQ2FjaGVkVG9rZW4odG9rZW4sIHRva2VuaXplciwgc3RhY2spO1xuICAgICAgICAgICAgICAgIHRva2VuLm1hc2sgPSBtYXNrO1xuICAgICAgICAgICAgICAgIHRva2VuLmNvbnRleHQgPSBjb250ZXh0O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHRva2VuLmxvb2tBaGVhZCA+IHRva2VuLmVuZCArIDI1IC8qIE1hcmdpbiAqLylcbiAgICAgICAgICAgICAgICBsb29rQWhlYWQgPSBNYXRoLm1heCh0b2tlbi5sb29rQWhlYWQsIGxvb2tBaGVhZCk7XG4gICAgICAgICAgICBpZiAodG9rZW4udmFsdWUgIT0gMCAvKiBFcnIgKi8pIHtcbiAgICAgICAgICAgICAgICBsZXQgc3RhcnRJbmRleCA9IGFjdGlvbkluZGV4O1xuICAgICAgICAgICAgICAgIGlmICh0b2tlbi5leHRlbmRlZCA+IC0xKVxuICAgICAgICAgICAgICAgICAgICBhY3Rpb25JbmRleCA9IHRoaXMuYWRkQWN0aW9ucyhzdGFjaywgdG9rZW4uZXh0ZW5kZWQsIHRva2VuLmVuZCwgYWN0aW9uSW5kZXgpO1xuICAgICAgICAgICAgICAgIGFjdGlvbkluZGV4ID0gdGhpcy5hZGRBY3Rpb25zKHN0YWNrLCB0b2tlbi52YWx1ZSwgdG9rZW4uZW5kLCBhY3Rpb25JbmRleCk7XG4gICAgICAgICAgICAgICAgaWYgKCF0b2tlbml6ZXIuZXh0ZW5kKSB7XG4gICAgICAgICAgICAgICAgICAgIG1haW4gPSB0b2tlbjtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGFjdGlvbkluZGV4ID4gc3RhcnRJbmRleClcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICB3aGlsZSAodGhpcy5hY3Rpb25zLmxlbmd0aCA+IGFjdGlvbkluZGV4KVxuICAgICAgICAgICAgdGhpcy5hY3Rpb25zLnBvcCgpO1xuICAgICAgICBpZiAobG9va0FoZWFkKVxuICAgICAgICAgICAgc3RhY2suc2V0TG9va0FoZWFkKGxvb2tBaGVhZCk7XG4gICAgICAgIGlmICghbWFpbiAmJiBzdGFjay5wb3MgPT0gdGhpcy5zdHJlYW0uZW5kKSB7XG4gICAgICAgICAgICBtYWluID0gbmV3IENhY2hlZFRva2VuO1xuICAgICAgICAgICAgbWFpbi52YWx1ZSA9IHN0YWNrLnAucGFyc2VyLmVvZlRlcm07XG4gICAgICAgICAgICBtYWluLnN0YXJ0ID0gbWFpbi5lbmQgPSBzdGFjay5wb3M7XG4gICAgICAgICAgICBhY3Rpb25JbmRleCA9IHRoaXMuYWRkQWN0aW9ucyhzdGFjaywgbWFpbi52YWx1ZSwgbWFpbi5lbmQsIGFjdGlvbkluZGV4KTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLm1haW5Ub2tlbiA9IG1haW47XG4gICAgICAgIHJldHVybiB0aGlzLmFjdGlvbnM7XG4gICAgfVxuICAgIGdldE1haW5Ub2tlbihzdGFjaykge1xuICAgICAgICBpZiAodGhpcy5tYWluVG9rZW4pXG4gICAgICAgICAgICByZXR1cm4gdGhpcy5tYWluVG9rZW47XG4gICAgICAgIGxldCBtYWluID0gbmV3IENhY2hlZFRva2VuLCB7IHBvcywgcCB9ID0gc3RhY2s7XG4gICAgICAgIG1haW4uc3RhcnQgPSBwb3M7XG4gICAgICAgIG1haW4uZW5kID0gTWF0aC5taW4ocG9zICsgMSwgcC5zdHJlYW0uZW5kKTtcbiAgICAgICAgbWFpbi52YWx1ZSA9IHBvcyA9PSBwLnN0cmVhbS5lbmQgPyBwLnBhcnNlci5lb2ZUZXJtIDogMCAvKiBFcnIgKi87XG4gICAgICAgIHJldHVybiBtYWluO1xuICAgIH1cbiAgICB1cGRhdGVDYWNoZWRUb2tlbih0b2tlbiwgdG9rZW5pemVyLCBzdGFjaykge1xuICAgICAgICB0b2tlbml6ZXIudG9rZW4odGhpcy5zdHJlYW0ucmVzZXQoc3RhY2sucG9zLCB0b2tlbiksIHN0YWNrKTtcbiAgICAgICAgaWYgKHRva2VuLnZhbHVlID4gLTEpIHtcbiAgICAgICAgICAgIGxldCB7IHBhcnNlciB9ID0gc3RhY2sucDtcbiAgICAgICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgcGFyc2VyLnNwZWNpYWxpemVkLmxlbmd0aDsgaSsrKVxuICAgICAgICAgICAgICAgIGlmIChwYXJzZXIuc3BlY2lhbGl6ZWRbaV0gPT0gdG9rZW4udmFsdWUpIHtcbiAgICAgICAgICAgICAgICAgICAgbGV0IHJlc3VsdCA9IHBhcnNlci5zcGVjaWFsaXplcnNbaV0odGhpcy5zdHJlYW0ucmVhZCh0b2tlbi5zdGFydCwgdG9rZW4uZW5kKSwgc3RhY2spO1xuICAgICAgICAgICAgICAgICAgICBpZiAocmVzdWx0ID49IDAgJiYgc3RhY2sucC5wYXJzZXIuZGlhbGVjdC5hbGxvd3MocmVzdWx0ID4+IDEpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoKHJlc3VsdCAmIDEpID09IDAgLyogU3BlY2lhbGl6ZSAqLylcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0b2tlbi52YWx1ZSA9IHJlc3VsdCA+PiAxO1xuICAgICAgICAgICAgICAgICAgICAgICAgZWxzZVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRva2VuLmV4dGVuZGVkID0gcmVzdWx0ID4+IDE7XG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHRva2VuLnZhbHVlID0gMCAvKiBFcnIgKi87XG4gICAgICAgICAgICB0b2tlbi5lbmQgPSBNYXRoLm1pbihzdGFjay5wLnN0cmVhbS5lbmQsIHN0YWNrLnBvcyArIDEpO1xuICAgICAgICB9XG4gICAgfVxuICAgIHB1dEFjdGlvbihhY3Rpb24sIHRva2VuLCBlbmQsIGluZGV4KSB7XG4gICAgICAgIC8vIERvbid0IGFkZCBkdXBsaWNhdGUgYWN0aW9uc1xuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IGluZGV4OyBpICs9IDMpXG4gICAgICAgICAgICBpZiAodGhpcy5hY3Rpb25zW2ldID09IGFjdGlvbilcbiAgICAgICAgICAgICAgICByZXR1cm4gaW5kZXg7XG4gICAgICAgIHRoaXMuYWN0aW9uc1tpbmRleCsrXSA9IGFjdGlvbjtcbiAgICAgICAgdGhpcy5hY3Rpb25zW2luZGV4KytdID0gdG9rZW47XG4gICAgICAgIHRoaXMuYWN0aW9uc1tpbmRleCsrXSA9IGVuZDtcbiAgICAgICAgcmV0dXJuIGluZGV4O1xuICAgIH1cbiAgICBhZGRBY3Rpb25zKHN0YWNrLCB0b2tlbiwgZW5kLCBpbmRleCkge1xuICAgICAgICBsZXQgeyBzdGF0ZSB9ID0gc3RhY2ssIHsgcGFyc2VyIH0gPSBzdGFjay5wLCB7IGRhdGEgfSA9IHBhcnNlcjtcbiAgICAgICAgZm9yIChsZXQgc2V0ID0gMDsgc2V0IDwgMjsgc2V0KyspIHtcbiAgICAgICAgICAgIGZvciAobGV0IGkgPSBwYXJzZXIuc3RhdGVTbG90KHN0YXRlLCBzZXQgPyAyIC8qIFNraXAgKi8gOiAxIC8qIEFjdGlvbnMgKi8pOzsgaSArPSAzKSB7XG4gICAgICAgICAgICAgICAgaWYgKGRhdGFbaV0gPT0gNjU1MzUgLyogRW5kICovKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChkYXRhW2kgKyAxXSA9PSAxIC8qIE5leHQgKi8pIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGkgPSBwYWlyKGRhdGEsIGkgKyAyKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChpbmRleCA9PSAwICYmIGRhdGFbaSArIDFdID09IDIgLyogT3RoZXIgKi8pXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaW5kZXggPSB0aGlzLnB1dEFjdGlvbihwYWlyKGRhdGEsIGkgKyAyKSwgdG9rZW4sIGVuZCwgaW5kZXgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKGRhdGFbaV0gPT0gdG9rZW4pXG4gICAgICAgICAgICAgICAgICAgIGluZGV4ID0gdGhpcy5wdXRBY3Rpb24ocGFpcihkYXRhLCBpICsgMSksIHRva2VuLCBlbmQsIGluZGV4KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gaW5kZXg7XG4gICAgfVxufVxudmFyIFJlYztcbihmdW5jdGlvbiAoUmVjKSB7XG4gICAgUmVjW1JlY1tcIkRpc3RhbmNlXCJdID0gNV0gPSBcIkRpc3RhbmNlXCI7XG4gICAgUmVjW1JlY1tcIk1heFJlbWFpbmluZ1BlclN0ZXBcIl0gPSAzXSA9IFwiTWF4UmVtYWluaW5nUGVyU3RlcFwiO1xuICAgIC8vIFdoZW4gdHdvIHN0YWNrcyBoYXZlIGJlZW4gcnVubmluZyBpbmRlcGVuZGVudGx5IGxvbmcgZW5vdWdoIHRvXG4gICAgLy8gYWRkIHRoaXMgbWFueSBlbGVtZW50cyB0byB0aGVpciBidWZmZXJzLCBwcnVuZSBvbmUuXG4gICAgUmVjW1JlY1tcIk1pbkJ1ZmZlckxlbmd0aFBydW5lXCJdID0gNTAwXSA9IFwiTWluQnVmZmVyTGVuZ3RoUHJ1bmVcIjtcbiAgICBSZWNbUmVjW1wiRm9yY2VSZWR1Y2VMaW1pdFwiXSA9IDEwXSA9IFwiRm9yY2VSZWR1Y2VMaW1pdFwiO1xuICAgIC8vIE9uY2UgYSBzdGFjayByZWFjaGVzIHRoaXMgZGVwdGggKGluIC5zdGFjay5sZW5ndGgpIGZvcmNlLXJlZHVjZVxuICAgIC8vIGl0IGJhY2sgdG8gQ3V0VG8gdG8gYXZvaWQgY3JlYXRpbmcgdHJlZXMgdGhhdCBvdmVyZmxvdyB0aGUgc3RhY2tcbiAgICAvLyBvbiByZWN1cnNpdmUgdHJhdmVyc2FsLlxuICAgIFJlY1tSZWNbXCJDdXREZXB0aFwiXSA9IDE1MDAwXSA9IFwiQ3V0RGVwdGhcIjtcbiAgICBSZWNbUmVjW1wiQ3V0VG9cIl0gPSA5MDAwXSA9IFwiQ3V0VG9cIjtcbn0pKFJlYyB8fCAoUmVjID0ge30pKTtcbmNsYXNzIFBhcnNlIHtcbiAgICBjb25zdHJ1Y3RvcihwYXJzZXIsIGlucHV0LCBmcmFnbWVudHMsIHJhbmdlcykge1xuICAgICAgICB0aGlzLnBhcnNlciA9IHBhcnNlcjtcbiAgICAgICAgdGhpcy5pbnB1dCA9IGlucHV0O1xuICAgICAgICB0aGlzLnJhbmdlcyA9IHJhbmdlcztcbiAgICAgICAgdGhpcy5yZWNvdmVyaW5nID0gMDtcbiAgICAgICAgdGhpcy5uZXh0U3RhY2tJRCA9IDB4MjY1NDsgLy8g4pmULCDimZUsIOKZliwg4pmXLCDimZgsIOKZmSwg4pmgLCDimaEsIOKZoiwg4pmjLCDimaQsIOKZpSwg4pmmLCDimadcbiAgICAgICAgdGhpcy5taW5TdGFja1BvcyA9IDA7XG4gICAgICAgIHRoaXMucmV1c2VkID0gW107XG4gICAgICAgIHRoaXMuc3RvcHBlZEF0ID0gbnVsbDtcbiAgICAgICAgdGhpcy5zdHJlYW0gPSBuZXcgSW5wdXRTdHJlYW0oaW5wdXQsIHJhbmdlcyk7XG4gICAgICAgIHRoaXMudG9rZW5zID0gbmV3IFRva2VuQ2FjaGUocGFyc2VyLCB0aGlzLnN0cmVhbSk7XG4gICAgICAgIHRoaXMudG9wVGVybSA9IHBhcnNlci50b3BbMV07XG4gICAgICAgIGxldCB7IGZyb20gfSA9IHJhbmdlc1swXTtcbiAgICAgICAgdGhpcy5zdGFja3MgPSBbU3RhY2suc3RhcnQodGhpcywgcGFyc2VyLnRvcFswXSwgZnJvbSldO1xuICAgICAgICB0aGlzLmZyYWdtZW50cyA9IGZyYWdtZW50cy5sZW5ndGggJiYgdGhpcy5zdHJlYW0uZW5kIC0gZnJvbSA+IHBhcnNlci5idWZmZXJMZW5ndGggKiA0XG4gICAgICAgICAgICA/IG5ldyBGcmFnbWVudEN1cnNvcihmcmFnbWVudHMsIHBhcnNlci5ub2RlU2V0KSA6IG51bGw7XG4gICAgfVxuICAgIGdldCBwYXJzZWRQb3MoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLm1pblN0YWNrUG9zO1xuICAgIH1cbiAgICAvLyBNb3ZlIHRoZSBwYXJzZXIgZm9yd2FyZC4gVGhpcyB3aWxsIHByb2Nlc3MgYWxsIHBhcnNlIHN0YWNrcyBhdFxuICAgIC8vIGB0aGlzLnBvc2AgYW5kIHRyeSB0byBhZHZhbmNlIHRoZW0gdG8gYSBmdXJ0aGVyIHBvc2l0aW9uLiBJZiBub1xuICAgIC8vIHN0YWNrIGZvciBzdWNoIGEgcG9zaXRpb24gaXMgZm91bmQsIGl0J2xsIHN0YXJ0IGVycm9yLXJlY292ZXJ5LlxuICAgIC8vXG4gICAgLy8gV2hlbiB0aGUgcGFyc2UgaXMgZmluaXNoZWQsIHRoaXMgd2lsbCByZXR1cm4gYSBzeW50YXggdHJlZS4gV2hlblxuICAgIC8vIG5vdCwgaXQgcmV0dXJucyBgbnVsbGAuXG4gICAgYWR2YW5jZSgpIHtcbiAgICAgICAgbGV0IHN0YWNrcyA9IHRoaXMuc3RhY2tzLCBwb3MgPSB0aGlzLm1pblN0YWNrUG9zO1xuICAgICAgICAvLyBUaGlzIHdpbGwgaG9sZCBzdGFja3MgYmV5b25kIGBwb3NgLlxuICAgICAgICBsZXQgbmV3U3RhY2tzID0gdGhpcy5zdGFja3MgPSBbXTtcbiAgICAgICAgbGV0IHN0b3BwZWQsIHN0b3BwZWRUb2tlbnM7XG4gICAgICAgIC8vIEtlZXAgYWR2YW5jaW5nIGFueSBzdGFja3MgYXQgYHBvc2AgdW50aWwgdGhleSBlaXRoZXIgbW92ZVxuICAgICAgICAvLyBmb3J3YXJkIG9yIGNhbid0IGJlIGFkdmFuY2VkLiBHYXRoZXIgc3RhY2tzIHRoYXQgY2FuJ3QgYmVcbiAgICAgICAgLy8gYWR2YW5jZWQgZnVydGhlciBpbiBgc3RvcHBlZGAuXG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgc3RhY2tzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICBsZXQgc3RhY2sgPSBzdGFja3NbaV07XG4gICAgICAgICAgICBmb3IgKDs7KSB7XG4gICAgICAgICAgICAgICAgdGhpcy50b2tlbnMubWFpblRva2VuID0gbnVsbDtcbiAgICAgICAgICAgICAgICBpZiAoc3RhY2sucG9zID4gcG9zKSB7XG4gICAgICAgICAgICAgICAgICAgIG5ld1N0YWNrcy5wdXNoKHN0YWNrKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSBpZiAodGhpcy5hZHZhbmNlU3RhY2soc3RhY2ssIG5ld1N0YWNrcywgc3RhY2tzKSkge1xuICAgICAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIGlmICghc3RvcHBlZCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgc3RvcHBlZCA9IFtdO1xuICAgICAgICAgICAgICAgICAgICAgICAgc3RvcHBlZFRva2VucyA9IFtdO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIHN0b3BwZWQucHVzaChzdGFjayk7XG4gICAgICAgICAgICAgICAgICAgIGxldCB0b2sgPSB0aGlzLnRva2Vucy5nZXRNYWluVG9rZW4oc3RhY2spO1xuICAgICAgICAgICAgICAgICAgICBzdG9wcGVkVG9rZW5zLnB1c2godG9rLnZhbHVlLCB0b2suZW5kKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCFuZXdTdGFja3MubGVuZ3RoKSB7XG4gICAgICAgICAgICBsZXQgZmluaXNoZWQgPSBzdG9wcGVkICYmIGZpbmRGaW5pc2hlZChzdG9wcGVkKTtcbiAgICAgICAgICAgIGlmIChmaW5pc2hlZClcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5zdGFja1RvVHJlZShmaW5pc2hlZCk7XG4gICAgICAgICAgICBpZiAodGhpcy5wYXJzZXIuc3RyaWN0KSB7XG4gICAgICAgICAgICAgICAgaWYgKHZlcmJvc2UgJiYgc3RvcHBlZClcbiAgICAgICAgICAgICAgICAgICAgY29uc29sZS5sb2coXCJTdHVjayB3aXRoIHRva2VuIFwiICsgKHRoaXMudG9rZW5zLm1haW5Ub2tlbiA/IHRoaXMucGFyc2VyLmdldE5hbWUodGhpcy50b2tlbnMubWFpblRva2VuLnZhbHVlKSA6IFwibm9uZVwiKSk7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IFN5bnRheEVycm9yKFwiTm8gcGFyc2UgYXQgXCIgKyBwb3MpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKCF0aGlzLnJlY292ZXJpbmcpXG4gICAgICAgICAgICAgICAgdGhpcy5yZWNvdmVyaW5nID0gNSAvKiBEaXN0YW5jZSAqLztcbiAgICAgICAgfVxuICAgICAgICBpZiAodGhpcy5yZWNvdmVyaW5nICYmIHN0b3BwZWQpIHtcbiAgICAgICAgICAgIGxldCBmaW5pc2hlZCA9IHRoaXMuc3RvcHBlZEF0ICE9IG51bGwgJiYgc3RvcHBlZFswXS5wb3MgPiB0aGlzLnN0b3BwZWRBdCA/IHN0b3BwZWRbMF1cbiAgICAgICAgICAgICAgICA6IHRoaXMucnVuUmVjb3Zlcnkoc3RvcHBlZCwgc3RvcHBlZFRva2VucywgbmV3U3RhY2tzKTtcbiAgICAgICAgICAgIGlmIChmaW5pc2hlZClcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5zdGFja1RvVHJlZShmaW5pc2hlZC5mb3JjZUFsbCgpKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodGhpcy5yZWNvdmVyaW5nKSB7XG4gICAgICAgICAgICBsZXQgbWF4UmVtYWluaW5nID0gdGhpcy5yZWNvdmVyaW5nID09IDEgPyAxIDogdGhpcy5yZWNvdmVyaW5nICogMyAvKiBNYXhSZW1haW5pbmdQZXJTdGVwICovO1xuICAgICAgICAgICAgaWYgKG5ld1N0YWNrcy5sZW5ndGggPiBtYXhSZW1haW5pbmcpIHtcbiAgICAgICAgICAgICAgICBuZXdTdGFja3Muc29ydCgoYSwgYikgPT4gYi5zY29yZSAtIGEuc2NvcmUpO1xuICAgICAgICAgICAgICAgIHdoaWxlIChuZXdTdGFja3MubGVuZ3RoID4gbWF4UmVtYWluaW5nKVxuICAgICAgICAgICAgICAgICAgICBuZXdTdGFja3MucG9wKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAobmV3U3RhY2tzLnNvbWUocyA9PiBzLnJlZHVjZVBvcyA+IHBvcykpXG4gICAgICAgICAgICAgICAgdGhpcy5yZWNvdmVyaW5nLS07XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAobmV3U3RhY2tzLmxlbmd0aCA+IDEpIHtcbiAgICAgICAgICAgIC8vIFBydW5lIHN0YWNrcyB0aGF0IGFyZSBpbiB0aGUgc2FtZSBzdGF0ZSwgb3IgdGhhdCBoYXZlIGJlZW5cbiAgICAgICAgICAgIC8vIHJ1bm5pbmcgd2l0aG91dCBzcGxpdHRpbmcgZm9yIGEgd2hpbGUsIHRvIGF2b2lkIGdldHRpbmcgc3R1Y2tcbiAgICAgICAgICAgIC8vIHdpdGggbXVsdGlwbGUgc3VjY2Vzc2Z1bCBzdGFja3MgcnVubmluZyBlbmRsZXNzbHkgb24uXG4gICAgICAgICAgICBvdXRlcjogZm9yIChsZXQgaSA9IDA7IGkgPCBuZXdTdGFja3MubGVuZ3RoIC0gMTsgaSsrKSB7XG4gICAgICAgICAgICAgICAgbGV0IHN0YWNrID0gbmV3U3RhY2tzW2ldO1xuICAgICAgICAgICAgICAgIGZvciAobGV0IGogPSBpICsgMTsgaiA8IG5ld1N0YWNrcy5sZW5ndGg7IGorKykge1xuICAgICAgICAgICAgICAgICAgICBsZXQgb3RoZXIgPSBuZXdTdGFja3Nbal07XG4gICAgICAgICAgICAgICAgICAgIGlmIChzdGFjay5zYW1lU3RhdGUob3RoZXIpIHx8XG4gICAgICAgICAgICAgICAgICAgICAgICBzdGFjay5idWZmZXIubGVuZ3RoID4gNTAwIC8qIE1pbkJ1ZmZlckxlbmd0aFBydW5lICovICYmIG90aGVyLmJ1ZmZlci5sZW5ndGggPiA1MDAgLyogTWluQnVmZmVyTGVuZ3RoUHJ1bmUgKi8pIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICgoKHN0YWNrLnNjb3JlIC0gb3RoZXIuc2NvcmUpIHx8IChzdGFjay5idWZmZXIubGVuZ3RoIC0gb3RoZXIuYnVmZmVyLmxlbmd0aCkpID4gMCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG5ld1N0YWNrcy5zcGxpY2Uoai0tLCAxKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG5ld1N0YWNrcy5zcGxpY2UoaS0tLCAxKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb250aW51ZSBvdXRlcjtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICB0aGlzLm1pblN0YWNrUG9zID0gbmV3U3RhY2tzWzBdLnBvcztcbiAgICAgICAgZm9yIChsZXQgaSA9IDE7IGkgPCBuZXdTdGFja3MubGVuZ3RoOyBpKyspXG4gICAgICAgICAgICBpZiAobmV3U3RhY2tzW2ldLnBvcyA8IHRoaXMubWluU3RhY2tQb3MpXG4gICAgICAgICAgICAgICAgdGhpcy5taW5TdGFja1BvcyA9IG5ld1N0YWNrc1tpXS5wb3M7XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgICBzdG9wQXQocG9zKSB7XG4gICAgICAgIGlmICh0aGlzLnN0b3BwZWRBdCAhPSBudWxsICYmIHRoaXMuc3RvcHBlZEF0IDwgcG9zKVxuICAgICAgICAgICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoXCJDYW4ndCBtb3ZlIHN0b3BwZWRBdCBmb3J3YXJkXCIpO1xuICAgICAgICB0aGlzLnN0b3BwZWRBdCA9IHBvcztcbiAgICB9XG4gICAgLy8gUmV0dXJucyBhbiB1cGRhdGVkIHZlcnNpb24gb2YgdGhlIGdpdmVuIHN0YWNrLCBvciBudWxsIGlmIHRoZVxuICAgIC8vIHN0YWNrIGNhbid0IGFkdmFuY2Ugbm9ybWFsbHkuIFdoZW4gYHNwbGl0YCBhbmQgYHN0YWNrc2AgYXJlXG4gICAgLy8gZ2l2ZW4sIHN0YWNrcyBzcGxpdCBvZmYgYnkgYW1iaWd1b3VzIG9wZXJhdGlvbnMgd2lsbCBiZSBwdXNoZWQgdG9cbiAgICAvLyBgc3BsaXRgLCBvciBhZGRlZCB0byBgc3RhY2tzYCBpZiB0aGV5IG1vdmUgYHBvc2AgZm9yd2FyZC5cbiAgICBhZHZhbmNlU3RhY2soc3RhY2ssIHN0YWNrcywgc3BsaXQpIHtcbiAgICAgICAgbGV0IHN0YXJ0ID0gc3RhY2sucG9zLCB7IHBhcnNlciB9ID0gdGhpcztcbiAgICAgICAgbGV0IGJhc2UgPSB2ZXJib3NlID8gdGhpcy5zdGFja0lEKHN0YWNrKSArIFwiIC0+IFwiIDogXCJcIjtcbiAgICAgICAgaWYgKHRoaXMuc3RvcHBlZEF0ICE9IG51bGwgJiYgc3RhcnQgPiB0aGlzLnN0b3BwZWRBdClcbiAgICAgICAgICAgIHJldHVybiBzdGFjay5mb3JjZVJlZHVjZSgpID8gc3RhY2sgOiBudWxsO1xuICAgICAgICBpZiAodGhpcy5mcmFnbWVudHMpIHtcbiAgICAgICAgICAgIGxldCBzdHJpY3RDeCA9IHN0YWNrLmN1ckNvbnRleHQgJiYgc3RhY2suY3VyQ29udGV4dC50cmFja2VyLnN0cmljdCwgY3hIYXNoID0gc3RyaWN0Q3ggPyBzdGFjay5jdXJDb250ZXh0Lmhhc2ggOiAwO1xuICAgICAgICAgICAgZm9yIChsZXQgY2FjaGVkID0gdGhpcy5mcmFnbWVudHMubm9kZUF0KHN0YXJ0KTsgY2FjaGVkOykge1xuICAgICAgICAgICAgICAgIGxldCBtYXRjaCA9IHRoaXMucGFyc2VyLm5vZGVTZXQudHlwZXNbY2FjaGVkLnR5cGUuaWRdID09IGNhY2hlZC50eXBlID8gcGFyc2VyLmdldEdvdG8oc3RhY2suc3RhdGUsIGNhY2hlZC50eXBlLmlkKSA6IC0xO1xuICAgICAgICAgICAgICAgIGlmIChtYXRjaCA+IC0xICYmIGNhY2hlZC5sZW5ndGggJiYgKCFzdHJpY3RDeCB8fCAoY2FjaGVkLnByb3AoY29tbW9uLk5vZGVQcm9wLmNvbnRleHRIYXNoKSB8fCAwKSA9PSBjeEhhc2gpKSB7XG4gICAgICAgICAgICAgICAgICAgIHN0YWNrLnVzZU5vZGUoY2FjaGVkLCBtYXRjaCk7XG4gICAgICAgICAgICAgICAgICAgIGlmICh2ZXJib3NlKVxuICAgICAgICAgICAgICAgICAgICAgICAgY29uc29sZS5sb2coYmFzZSArIHRoaXMuc3RhY2tJRChzdGFjaykgKyBgICh2aWEgcmV1c2Ugb2YgJHtwYXJzZXIuZ2V0TmFtZShjYWNoZWQudHlwZS5pZCl9KWApO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKCEoY2FjaGVkIGluc3RhbmNlb2YgY29tbW9uLlRyZWUpIHx8IGNhY2hlZC5jaGlsZHJlbi5sZW5ndGggPT0gMCB8fCBjYWNoZWQucG9zaXRpb25zWzBdID4gMClcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgbGV0IGlubmVyID0gY2FjaGVkLmNoaWxkcmVuWzBdO1xuICAgICAgICAgICAgICAgIGlmIChpbm5lciBpbnN0YW5jZW9mIGNvbW1vbi5UcmVlICYmIGNhY2hlZC5wb3NpdGlvbnNbMF0gPT0gMClcbiAgICAgICAgICAgICAgICAgICAgY2FjaGVkID0gaW5uZXI7XG4gICAgICAgICAgICAgICAgZWxzZVxuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBsZXQgZGVmYXVsdFJlZHVjZSA9IHBhcnNlci5zdGF0ZVNsb3Qoc3RhY2suc3RhdGUsIDQgLyogRGVmYXVsdFJlZHVjZSAqLyk7XG4gICAgICAgIGlmIChkZWZhdWx0UmVkdWNlID4gMCkge1xuICAgICAgICAgICAgc3RhY2sucmVkdWNlKGRlZmF1bHRSZWR1Y2UpO1xuICAgICAgICAgICAgaWYgKHZlcmJvc2UpXG4gICAgICAgICAgICAgICAgY29uc29sZS5sb2coYmFzZSArIHRoaXMuc3RhY2tJRChzdGFjaykgKyBgICh2aWEgYWx3YXlzLXJlZHVjZSAke3BhcnNlci5nZXROYW1lKGRlZmF1bHRSZWR1Y2UgJiA2NTUzNSAvKiBWYWx1ZU1hc2sgKi8pfSlgKTtcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICB9XG4gICAgICAgIGlmIChzdGFjay5zdGFjay5sZW5ndGggPj0gMTUwMDAgLyogQ3V0RGVwdGggKi8pIHtcbiAgICAgICAgICAgIHdoaWxlIChzdGFjay5zdGFjay5sZW5ndGggPiA5MDAwIC8qIEN1dFRvICovICYmIHN0YWNrLmZvcmNlUmVkdWNlKCkpIHsgfVxuICAgICAgICB9XG4gICAgICAgIGxldCBhY3Rpb25zID0gdGhpcy50b2tlbnMuZ2V0QWN0aW9ucyhzdGFjayk7XG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgYWN0aW9ucy5sZW5ndGg7KSB7XG4gICAgICAgICAgICBsZXQgYWN0aW9uID0gYWN0aW9uc1tpKytdLCB0ZXJtID0gYWN0aW9uc1tpKytdLCBlbmQgPSBhY3Rpb25zW2krK107XG4gICAgICAgICAgICBsZXQgbGFzdCA9IGkgPT0gYWN0aW9ucy5sZW5ndGggfHwgIXNwbGl0O1xuICAgICAgICAgICAgbGV0IGxvY2FsU3RhY2sgPSBsYXN0ID8gc3RhY2sgOiBzdGFjay5zcGxpdCgpO1xuICAgICAgICAgICAgbG9jYWxTdGFjay5hcHBseShhY3Rpb24sIHRlcm0sIGVuZCk7XG4gICAgICAgICAgICBpZiAodmVyYm9zZSlcbiAgICAgICAgICAgICAgICBjb25zb2xlLmxvZyhiYXNlICsgdGhpcy5zdGFja0lEKGxvY2FsU3RhY2spICsgYCAodmlhICR7KGFjdGlvbiAmIDY1NTM2IC8qIFJlZHVjZUZsYWcgKi8pID09IDAgPyBcInNoaWZ0XCJcbiAgICAgICAgICAgICAgICAgICAgOiBgcmVkdWNlIG9mICR7cGFyc2VyLmdldE5hbWUoYWN0aW9uICYgNjU1MzUgLyogVmFsdWVNYXNrICovKX1gfSBmb3IgJHtwYXJzZXIuZ2V0TmFtZSh0ZXJtKX0gQCAke3N0YXJ0fSR7bG9jYWxTdGFjayA9PSBzdGFjayA/IFwiXCIgOiBcIiwgc3BsaXRcIn0pYCk7XG4gICAgICAgICAgICBpZiAobGFzdClcbiAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgICAgIGVsc2UgaWYgKGxvY2FsU3RhY2sucG9zID4gc3RhcnQpXG4gICAgICAgICAgICAgICAgc3RhY2tzLnB1c2gobG9jYWxTdGFjayk7XG4gICAgICAgICAgICBlbHNlXG4gICAgICAgICAgICAgICAgc3BsaXQucHVzaChsb2NhbFN0YWNrKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIC8vIEFkdmFuY2UgYSBnaXZlbiBzdGFjayBmb3J3YXJkIGFzIGZhciBhcyBpdCB3aWxsIGdvLiBSZXR1cm5zIHRoZVxuICAgIC8vIChwb3NzaWJseSB1cGRhdGVkKSBzdGFjayBpZiBpdCBnb3Qgc3R1Y2ssIG9yIG51bGwgaWYgaXQgbW92ZWRcbiAgICAvLyBmb3J3YXJkIGFuZCB3YXMgZ2l2ZW4gdG8gYHB1c2hTdGFja0RlZHVwYC5cbiAgICBhZHZhbmNlRnVsbHkoc3RhY2ssIG5ld1N0YWNrcykge1xuICAgICAgICBsZXQgcG9zID0gc3RhY2sucG9zO1xuICAgICAgICBmb3IgKDs7KSB7XG4gICAgICAgICAgICBpZiAoIXRoaXMuYWR2YW5jZVN0YWNrKHN0YWNrLCBudWxsLCBudWxsKSlcbiAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICBpZiAoc3RhY2sucG9zID4gcG9zKSB7XG4gICAgICAgICAgICAgICAgcHVzaFN0YWNrRGVkdXAoc3RhY2ssIG5ld1N0YWNrcyk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG4gICAgcnVuUmVjb3Zlcnkoc3RhY2tzLCB0b2tlbnMsIG5ld1N0YWNrcykge1xuICAgICAgICBsZXQgZmluaXNoZWQgPSBudWxsLCByZXN0YXJ0ZWQgPSBmYWxzZTtcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBzdGFja3MubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIGxldCBzdGFjayA9IHN0YWNrc1tpXSwgdG9rZW4gPSB0b2tlbnNbaSA8PCAxXSwgdG9rZW5FbmQgPSB0b2tlbnNbKGkgPDwgMSkgKyAxXTtcbiAgICAgICAgICAgIGxldCBiYXNlID0gdmVyYm9zZSA/IHRoaXMuc3RhY2tJRChzdGFjaykgKyBcIiAtPiBcIiA6IFwiXCI7XG4gICAgICAgICAgICBpZiAoc3RhY2suZGVhZEVuZCkge1xuICAgICAgICAgICAgICAgIGlmIChyZXN0YXJ0ZWQpXG4gICAgICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgICAgIHJlc3RhcnRlZCA9IHRydWU7XG4gICAgICAgICAgICAgICAgc3RhY2sucmVzdGFydCgpO1xuICAgICAgICAgICAgICAgIGlmICh2ZXJib3NlKVxuICAgICAgICAgICAgICAgICAgICBjb25zb2xlLmxvZyhiYXNlICsgdGhpcy5zdGFja0lEKHN0YWNrKSArIFwiIChyZXN0YXJ0ZWQpXCIpO1xuICAgICAgICAgICAgICAgIGxldCBkb25lID0gdGhpcy5hZHZhbmNlRnVsbHkoc3RhY2ssIG5ld1N0YWNrcyk7XG4gICAgICAgICAgICAgICAgaWYgKGRvbmUpXG4gICAgICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgbGV0IGZvcmNlID0gc3RhY2suc3BsaXQoKSwgZm9yY2VCYXNlID0gYmFzZTtcbiAgICAgICAgICAgIGZvciAobGV0IGogPSAwOyBmb3JjZS5mb3JjZVJlZHVjZSgpICYmIGogPCAxMCAvKiBGb3JjZVJlZHVjZUxpbWl0ICovOyBqKyspIHtcbiAgICAgICAgICAgICAgICBpZiAodmVyYm9zZSlcbiAgICAgICAgICAgICAgICAgICAgY29uc29sZS5sb2coZm9yY2VCYXNlICsgdGhpcy5zdGFja0lEKGZvcmNlKSArIFwiICh2aWEgZm9yY2UtcmVkdWNlKVwiKTtcbiAgICAgICAgICAgICAgICBsZXQgZG9uZSA9IHRoaXMuYWR2YW5jZUZ1bGx5KGZvcmNlLCBuZXdTdGFja3MpO1xuICAgICAgICAgICAgICAgIGlmIChkb25lKVxuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBpZiAodmVyYm9zZSlcbiAgICAgICAgICAgICAgICAgICAgZm9yY2VCYXNlID0gdGhpcy5zdGFja0lEKGZvcmNlKSArIFwiIC0+IFwiO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZm9yIChsZXQgaW5zZXJ0IG9mIHN0YWNrLnJlY292ZXJCeUluc2VydCh0b2tlbikpIHtcbiAgICAgICAgICAgICAgICBpZiAodmVyYm9zZSlcbiAgICAgICAgICAgICAgICAgICAgY29uc29sZS5sb2coYmFzZSArIHRoaXMuc3RhY2tJRChpbnNlcnQpICsgXCIgKHZpYSByZWNvdmVyLWluc2VydClcIik7XG4gICAgICAgICAgICAgICAgdGhpcy5hZHZhbmNlRnVsbHkoaW5zZXJ0LCBuZXdTdGFja3MpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHRoaXMuc3RyZWFtLmVuZCA+IHN0YWNrLnBvcykge1xuICAgICAgICAgICAgICAgIGlmICh0b2tlbkVuZCA9PSBzdGFjay5wb3MpIHtcbiAgICAgICAgICAgICAgICAgICAgdG9rZW5FbmQrKztcbiAgICAgICAgICAgICAgICAgICAgdG9rZW4gPSAwIC8qIEVyciAqLztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgc3RhY2sucmVjb3ZlckJ5RGVsZXRlKHRva2VuLCB0b2tlbkVuZCk7XG4gICAgICAgICAgICAgICAgaWYgKHZlcmJvc2UpXG4gICAgICAgICAgICAgICAgICAgIGNvbnNvbGUubG9nKGJhc2UgKyB0aGlzLnN0YWNrSUQoc3RhY2spICsgYCAodmlhIHJlY292ZXItZGVsZXRlICR7dGhpcy5wYXJzZXIuZ2V0TmFtZSh0b2tlbil9KWApO1xuICAgICAgICAgICAgICAgIHB1c2hTdGFja0RlZHVwKHN0YWNrLCBuZXdTdGFja3MpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAoIWZpbmlzaGVkIHx8IGZpbmlzaGVkLnNjb3JlIDwgc3RhY2suc2NvcmUpIHtcbiAgICAgICAgICAgICAgICBmaW5pc2hlZCA9IHN0YWNrO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBmaW5pc2hlZDtcbiAgICB9XG4gICAgLy8gQ29udmVydCB0aGUgc3RhY2sncyBidWZmZXIgdG8gYSBzeW50YXggdHJlZS5cbiAgICBzdGFja1RvVHJlZShzdGFjaykge1xuICAgICAgICBzdGFjay5jbG9zZSgpO1xuICAgICAgICByZXR1cm4gY29tbW9uLlRyZWUuYnVpbGQoeyBidWZmZXI6IFN0YWNrQnVmZmVyQ3Vyc29yLmNyZWF0ZShzdGFjayksXG4gICAgICAgICAgICBub2RlU2V0OiB0aGlzLnBhcnNlci5ub2RlU2V0LFxuICAgICAgICAgICAgdG9wSUQ6IHRoaXMudG9wVGVybSxcbiAgICAgICAgICAgIG1heEJ1ZmZlckxlbmd0aDogdGhpcy5wYXJzZXIuYnVmZmVyTGVuZ3RoLFxuICAgICAgICAgICAgcmV1c2VkOiB0aGlzLnJldXNlZCxcbiAgICAgICAgICAgIHN0YXJ0OiB0aGlzLnJhbmdlc1swXS5mcm9tLFxuICAgICAgICAgICAgbGVuZ3RoOiBzdGFjay5wb3MgLSB0aGlzLnJhbmdlc1swXS5mcm9tLFxuICAgICAgICAgICAgbWluUmVwZWF0VHlwZTogdGhpcy5wYXJzZXIubWluUmVwZWF0VGVybSB9KTtcbiAgICB9XG4gICAgc3RhY2tJRChzdGFjaykge1xuICAgICAgICBsZXQgaWQgPSAoc3RhY2tJRHMgfHwgKHN0YWNrSURzID0gbmV3IFdlYWtNYXApKS5nZXQoc3RhY2spO1xuICAgICAgICBpZiAoIWlkKVxuICAgICAgICAgICAgc3RhY2tJRHMuc2V0KHN0YWNrLCBpZCA9IFN0cmluZy5mcm9tQ29kZVBvaW50KHRoaXMubmV4dFN0YWNrSUQrKykpO1xuICAgICAgICByZXR1cm4gaWQgKyBzdGFjaztcbiAgICB9XG59XG5mdW5jdGlvbiBwdXNoU3RhY2tEZWR1cChzdGFjaywgbmV3U3RhY2tzKSB7XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBuZXdTdGFja3MubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgbGV0IG90aGVyID0gbmV3U3RhY2tzW2ldO1xuICAgICAgICBpZiAob3RoZXIucG9zID09IHN0YWNrLnBvcyAmJiBvdGhlci5zYW1lU3RhdGUoc3RhY2spKSB7XG4gICAgICAgICAgICBpZiAobmV3U3RhY2tzW2ldLnNjb3JlIDwgc3RhY2suc2NvcmUpXG4gICAgICAgICAgICAgICAgbmV3U3RhY2tzW2ldID0gc3RhY2s7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICB9XG4gICAgbmV3U3RhY2tzLnB1c2goc3RhY2spO1xufVxuY2xhc3MgRGlhbGVjdCB7XG4gICAgY29uc3RydWN0b3Ioc291cmNlLCBmbGFncywgZGlzYWJsZWQpIHtcbiAgICAgICAgdGhpcy5zb3VyY2UgPSBzb3VyY2U7XG4gICAgICAgIHRoaXMuZmxhZ3MgPSBmbGFncztcbiAgICAgICAgdGhpcy5kaXNhYmxlZCA9IGRpc2FibGVkO1xuICAgIH1cbiAgICBhbGxvd3ModGVybSkgeyByZXR1cm4gIXRoaXMuZGlzYWJsZWQgfHwgdGhpcy5kaXNhYmxlZFt0ZXJtXSA9PSAwOyB9XG59XG5jb25zdCBpZCA9IHggPT4geDtcbi8vLyBDb250ZXh0IHRyYWNrZXJzIGFyZSB1c2VkIHRvIHRyYWNrIHN0YXRlZnVsIGNvbnRleHQgKHN1Y2ggYXNcbi8vLyBpbmRlbnRhdGlvbiBpbiB0aGUgUHl0aG9uIGdyYW1tYXIsIG9yIHBhcmVudCBlbGVtZW50cyBpbiB0aGUgWE1MXG4vLy8gZ3JhbW1hcikgbmVlZGVkIGJ5IGV4dGVybmFsIHRva2VuaXplcnMuIFlvdSBkZWNsYXJlIHRoZW0gaW4gYVxuLy8vIGdyYW1tYXIgZmlsZSBhcyBgQGNvbnRleHQgZXhwb3J0TmFtZSBmcm9tIFwibW9kdWxlXCJgLlxuLy8vXG4vLy8gQ29udGV4dCB2YWx1ZXMgc2hvdWxkIGJlIGltbXV0YWJsZSwgYW5kIGNhbiBiZSB1cGRhdGVkIChyZXBsYWNlZClcbi8vLyBvbiBzaGlmdCBvciByZWR1Y2UgYWN0aW9ucy5cbi8vL1xuLy8vIFRoZSBleHBvcnQgdXNlZCBpbiBhIGBAY29udGV4dGAgZGVjbGFyYXRpb24gc2hvdWxkIGJlIG9mIHRoaXNcbi8vLyB0eXBlLlxuY2xhc3MgQ29udGV4dFRyYWNrZXIge1xuICAgIC8vLyBEZWZpbmUgYSBjb250ZXh0IHRyYWNrZXIuXG4gICAgY29uc3RydWN0b3Ioc3BlYykge1xuICAgICAgICB0aGlzLnN0YXJ0ID0gc3BlYy5zdGFydDtcbiAgICAgICAgdGhpcy5zaGlmdCA9IHNwZWMuc2hpZnQgfHwgaWQ7XG4gICAgICAgIHRoaXMucmVkdWNlID0gc3BlYy5yZWR1Y2UgfHwgaWQ7XG4gICAgICAgIHRoaXMucmV1c2UgPSBzcGVjLnJldXNlIHx8IGlkO1xuICAgICAgICB0aGlzLmhhc2ggPSBzcGVjLmhhc2ggfHwgKCgpID0+IDApO1xuICAgICAgICB0aGlzLnN0cmljdCA9IHNwZWMuc3RyaWN0ICE9PSBmYWxzZTtcbiAgICB9XG59XG4vLy8gQSBwYXJzZXIgaG9sZHMgdGhlIHBhcnNlIHRhYmxlcyBmb3IgYSBnaXZlbiBncmFtbWFyLCBhcyBnZW5lcmF0ZWRcbi8vLyBieSBgbGV6ZXItZ2VuZXJhdG9yYC5cbmNsYXNzIExSUGFyc2VyIGV4dGVuZHMgY29tbW9uLlBhcnNlciB7XG4gICAgLy8vIEBpbnRlcm5hbFxuICAgIGNvbnN0cnVjdG9yKHNwZWMpIHtcbiAgICAgICAgc3VwZXIoKTtcbiAgICAgICAgLy8vIEBpbnRlcm5hbFxuICAgICAgICB0aGlzLndyYXBwZXJzID0gW107XG4gICAgICAgIGlmIChzcGVjLnZlcnNpb24gIT0gMTQgLyogVmVyc2lvbiAqLylcbiAgICAgICAgICAgIHRocm93IG5ldyBSYW5nZUVycm9yKGBQYXJzZXIgdmVyc2lvbiAoJHtzcGVjLnZlcnNpb259KSBkb2Vzbid0IG1hdGNoIHJ1bnRpbWUgdmVyc2lvbiAoJHsxNCAvKiBWZXJzaW9uICovfSlgKTtcbiAgICAgICAgbGV0IG5vZGVOYW1lcyA9IHNwZWMubm9kZU5hbWVzLnNwbGl0KFwiIFwiKTtcbiAgICAgICAgdGhpcy5taW5SZXBlYXRUZXJtID0gbm9kZU5hbWVzLmxlbmd0aDtcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBzcGVjLnJlcGVhdE5vZGVDb3VudDsgaSsrKVxuICAgICAgICAgICAgbm9kZU5hbWVzLnB1c2goXCJcIik7XG4gICAgICAgIGxldCB0b3BUZXJtcyA9IE9iamVjdC5rZXlzKHNwZWMudG9wUnVsZXMpLm1hcChyID0+IHNwZWMudG9wUnVsZXNbcl1bMV0pO1xuICAgICAgICBsZXQgbm9kZVByb3BzID0gW107XG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgbm9kZU5hbWVzLmxlbmd0aDsgaSsrKVxuICAgICAgICAgICAgbm9kZVByb3BzLnB1c2goW10pO1xuICAgICAgICBmdW5jdGlvbiBzZXRQcm9wKG5vZGVJRCwgcHJvcCwgdmFsdWUpIHtcbiAgICAgICAgICAgIG5vZGVQcm9wc1tub2RlSURdLnB1c2goW3Byb3AsIHByb3AuZGVzZXJpYWxpemUoU3RyaW5nKHZhbHVlKSldKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoc3BlYy5ub2RlUHJvcHMpXG4gICAgICAgICAgICBmb3IgKGxldCBwcm9wU3BlYyBvZiBzcGVjLm5vZGVQcm9wcykge1xuICAgICAgICAgICAgICAgIGxldCBwcm9wID0gcHJvcFNwZWNbMF07XG4gICAgICAgICAgICAgICAgaWYgKHR5cGVvZiBwcm9wID09IFwic3RyaW5nXCIpXG4gICAgICAgICAgICAgICAgICAgIHByb3AgPSBjb21tb24uTm9kZVByb3BbcHJvcF07XG4gICAgICAgICAgICAgICAgZm9yIChsZXQgaSA9IDE7IGkgPCBwcm9wU3BlYy5sZW5ndGg7KSB7XG4gICAgICAgICAgICAgICAgICAgIGxldCBuZXh0ID0gcHJvcFNwZWNbaSsrXTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKG5leHQgPj0gMCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgc2V0UHJvcChuZXh0LCBwcm9wLCBwcm9wU3BlY1tpKytdKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGxldCB2YWx1ZSA9IHByb3BTcGVjW2kgKyAtbmV4dF07XG4gICAgICAgICAgICAgICAgICAgICAgICBmb3IgKGxldCBqID0gLW5leHQ7IGogPiAwOyBqLS0pXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgc2V0UHJvcChwcm9wU3BlY1tpKytdLCBwcm9wLCB2YWx1ZSk7XG4gICAgICAgICAgICAgICAgICAgICAgICBpKys7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIHRoaXMubm9kZVNldCA9IG5ldyBjb21tb24uTm9kZVNldChub2RlTmFtZXMubWFwKChuYW1lLCBpKSA9PiBjb21tb24uTm9kZVR5cGUuZGVmaW5lKHtcbiAgICAgICAgICAgIG5hbWU6IGkgPj0gdGhpcy5taW5SZXBlYXRUZXJtID8gdW5kZWZpbmVkIDogbmFtZSxcbiAgICAgICAgICAgIGlkOiBpLFxuICAgICAgICAgICAgcHJvcHM6IG5vZGVQcm9wc1tpXSxcbiAgICAgICAgICAgIHRvcDogdG9wVGVybXMuaW5kZXhPZihpKSA+IC0xLFxuICAgICAgICAgICAgZXJyb3I6IGkgPT0gMCxcbiAgICAgICAgICAgIHNraXBwZWQ6IHNwZWMuc2tpcHBlZE5vZGVzICYmIHNwZWMuc2tpcHBlZE5vZGVzLmluZGV4T2YoaSkgPiAtMVxuICAgICAgICB9KSkpO1xuICAgICAgICBpZiAoc3BlYy5wcm9wU291cmNlcylcbiAgICAgICAgICAgIHRoaXMubm9kZVNldCA9IHRoaXMubm9kZVNldC5leHRlbmQoLi4uc3BlYy5wcm9wU291cmNlcyk7XG4gICAgICAgIHRoaXMuc3RyaWN0ID0gZmFsc2U7XG4gICAgICAgIHRoaXMuYnVmZmVyTGVuZ3RoID0gY29tbW9uLkRlZmF1bHRCdWZmZXJMZW5ndGg7XG4gICAgICAgIGxldCB0b2tlbkFycmF5ID0gZGVjb2RlQXJyYXkoc3BlYy50b2tlbkRhdGEpO1xuICAgICAgICB0aGlzLmNvbnRleHQgPSBzcGVjLmNvbnRleHQ7XG4gICAgICAgIHRoaXMuc3BlY2lhbGl6ZWQgPSBuZXcgVWludDE2QXJyYXkoc3BlYy5zcGVjaWFsaXplZCA/IHNwZWMuc3BlY2lhbGl6ZWQubGVuZ3RoIDogMCk7XG4gICAgICAgIHRoaXMuc3BlY2lhbGl6ZXJzID0gW107XG4gICAgICAgIGlmIChzcGVjLnNwZWNpYWxpemVkKVxuICAgICAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBzcGVjLnNwZWNpYWxpemVkLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5zcGVjaWFsaXplZFtpXSA9IHNwZWMuc3BlY2lhbGl6ZWRbaV0udGVybTtcbiAgICAgICAgICAgICAgICB0aGlzLnNwZWNpYWxpemVyc1tpXSA9IHNwZWMuc3BlY2lhbGl6ZWRbaV0uZ2V0O1xuICAgICAgICAgICAgfVxuICAgICAgICB0aGlzLnN0YXRlcyA9IGRlY29kZUFycmF5KHNwZWMuc3RhdGVzLCBVaW50MzJBcnJheSk7XG4gICAgICAgIHRoaXMuZGF0YSA9IGRlY29kZUFycmF5KHNwZWMuc3RhdGVEYXRhKTtcbiAgICAgICAgdGhpcy5nb3RvID0gZGVjb2RlQXJyYXkoc3BlYy5nb3RvKTtcbiAgICAgICAgdGhpcy5tYXhUZXJtID0gc3BlYy5tYXhUZXJtO1xuICAgICAgICB0aGlzLnRva2VuaXplcnMgPSBzcGVjLnRva2VuaXplcnMubWFwKHZhbHVlID0+IHR5cGVvZiB2YWx1ZSA9PSBcIm51bWJlclwiID8gbmV3IFRva2VuR3JvdXAodG9rZW5BcnJheSwgdmFsdWUpIDogdmFsdWUpO1xuICAgICAgICB0aGlzLnRvcFJ1bGVzID0gc3BlYy50b3BSdWxlcztcbiAgICAgICAgdGhpcy5kaWFsZWN0cyA9IHNwZWMuZGlhbGVjdHMgfHwge307XG4gICAgICAgIHRoaXMuZHluYW1pY1ByZWNlZGVuY2VzID0gc3BlYy5keW5hbWljUHJlY2VkZW5jZXMgfHwgbnVsbDtcbiAgICAgICAgdGhpcy50b2tlblByZWNUYWJsZSA9IHNwZWMudG9rZW5QcmVjO1xuICAgICAgICB0aGlzLnRlcm1OYW1lcyA9IHNwZWMudGVybU5hbWVzIHx8IG51bGw7XG4gICAgICAgIHRoaXMubWF4Tm9kZSA9IHRoaXMubm9kZVNldC50eXBlcy5sZW5ndGggLSAxO1xuICAgICAgICB0aGlzLmRpYWxlY3QgPSB0aGlzLnBhcnNlRGlhbGVjdCgpO1xuICAgICAgICB0aGlzLnRvcCA9IHRoaXMudG9wUnVsZXNbT2JqZWN0LmtleXModGhpcy50b3BSdWxlcylbMF1dO1xuICAgIH1cbiAgICBjcmVhdGVQYXJzZShpbnB1dCwgZnJhZ21lbnRzLCByYW5nZXMpIHtcbiAgICAgICAgbGV0IHBhcnNlID0gbmV3IFBhcnNlKHRoaXMsIGlucHV0LCBmcmFnbWVudHMsIHJhbmdlcyk7XG4gICAgICAgIGZvciAobGV0IHcgb2YgdGhpcy53cmFwcGVycylcbiAgICAgICAgICAgIHBhcnNlID0gdyhwYXJzZSwgaW5wdXQsIGZyYWdtZW50cywgcmFuZ2VzKTtcbiAgICAgICAgcmV0dXJuIHBhcnNlO1xuICAgIH1cbiAgICAvLy8gR2V0IGEgZ290byB0YWJsZSBlbnRyeSBAaW50ZXJuYWxcbiAgICBnZXRHb3RvKHN0YXRlLCB0ZXJtLCBsb29zZSA9IGZhbHNlKSB7XG4gICAgICAgIGxldCB0YWJsZSA9IHRoaXMuZ290bztcbiAgICAgICAgaWYgKHRlcm0gPj0gdGFibGVbMF0pXG4gICAgICAgICAgICByZXR1cm4gLTE7XG4gICAgICAgIGZvciAobGV0IHBvcyA9IHRhYmxlW3Rlcm0gKyAxXTs7KSB7XG4gICAgICAgICAgICBsZXQgZ3JvdXBUYWcgPSB0YWJsZVtwb3MrK10sIGxhc3QgPSBncm91cFRhZyAmIDE7XG4gICAgICAgICAgICBsZXQgdGFyZ2V0ID0gdGFibGVbcG9zKytdO1xuICAgICAgICAgICAgaWYgKGxhc3QgJiYgbG9vc2UpXG4gICAgICAgICAgICAgICAgcmV0dXJuIHRhcmdldDtcbiAgICAgICAgICAgIGZvciAobGV0IGVuZCA9IHBvcyArIChncm91cFRhZyA+PiAxKTsgcG9zIDwgZW5kOyBwb3MrKylcbiAgICAgICAgICAgICAgICBpZiAodGFibGVbcG9zXSA9PSBzdGF0ZSlcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRhcmdldDtcbiAgICAgICAgICAgIGlmIChsYXN0KVxuICAgICAgICAgICAgICAgIHJldHVybiAtMTtcbiAgICAgICAgfVxuICAgIH1cbiAgICAvLy8gQ2hlY2sgaWYgdGhpcyBzdGF0ZSBoYXMgYW4gYWN0aW9uIGZvciBhIGdpdmVuIHRlcm1pbmFsIEBpbnRlcm5hbFxuICAgIGhhc0FjdGlvbihzdGF0ZSwgdGVybWluYWwpIHtcbiAgICAgICAgbGV0IGRhdGEgPSB0aGlzLmRhdGE7XG4gICAgICAgIGZvciAobGV0IHNldCA9IDA7IHNldCA8IDI7IHNldCsrKSB7XG4gICAgICAgICAgICBmb3IgKGxldCBpID0gdGhpcy5zdGF0ZVNsb3Qoc3RhdGUsIHNldCA/IDIgLyogU2tpcCAqLyA6IDEgLyogQWN0aW9ucyAqLyksIG5leHQ7OyBpICs9IDMpIHtcbiAgICAgICAgICAgICAgICBpZiAoKG5leHQgPSBkYXRhW2ldKSA9PSA2NTUzNSAvKiBFbmQgKi8pIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGRhdGFbaSArIDFdID09IDEgLyogTmV4dCAqLylcbiAgICAgICAgICAgICAgICAgICAgICAgIG5leHQgPSBkYXRhW2kgPSBwYWlyKGRhdGEsIGkgKyAyKV07XG4gICAgICAgICAgICAgICAgICAgIGVsc2UgaWYgKGRhdGFbaSArIDFdID09IDIgLyogT3RoZXIgKi8pXG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gcGFpcihkYXRhLCBpICsgMik7XG4gICAgICAgICAgICAgICAgICAgIGVsc2VcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAobmV4dCA9PSB0ZXJtaW5hbCB8fCBuZXh0ID09IDAgLyogRXJyICovKVxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gcGFpcihkYXRhLCBpICsgMSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIDA7XG4gICAgfVxuICAgIC8vLyBAaW50ZXJuYWxcbiAgICBzdGF0ZVNsb3Qoc3RhdGUsIHNsb3QpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuc3RhdGVzWyhzdGF0ZSAqIDYgLyogU2l6ZSAqLykgKyBzbG90XTtcbiAgICB9XG4gICAgLy8vIEBpbnRlcm5hbFxuICAgIHN0YXRlRmxhZyhzdGF0ZSwgZmxhZykge1xuICAgICAgICByZXR1cm4gKHRoaXMuc3RhdGVTbG90KHN0YXRlLCAwIC8qIEZsYWdzICovKSAmIGZsYWcpID4gMDtcbiAgICB9XG4gICAgLy8vIEBpbnRlcm5hbFxuICAgIHZhbGlkQWN0aW9uKHN0YXRlLCBhY3Rpb24pIHtcbiAgICAgICAgaWYgKGFjdGlvbiA9PSB0aGlzLnN0YXRlU2xvdChzdGF0ZSwgNCAvKiBEZWZhdWx0UmVkdWNlICovKSlcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICBmb3IgKGxldCBpID0gdGhpcy5zdGF0ZVNsb3Qoc3RhdGUsIDEgLyogQWN0aW9ucyAqLyk7OyBpICs9IDMpIHtcbiAgICAgICAgICAgIGlmICh0aGlzLmRhdGFbaV0gPT0gNjU1MzUgLyogRW5kICovKSB7XG4gICAgICAgICAgICAgICAgaWYgKHRoaXMuZGF0YVtpICsgMV0gPT0gMSAvKiBOZXh0ICovKVxuICAgICAgICAgICAgICAgICAgICBpID0gcGFpcih0aGlzLmRhdGEsIGkgKyAyKTtcbiAgICAgICAgICAgICAgICBlbHNlXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChhY3Rpb24gPT0gcGFpcih0aGlzLmRhdGEsIGkgKyAxKSlcbiAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgfVxuICAgIH1cbiAgICAvLy8gR2V0IHRoZSBzdGF0ZXMgdGhhdCBjYW4gZm9sbG93IHRoaXMgb25lIHRocm91Z2ggc2hpZnQgYWN0aW9ucyBvclxuICAgIC8vLyBnb3RvIGp1bXBzLiBAaW50ZXJuYWxcbiAgICBuZXh0U3RhdGVzKHN0YXRlKSB7XG4gICAgICAgIGxldCByZXN1bHQgPSBbXTtcbiAgICAgICAgZm9yIChsZXQgaSA9IHRoaXMuc3RhdGVTbG90KHN0YXRlLCAxIC8qIEFjdGlvbnMgKi8pOzsgaSArPSAzKSB7XG4gICAgICAgICAgICBpZiAodGhpcy5kYXRhW2ldID09IDY1NTM1IC8qIEVuZCAqLykge1xuICAgICAgICAgICAgICAgIGlmICh0aGlzLmRhdGFbaSArIDFdID09IDEgLyogTmV4dCAqLylcbiAgICAgICAgICAgICAgICAgICAgaSA9IHBhaXIodGhpcy5kYXRhLCBpICsgMik7XG4gICAgICAgICAgICAgICAgZWxzZVxuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICgodGhpcy5kYXRhW2kgKyAyXSAmICg2NTUzNiAvKiBSZWR1Y2VGbGFnICovID4+IDE2KSkgPT0gMCkge1xuICAgICAgICAgICAgICAgIGxldCB2YWx1ZSA9IHRoaXMuZGF0YVtpICsgMV07XG4gICAgICAgICAgICAgICAgaWYgKCFyZXN1bHQuc29tZSgodiwgaSkgPT4gKGkgJiAxKSAmJiB2ID09IHZhbHVlKSlcbiAgICAgICAgICAgICAgICAgICAgcmVzdWx0LnB1c2godGhpcy5kYXRhW2ldLCB2YWx1ZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG4gICAgLy8vIEBpbnRlcm5hbFxuICAgIG92ZXJyaWRlcyh0b2tlbiwgcHJldikge1xuICAgICAgICBsZXQgaVByZXYgPSBmaW5kT2Zmc2V0KHRoaXMuZGF0YSwgdGhpcy50b2tlblByZWNUYWJsZSwgcHJldik7XG4gICAgICAgIHJldHVybiBpUHJldiA8IDAgfHwgZmluZE9mZnNldCh0aGlzLmRhdGEsIHRoaXMudG9rZW5QcmVjVGFibGUsIHRva2VuKSA8IGlQcmV2O1xuICAgIH1cbiAgICAvLy8gQ29uZmlndXJlIHRoZSBwYXJzZXIuIFJldHVybnMgYSBuZXcgcGFyc2VyIGluc3RhbmNlIHRoYXQgaGFzIHRoZVxuICAgIC8vLyBnaXZlbiBzZXR0aW5ncyBtb2RpZmllZC4gU2V0dGluZ3Mgbm90IHByb3ZpZGVkIGluIGBjb25maWdgIGFyZVxuICAgIC8vLyBrZXB0IGZyb20gdGhlIG9yaWdpbmFsIHBhcnNlci5cbiAgICBjb25maWd1cmUoY29uZmlnKSB7XG4gICAgICAgIC8vIEhpZGVvdXMgcmVmbGVjdGlvbi1iYXNlZCBrbHVkZ2UgdG8gbWFrZSBpdCBlYXN5IHRvIGNyZWF0ZSBhXG4gICAgICAgIC8vIHNsaWdodGx5IG1vZGlmaWVkIGNvcHkgb2YgYSBwYXJzZXIuXG4gICAgICAgIGxldCBjb3B5ID0gT2JqZWN0LmFzc2lnbihPYmplY3QuY3JlYXRlKExSUGFyc2VyLnByb3RvdHlwZSksIHRoaXMpO1xuICAgICAgICBpZiAoY29uZmlnLnByb3BzKVxuICAgICAgICAgICAgY29weS5ub2RlU2V0ID0gdGhpcy5ub2RlU2V0LmV4dGVuZCguLi5jb25maWcucHJvcHMpO1xuICAgICAgICBpZiAoY29uZmlnLnRvcCkge1xuICAgICAgICAgICAgbGV0IGluZm8gPSB0aGlzLnRvcFJ1bGVzW2NvbmZpZy50b3BdO1xuICAgICAgICAgICAgaWYgKCFpbmZvKVxuICAgICAgICAgICAgICAgIHRocm93IG5ldyBSYW5nZUVycm9yKGBJbnZhbGlkIHRvcCBydWxlIG5hbWUgJHtjb25maWcudG9wfWApO1xuICAgICAgICAgICAgY29weS50b3AgPSBpbmZvO1xuICAgICAgICB9XG4gICAgICAgIGlmIChjb25maWcudG9rZW5pemVycylcbiAgICAgICAgICAgIGNvcHkudG9rZW5pemVycyA9IHRoaXMudG9rZW5pemVycy5tYXAodCA9PiB7XG4gICAgICAgICAgICAgICAgbGV0IGZvdW5kID0gY29uZmlnLnRva2VuaXplcnMuZmluZChyID0+IHIuZnJvbSA9PSB0KTtcbiAgICAgICAgICAgICAgICByZXR1cm4gZm91bmQgPyBmb3VuZC50byA6IHQ7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgaWYgKGNvbmZpZy5jb250ZXh0VHJhY2tlcilcbiAgICAgICAgICAgIGNvcHkuY29udGV4dCA9IGNvbmZpZy5jb250ZXh0VHJhY2tlcjtcbiAgICAgICAgaWYgKGNvbmZpZy5kaWFsZWN0KVxuICAgICAgICAgICAgY29weS5kaWFsZWN0ID0gdGhpcy5wYXJzZURpYWxlY3QoY29uZmlnLmRpYWxlY3QpO1xuICAgICAgICBpZiAoY29uZmlnLnN0cmljdCAhPSBudWxsKVxuICAgICAgICAgICAgY29weS5zdHJpY3QgPSBjb25maWcuc3RyaWN0O1xuICAgICAgICBpZiAoY29uZmlnLndyYXApXG4gICAgICAgICAgICBjb3B5LndyYXBwZXJzID0gY29weS53cmFwcGVycy5jb25jYXQoY29uZmlnLndyYXApO1xuICAgICAgICBpZiAoY29uZmlnLmJ1ZmZlckxlbmd0aCAhPSBudWxsKVxuICAgICAgICAgICAgY29weS5idWZmZXJMZW5ndGggPSBjb25maWcuYnVmZmVyTGVuZ3RoO1xuICAgICAgICByZXR1cm4gY29weTtcbiAgICB9XG4gICAgLy8vIFRlbGxzIHlvdSB3aGV0aGVyIGFueSBbcGFyc2Ugd3JhcHBlcnNdKCNsci5QYXJzZXJDb25maWcud3JhcClcbiAgICAvLy8gYXJlIHJlZ2lzdGVyZWQgZm9yIHRoaXMgcGFyc2VyLlxuICAgIGhhc1dyYXBwZXJzKCkge1xuICAgICAgICByZXR1cm4gdGhpcy53cmFwcGVycy5sZW5ndGggPiAwO1xuICAgIH1cbiAgICAvLy8gUmV0dXJucyB0aGUgbmFtZSBhc3NvY2lhdGVkIHdpdGggYSBnaXZlbiB0ZXJtLiBUaGlzIHdpbGwgb25seVxuICAgIC8vLyB3b3JrIGZvciBhbGwgdGVybXMgd2hlbiB0aGUgcGFyc2VyIHdhcyBnZW5lcmF0ZWQgd2l0aCB0aGVcbiAgICAvLy8gYC0tbmFtZXNgIG9wdGlvbi4gQnkgZGVmYXVsdCwgb25seSB0aGUgbmFtZXMgb2YgdGFnZ2VkIHRlcm1zIGFyZVxuICAgIC8vLyBzdG9yZWQuXG4gICAgZ2V0TmFtZSh0ZXJtKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnRlcm1OYW1lcyA/IHRoaXMudGVybU5hbWVzW3Rlcm1dIDogU3RyaW5nKHRlcm0gPD0gdGhpcy5tYXhOb2RlICYmIHRoaXMubm9kZVNldC50eXBlc1t0ZXJtXS5uYW1lIHx8IHRlcm0pO1xuICAgIH1cbiAgICAvLy8gVGhlIGVvZiB0ZXJtIGlkIGlzIGFsd2F5cyBhbGxvY2F0ZWQgZGlyZWN0bHkgYWZ0ZXIgdGhlIG5vZGVcbiAgICAvLy8gdHlwZXMuIEBpbnRlcm5hbFxuICAgIGdldCBlb2ZUZXJtKCkgeyByZXR1cm4gdGhpcy5tYXhOb2RlICsgMTsgfVxuICAgIC8vLyBUaGUgdHlwZSBvZiB0b3Agbm9kZSBwcm9kdWNlZCBieSB0aGUgcGFyc2VyLlxuICAgIGdldCB0b3BOb2RlKCkgeyByZXR1cm4gdGhpcy5ub2RlU2V0LnR5cGVzW3RoaXMudG9wWzFdXTsgfVxuICAgIC8vLyBAaW50ZXJuYWxcbiAgICBkeW5hbWljUHJlY2VkZW5jZSh0ZXJtKSB7XG4gICAgICAgIGxldCBwcmVjID0gdGhpcy5keW5hbWljUHJlY2VkZW5jZXM7XG4gICAgICAgIHJldHVybiBwcmVjID09IG51bGwgPyAwIDogcHJlY1t0ZXJtXSB8fCAwO1xuICAgIH1cbiAgICAvLy8gQGludGVybmFsXG4gICAgcGFyc2VEaWFsZWN0KGRpYWxlY3QpIHtcbiAgICAgICAgbGV0IHZhbHVlcyA9IE9iamVjdC5rZXlzKHRoaXMuZGlhbGVjdHMpLCBmbGFncyA9IHZhbHVlcy5tYXAoKCkgPT4gZmFsc2UpO1xuICAgICAgICBpZiAoZGlhbGVjdClcbiAgICAgICAgICAgIGZvciAobGV0IHBhcnQgb2YgZGlhbGVjdC5zcGxpdChcIiBcIikpIHtcbiAgICAgICAgICAgICAgICBsZXQgaWQgPSB2YWx1ZXMuaW5kZXhPZihwYXJ0KTtcbiAgICAgICAgICAgICAgICBpZiAoaWQgPj0gMClcbiAgICAgICAgICAgICAgICAgICAgZmxhZ3NbaWRdID0gdHJ1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgbGV0IGRpc2FibGVkID0gbnVsbDtcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCB2YWx1ZXMubGVuZ3RoOyBpKyspXG4gICAgICAgICAgICBpZiAoIWZsYWdzW2ldKSB7XG4gICAgICAgICAgICAgICAgZm9yIChsZXQgaiA9IHRoaXMuZGlhbGVjdHNbdmFsdWVzW2ldXSwgaWQ7IChpZCA9IHRoaXMuZGF0YVtqKytdKSAhPSA2NTUzNSAvKiBFbmQgKi87KVxuICAgICAgICAgICAgICAgICAgICAoZGlzYWJsZWQgfHwgKGRpc2FibGVkID0gbmV3IFVpbnQ4QXJyYXkodGhpcy5tYXhUZXJtICsgMSkpKVtpZF0gPSAxO1xuICAgICAgICAgICAgfVxuICAgICAgICByZXR1cm4gbmV3IERpYWxlY3QoZGlhbGVjdCwgZmxhZ3MsIGRpc2FibGVkKTtcbiAgICB9XG4gICAgLy8vICh1c2VkIGJ5IHRoZSBvdXRwdXQgb2YgdGhlIHBhcnNlciBnZW5lcmF0b3IpIEBpbnRlcm5hbFxuICAgIHN0YXRpYyBkZXNlcmlhbGl6ZShzcGVjKSB7XG4gICAgICAgIHJldHVybiBuZXcgTFJQYXJzZXIoc3BlYyk7XG4gICAgfVxufVxuZnVuY3Rpb24gcGFpcihkYXRhLCBvZmYpIHsgcmV0dXJuIGRhdGFbb2ZmXSB8IChkYXRhW29mZiArIDFdIDw8IDE2KTsgfVxuZnVuY3Rpb24gZmluZE9mZnNldChkYXRhLCBzdGFydCwgdGVybSkge1xuICAgIGZvciAobGV0IGkgPSBzdGFydCwgbmV4dDsgKG5leHQgPSBkYXRhW2ldKSAhPSA2NTUzNSAvKiBFbmQgKi87IGkrKylcbiAgICAgICAgaWYgKG5leHQgPT0gdGVybSlcbiAgICAgICAgICAgIHJldHVybiBpIC0gc3RhcnQ7XG4gICAgcmV0dXJuIC0xO1xufVxuZnVuY3Rpb24gZmluZEZpbmlzaGVkKHN0YWNrcykge1xuICAgIGxldCBiZXN0ID0gbnVsbDtcbiAgICBmb3IgKGxldCBzdGFjayBvZiBzdGFja3MpIHtcbiAgICAgICAgbGV0IHN0b3BwZWQgPSBzdGFjay5wLnN0b3BwZWRBdDtcbiAgICAgICAgaWYgKChzdGFjay5wb3MgPT0gc3RhY2sucC5zdHJlYW0uZW5kIHx8IHN0b3BwZWQgIT0gbnVsbCAmJiBzdGFjay5wb3MgPiBzdG9wcGVkKSAmJlxuICAgICAgICAgICAgc3RhY2sucC5wYXJzZXIuc3RhdGVGbGFnKHN0YWNrLnN0YXRlLCAyIC8qIEFjY2VwdGluZyAqLykgJiZcbiAgICAgICAgICAgICghYmVzdCB8fCBiZXN0LnNjb3JlIDwgc3RhY2suc2NvcmUpKVxuICAgICAgICAgICAgYmVzdCA9IHN0YWNrO1xuICAgIH1cbiAgICByZXR1cm4gYmVzdDtcbn1cblxuZXhwb3J0cy5Db250ZXh0VHJhY2tlciA9IENvbnRleHRUcmFja2VyO1xuZXhwb3J0cy5FeHRlcm5hbFRva2VuaXplciA9IEV4dGVybmFsVG9rZW5pemVyO1xuZXhwb3J0cy5JbnB1dFN0cmVhbSA9IElucHV0U3RyZWFtO1xuZXhwb3J0cy5MUlBhcnNlciA9IExSUGFyc2VyO1xuZXhwb3J0cy5TdGFjayA9IFN0YWNrO1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgJ19fZXNNb2R1bGUnLCB7IHZhbHVlOiB0cnVlIH0pO1xuXG52YXIgbHIgPSByZXF1aXJlKCdAbGV6ZXIvbHInKTtcbnZhciBoaWdobGlnaHQgPSByZXF1aXJlKCdAbGV6ZXIvaGlnaGxpZ2h0Jyk7XG5cbi8vIFRoaXMgZmlsZSB3YXMgZ2VuZXJhdGVkIGJ5IGxlemVyLWdlbmVyYXRvci4gWW91IHByb2JhYmx5IHNob3VsZG4ndCBlZGl0IGl0LlxuY29uc3QgcHJpbnRLZXl3b3JkID0gMSxcbiAgaW5kZW50ID0gMTYyLFxuICBkZWRlbnQgPSAxNjMsXG4gIG5ld2xpbmUkMSA9IDE2NCxcbiAgbmV3bGluZUJyYWNrZXRlZCA9IDE2NSxcbiAgbmV3bGluZUVtcHR5ID0gMTY2LFxuICBlb2YgPSAxNjcsXG4gIFBhcmVuTCA9IDIyLFxuICBQYXJlbnRoZXNpemVkRXhwcmVzc2lvbiA9IDIzLFxuICBUdXBsZUV4cHJlc3Npb24gPSA0NyxcbiAgQ29tcHJlaGVuc2lvbkV4cHJlc3Npb24gPSA0OCxcbiAgQnJhY2tldEwgPSA1MyxcbiAgQXJyYXlFeHByZXNzaW9uID0gNTQsXG4gIEFycmF5Q29tcHJlaGVuc2lvbkV4cHJlc3Npb24gPSA1NSxcbiAgQnJhY2VMID0gNTcsXG4gIERpY3Rpb25hcnlFeHByZXNzaW9uID0gNTgsXG4gIERpY3Rpb25hcnlDb21wcmVoZW5zaW9uRXhwcmVzc2lvbiA9IDU5LFxuICBTZXRFeHByZXNzaW9uID0gNjAsXG4gIFNldENvbXByZWhlbnNpb25FeHByZXNzaW9uID0gNjEsXG4gIEFyZ0xpc3QgPSA2MyxcbiAgc3Vic2NyaXB0ID0gMjAzLFxuICBGb3JtYXRSZXBsYWNlbWVudCA9IDcxLFxuICBpbXBvcnRMaXN0ID0gMjI4LFxuICBQYXJhbUxpc3QgPSAxMjE7XG5cbmNvbnN0IG5ld2xpbmUgPSAxMCwgY2FycmlhZ2VSZXR1cm4gPSAxMywgc3BhY2UgPSAzMiwgdGFiID0gOSwgaGFzaCA9IDM1LCBwYXJlbk9wZW4gPSA0MCwgZG90ID0gNDY7XG5cbmNvbnN0IGJyYWNrZXRlZCA9IFtcbiAgUGFyZW50aGVzaXplZEV4cHJlc3Npb24sIFR1cGxlRXhwcmVzc2lvbiwgQ29tcHJlaGVuc2lvbkV4cHJlc3Npb24sIGltcG9ydExpc3QsIEFyZ0xpc3QsIFBhcmFtTGlzdCxcbiAgQXJyYXlFeHByZXNzaW9uLCBBcnJheUNvbXByZWhlbnNpb25FeHByZXNzaW9uLCBzdWJzY3JpcHQsXG4gIFNldEV4cHJlc3Npb24sIFNldENvbXByZWhlbnNpb25FeHByZXNzaW9uLFxuICBEaWN0aW9uYXJ5RXhwcmVzc2lvbiwgRGljdGlvbmFyeUNvbXByZWhlbnNpb25FeHByZXNzaW9uLCBGb3JtYXRSZXBsYWNlbWVudFxuXTtcblxuY29uc3QgbmV3bGluZXMgPSBuZXcgbHIuRXh0ZXJuYWxUb2tlbml6ZXIoKGlucHV0LCBzdGFjaykgPT4ge1xuICBpZiAoaW5wdXQubmV4dCA8IDApIHtcbiAgICBpbnB1dC5hY2NlcHRUb2tlbihlb2YpO1xuICB9IGVsc2UgaWYgKGlucHV0Lm5leHQgIT0gbmV3bGluZSAmJiBpbnB1dC5uZXh0ICE9IGNhcnJpYWdlUmV0dXJuKSA7IGVsc2UgaWYgKHN0YWNrLmNvbnRleHQuZGVwdGggPCAwKSB7XG4gICAgaW5wdXQuYWNjZXB0VG9rZW4obmV3bGluZUJyYWNrZXRlZCwgMSk7XG4gIH0gZWxzZSB7XG4gICAgaW5wdXQuYWR2YW5jZSgpO1xuICAgIGxldCBzcGFjZXMgPSAwO1xuICAgIHdoaWxlIChpbnB1dC5uZXh0ID09IHNwYWNlIHx8IGlucHV0Lm5leHQgPT0gdGFiKSB7IGlucHV0LmFkdmFuY2UoKTsgc3BhY2VzKys7IH1cbiAgICBsZXQgZW1wdHkgPSBpbnB1dC5uZXh0ID09IG5ld2xpbmUgfHwgaW5wdXQubmV4dCA9PSBjYXJyaWFnZVJldHVybiB8fCBpbnB1dC5uZXh0ID09IGhhc2g7XG4gICAgaW5wdXQuYWNjZXB0VG9rZW4oZW1wdHkgPyBuZXdsaW5lRW1wdHkgOiBuZXdsaW5lJDEsIC1zcGFjZXMpO1xuICB9XG59LCB7Y29udGV4dHVhbDogdHJ1ZSwgZmFsbGJhY2s6IHRydWV9KTtcblxuY29uc3QgaW5kZW50YXRpb24gPSBuZXcgbHIuRXh0ZXJuYWxUb2tlbml6ZXIoKGlucHV0LCBzdGFjaykgPT4ge1xuICBsZXQgY0RlcHRoID0gc3RhY2suY29udGV4dC5kZXB0aDtcbiAgaWYgKGNEZXB0aCA8IDApIHJldHVyblxuICBsZXQgcHJldiA9IGlucHV0LnBlZWsoLTEpO1xuICBpZiAoKHByZXYgPT0gbmV3bGluZSB8fCBwcmV2ID09IGNhcnJpYWdlUmV0dXJuKSAmJiBzdGFjay5jb250ZXh0LmRlcHRoID49IDApIHtcbiAgICBsZXQgZGVwdGggPSAwLCBjaGFycyA9IDA7XG4gICAgZm9yICg7Oykge1xuICAgICAgaWYgKGlucHV0Lm5leHQgPT0gc3BhY2UpIGRlcHRoKys7XG4gICAgICBlbHNlIGlmIChpbnB1dC5uZXh0ID09IHRhYikgZGVwdGggKz0gOCAtIChkZXB0aCAlIDgpO1xuICAgICAgZWxzZSBicmVha1xuICAgICAgaW5wdXQuYWR2YW5jZSgpO1xuICAgICAgY2hhcnMrKztcbiAgICB9XG4gICAgaWYgKGRlcHRoICE9IGNEZXB0aCAmJlxuICAgICAgICBpbnB1dC5uZXh0ICE9IG5ld2xpbmUgJiYgaW5wdXQubmV4dCAhPSBjYXJyaWFnZVJldHVybiAmJiBpbnB1dC5uZXh0ICE9IGhhc2gpIHtcbiAgICAgIGlmIChkZXB0aCA8IGNEZXB0aCkgaW5wdXQuYWNjZXB0VG9rZW4oZGVkZW50LCAtY2hhcnMpO1xuICAgICAgZWxzZSBpbnB1dC5hY2NlcHRUb2tlbihpbmRlbnQpO1xuICAgIH1cbiAgfVxufSk7XG5cbmZ1bmN0aW9uIEluZGVudExldmVsKHBhcmVudCwgZGVwdGgpIHtcbiAgdGhpcy5wYXJlbnQgPSBwYXJlbnQ7XG4gIC8vIC0xIG1lYW5zIHRoaXMgaXMgbm90IGFuIGFjdHVhbCBpbmRlbnQgbGV2ZWwgYnV0IGEgc2V0IG9mIGJyYWNrZXRzXG4gIHRoaXMuZGVwdGggPSBkZXB0aDtcbiAgdGhpcy5oYXNoID0gKHBhcmVudCA/IHBhcmVudC5oYXNoICsgcGFyZW50Lmhhc2ggPDwgOCA6IDApICsgZGVwdGggKyAoZGVwdGggPDwgNCk7XG59XG5cbmNvbnN0IHRvcEluZGVudCA9IG5ldyBJbmRlbnRMZXZlbChudWxsLCAwKTtcblxuZnVuY3Rpb24gY291bnRJbmRlbnQoc3BhY2UpIHtcbiAgbGV0IGRlcHRoID0gMDtcbiAgZm9yIChsZXQgaSA9IDA7IGkgPCBzcGFjZS5sZW5ndGg7IGkrKylcbiAgICBkZXB0aCArPSBzcGFjZS5jaGFyQ29kZUF0KGkpID09IHRhYiA/IDggLSAoZGVwdGggJSA4KSA6IDE7XG4gIHJldHVybiBkZXB0aFxufVxuXG5jb25zdCB0cmFja0luZGVudCA9IG5ldyBsci5Db250ZXh0VHJhY2tlcih7XG4gIHN0YXJ0OiB0b3BJbmRlbnQsXG4gIHJlZHVjZShjb250ZXh0LCB0ZXJtKSB7XG4gICAgcmV0dXJuIGNvbnRleHQuZGVwdGggPCAwICYmIGJyYWNrZXRlZC5pbmRleE9mKHRlcm0pID4gLTEgPyBjb250ZXh0LnBhcmVudCA6IGNvbnRleHRcbiAgfSxcbiAgc2hpZnQoY29udGV4dCwgdGVybSwgc3RhY2ssIGlucHV0KSB7XG4gICAgaWYgKHRlcm0gPT0gaW5kZW50KSByZXR1cm4gbmV3IEluZGVudExldmVsKGNvbnRleHQsIGNvdW50SW5kZW50KGlucHV0LnJlYWQoaW5wdXQucG9zLCBzdGFjay5wb3MpKSlcbiAgICBpZiAodGVybSA9PSBkZWRlbnQpIHJldHVybiBjb250ZXh0LnBhcmVudFxuICAgIGlmICh0ZXJtID09IFBhcmVuTCB8fCB0ZXJtID09IEJyYWNrZXRMIHx8IHRlcm0gPT0gQnJhY2VMKSByZXR1cm4gbmV3IEluZGVudExldmVsKGNvbnRleHQsIC0xKVxuICAgIHJldHVybiBjb250ZXh0XG4gIH0sXG4gIGhhc2goY29udGV4dCkgeyByZXR1cm4gY29udGV4dC5oYXNoIH1cbn0pO1xuXG5jb25zdCBsZWdhY3lQcmludCA9IG5ldyBsci5FeHRlcm5hbFRva2VuaXplcihpbnB1dCA9PiB7XG4gIGZvciAobGV0IGkgPSAwOyBpIDwgNTsgaSsrKSB7XG4gICAgaWYgKGlucHV0Lm5leHQgIT0gXCJwcmludFwiLmNoYXJDb2RlQXQoaSkpIHJldHVyblxuICAgIGlucHV0LmFkdmFuY2UoKTtcbiAgfVxuICBpZiAoL1xcdy8udGVzdChTdHJpbmcuZnJvbUNoYXJDb2RlKGlucHV0Lm5leHQpKSkgcmV0dXJuXG4gIGZvciAobGV0IG9mZiA9IDA7OyBvZmYrKykge1xuICAgIGxldCBuZXh0ID0gaW5wdXQucGVlayhvZmYpO1xuICAgIGlmIChuZXh0ID09IHNwYWNlIHx8IG5leHQgPT0gdGFiKSBjb250aW51ZVxuICAgIGlmIChuZXh0ICE9IHBhcmVuT3BlbiAmJiBuZXh0ICE9IGRvdCAmJiBuZXh0ICE9IG5ld2xpbmUgJiYgbmV4dCAhPSBjYXJyaWFnZVJldHVybiAmJiBuZXh0ICE9IGhhc2gpXG4gICAgICBpbnB1dC5hY2NlcHRUb2tlbihwcmludEtleXdvcmQpO1xuICAgIHJldHVyblxuICB9XG59KTtcblxuY29uc3QgcHl0aG9uSGlnaGxpZ2h0aW5nID0gaGlnaGxpZ2h0LnN0eWxlVGFncyh7XG4gIFwiYXN5bmMgXFxcIipcXFwiIFxcXCIqKlxcXCIgRm9ybWF0Q29udmVyc2lvbiBGb3JtYXRTcGVjXCI6IGhpZ2hsaWdodC50YWdzLm1vZGlmaWVyLFxuICBcImZvciB3aGlsZSBpZiBlbGlmIGVsc2UgdHJ5IGV4Y2VwdCBmaW5hbGx5IHJldHVybiByYWlzZSBicmVhayBjb250aW51ZSB3aXRoIHBhc3MgYXNzZXJ0IGF3YWl0IHlpZWxkXCI6IGhpZ2hsaWdodC50YWdzLmNvbnRyb2xLZXl3b3JkLFxuICBcImluIG5vdCBhbmQgb3IgaXMgZGVsXCI6IGhpZ2hsaWdodC50YWdzLm9wZXJhdG9yS2V5d29yZCxcbiAgXCJmcm9tIGRlZiBjbGFzcyBnbG9iYWwgbm9ubG9jYWwgbGFtYmRhXCI6IGhpZ2hsaWdodC50YWdzLmRlZmluaXRpb25LZXl3b3JkLFxuICBpbXBvcnQ6IGhpZ2hsaWdodC50YWdzLm1vZHVsZUtleXdvcmQsXG4gIFwid2l0aCBhcyBwcmludFwiOiBoaWdobGlnaHQudGFncy5rZXl3b3JkLFxuICBCb29sZWFuOiBoaWdobGlnaHQudGFncy5ib29sLFxuICBOb25lOiBoaWdobGlnaHQudGFncy5udWxsLFxuICBWYXJpYWJsZU5hbWU6IGhpZ2hsaWdodC50YWdzLnZhcmlhYmxlTmFtZSxcbiAgXCJDYWxsRXhwcmVzc2lvbi9WYXJpYWJsZU5hbWVcIjogaGlnaGxpZ2h0LnRhZ3MuZnVuY3Rpb24oaGlnaGxpZ2h0LnRhZ3MudmFyaWFibGVOYW1lKSxcbiAgXCJGdW5jdGlvbkRlZmluaXRpb24vVmFyaWFibGVOYW1lXCI6IGhpZ2hsaWdodC50YWdzLmZ1bmN0aW9uKGhpZ2hsaWdodC50YWdzLmRlZmluaXRpb24oaGlnaGxpZ2h0LnRhZ3MudmFyaWFibGVOYW1lKSksXG4gIFwiQ2xhc3NEZWZpbml0aW9uL1ZhcmlhYmxlTmFtZVwiOiBoaWdobGlnaHQudGFncy5kZWZpbml0aW9uKGhpZ2hsaWdodC50YWdzLmNsYXNzTmFtZSksXG4gIFByb3BlcnR5TmFtZTogaGlnaGxpZ2h0LnRhZ3MucHJvcGVydHlOYW1lLFxuICBcIkNhbGxFeHByZXNzaW9uL01lbWJlckV4cHJlc3Npb24vUHJvcGVydHlOYW1lXCI6IGhpZ2hsaWdodC50YWdzLmZ1bmN0aW9uKGhpZ2hsaWdodC50YWdzLnByb3BlcnR5TmFtZSksXG4gIENvbW1lbnQ6IGhpZ2hsaWdodC50YWdzLmxpbmVDb21tZW50LFxuICBOdW1iZXI6IGhpZ2hsaWdodC50YWdzLm51bWJlcixcbiAgU3RyaW5nOiBoaWdobGlnaHQudGFncy5zdHJpbmcsXG4gIEZvcm1hdFN0cmluZzogaGlnaGxpZ2h0LnRhZ3Muc3BlY2lhbChoaWdobGlnaHQudGFncy5zdHJpbmcpLFxuICBVcGRhdGVPcDogaGlnaGxpZ2h0LnRhZ3MudXBkYXRlT3BlcmF0b3IsXG4gIEFyaXRoT3A6IGhpZ2hsaWdodC50YWdzLmFyaXRobWV0aWNPcGVyYXRvcixcbiAgQml0T3A6IGhpZ2hsaWdodC50YWdzLmJpdHdpc2VPcGVyYXRvcixcbiAgQ29tcGFyZU9wOiBoaWdobGlnaHQudGFncy5jb21wYXJlT3BlcmF0b3IsXG4gIEFzc2lnbk9wOiBoaWdobGlnaHQudGFncy5kZWZpbml0aW9uT3BlcmF0b3IsXG4gIEVsbGlwc2lzOiBoaWdobGlnaHQudGFncy5wdW5jdHVhdGlvbixcbiAgQXQ6IGhpZ2hsaWdodC50YWdzLm1ldGEsXG4gIFwiKCApXCI6IGhpZ2hsaWdodC50YWdzLnBhcmVuLFxuICBcIlsgXVwiOiBoaWdobGlnaHQudGFncy5zcXVhcmVCcmFja2V0LFxuICBcInsgfVwiOiBoaWdobGlnaHQudGFncy5icmFjZSxcbiAgXCIuXCI6IGhpZ2hsaWdodC50YWdzLmRlcmVmT3BlcmF0b3IsXG4gIFwiLCA7XCI6IGhpZ2hsaWdodC50YWdzLnNlcGFyYXRvclxufSk7XG5cbi8vIFRoaXMgZmlsZSB3YXMgZ2VuZXJhdGVkIGJ5IGxlemVyLWdlbmVyYXRvci4gWW91IHByb2JhYmx5IHNob3VsZG4ndCBlZGl0IGl0LlxuY29uc3Qgc3BlY19pZGVudGlmaWVyID0ge19fcHJvdG9fXzpudWxsLGF3YWl0OjQwLCBvcjo1MCwgYW5kOjUyLCBpbjo1Niwgbm90OjU4LCBpczo2MCwgaWY6NjYsIGVsc2U6NjgsIGxhbWJkYTo3MiwgeWllbGQ6OTAsIGZyb206OTIsIGFzeW5jOjk4LCBmb3I6MTAwLCBOb25lOjE1MiwgVHJ1ZToxNTQsIEZhbHNlOjE1NCwgZGVsOjE2OCwgcGFzczoxNzIsIGJyZWFrOjE3NiwgY29udGludWU6MTgwLCByZXR1cm46MTg0LCByYWlzZToxOTIsIGltcG9ydDoxOTYsIGFzOjE5OCwgZ2xvYmFsOjIwMiwgbm9ubG9jYWw6MjA0LCBhc3NlcnQ6MjA4LCBlbGlmOjIxOCwgd2hpbGU6MjIyLCB0cnk6MjI4LCBleGNlcHQ6MjMwLCBmaW5hbGx5OjIzMiwgd2l0aDoyMzYsIGRlZjoyNDAsIGNsYXNzOjI1MH07XG5jb25zdCBwYXJzZXIgPSBsci5MUlBhcnNlci5kZXNlcmlhbGl6ZSh7XG4gIHZlcnNpb246IDE0LFxuICBzdGF0ZXM6IFwiIT9wT2BRJElYT09PJWNRJElbTycjR2FPT1EkSVMnI0NtJyNDbU9PUSRJUycjQ24nI0NuTydSUSRJV08nI0NsTyh0USRJW08nI0dgT09RJElTJyNHYScjR2FPT1EkSVMnI0RTJyNEU09PUSRJUycjR2AnI0dgTyliUSRJV08nI0NzTylyUSRJV08nI0RkTypTUSRJV08nI0RoT09RJElTJyNEcycjRHNPKmdPYE8nI0RzTypvT3BPJyNEc08qd08hYk8nI0R0TytTTyN0TycjRHRPK19PJmpPJyNEdE8rak8sVU8nI0R0Ty1sUSRJW08nI0dRT09RJElTJyNHUScjR1FPJ1JRJElXTycjR1BPL09RJElbTycjR1BPT1EkSVMnI0VdJyNFXU8vZ1EkSVdPJyNFXk9PUSRJUycjR08nI0dPTy9xUSRJV08nI0Z9T09RJElWJyNGfScjRn1PL3xRJElXTycjRlBPT1EkSVMnI0ZyJyNGck8wUlEkSVdPJyNGT09PUSRJVicjSF0nI0hdT09RJElWJyNGfCcjRnxPT1EkSVQnI0ZSJyNGUlFgUSRJWE9PTydSUSRJV08nI0NvTzBhUSRJV08nI0N7TzBoUSRJV08nI0RQTzB2USRJV08nI0dlTzFXUSRJW08nI0VRTydSUSRJV08nI0VST09RJElTJyNFVCcjRVRPT1EkSVMnI0VWJyNFVk9PUSRJUycjRVgnI0VYTzFsUSRJV08nI0VaTzJTUSRJV08nI0VfTy98USRJV08nI0VhTzJnUSRJW08nI0VhTy98USRJV08nI0VkTy9nUSRJV08nI0VnTy9nUSRJV08nI0VrTy9nUSRJV08nI0VuTzJyUSRJV08nI0VwTzJ5USRJV08nI0V1TzNVUSRJV08nI0VxTy9nUSRJV08nI0V1Ty98USRJV08nI0V3Ty98USRJV08nI0V8T09RJElTJyNDYycjQ2NPT1EkSVMnI0NkJyNDZE9PUSRJUycjQ2UnI0NlT09RJElTJyNDZicjQ2ZPT1EkSVMnI0NnJyNDZ09PUSRJUycjQ2gnI0NoT09RJElTJyNDaicjQ2pPJ1JRJElXTyw1OHxPJ1JRJElXTyw1OHxPJ1JRJElXTyw1OHxPJ1JRJElXTyw1OHxPJ1JRJElXTyw1OHxPJ1JRJElXTyw1OHxPM1pRJElXTycjRG1PT1EkSVMsNTpXLDU6V08zblEkSVdPJyNHb09PUSRJUyw1OlosNTpaTzN7USUxYE8sNTpaTzRRUSRJW08sNTlXTzBhUSRJV08sNTlgTzBhUSRJV08sNTlgTzBhUSRJV08sNTlgTzZwUSRJV08sNTlgTzZ1USRJV08sNTlgTzZ8USRJV08sNTloTzdUUSRJV08nI0dgTzhaUSRJV08nI0dfT09RJElTJyNHXycjR19PT1EkSVMnI0RZJyNEWU84clEkSVdPLDU5X08nUlEkSVdPLDU5X085UVEkSVdPLDU5X085VlEkSVdPLDU6UE8nUlEkSVdPLDU6UE9PUSRJUyw1Ok8sNTpPTzllUSRJV08sNTpPTzlqUSRJV08sNTpWTydSUSRJV08sNTpWTydSUSRJV08sNTpUT09RJElTLDU6Uyw1OlNPOXtRJElXTyw1OlNPOlFRJElXTyw1OlVPT09PJyNGWicjRlpPOlZPYE8sNTpfT09RJElTLDU6Xyw1Ol9PT09PJyNGWycjRltPOl9PcE8sNTpfTzpnUSRJV08nI0R1T09PTycjRl0nI0ZdTzp3TyFiTyw1OmBPT1EkSVMsNTpgLDU6YE9PT08nI0ZgJyNGYE87U08jdE8sNTpgT09PTycjRmEnI0ZhTztfTyZqTyw1OmBPT09PJyNGYicjRmJPO2pPLFVPLDU6YE9PUSRJUycjRmMnI0ZjTzt1USRJW08sNTpkTz5nUSRJW08sNTxrTz9RUSVHbE8sNTxrTz9xUSRJW08sNTxrT09RJElTLDU6eCw1OnhPQFlRJElYTycjRmtPQWlRJElXTyw1O1RPT1EkSVYsNTxpLDU8aU9BdFEkSVtPJyNIWE9CXVEkSVdPLDU7a09PUSRJUy1FOXAtRTlwT09RJElWLDU7aiw1O2pPM1BRJElXTycjRXdPT1EkSVQtRTlQLUU5UE9CZVEkSVtPLDU5Wk9EbFEkSVtPLDU5Z09FVlEkSVdPJyNHYk9FYlEkSVdPJyNHYk8vfFEkSVdPJyNHYk9FbVEkSVdPJyNEUk9FdVEkSVdPLDU5a09FelEkSVdPJyNHZk8nUlEkSVdPJyNHZk8vZ1EkSVdPLDU9UE9PUSRJUyw1PVAsNT1QTy9nUSRJV08nI0R8T09RJElTJyNEfScjRH1PRmlRJElXTycjRmVPRnlRJElXTyw1OHpPRnlRJElXTyw1OHpPKWVRJElXTyw1OmpPR1hRJElbTycjR2hPT1EkSVMsNTptLDU6bU9PUSRJUyw1OnUsNTp1T0dsUSRJV08sNTp5T0d9USRJV08sNTp7T09RJElTJyNGaCcjRmhPSF1RJElbTyw1OntPSGtRJElXTyw1OntPSHBRJElXTycjSFtPT1EkSVMsNTtPLDU7T09JT1EkSVdPJyNIV09PUSRJUyw1O1IsNTtSTzNVUSRJV08sNTtWTzNVUSRJV08sNTtZT0lhUSRJW08nI0heTydSUSRJV08nI0heT0lrUSRJV08sNTtbTzJyUSRJV08sNTtbTy9nUSRJV08sNTthTy98USRJV08sNTtjT0lwUSRJWE8nI0VsT0p5USRJWk8sNTtdT05bUSRJV08nI0hfTzNVUSRJV08sNTthT05nUSRJV08sNTtjT05sUSRJV08sNTtoTyEjYVEkSVtPMUcuaE8hI2hRJElbTzFHLmhPISZYUSRJW08xRy5oTyEmY1EkSVtPMUcuaE8hKHxRJElbTzFHLmhPISlhUSRJW08xRy5oTyEpdFEkSVdPJyNHbk8hKlNRJElbTycjR1FPL2dRJElXTycjR25PISpeUSRJV08nI0dtT09RJElTLDU6WCw1OlhPISpmUSRJV08sNTpYTyEqa1EkSVdPJyNHcE8hKnZRJElXTycjR3BPIStaUSRJV08sNT1aT09RJElTJyNEcScjRHFPT1EkSVMxRy91MUcvdU9PUSRJUzFHLnoxRy56TyEsWlEkSVtPMUcuek8hLGJRJElbTzFHLnpPMGFRJElXTzFHLnpPISx9USRJV08xRy9TT09RJElTJyNEWCcjRFhPL2dRJElXTyw1OXJPT1EkSVMxRy55MUcueU8hLVVRJElXTzFHL2NPIS1mUSRJV08xRy9jTyEtblEkSVdPMUcvZE8nUlEkSVdPJyNHZ08hLXNRJElXTycjR2dPIS14USRJW08xRy55TyEuWVEkSVdPLDU5Z08hL2BRJElXTyw1PVZPIS9wUSRJV08sNT1WTyEveFEkSVdPMUcva08hL31RJElbTzFHL2tPT1EkSVMxRy9qMUcvak8hMF9RJElXTyw1PVFPITFVUSRJV08sNT1RTy9nUSRJV08xRy9vTyExc1EkSVdPMUcvcU8hMXhRJElbTzFHL3FPITJZUSRJW08xRy9vT09RJElTMUcvbjFHL25PT1EkSVMxRy9wMUcvcE9PT08tRTlYLUU5WE9PUSRJUzFHL3kxRy95T09PTy1FOVktRTlZTyEyalEkSVdPJyNHe08vZ1EkSVdPJyNHe08hMnhRJElXTyw1OmFPT09PLUU5Wi1FOVpPT1EkSVMxRy96MUcvek9PT08tRTleLUU5Xk9PT08tRTlfLUU5X09PT08tRTlgLUU5YE9PUSRJUy1FOWEtRTlhTyEzVFElR2xPMUcyVk8hM3RRJElbTzFHMlZPJ1JRJElXTyw1PE9PT1EkSVMsNTxPLDU8T09PUSRJUy1FOWItRTliT09RJElTLDU8Viw1PFZPT1EkSVMtRTlpLUU5aU9PUSRJVjFHMG8xRzBvTy98USRJV08nI0ZnTyE0XVEkSVtPLDU9c09PUSRJUzFHMVYxRzFWTyE0dFEkSVdPMUcxVk9PUSRJUycjRFQnI0RUTy9nUSRJV08sNTx8T09RJElTLDU8fCw1PHxPITR5USRJV08nI0ZTTyE1VVEkSVdPLDU5bU8hNV5RJElXTzFHL1ZPITVoUSRJW08sNT1RT09RJElTMUcyazFHMmtPT1EkSVMsNTpoLDU6aE8hNlhRJElXTycjR1BPT1EkSVMsNTxQLDU8UE9PUSRJUy1FOWMtRTljTyE2alEkSVdPMUcuZk9PUSRJUzFHMFUxRzBVTyE2eFEkSVdPLDU9U08hN1lRJElXTyw1PVNPL2dRJElXTzFHMGVPL2dRJElXTzFHMGVPL3xRJElXTzFHMGdPT1EkSVMtRTlmLUU5Zk8hN2tRJElXTzFHMGdPITd2USRJV08xRzBnTyE3e1EkSVdPLDU9dk8hOFpRJElXTyw1PXZPIThpUSRJV08sNT1yTyE5UFEkSVdPLDU9ck8hOWJRJElaTzFHMHFPITxwUSRJWk8xRzB0TyE/e1EkSVdPLDU9eE8hQFZRJElXTyw1PXhPIUBfUSRJW08sNT14Ty9nUSRJV08xRzB2TyFAaVEkSVdPMUcwdk8zVVEkSVdPMUcwe09OZ1EkSVdPMUcwfU9PUSRJViw1O1csNTtXTyFAblEkSVlPLDU7V08hQHNRJElaTzFHMHdPIURVUSRJV08nI0ZvTzNVUSRJV08xRzB3TzNVUSRJV08xRzB3TyFEY1EkSVdPLDU9eU8hRHBRJElXTyw1PXlPL3xRJElXTyw1PXlPT1EkSVYxRzB7MUcwe08hRHhRJElXTycjRXlPIUVaUSUxYE8xRzB9T09RJElWMUcxUzFHMVNPM1VRJElXTzFHMVNPT1EkSVMsNT1ZLDU9WU9PUSRJUycjRG4nI0RuTy9nUSRJV08sNT1ZTyFFY1EkSVdPLDU9WE8hRXZRJElXTyw1PVhPT1EkSVMxRy9zMUcvc08hRk9RJElXTyw1PVtPIUZgUSRJV08sNT1bTyFGaFEkSVdPLDU9W08hRntRJElXTyw1PVtPIUddUSRJV08sNT1bT09RJElTMUcydTFHMnVPT1EkSVM3KyRmNyskZk8hNV5RJElXTzcrJG5PIUlPUSRJV08xRy56TyFJVlEkSVdPMUcuek9PUSRJUzFHL14xRy9eT09RJElTLDU7cCw1O3BPJ1JRJElXTyw1O3BPT1EkSVM3KyR9NyskfU8hSV5RJElXTzcrJH1PT1EkSVMtRTlTLUU5U09PUSRJUzcrJU83KyVPTyFJblEkSVdPLDU9Uk8nUlEkSVdPLDU9Uk9PUSRJUzcrJGU3KyRlTyFJc1EkSVdPNyskfU8hSXtRJElXTzcrJU9PIUpRUSRJV08xRzJxT09RJElTNyslVjcrJVZPIUpiUSRJV08xRzJxTyFKalEkSVdPNyslVk9PUSRJUyw1O28sNTtvTydSUSRJV08sNTtvTyFKb1EkSVdPMUcybE9PUSRJUy1FOVItRTlSTyFLZlEkSVdPNyslWk9PUSRJUzcrJV03KyVdTyFLdFEkSVdPMUcybE8hTGNRJElXTzcrJV1PIUxoUSRJV08xRzJyTyFMeFEkSVdPMUcyck8hTVFRJElXTzcrJVpPIU1WUSRJV08sNT1nTyFNbVEkSVdPLDU9Z08hTW1RJElXTyw1PWdPIU17TyFMUU8nI0R3TyFOV09TTycjR3xPT09PMUcvezFHL3tPIU5dUSRJV08xRy97TyFOZVElR2xPNysncU8jIFVRJElbTzFHMWpQIyBvUSRJV08nI0ZkT09RJElTLDU8Uiw1PFJPT1EkSVMtRTllLUU5ZU9PUSRJUzcrJnE3KyZxT09RJElTMUcyaDFHMmhPT1EkSVMsNTtuLDU7bk9PUSRJUy1FOVEtRTlRT09RJElTNyskcTcrJHFPIyB8USRJV08sNTxrTyMhZ1EkSVdPLDU8a08jIXhRJElbTyw1O3FPIyNdUSRJV08xRzJuT09RJElTLUU5VC1FOVRPT1EkSVM3KyZQNysmUE8jI21RJElXTzcrJlBPT1EkSVM3KyZSNysmUk8jI3tRJElXTycjSFpPL3xRJElXTycjSFlPIyRhUSRJV083KyZST09RJElTLDU8VSw1PFVPIyRsUSRJV08xRzNiT09RJElTLUU5aC1FOWhPT1EkSVMsNTxRLDU8UU8jJHpRJElXTzFHM15PT1EkSVMtRTlkLUU5ZE8jJWJRJElaTzcrJl1PIURVUSRJV08nI0ZtTzNVUSRJV083KyZdTzNVUSRJV083KyZgTyMocFEkSVtPLDU8WU8nUlEkSVdPLDU8WU8jKHpRJElXTzFHM2RPT1EkSVMtRTlsLUU5bE8jKVVRJElXTzFHM2RPM1VRJElXTzcrJmJPL2dRJElXTzcrJmJPT1EkSVY3KyZnNysmZ08hRVpRJTFgTzcrJmlPIyleUSRJWE8xRzByT09RJElWLUU5bS1FOW1PM1VRJElXTzcrJmNPM1VRJElXTzcrJmNPT1EkSVYsNTxaLDU8Wk8jK1BRJElXTyw1PFpPT1EkSVY3KyZjNysmY08jK1tRJElaTzcrJmNPIy5nUSRJV08sNTxbTyMuclEkSVdPMUczZU9PUSRJUy1FOW4tRTluTyMvUFEkSVdPMUczZU8jL1hRJElXTycjSGFPIy9nUSRJV08nI0hhTy98USRJV08nI0hhT09RJElTJyNIYScjSGFPIy9yUSRJV08nI0hgT09RJElTLDU7ZSw1O2VPIy96USRJV08sNTtlTy9nUSRJV08nI0V7T09RJElWNysmaTcrJmlPM1VRJElXTzcrJmlPT1EkSVY3KyZuNysmbk9PUSRJUzFHMnQxRzJ0T09RJElTLDU7cyw1O3NPIzBQUSRJV08xRzJzT09RJElTLUU5Vi1FOVZPIzBkUSRJV08sNTt0TyMwb1EkSVdPLDU7dE8jMVNRJElXTzFHMnZPT1EkSVMtRTlXLUU5V08jMWRRJElXTzFHMnZPIzFsUSRJV08xRzJ2TyMxfFEkSVdPMUcydk8jMWRRJElXTzFHMnZPT1EkSVM8PEhZPDxIWU8jMlhRJElbTzFHMVtPT1EkSVM8PEhpPDxIaVAjMmZRJElXTycjRlVPNnxRJElXTzFHMm1PIzJzUSRJV08xRzJtTyMyeFEkSVdPPDxIaU9PUSRJUzw8SGo8PEhqTyMzWVEkSVdPNysoXU9PUSRJUzw8SHE8PEhxTyMzalEkSVtPMUcxWlAjNFpRJElXTycjRlRPIzRoUSRJV083KyheTyM0eFEkSVdPNysoXk8jNVFRJElXTzw8SHVPIzVWUSRJV083KyhXT09RJElTPDxIdzw8SHdPIzV8USRJV08sNTtyTydSUSRJV08sNTtyT09RJElTLUU5VS1FOVVPT1EkSVM8PEh1PDxIdU9PUSRJUyw1O3gsNTt4Ty9nUSRJV08sNTt4TyM2UlEkSVdPMUczUk9PUSRJUy1FOVstRTlbTyM2aVEkSVdPMUczUk9PT08nI0ZfJyNGX08jNndPIUxRTyw1OmNPT09PLDU9aCw1PWhPT09PNyslZzcrJWdPIzdTUSRJV08xRzJWTyM3bVEkSVdPMUcyVlAnUlEkSVdPJyNGVk8vZ1EkSVdPPDxJa08jOE9RJElXTyw1PXVPIzhhUSRJV08sNT11Ty98USRJV08sNT11TyM4clEkSVdPLDU9dE9PUSRJUzw8SW08PEltUC98USRJV08nI0ZqUC9nUSRJV08nI0ZmT09RJElWLUU5ay1FOWtPM1VRJElXTzw8SXdPT1EkSVYsNTxYLDU8WE8zVVEkSVdPLDU8WE9PUSRJVjw8SXc8PEl3T09RJElWPDxJejw8SXpPIzh3USRJW08xRzF0UCM5UlEkSVdPJyNGbk8jOVlRJElXTzcrKU9PIzlkUSRJWk88PEl8TzNVUSRJV088PEl8T09RJElWPDxKVDw8SlRPM1VRJElXTzw8SlRPT1EkSVYnI0ZsJyNGbE8jPG9RJElaTzcrJl5PT1EkSVY8PEl9PDxJfU8jPmhRJElaTzw8SX1PT1EkSVYxRzF1MUcxdU8vfFEkSVdPMUcxdU8zVVEkSVdPPDxJfU8vfFEkSVdPMUcxdlAvZ1EkSVdPJyNGcE8jQXNRJElXTzcrKVBPI0JRUSRJV083KylQT09RJElTJyNFeicjRXpPL2dRJElXTyw1PXtPI0JZUSRJV08sNT17T09RJElTLDU9eyw1PXtPI0JlUSRJV08sNT16TyNCdlEkSVdPLDU9ek9PUSRJUzFHMVAxRzFQT09RJElTLDU7Zyw1O2dQI0NPUSRJV08nI0ZYTyNDYFEkSVdPMUcxYE8jQ3NRJElXTzFHMWBPI0RUUSRJV08xRzFgUCNEYFEkSVdPJyNGWU8jRG1RJElXTzcrKGJPI0R9USRJV083KyhiTyNEfVEkSVdPNysoYk8jRVZRJElXTzcrKGJPI0VnUSRJV083KyhYTzZ8USRJV083KyhYT09RJElTQU4+VEFOPlRPI0ZRUSRJV088PEt4T09RJElTQU4+YUFOPmFPL2dRJElXTzFHMV5PI0ZiUSRJW08xRzFeUCNGbFEkSVdPJyNGV09PUSRJUzFHMWQxRzFkUCNGeVEkSVdPJyNGXk8jR1dRJElXTzcrKG1PT09PLUU5XS1FOV1PI0duUSRJV083KydxT09RJElTQU4/VkFOP1ZPI0hYUSRJV08sNTxUTyNIbVEkSVdPMUczYU9PUSRJUy1FOWctRTlnTyNJT1EkSVdPMUczYU9PUSRJUzFHM2AxRzNgT09RJElWQU4/Y0FOP2NPT1EkSVYxRzFzMUcxc08zVVEkSVdPQU4/aE8jSWFRJElaT0FOP2hPT1EkSVZBTj9vQU4/b09PUSRJVi1FOWotRTlqT09RJElWPDxJeDw8SXhPM1VRJElXT0FOP2lPM1VRJElXTzcrJ2FPT1EkSVZBTj9pQU4/aU9PUSRJUzcrJ2I3KydiTyNMbFEkSVdPPDxMa09PUSRJUzFHM2cxRzNnTy9nUSRJV08xRzNnT09RJElTLDU8XSw1PF1PI0x5USRJV08xRzNmT09RJElTLUU5by1FOW9PI01bUSRJV083KyZ6TyNNbFEkSVdPNysmek9PUSRJUzcrJno3KyZ6TyNNd1EkSVdPPDxLfE8jTlhRJElXTzw8S3xPI05YUSRJV088PEt8TyNOYVEkSVdPJyNHaU9PUSRJUzw8S3M8PEtzTyNOa1EkSVdPPDxLc09PUSRJUzcrJng3KyZ4Ty98USRJV08xRzFvUC98USRJV08nI0ZpTyQgVVEkSVdPNysoe08kIGdRJElXTzcrKHtPT1EkSVZHMjVTRzI1U08zVVEkSVdPRzI1U09PUSRJVkcyNVRHMjVUT09RJElWPDxKezw8SntPT1EkSVM3KylSNyspUlAkIHhRJElXTycjRnFPT1EkSVM8PEpmPDxKZk8kIVdRJElXTzw8SmZPJCFoUSRJV09BTkFoTyQheFEkSVdPQU5BaE8kI1FRJElXTycjR2pPT1EkSVMnI0dqJyNHak8waFEkSVdPJyNEYU8kI2tRJElXTyw1PVRPT1EkSVNBTkFfQU5BX09PUSRJUzcrJ1o3KydaTyQkU1EkSVdPPDxMZ09PUSRJVkxEKm5MRCpuT09RJElTQU5AUUFOQFFPJCRlUSRJV09HMjdTTyQkdVEkSVdPLDU5e09PUSRJUzFHMm8xRzJvTyNOYVEkSVdPMUcvZ09PUSRJUzcrJVI3KyVSTzZ8USRJV08nI0N7TzZ8USRJV08sNTlgTzZ8USRJV08sNTlgTzZ8USRJV08sNTlgTyQkelEkSVtPLDU8a082fFEkSVdPMUcuek8vZ1EkSVdPMUcvVk8vZ1EkSVdPNyskblAkJV9RJElXTycjRmRPJ1JRJElXTycjR1BPJCVsUSRJV08sNTlgTyQlcVEkSVdPLDU5YE8kJXhRJElXTyw1OWtPJCV9USRJV08xRy9TTzBoUSRJV08nI0RQTzZ8USRJV08sNTloXCIsXG4gIHN0YXRlRGF0YTogXCIkJmV+TyRvT1MkbE9TJGtPU1FPU35PUGhPVGVPZHNPZlhPbXRPcSFTT3R1T312TyFPIVBPIVIhVk8hUyFVTyFWWU8hWlpPIWZkTyFtZE8hbmRPIW9kTyF2eE8heHlPIXp6TyF8e08jT3xPI1N9TyNVIU9PI1ghUU8jWSFRTyNbIVJPI2MhVE8jZiFXTyNqIVhPI2whWU8jcSFaTyN0bE8kanFPJHpRTyR7UU8lUFJPJVFWTyVmW08lZ11PJWpeTyVtX08lc2BPJXZhTyV4Yk9+T1QhYU9dIWFPXyFiT2YhaU8hViFrTyFkIW1PJHUhW08kdiFdTyR3IV5PJHghX08keSFfTyR6IWBPJHshYE8kfCFhTyR9IWFPJU8hYU9+T2klVFhqJVRYayVUWGwlVFhtJVRYbiVUWHElVFh4JVRYeSVUWCFzJVRYI14lVFgkaiVUWCRtJVRYJVYlVFhlJVRYIVIlVFghUyVUWCVXJVRYIVUlVFghWSVUWCFPJVRYI1YlVFhyJVRYIWolVFh+UCRfT2RzT2ZYTyFWWU8hWlpPIWZkTyFtZE8hbmRPIW9kTyR6UU8ke1FPJVBSTyVRVk8lZltPJWddTyVqXk8lbV9PJXNgTyV2YU8leGJPfk94JVNYeSVTWCNeJVNYJGolU1gkbSVTWCVWJVNYfk9pIXBPaiFxT2shb09sIW9PbSFyT24hc09xIXRPIXMlU1h+UChgT1Qhek9tLWRPdC1yT312T35QJ1JPVCF9T20tZE90LXJPIVUjT09+UCdST1QjUk9fI1NPbS1kT3Qtck8hWSNUT35QJ1JPJWgjV08laSNZT35PJWsjWk8lbCNZT35PIVojXU8lbiNeTyVyI2BPfk8hWiNdTyV0I2FPJXUjYE9+TyFaI11PJWkjYE8ldyNjT35PIVojXU8lbCNgTyV5I2VPfk9UJHRYXSR0WF8kdFhmJHRYaSR0WGokdFhrJHRYbCR0WG0kdFhuJHRYcSR0WHgkdFghViR0WCFkJHRYJHUkdFgkdiR0WCR3JHRYJHgkdFgkeSR0WCR6JHRYJHskdFgkfCR0WCR9JHRYJU8kdFhlJHRYIVIkdFghUyR0WH5PJWZbTyVnXU8lal5PJW1fTyVzYE8ldmFPJXhiT3kkdFghcyR0WCNeJHRYJGokdFgkbSR0WCVWJHRYJVckdFghVSR0WCFZJHRYIU8kdFgjViR0WHIkdFghaiR0WH5QK3VPeCNqT3kkc1ghcyRzWCNeJHNYJGokc1gkbSRzWCVWJHNYfk9tLWRPdC1yT35QJ1JPI14jbU8kaiNvTyRtI29Pfk8lUVZPfk8hUiN0TyNsIVlPI3EhWk8jdGxPfk9tdE9+UCdST1QjeU9fI3pPJVFWT3l1UH5PVCRPT20tZE90LXJPIU8kUE9+UCdST3kkUk8hcyRXTyVWJFNPI14hdFgkaiF0WCRtIXRYfk9UJE9PbS1kT3Qtck8jXiF9WCRqIX1YJG0hfVh+UCdST20tZE90LXJPI14jUlgkaiNSWCRtI1JYflAnUk8hZCReTyFtJF5PJVFWT35PVCRoT35QJ1JPIVMkak8jaiRrTyNsJGxPfk95JG1Pfk9UJHtPXyR7T2UkfU9tLWRPdC1yT35QJ1JPbS1kT3Qtck95JVFPflAnUk8lZSVTT35PXyFiT2YhaU8hViFrTyFkIW1PVGBhXWBhaWBhamBha2BhbGBhbWBhbmBhcWBheGBheWBhIXNgYSNeYGEkamBhJG1gYSR1YGEkdmBhJHdgYSR4YGEkeWBhJHpgYSR7YGEkfGBhJH1gYSVPYGElVmBhZWBhIVJgYSFTYGElV2BhIVVgYSFZYGEhT2BhI1ZgYXJgYSFqYGF+T2wlWE9+T20lWE9+UCdST20tZE9+UCdST2ktZk9qLWdPay1lT2wtZU9tLW5Pbi1vT3Etc09lJVNYIVIlU1ghUyVTWCVXJVNYIVUlU1ghWSVTWCFPJVNYI1YlU1ghaiVTWH5QKGBPJVclWk9lJVJYeCVSWCFSJVJYIVMlUlghVSVSWHklUlh+T2UlXU94JV5PIVIlYk8hUyVhT35PZSVdT35PeCVlTyFSJWJPIVMlYU8hVSVfWH5PIVUlaU9+T3glak95JWxPIVIlYk8hUyVhTyFZJVlYfk8hWSVwT35PIVklcU9+TyVoI1dPJWklc09+TyVrI1pPJWwlc09+T1Qldk9tLWRPdC1yT312T35QJ1JPIVojXU8lbiNeTyVyJXlPfk8hWiNdTyV0I2FPJXUleU9+TyFaI11PJWkleU8ldyNjT35PIVojXU8lbCV5TyV5I2VPfk9UIWxhXSFsYV8hbGFmIWxhaSFsYWohbGFrIWxhbCFsYW0hbGFuIWxhcSFsYXghbGF5IWxhIVYhbGEhZCFsYSFzIWxhI14hbGEkaiFsYSRtIWxhJHUhbGEkdiFsYSR3IWxhJHghbGEkeSFsYSR6IWxhJHshbGEkfCFsYSR9IWxhJU8hbGElViFsYWUhbGEhUiFsYSFTIWxhJVchbGEhVSFsYSFZIWxhIU8hbGEjViFsYXIhbGEhaiFsYX5QI3ZPeCZPT3kkc2EhcyRzYSNeJHNhJGokc2EkbSRzYSVWJHNhflAkX09UJlFPbXRPdHVPeSRzYSFzJHNhI14kc2EkaiRzYSRtJHNhJVYkc2F+UCdST3gmT095JHNhIXMkc2EjXiRzYSRqJHNhJG0kc2ElViRzYX5PUGhPVGVPbXRPdHVPfXZPIU8hUE8hdnhPIXh5TyF6ek8hfHtPI098TyNTfU8jVSFPTyNYIVFPI1khUU8jWyFSTyNeJF9YJGokX1gkbSRfWH5QJ1JPI14jbU8kaiZWTyRtJlZPfk8hZCZXT2Yle1gkaiV7WCNWJXtYI14le1gkbSV7WCNVJXtYfk9mIWlPJGomWU9+T2ljYWpjYWtjYWxjYW1jYW5jYXFjYXhjYXljYSFzY2EjXmNhJGpjYSRtY2ElVmNhZWNhIVJjYSFTY2ElV2NhIVVjYSFZY2EhT2NhI1ZjYXJjYSFqY2F+UCRfT3FvYXhvYXlvYSNeb2Ekam9hJG1vYSVWb2F+T2khcE9qIXFPayFvT2whb09tIXJPbiFzTyFzb2F+UERUTyVWJltPeCVVWHklVVh+TyVRVk94JVVYeSVVWH5PeCZfT3l1WH5PeSZhT35PeCVqTyNeJVlYJGolWVgkbSVZWGUlWVh5JVlYIVklWVghaiVZWCVWJVlYfk9ULW1PbS1kT3Qtck99dk9+UCdSTyVWJFNPI15TYSRqU2EkbVNhfk94JmpPI14lW1gkaiVbWCRtJVtYbCVbWH5QJF9PeCZtTyFPJmxPI14jUmEkaiNSYSRtI1Jhfk8jViZuTyNeI1RhJGojVGEkbSNUYX5PIWQkXk8hbSReTyNVJnBPJVFWT35PI1UmcE9+T3gmck8jXiZPWCRqJk9YJG0mT1h+T3gmdE8jXiV6WCRqJXpYJG0lelh5JXpYfk94JnhPbCZRWH5QJF9PbCZ7T35PUGhPVGVPbXRPdHVPfXZPIU8hUE8hdnhPIXh5TyF6ek8hfHtPI098TyNTfU8jVSFPTyNYIVFPI1khUU8jWyFSTyRqJ1FPflAnUk9yJ1VPI2cnU08jaCdUT1AjZWFUI2VhZCNlYWYjZWFtI2VhcSNlYXQjZWF9I2VhIU8jZWEhUiNlYSFTI2VhIVYjZWEhWiNlYSFmI2VhIW0jZWEhbiNlYSFvI2VhIXYjZWEheCNlYSF6I2VhIXwjZWEjTyNlYSNTI2VhI1UjZWEjWCNlYSNZI2VhI1sjZWEjYyNlYSNmI2VhI2ojZWEjbCNlYSNxI2VhI3QjZWEkZyNlYSRqI2VhJHojZWEkeyNlYSVQI2VhJVEjZWElZiNlYSVnI2VhJWojZWElbSNlYSVzI2VhJXYjZWEleCNlYSRpI2VhJG0jZWF+T3gnVk8jVidYT3kmUlh+T2YnWk9+T2YhaU95JG1Pfk9UIWFPXSFhT18hYk9mIWlPIVYha08hZCFtTyR3IV5PJHghX08keSFfTyR6IWBPJHshYE8kfCFhTyR9IWFPJU8hYU9pVWlqVWlrVWlsVWltVWluVWlxVWl4VWl5VWkhc1VpI15VaSRqVWkkbVVpJHVVaSVWVWllVWkhUlVpIVNVaSVXVWkhVVVpIVlVaSFPVWkjVlVpclVpIWpVaX5PJHYhXU9+UE50TyR2VWl+UE50T1QhYU9dIWFPXyFiT2YhaU8hViFrTyFkIW1PJHohYE8keyFgTyR8IWFPJH0hYU8lTyFhT2lVaWpVaWtVaWxVaW1VaW5VaXFVaXhVaXlVaSFzVWkjXlVpJGpVaSRtVWkkdVVpJHZVaSR3VWklVlVpZVVpIVJVaSFTVWklV1VpIVVVaSFZVWkhT1VpI1ZVaXJVaSFqVWl+TyR4IV9PJHkhX09+UCEjb08keFVpJHlVaX5QISNvT18hYk9mIWlPIVYha08hZCFtT2lVaWpVaWtVaWxVaW1VaW5VaXFVaXhVaXlVaSFzVWkjXlVpJGpVaSRtVWkkdVVpJHZVaSR3VWkkeFVpJHlVaSR6VWkke1VpJVZVaWVVaSFSVWkhU1VpJVdVaSFVVWkhWVVpIU9VaSNWVWlyVWkhalVpfk9UIWFPXSFhTyR8IWFPJH0hYU8lTyFhT35QISZtT1RVaV1VaSR8VWkkfVVpJU9VaX5QISZtTyFSJWJPIVMlYU9lJWJYeCViWH5PJVYnYE8lVydgT35QK3VPeCdiT2UlYVh+T2UnZE9+T3gnZU95J2dPIVUlZFh+T20tZE90LXJPeCdlT3knaE8hVSVkWH5QJ1JPIVUnak9+T2shb09sIW9PbSFyT24hc09paGlxaGl4aGl5aGkhc2hpI15oaSRqaGkkbWhpJVZoaX5PaiFxT35QIStgT2poaX5QIStgT2ktZk9qLWdPay1lT2wtZU9tLW5Pbi1vT35PcidsT35QISxpT1QncU9lJ3JPbS1kT3Qtck9+UCdST2Unck94J3NPfk9lJ3VPfk8hUyd3T35PZSd4T3gnc08hUiViTyFTJWFPflAkX09pLWZPai1nT2stZU9sLWVPbS1uT24tb09lb2EhUm9hIVNvYSVXb2EhVW9hIVlvYSFPb2EjVm9hcm9hIWpvYX5QRFRPVCdxT20tZE90LXJPIVUlX2F+UCdST3gne08hVSVfYX5PIVUnfE9+T3gne08hUiViTyFTJWFPIVUlX2F+UCRfT1QoUU9tLWRPdC1yTyFZJVlhI14lWWEkaiVZYSRtJVlhZSVZYXklWWEhaiVZYSVWJVlhflAnUk94KFJPIVklWWEjXiVZYSRqJVlhJG0lWWFlJVlheSVZYSFqJVlhJVYlWWF+TyFZKFVPfk94KFJPIVIlYk8hUyVhTyFZJVlhflAkX094KFhPIVIlYk8hUyVhTyFZJWBhflAkX094KFtPeSVvWCFZJW9YIWolb1h+T3koX08hWShhTyFqKGJPfk9UJlFPbXRPdHVPeSRzaSFzJHNpI14kc2kkaiRzaSRtJHNpJVYkc2l+UCdST3goY095JHNpIXMkc2kjXiRzaSRqJHNpJG0kc2klViRzaX5PIWQmV09mJXthJGole2EjViV7YSNeJXthJG0le2EjVSV7YX5PJGooaE9+T1QjeU9fI3pPJVFWT35PeCZfT3l1YX5PbXRPdHVPflAnUk94KFJPI14lWWEkaiVZYSRtJVlhZSVZYXklWWEhWSVZYSFqJVlhJVYlWWF+UCRfT3gobU8jXiRzWCRqJHNYJG0kc1glViRzWH5PJVYkU08jXlNpJGpTaSRtU2l+TyNeJVthJGolW2EkbSVbYWwlW2F+UCdST3gocE8jXiVbYSRqJVthJG0lW2FsJVthfk9UKHRPZih2TyVRVk9+TyNVKHdPfk8lUVZPI14mT2EkaiZPYSRtJk9hfk94KHlPI14mT2EkaiZPYSRtJk9hfk9tLWRPdC1yTyNeJXphJGolemEkbSV6YXklemF+UCdST3gofE8jXiV6YSRqJXphJG0lemF5JXphfk9yKVFPI2EpUE9QI19pVCNfaWQjX2lmI19pbSNfaXEjX2l0I19pfSNfaSFPI19pIVIjX2khUyNfaSFWI19pIVojX2khZiNfaSFtI19pIW4jX2khbyNfaSF2I19pIXgjX2kheiNfaSF8I19pI08jX2kjUyNfaSNVI19pI1gjX2kjWSNfaSNbI19pI2MjX2kjZiNfaSNqI19pI2wjX2kjcSNfaSN0I19pJGcjX2kkaiNfaSR6I19pJHsjX2klUCNfaSVRI19pJWYjX2klZyNfaSVqI19pJW0jX2klcyNfaSV2I19pJXgjX2kkaSNfaSRtI19pfk9yKVJPUCNiaVQjYmlkI2JpZiNiaW0jYmlxI2JpdCNiaX0jYmkhTyNiaSFSI2JpIVMjYmkhViNiaSFaI2JpIWYjYmkhbSNiaSFuI2JpIW8jYmkhdiNiaSF4I2JpIXojYmkhfCNiaSNPI2JpI1MjYmkjVSNiaSNYI2JpI1kjYmkjWyNiaSNjI2JpI2YjYmkjaiNiaSNsI2JpI3EjYmkjdCNiaSRnI2JpJGojYmkkeiNiaSR7I2JpJVAjYmklUSNiaSVmI2JpJWcjYmklaiNiaSVtI2JpJXMjYmkldiNiaSV4I2JpJGkjYmkkbSNiaX5PVClUT2wmUWF+UCdST3gpVU9sJlFhfk94KVVPbCZRYX5QJF9PbClZT35PJGgpXU9+T3IpYE8jZydTTyNoKV9PUCNlaVQjZWlkI2VpZiNlaW0jZWlxI2VpdCNlaX0jZWkhTyNlaSFSI2VpIVMjZWkhViNlaSFaI2VpIWYjZWkhbSNlaSFuI2VpIW8jZWkhdiNlaSF4I2VpIXojZWkhfCNlaSNPI2VpI1MjZWkjVSNlaSNYI2VpI1kjZWkjWyNlaSNjI2VpI2YjZWkjaiNlaSNsI2VpI3EjZWkjdCNlaSRnI2VpJGojZWkkeiNlaSR7I2VpJVAjZWklUSNlaSVmI2VpJWcjZWklaiNlaSVtI2VpJXMjZWkldiNlaSV4I2VpJGkjZWkkbSNlaX5PbS1kT3Qtck95JG1PflAnUk9tLWRPdC1yT3kmUmF+UCdST3gpZk95JlJhfk9UKWpPXylrT2Upbk8kfClsTyVRVk9+T3kkbU8mVSlwT35PVCR7T18ke09tLWRPdC1yT2UlYWF+UCdST3gpdk9lJWFhfk9tLWRPdC1yT3kpeU8hVSVkYX5QJ1JPeCl6TyFVJWRhfk9tLWRPdC1yT3gpek95KX1PIVUlZGF+UCdST20tZE90LXJPeCl6TyFVJWRhflAnUk94KXpPeSl9TyFVJWRhfk9rLWVPbC1lT20tbk9uLW9PZWhpaWhpcWhpeGhpIVJoaSFTaGklV2hpIVVoaXloaSFZaGkjXmhpJGpoaSRtaGkhT2hpI1ZoaXJoaSFqaGklVmhpfk9qLWdPflAhR2hPamhpflAhR2hPVCdxT2UqU09tLWRPdC1yT35QJ1JPbCpVT35PZSpTT3gqV09+T2UqWE9+T1QncU9tLWRPdC1yTyFVJV9pflAnUk94KllPIVUlX2l+TyFVKlpPfk9UKFFPbS1kT3Qtck8hWSVZaSNeJVlpJGolWWkkbSVZaWUlWWl5JVlpIWolWWklViVZaX5QJ1JPeCpeTyFSJWJPIVMlYU8hWSVgaX5PeCphTyFZJVlpI14lWWkkaiVZaSRtJVlpZSVZaXklWWkhaiVZaSVWJVlpfk8hWSpiT35PXypkT20tZE90LXJPIVklYGl+UCdST3gqXk8hWSVgaX5PIVkqZk9+T1QqaE9tLWRPdC1yT3klb2EhWSVvYSFqJW9hflAnUk94KmlPeSVvYSFZJW9hIWolb2F+TyFaI11PJXEqbE8hWSFrWH5PIVkqbk9+T3koX08hWSpvT35PVCZRT210T3R1T3kkc3EhcyRzcSNeJHNxJGokc3EkbSRzcSVWJHNxflAnUk94JFdpeSRXaSFzJFdpI14kV2kkaiRXaSRtJFdpJVYkV2l+UCRfT1QmUU9tdE90dU9+UCdST1QmUU9tLWRPdC1yTyNeJHNhJGokc2EkbSRzYSVWJHNhflAnUk94KnBPI14kc2EkaiRzYSRtJHNhJVYkc2F+T3gjeWEjXiN5YSRqI3lhJG0jeWFsI3lhflAkX08jXiVbaSRqJVtpJG0lW2lsJVtpflAnUk94KnNPI14jUnEkaiNScSRtI1Jxfk94KnRPI1Yqdk8jXiV9WCRqJX1YJG0lfVhlJX1Yfk9UKnhPZih2TyVRVk9+TyVRVk8jXiZPaSRqJk9pJG0mT2l+T20tZE90LXJPI14lemkkaiV6aSRtJXppeSV6aX5QJ1JPcip8TyNhKVBPUCNfcVQjX3FkI19xZiNfcW0jX3FxI19xdCNfcX0jX3EhTyNfcSFSI19xIVMjX3EhViNfcSFaI19xIWYjX3EhbSNfcSFuI19xIW8jX3EhdiNfcSF4I19xIXojX3EhfCNfcSNPI19xI1MjX3EjVSNfcSNYI19xI1kjX3EjWyNfcSNjI19xI2YjX3EjaiNfcSNsI19xI3EjX3EjdCNfcSRnI19xJGojX3EkeiNfcSR7I19xJVAjX3ElUSNfcSVmI19xJWcjX3ElaiNfcSVtI19xJXMjX3EldiNfcSV4I19xJGkjX3EkbSNfcX5PbCRiYXgkYmF+UCRfT1QpVE9sJlFpflAnUk94K1RPbCZRaX5PUGhPVGVPbXRPcSFTT3R1T312TyFPIVBPIVIhVk8hUyFVTyF2eE8heHlPIXp6TyF8e08jT3xPI1N9TyNVIU9PI1ghUU8jWSFRTyNbIVJPI2MhVE8jZiFXTyNqIVhPI2whWU8jcSFaTyN0bE9+UCdST3grX095JG1PI1YrX09+TyNoK2BPUCNlcVQjZXFkI2VxZiNlcW0jZXFxI2VxdCNlcX0jZXEhTyNlcSFSI2VxIVMjZXEhViNlcSFaI2VxIWYjZXEhbSNlcSFuI2VxIW8jZXEhdiNlcSF4I2VxIXojZXEhfCNlcSNPI2VxI1MjZXEjVSNlcSNYI2VxI1kjZXEjWyNlcSNjI2VxI2YjZXEjaiNlcSNsI2VxI3EjZXEjdCNlcSRnI2VxJGojZXEkeiNlcSR7I2VxJVAjZXElUSNlcSVmI2VxJWcjZXElaiNlcSVtI2VxJXMjZXEldiNlcSV4I2VxJGkjZXEkbSNlcX5PI1YrYU94JGRheSRkYX5PbS1kT3Qtck95JlJpflAnUk94K2NPeSZSaX5PeSRSTyVWK2VPZSZUWHgmVFh+TyVRVk9lJlRYeCZUWH5PeCtpT2UmU1h+T2Ura09+T1Qke09fJHtPbS1kT3Qtck9lJWFpflAnUk95K25PeCN8YSFVI3xhfk9tLWRPdC1yT3krb094I3xhIVUjfGF+UCdST20tZE90LXJPeSl5TyFVJWRpflAnUk94K3JPIVUlZGl+T20tZE90LXJPeCtyTyFVJWRpflAnUk94K3JPeSt1TyFVJWRpfk9lI3hpeCN4aSFVI3hpflAkX09UJ3FPbS1kT3Qtck9+UCdST2wrd09+T1QncU9lK3hPbS1kT3Qtck9+UCdST1QncU9tLWRPdC1yTyFVJV9xflAnUk94I3dpIVkjd2kjXiN3aSRqI3dpJG0jd2llI3dpeSN3aSFqI3dpJVYjd2l+UCRfT1QoUU9tLWRPdC1yT35QJ1JPXypkT20tZE90LXJPIVklYHF+UCdST3greU8hWSVgcX5PIVkrek9+T1QoUU9tLWRPdC1yTyFZJVlxI14lWXEkaiVZcSRtJVlxZSVZcXklWXEhaiVZcSVWJVlxflAnUk95K3tPfk9UKmhPbS1kT3Qtck95JW9pIVklb2khaiVvaX5QJ1JPeCxRT3klb2khWSVvaSFqJW9pfk8hWiNdTyVxKmxPIVkha2F+T1QmUU9tLWRPdC1yTyNeJHNpJGokc2kkbSRzaSVWJHNpflAnUk94LFNPI14kc2kkaiRzaSRtJHNpJVYkc2l+TyVRVk8jXiV9YSRqJX1hJG0lfWFlJX1hfk94LFZPI14lfWEkaiV9YSRtJX1hZSV9YX5PZSxZT35PbCRiaXgkYml+UCRfT1QpVE9+UCdST1QpVE9sJlFxflAnUk9yLF1PUCNkeVQjZHlkI2R5ZiNkeW0jZHlxI2R5dCNkeX0jZHkhTyNkeSFSI2R5IVMjZHkhViNkeSFaI2R5IWYjZHkhbSNkeSFuI2R5IW8jZHkhdiNkeSF4I2R5IXojZHkhfCNkeSNPI2R5I1MjZHkjVSNkeSNYI2R5I1kjZHkjWyNkeSNjI2R5I2YjZHkjaiNkeSNsI2R5I3EjZHkjdCNkeSRnI2R5JGojZHkkeiNkeSR7I2R5JVAjZHklUSNkeSVmI2R5JWcjZHklaiNkeSVtI2R5JXMjZHkldiNkeSV4I2R5JGkjZHkkbSNkeX5PUGhPVGVPbXRPcSFTT3R1T312TyFPIVBPIVIhVk8hUyFVTyF2eE8heHlPIXp6TyF8e08jT3xPI1N9TyNVIU9PI1ghUU8jWSFRTyNbIVJPI2MhVE8jZiFXTyNqIVhPI2whWU8jcSFaTyN0bE8kaSxhTyRtLGFPflAnUk8jaCxiT1AjZXlUI2V5ZCNleWYjZXltI2V5cSNleXQjZXl9I2V5IU8jZXkhUiNleSFTI2V5IVYjZXkhWiNleSFmI2V5IW0jZXkhbiNleSFvI2V5IXYjZXkheCNleSF6I2V5IXwjZXkjTyNleSNTI2V5I1UjZXkjWCNleSNZI2V5I1sjZXkjYyNleSNmI2V5I2ojZXkjbCNleSNxI2V5I3QjZXkkZyNleSRqI2V5JHojZXkkeyNleSVQI2V5JVEjZXklZiNleSVnI2V5JWojZXklbSNleSVzI2V5JXYjZXkleCNleSRpI2V5JG0jZXl+T20tZE90LXJPeSZScX5QJ1JPeCxmT3kmUnF+TyVWK2VPZSZUYXgmVGF+T1Qpak9fKWtPJHwpbE8lUVZPZSZTYX5PeCxqT2UmU2F+T1Qke09fJHtPbS1kT3Qtck9+UCdST20tZE90LXJPeSxsT3gjfGkhVSN8aX5QJ1JPbS1kT3Qtck94I3xpIVUjfGl+UCdST3ksbE94I3xpIVUjfGl+T20tZE90LXJPeSl5T35QJ1JPbS1kT3Qtck95KXlPIVUlZHF+UCdST3gsb08hVSVkcX5PbS1kT3Qtck94LG9PIVUlZHF+UCdST3Esck8hUiViTyFTJWFPZSVacSFVJVpxIVklWnF4JVpxflAhLGlPXypkT20tZE90LXJPIVklYHl+UCdST3gjemkhWSN6aX5QJF9PXypkT20tZE90LXJPflAnUk9UKmhPbS1kT3Qtck9+UCdST1QqaE9tLWRPdC1yT3klb3EhWSVvcSFqJW9xflAnUk9UJlFPbS1kT3Qtck8jXiRzcSRqJHNxJG0kc3ElViRzcX5QJ1JPI1Ysdk94JF1hI14kXWEkaiRdYSRtJF1hZSRdYX5PJVFWTyNeJX1pJGolfWkkbSV9aWUlfWl+T3gseE8jXiV9aSRqJX1pJG0lfWllJX1pfk9yLHtPUCNkIVJUI2QhUmQjZCFSZiNkIVJtI2QhUnEjZCFSdCNkIVJ9I2QhUiFPI2QhUiFSI2QhUiFTI2QhUiFWI2QhUiFaI2QhUiFmI2QhUiFtI2QhUiFuI2QhUiFvI2QhUiF2I2QhUiF4I2QhUiF6I2QhUiF8I2QhUiNPI2QhUiNTI2QhUiNVI2QhUiNYI2QhUiNZI2QhUiNbI2QhUiNjI2QhUiNmI2QhUiNqI2QhUiNsI2QhUiNxI2QhUiN0I2QhUiRnI2QhUiRqI2QhUiR6I2QhUiR7I2QhUiVQI2QhUiVRI2QhUiVmI2QhUiVnI2QhUiVqI2QhUiVtI2QhUiVzI2QhUiV2I2QhUiV4I2QhUiRpI2QhUiRtI2QhUn5PbS1kT3Qtck95JlJ5flAnUk9UKWpPXylrTyR8KWxPJVFWT2UmU2l+T20tZE90LXJPeCN8cSFVI3xxflAnUk95LVJPeCN8cSFVI3xxfk9tLWRPdC1yT3kpeU8hVSVkeX5QJ1JPeC1TTyFVJWR5fk9tLWRPdC1XT35QJ1JPcSxyTyFSJWJPIVMlYU9lJVp5IVUlWnkhWSVaeXglWnl+UCEsaU8lUVZPI14lfXEkaiV9cSRtJX1xZSV9cX5PeC1bTyNeJX1xJGolfXEkbSV9cWUlfXF+T1Qpak9fKWtPJHwpbE8lUVZPfk9tLWRPdC1yT3gjfHkhVSN8eX5QJ1JPbS1kT3Qtck95KXlPIVUlZCFSflAnUk94LV9PIVUlZCFSfk9lJV5YcSVeWCFSJV5YIVMlXlghVSVeWCFZJV5YeCVeWH5QISxpT3Esck8hUiViTyFTJWFPZSVdYSFVJV1hIVklXWF4JV1hfk8lUVZPI14lfXkkaiV9eSRtJX15ZSV9eX5PbS1kT3Qtck95KXlPIVUlZCFaflAnUk95LWJPfk94KnBPI14kc2EkaiRzYSRtJHNhJVYkc2F+UCRfT1QmUU9tLWRPdC1yT35QJ1JPbC1pT35PbS1pT35QJ1JPeS1qT35Pci1rT35QISxpTyVnJWoldiV4JWYhWiVuJXQldyV5JW0lcyVtJVF+XCIsXG4gIGdvdG86IFwiIS1nJlVQUFBQJlZQJl8pcCpWKm0rVStuLFhQLHNQJl8tYS1hJl9QUFAmXzByUFBQUFBQMHIzYlBQM2JQNW41dzp6UFA6fTtdO2BQUCZfJl9QUDtsUFAmXyZfUFAmXyZfJl8mXyZfO3A8ZCZfUDxnUDxqPGpAUFBAZSZfUFBQQGlAbyZWUCZWJlZQJlZQJlZQJlZQJlZQJlYmViZWUCZWUFAmVlBQJlZQQHVQQHxBU1BAfFBAfEB8UFBQQHxQQntQQ1VDW0NiQntQQHxDaFBDb0N1Q3tEWERrRHFEe0VSRW9FdUV7RlJGXUZjRmlGb0Z1RntHX0dpR29HdUd7SFZIXUhjSGlIb0h5SVBJWklhUFBQUFBQUFBQSWpJckl7SlZKYlBQUFBQUFBQUFBQUE53ISBhISVvISh7UFAhKVQhKWMhKWwhKmIhKlghKmshKnEhKnQhKnchKnohK1MhK3BQUFBQUFBQUFBQIStzISt2UFBQUFBQUFBQISt8ISxZISxmISxsISx1ISx4IS1PIS1VIS1bIS1fXWlPciNtJG0pXStaJ29kT1NYWVplaHJzdHZ4fH0hUiFTIVQhVSFYIWMhZCFlIWYhZyFoIWkhayFvIXAhcSFzIXQheiF9I1IjUyNdI2ojbSRPJFAkUiRUJFckaCRqJGskbSR7JVElWCVbJV4lYSVlJWolbCV2Jk8mUSZdJmEmaiZsJm0mdCZ4JnsnUydWJ2EnYidlJ2cnaCdsJ3Encyd3J3soUShSKFgoWyhjKGUobShwKHwpUClUKVUpWSldKWYpcCl2KXkpeil9KlQqVSpXKlkqXSpeKmEqZCpoKmkqcCpyKnMqeitTK1QrWitiK2MrZittK24rbytxK3IrdSt3K3kreyt9LFAsUSxTLGYsaCxsLG8sci1SLVMtXy1iLWQtZS1mLWctaS1qLWstbC1tLW8tc3chY1AjaSN2JFgkZyVjJWglbiVvJmImeihkKG8pUypSKlsrUit8LWh5IWRQI2kjdiRYJGckcyVjJWglbiVvJmImeihkKG8pUypSKlsrUit8LWh7IWVQI2kjdiRYJGckcyR0JWMlaCVuJW8mYiZ6KGQobylTKlIqWytSK3wtaH0hZlAjaSN2JFgkZyRzJHQkdSVjJWglbiVvJmImeihkKG8pUypSKlsrUit8LWghUCFnUCNpI3YkWCRnJHMkdCR1JHYlYyVoJW4lbyZiJnooZChvKVMqUipbK1IrfC1oIVIhaFAjaSN2JFgkZyRzJHQkdSR2JHclYyVoJW4lbyZiJnooZChvKVMqUipbK1IrfC1oIVYhaFAhbiNpI3YkWCRnJHMkdCR1JHYkdyR4JWMlaCVuJW8mYiZ6KGQobylTKlIqWytSK3wtaCdvU09TWFlaZWhyc3R2eHx9IVIhUyFUIVUhWCFjIWQhZSFmIWchaCFpIWshbyFwIXEhcyF0IXohfSNSI1MjXSNqI20kTyRQJFIkVCRXJGgkaiRrJG0keyVRJVglWyVeJWElZSVqJWwldiZPJlEmXSZhJmombCZtJnQmeCZ7J1MnVidhJ2InZSdnJ2gnbCdxJ3Mndyd7KFEoUihYKFsoYyhlKG0ocCh8KVApVClVKVkpXSlmKXApdil5KXopfSpUKlUqVypZKl0qXiphKmQqaCppKnAqcipzKnorUytUK1orYitjK2YrbStuK28rcStyK3Urdyt5K3srfSxQLFEsUyxmLGgsbCxvLHItUi1TLV8tYi1kLWUtZi1nLWktai1rLWwtbS1vLXMmWlVPWFlaaHJ0dnx9IVIhUyFUIVghaSFrIW8hcCFxIXMhdCNdI2ojbSRQJFIkVCRXJGskbSR7JVElWCVbJV4lZSVqJWwldiZPJl0mYSZsJm0mdCZ7J1MnVidhJ2InZSdnJ2gnbCdzJ3soUihYKFsoYyhlKG0ofClQKVkpXSlmKXApdil5KXopfSpUKlUqVypZKl0qXiphKmgqaSpwKnMqeitaK2IrYytmK20rbitvK3Ercit1K3creSt7K30sUCxRLFMsZixoLGwsbyxyLVItUy1fLWItZC1lLWYtZy1pLWotay1sLW8tcyVlV09YWVpocnZ8fSFSIVMhVCFYIWkhayNdI2ojbSRQJFIkVCRXJGskbSR7JVElWyVeJWUlaiVsJXYmTyZdJmEmbCZtJnQmeydTJ1YnYSdiJ2UnZydoJ2wncyd7KFIoWChbKGMoZShtKHwpUClZKV0pZilwKXYpeSl6KX0qVCpXKlkqXSpeKmEqaCppKnAqcyp6K1orYitjK2YrbStuK28rcStyK3UreSt7K30sUCxRLFMsZixoLGwsby1SLVMtXy1qLWstbFEjfHVRLWAtV1ItcC1yJ2ZkT1NYWVplaHJzdHZ4fH0hUiFTIVQhVSFYIWMhZCFlIWYhZyFoIWshbyFwIXEhcyF0IXohfSNSI1MjXSNqI20kTyRQJFIkVCRXJGgkaiRrJG0keyVRJVglWyVeJWElZSVqJWwldiZPJlEmXSZhJmombCZtJnQmeCZ7J1MnVidhJ2UnZydoJ2wncSdzJ3cneyhRKFIoWChbKGMoZShtKHAofClQKVQpVSlZKV0pZilwKXkpeil9KlQqVSpXKlkqXSpeKmEqZCpoKmkqcCpyKnMqeitTK1QrWitiK2MrZituK28rcStyK3Urdyt5K3srfSxQLFEsUyxmLGgsbCxvLHItUi1TLV8tYi1kLWUtZi1nLWktai1rLWwtbS1vLXNXI3BsIU8hUCRfVyN4dSZfLVctclEkYSFRUSRxIVlRJHIhWlckeiFpJ2IpdittUyZeI3kjelEnTyRsUShmJldRKHQmblUodSZwKHYod1UoeCZyKHkqeVEpaCdYVylpJ1oraSxqLVBTK2gpailrWSxVKnQsVix3LHgtW1EsWCp2USxjK19RLGUrYVItWix2UiZdI3hpIXdYWSFTIVQlXiVlJ3MneylQKlQqVypZUiVbIXZRIXtYUSV3I11RJmYkVFImaSRXVC1WLHItYiFVIWpQIW4jaSN2JFgkZyRzJHQkdSR2JHckeCVjJWglbiVvJmImeihkKG8pUypSKlsrUit8LWhRJlojcVInXiRyUidhJHpSJVQhbSduY09TWFlaZWhyc3R2eHx9IVIhUyFUIVUhWCFjIWQhZSFmIWchaCFpIWshbyFwIXEhcyF0IXohfSNSI1MjXSNqI20kTyRQJFIkVCRXJGgkaiRrJG0keyVRJVglWyVeJWElZSVqJWwldiZPJlEmXSZhJmombCZtJnQmeCZ7J1MnVidhJ2InZSdnJ2gnbCdxJ3Mndyd7KFEoUihYKFsoYyhlKG0ocCh8KVApVClVKVkpXSlmKXApdil5KXopfSpUKlUqVypZKl0qXiphKmQqaCppKnAqcipzKnorUytUK1orYitjK2YrbStuK28rcStyK3Urdyt5K3srfSxQLFEsUyxmLGgsbCxvLHItUi1TLV8tYi1kLWUtZi1nLWktai1rLWwtbS1vLXNUI2djI2hTI15fI19TI2FgI2JTI2NhI2RTI2ViI2ZUKmwoXyptVChgJXcoYlEkVndSK2cpaVgkVHckVSRWJmhaa09yJG0pXStaWG9PcildK1pRJG4hV1EmdiRlUSZ3JGZRJ1kkcFEnXSRyUSlaJn1RKWEnU1EpYydUUSlkJ1VRKXEnW1EpcydeUSp9KVBRK1ApUVErUSlSUStVKVhTK1cpWylyUStbKV9RK10pYFErXiliUSxaKnxRLFsrT1EsXitWUSxfK1hRLGQrYFEseixdUSx8LGJRLH0sY1ItXSx7V29PcildK1pSI3NuUSdbJHFSKVsnT1ErZilpUixoK2dRKXInW1IrWClbWm1PbnIpXStaUXJPUiN1clEmYCN7UihrJmBTJWsjUSN9UyhTJWsoVlQoViVuJmJRJV8heVElZiF8Vyd0JV8lZid5J31RJ3klY1InfSVoUSZrJFhSKHEma1EoWSVvUSpfKFRUKmUoWSpfUSdjJHxSKXcnY1MnZiVQJVFZKXsnZil8K3MscC1UVSl8J2cnaCdpVStzKX0qTypQUyxwK3QrdVItVCxxUSNYXVIlciNYUSNbXlIldCNbUSNfX1IleCNfUShdJXVTKmooXSprUiprKF5RKm0oX1IsUiptUSNiYFIleiNiUSNkYVIleyNkUSNmYlIlfCNmUSNoY1IlfSNoUSNrZlEmUCNpVyZTI2smUChuKnFRKG4mZVIqcS1oUSRVd1MmZyRVJmhSJmgkVlEmdSRjUih9JnVRJlgjcFIoZyZYUSRfIVBSJm8kX1EqdSh1UyxXKnUseVIseSxYUSZzJGFSKHomc1EjbmpSJlUjblErWildUixgK1pRKU8mdlIqeylPUSZ5JGdTKVYmeSlXUilXJnpRJ1IkblIpXidSUSdXJG9TKWcnVytkUitkKWhRK2opbVIsaytqV25PcildK1pSI3JuU3FPclQrWSldK1pXcE9yKV0rWlInUCRtWWpPciRtKV0rWlImVCNtW3dPciNtJG0pXStaUiZmJFQmWVBPWFlaaHJ0dnx9IVIhUyFUIVghaSFrIW8hcCFxIXMhdCNdI2ojbSRQJFIkVCRXJGskbSR7JVElWCVbJV4lZSVqJWwldiZPJl0mYSZsJm0mdCZ7J1MnVidhJ2InZSdnJ2gnbCdzJ3soUihYKFsoYyhlKG0ofClQKVkpXSlmKXApdil5KXopfSpUKlUqVypZKl0qXiphKmgqaSpwKnMqeitaK2IrYytmK20rbitvK3Ercit1K3creSt7K30sUCxRLFMsZixoLGwsbyxyLVItUy1fLWItZC1lLWYtZy1pLWotay1sLW8tc1EhblNRI2llUSN2c1UkWHglYSd3UyRnIVUkalEkcyFjUSR0IWRRJHUhZVEkdiFmUSR3IWdRJHghaFElYyF6USVoIX1RJW4jUlElbyNTUSZiJE9RJnokaFEoZCZRVShvJmoocCpyVylTJngpVStTK1RRKlIncVEqWyhRUStSKVRRK3wqZFItaC1tUSF5WFEhfFlRJGUhU1EkZiFUXidwJV4lZSdzJ3sqVCpXKllSK08pUFtmT3IjbSRtKV0rWmghdlhZIVMhVCVeJWUncyd7KVAqVCpXKllRI1FaUSNsaFMjfXZ8USRbfVckYyFSJFcmeylZUyRvIVgka1ckeSFpJ2IpdittUSVQIWtRJXUjXWAmUiNqJk8oYyhlKG0qcCxTLWxRJmMkUFEmZCRSUSZlJFRRJ18ke1EnaSVRUSdvJVtXKFAlaihSKl0qYVEoVCVsUSheJXZRKGkmXVMobCZhLWpRKHImbFEocyZtVSh7JnQofCp6USliJ1NZKWUnVilmK2IrYyxmUSl0J2FeKXgnZSl6K3ErcixvLVMtX1EqTydnUSpQJ2hTKlEnbC1rVypjKFgqXit5K31XKmcoWyppLFAsUVErbClwUStwKXlRK3QpfVEsTypoUSxUKnNRLGcrZlEsbStuUSxuK29RLHErdVEsdSt7US1PLGhRLVEsbFItXi1SaFRPciNqI20kbSZPJmEnbChjKGUpXStaJHohdVhZWmh2fH0hUiFTIVQhWCFpIWsjXSRQJFIkVCRXJGskeyVRJVslXiVlJWolbCV2Jl0mbCZtJnQmeydTJ1YnYSdiJ2UnZydoJ3MneyhSKFgoWyhtKHwpUClZKWYpcCl2KXkpeil9KlQqVypZKl0qXiphKmgqaSpwKnMqeitiK2MrZittK24rbytxK3IrdSt5K3srfSxQLFEsUyxmLGgsbCxvLVItUy1fLWotay1sUSN3dFclVSFvIXMtZS1vUSVWIXBRJVchcVElWSF0USVkLWRTJ2slWC1pUSdtLWZRJ24tZ1ErdipVUSx0K3dTLVUsci1iUi1xLXNVI3t1LVctclIoaiZfW2dPciNtJG0pXStaWCF4WCNdJFQkV1EjVlpRJFF2UiRafFElYCF5USVnIXxRJW0jUVEnXyR5USd6JWNRKE8laFEoVyVuUShaJW9RKmAoVFEscyt2US1ZLHRSLWEtWFEkWXhRJ3YlYVIqVid3US1YLHJSLWMtYlIjUFlSI1VaUiVPIWlRJHwhaVYpdSdiKXYrbSFWIWxQIW4jaSN2JFgkZyRzJHQkdSR2JHckeCVjJWglbiVvJmImeihkKG8pUypSKlsrUit8LWhSJVIha1IldyNdUShhJXdSKm8oYlEkZCFSUSZpJFdRKVgme1IrVilZUSNxbFEkXSFPUSRgIVBSJnEkX1EodCZwUip4KHdRKHQmcFEqdyh2Uip4KHdSJGIhUVhwT3IpXStaUSRpIVVSJnwkalEkcCFYUiZ9JGtSKW8nWlEpbSdaVixpK2ksai1QXCIsXG4gIG5vZGVOYW1lczogXCLimqAgcHJpbnQgQ29tbWVudCBTY3JpcHQgQXNzaWduU3RhdGVtZW50ICogQmluYXJ5RXhwcmVzc2lvbiBCaXRPcCBCaXRPcCBCaXRPcCBCaXRPcCBBcml0aE9wIEFyaXRoT3AgQCBBcml0aE9wICoqIFVuYXJ5RXhwcmVzc2lvbiBBcml0aE9wIEJpdE9wIEF3YWl0RXhwcmVzc2lvbiBhd2FpdCApICggUGFyZW50aGVzaXplZEV4cHJlc3Npb24gQmluYXJ5RXhwcmVzc2lvbiBvciBhbmQgQ29tcGFyZU9wIGluIG5vdCBpcyBVbmFyeUV4cHJlc3Npb24gQ29uZGl0aW9uYWxFeHByZXNzaW9uIGlmIGVsc2UgTGFtYmRhRXhwcmVzc2lvbiBsYW1iZGEgUGFyYW1MaXN0IFZhcmlhYmxlTmFtZSBBc3NpZ25PcCAsIDogTmFtZWRFeHByZXNzaW9uIEFzc2lnbk9wIFlpZWxkRXhwcmVzc2lvbiB5aWVsZCBmcm9tIFR1cGxlRXhwcmVzc2lvbiBDb21wcmVoZW5zaW9uRXhwcmVzc2lvbiBhc3luYyBmb3IgTGFtYmRhRXhwcmVzc2lvbiBdIFsgQXJyYXlFeHByZXNzaW9uIEFycmF5Q29tcHJlaGVuc2lvbkV4cHJlc3Npb24gfSB7IERpY3Rpb25hcnlFeHByZXNzaW9uIERpY3Rpb25hcnlDb21wcmVoZW5zaW9uRXhwcmVzc2lvbiBTZXRFeHByZXNzaW9uIFNldENvbXByZWhlbnNpb25FeHByZXNzaW9uIENhbGxFeHByZXNzaW9uIEFyZ0xpc3QgQXNzaWduT3AgTWVtYmVyRXhwcmVzc2lvbiAuIFByb3BlcnR5TmFtZSBOdW1iZXIgU3RyaW5nIEZvcm1hdFN0cmluZyBGb3JtYXRSZXBsYWNlbWVudCBGb3JtYXRDb252ZXJzaW9uIEZvcm1hdFNwZWMgQ29udGludWVkU3RyaW5nIEVsbGlwc2lzIE5vbmUgQm9vbGVhbiBUeXBlRGVmIEFzc2lnbk9wIFVwZGF0ZVN0YXRlbWVudCBVcGRhdGVPcCBFeHByZXNzaW9uU3RhdGVtZW50IERlbGV0ZVN0YXRlbWVudCBkZWwgUGFzc1N0YXRlbWVudCBwYXNzIEJyZWFrU3RhdGVtZW50IGJyZWFrIENvbnRpbnVlU3RhdGVtZW50IGNvbnRpbnVlIFJldHVyblN0YXRlbWVudCByZXR1cm4gWWllbGRTdGF0ZW1lbnQgUHJpbnRTdGF0ZW1lbnQgUmFpc2VTdGF0ZW1lbnQgcmFpc2UgSW1wb3J0U3RhdGVtZW50IGltcG9ydCBhcyBTY29wZVN0YXRlbWVudCBnbG9iYWwgbm9ubG9jYWwgQXNzZXJ0U3RhdGVtZW50IGFzc2VydCBTdGF0ZW1lbnRHcm91cCA7IElmU3RhdGVtZW50IEJvZHkgZWxpZiBXaGlsZVN0YXRlbWVudCB3aGlsZSBGb3JTdGF0ZW1lbnQgVHJ5U3RhdGVtZW50IHRyeSBleGNlcHQgZmluYWxseSBXaXRoU3RhdGVtZW50IHdpdGggRnVuY3Rpb25EZWZpbml0aW9uIGRlZiBQYXJhbUxpc3QgQXNzaWduT3AgVHlwZURlZiBDbGFzc0RlZmluaXRpb24gY2xhc3MgRGVjb3JhdGVkU3RhdGVtZW50IERlY29yYXRvciBBdFwiLFxuICBtYXhUZXJtOiAyMzYsXG4gIGNvbnRleHQ6IHRyYWNrSW5kZW50LFxuICBub2RlUHJvcHM6IFtcbiAgICBbXCJncm91cFwiLCAtMTQsNCw4MCw4Miw4Myw4NSw4Nyw4OSw5MSw5Myw5NCw5NSw5NywxMDAsMTAzLFwiU3RhdGVtZW50IFN0YXRlbWVudFwiLC0yMiw2LDE2LDE5LDIzLDM4LDQ3LDQ4LDU0LDU1LDU4LDU5LDYwLDYxLDYyLDY1LDY4LDY5LDcwLDc0LDc1LDc2LDc3LFwiRXhwcmVzc2lvblwiLC05LDEwNSwxMDcsMTEwLDExMiwxMTMsMTE3LDExOSwxMjQsMTI2LFwiU3RhdGVtZW50XCJdLFxuICAgIFtcIm9wZW5lZEJ5XCIsIDIxLFwiKFwiLDUyLFwiW1wiLDU2LFwie1wiXSxcbiAgICBbXCJjbG9zZWRCeVwiLCAyMixcIilcIiw1MyxcIl1cIiw1NyxcIn1cIl1cbiAgXSxcbiAgcHJvcFNvdXJjZXM6IFtweXRob25IaWdobGlnaHRpbmddLFxuICBza2lwcGVkTm9kZXM6IFswLDJdLFxuICByZXBlYXROb2RlQ291bnQ6IDMyLFxuICB0b2tlbkRhdGE6IFwiJkpkTWdSIV5PWCR9WFkhJl1ZWyR9W10hJl1dcCR9cHEhJl1xciEoZ3JzISxec3QhSVl0dSR9dXYkNVt2dyQ3bnd4JDh6eHklJ3Z5eiUofHp7JSpTe3wlLHJ8fSUuT30hTyUvVSFPIVAlMWshUCFRJTxxIVEhUiU/YSFSIVslQ2MhWyFdJU5fIV0hXiYhcSFeIV8mI3chXyFgJiZnIWAhYSYncyFhIWIkfSFiIWMmKmAhYyFkJituIWQhZSYtYCFlIWgmK24haCFpJjdbIWkhdCYrbiF0IXUmQGohdSF3JituIXcheCY1aiF4IX0mK24hfSNPJkJ0I08jUCEndSNQI1EmQ3ojUSNSJkVRI1IjUyYrbiNTI1QkfSNUI1UmK24jVSNWJi1gI1YjWSYrbiNZI1omN1sjWiNmJituI2YjZyZAaiNnI2kmK24jaSNqJjVqI2ojbyYrbiNvI3AmRl4jcCNxJkdTI3EjciZIYCNyI3MmSV4jcyRnJH0kZ34mK248ciVgWiVxN1slaFMla1clbmAldHAldyFiJXkjdE9yJH1ycyZSc3ckfXd4SHN4I08kfSNPI1AhJFIjUCNvJH0jbyNwISVpI3AjcSR9I3EjciEkZyNyfiR9PFEmXlolcTdbJWhTJW5gJXchYk9yJ1Byc0Zpc3cnUHd4KFJ4I08nUCNPI1BBZSNQI28nUCNvI3BFdSNwI3EnUCNxI3JBeSNyfidQPFEnYFolcTdbJWhTJWtXJW5gJXchYiV5I3RPcidQcnMmUnN3J1B3eChSeCNPJ1AjTyNQQWUjUCNvJ1AjbyNwRXUjcCNxJ1AjcSNyQXkjcn4nUDtwKFtaJXE3WyVrVyV5I3RPcih9cnMpfXN3KH13eD17eCNPKH0jTyNQMl0jUCNvKH0jbyNwOlgjcCNxKH0jcSNyMnEjcn4ofTtwKVtaJXE3WyVoUyVrVyV3IWIleSN0T3IofXJzKX1zdyh9d3goUngjTyh9I08jUDJdI1Ajbyh9I28jcDpYI3AjcSh9I3EjcjJxI3J+KH07cCpXWiVxN1slaFMldyFiT3IofXJzKnlzdyh9d3goUngjTyh9I08jUDJdI1Ajbyh9I28jcDpYI3AjcSh9I3EjcjJxI3J+KH07cCtTWiVxN1slaFMldyFiT3IofXJzK3Vzdyh9d3goUngjTyh9I08jUDJdI1Ajbyh9I28jcDpYI3AjcSh9I3EjcjJxI3J+KH04cixPWCVxN1slaFMldyFiT3crdXd4LGt4I08rdSNPI1AuXSNQI28rdSNvI3AwZCNwI3ErdSNxI3IucSNyfit1OHIscFglcTdbT3crdXd4LV14I08rdSNPI1AuXSNQI28rdSNvI3AwZCNwI3ErdSNxI3IucSNyfit1OHItYlglcTdbT3crdXd4LX14I08rdSNPI1AuXSNQI28rdSNvI3AwZCNwI3ErdSNxI3IucSNyfit1N1suU1IlcTdbTyNvLX0jcCNxLX0jcn4tfThyLmJUJXE3W08jbyt1I28jcC5xI3AjcSt1I3Ejci5xI3J+K3UhZi54ViVoUyV3IWJPdy5xd3gvX3gjTy5xI08jUDBeI1Ajby5xI28jcDBkI3B+LnEhZi9iVk93LnF3eC93eCNPLnEjTyNQMF4jUCNvLnEjbyNwMGQjcH4ucSFmL3pVT3cucXgjTy5xI08jUDBeI1Ajby5xI28jcDBkI3B+LnEhZjBhUE9+LnEhZjBpViVoU093MU93eDFkeCNPMU8jTyNQMlYjUCNvMU8jbyNwLnEjcH4xT1MxVFQlaFNPdzFPd3gxZHgjTzFPI08jUDJWI1B+MU9TMWdUT3cxT3d4MXZ4I08xTyNPI1AyViNQfjFPUzF5U093MU94I08xTyNPI1AyViNQfjFPUzJZUE9+MU87cDJiVCVxN1tPI28ofSNvI3AycSNwI3EofSNxI3IycSNyfih9JWQyfFglaFMla1cldyFiJXkjdE9yMnFyczNpc3cycXd4NVB4I08ycSNPI1A6UiNQI28ycSNvI3A6WCNwfjJxJWQzcFglaFMldyFiT3IycXJzNF1zdzJxd3g1UHgjTzJxI08jUDpSI1AjbzJxI28jcDpYI3B+MnElZDRkWCVoUyV3IWJPcjJxcnMucXN3MnF3eDVQeCNPMnEjTyNQOlIjUCNvMnEjbyNwOlgjcH4ycSVkNVdYJWtXJXkjdE9yMnFyczNpc3cycXd4NXN4I08ycSNPI1A6UiNQI28ycSNvI3A6WCNwfjJxJWQ1elgla1cleSN0T3IycXJzM2lzdzJxd3g2Z3gjTzJxI08jUDpSI1AjbzJxI28jcDpYI3B+MnEjfDZuViVrVyV5I3RPcjZncnM3VHMjTzZnI08jUDhTI1AjbzZnI28jcDhZI3B+NmcjfDdXVk9yNmdyczdtcyNPNmcjTyNQOFMjUCNvNmcjbyNwOFkjcH42ZyN8N3BVT3I2Z3MjTzZnI08jUDhTI1AjbzZnI28jcDhZI3B+NmcjfDhWUE9+NmcjfDhfViVrV09yOHRyczlZcyNPOHQjTyNQOXsjUCNvOHQjbyNwNmcjcH44dFc4eVQla1dPcjh0cnM5WXMjTzh0I08jUDl7I1B+OHRXOV1UT3I4dHJzOWxzI084dCNPI1A5eyNQfjh0VzlvU09yOHRzI084dCNPI1A5eyNQfjh0VzpPUE9+OHQlZDpVUE9+MnElZDpgWCVoUyVrV09yOntycztpc3c6e3d4PG94I086eyNPI1A9dSNQI286eyNvI3AycSNwfjp7WztTViVoUyVrV09yOntycztpc3c6e3d4PG94I086eyNPI1A9dSNQfjp7WztuViVoU09yOntyczxUc3c6e3d4PG94I086eyNPI1A9dSNQfjp7WzxZViVoU09yOntyczFPc3c6e3d4PG94I086eyNPI1A9dSNQfjp7Wzx0ViVrV09yOntycztpc3c6e3d4PVp4I086eyNPI1A9dSNQfjp7Wz1gViVrV09yOntycztpc3c6e3d4OHR4I086eyNPI1A9dSNQfjp7Wz14UE9+Ons7cD5VWiVxN1sla1cleSN0T3IofXJzKX1zdyh9d3g+d3gjTyh9I08jUDJdI1Ajbyh9I28jcDpYI3AjcSh9I3EjcjJxI3J+KH06WT9RWCVxN1sla1cleSN0T3I+d3JzP21zI08+dyNPI1BBUCNQI28+dyNvI3A4WSNwI3E+dyNxI3I2ZyNyfj53Olk/clglcTdbT3I+d3JzQF9zI08+dyNPI1BBUCNQI28+dyNvI3A4WSNwI3E+dyNxI3I2ZyNyfj53OllAZFglcTdbT3I+d3JzLX1zI08+dyNPI1BBUCNQI28+dyNvI3A4WSNwI3E+dyNxI3I2ZyNyfj53OllBVVQlcTdbTyNvPncjbyNwNmcjcCNxPncjcSNyNmcjcn4+dzxRQWpUJXE3W08jbydQI28jcEF5I3AjcSdQI3EjckF5I3J+J1AldEJXWCVoUyVrVyVuYCV3IWIleSN0T3JBeXJzQnNzd0F5d3g1UHgjT0F5I08jUEVvI1Ajb0F5I28jcEV1I3B+QXkldEJ8WCVoUyVuYCV3IWJPckF5cnNDaXN3QXl3eDVQeCNPQXkjTyNQRW8jUCNvQXkjbyNwRXUjcH5BeSV0Q3JYJWhTJW5gJXchYk9yQXlyc0Rfc3dBeXd4NVB4I09BeSNPI1BFbyNQI29BeSNvI3BFdSNwfkF5IXZEaFYlaFMlbmAldyFiT3dEX3d4L194I09EXyNPI1BEfSNQI29EXyNvI3BFVCNwfkRfIXZFUVBPfkRfIXZFWVYlaFNPdzFPd3gxZHgjTzFPI08jUDJWI1AjbzFPI28jcERfI3B+MU8ldEVyUE9+QXkldEV8WCVoUyVrV09yOntycztpc3c6e3d4PG94I086eyNPI1A9dSNQI286eyNvI3BBeSNwfjp7PFFGdFolcTdbJWhTJW5gJXchYk9yJ1Byc0dnc3cnUHd4KFJ4I08nUCNPI1BBZSNQI28nUCNvI3BFdSNwI3EnUCNxI3JBeSNyfidQOVNHclglcTdbJWhTJW5gJXchYk93R2d3eCxreCNPR2cjTyNQSF8jUCNvR2cjbyNwRVQjcCNxR2cjcSNyRF8jcn5HZzlTSGRUJXE3W08jb0dnI28jcERfI3AjcUdnI3EjckRfI3J+R2c8YklPWiVxN1sla1cldHAleSN0T3JJcXJzKX1zd0lxd3ghIHd4I09JcSNPI1BKcyNQI29JcSNvI3AhIFQjcCNxSXEjcSNyS1gjcn5JcTxiSlFaJXE3WyVoUyVrVyV0cCV3IWIleSN0T3JJcXJzKX1zd0lxd3hIc3gjT0lxI08jUEpzI1Ajb0lxI28jcCEgVCNwI3FJcSNxI3JLWCNyfklxPGJKeFQlcTdbTyNvSXEjbyNwS1gjcCNxSXEjcSNyS1gjcn5JcSZVS2ZYJWhTJWtXJXRwJXchYiV5I3RPcktYcnMzaXN3S1h3eExSeCNPS1gjTyNQTn0jUCNvS1gjbyNwISBUI3B+S1gmVUxbWCVrVyV0cCV5I3RPcktYcnMzaXN3S1h3eEx3eCNPS1gjTyNQTn0jUCNvS1gjbyNwISBUI3B+S1gmVU1RWCVrVyV0cCV5I3RPcktYcnMzaXN3S1h3eE1teCNPS1gjTyNQTn0jUCNvS1gjbyNwISBUI3B+S1gkbk12ViVrVyV0cCV5I3RPck1tcnM3VHMjT01tI08jUE5dI1Ajb01tI28jcE5jI3B+TW0kbk5gUE9+TW0kbk5oViVrV09yOHRyczlZcyNPOHQjTyNQOXsjUCNvOHQjbyNwTW0jcH44dCZVISBRUE9+S1gmVSEgW1glaFMla1dPcjp7cnM7aXN3Ont3eDxveCNPOnsjTyNQPXUjUCNvOnsjbyNwS1gjcH46ezxiISFTWiVxN1sla1cldHAleSN0T3JJcXJzKX1zd0lxd3ghIXV4I09JcSNPI1BKcyNQI29JcSNvI3AhIFQjcCNxSXEjcSNyS1gjcn5JcTp6ISNRWCVxN1sla1cldHAleSN0T3IhIXVycz9tcyNPISF1I08jUCEjbSNQI28hIXUjbyNwTmMjcCNxISF1I3Ejck1tI3J+ISF1OnohI3JUJXE3W08jbyEhdSNvI3BNbSNwI3EhIXUjcSNyTW0jcn4hIXU8ciEkV1QlcTdbTyNvJH0jbyNwISRnI3AjcSR9I3EjciEkZyNyfiR9JmYhJHZYJWhTJWtXJW5gJXRwJXchYiV5I3RPciEkZ3JzQnNzdyEkZ3d4TFJ4I08hJGcjTyNQISVjI1AjbyEkZyNvI3AhJWkjcH4hJGcmZiElZlBPfiEkZyZmISVwWCVoUyVrV09yOntycztpc3c6e3d4PG94I086eyNPI1A9dSNQI286eyNvI3AhJGcjcH46e01nISZwYSVxN1slaFMla1ckbzFzJW5gJXRwJXchYiV5I3RPWCR9WFkhJl1ZWyR9W10hJl1dcCR9cHEhJl1xciR9cnMmUnN3JH13eEhzeCNPJH0jTyNQISd1I1AjbyR9I28jcCElaSNwI3EkfSNxI3IhJGcjcn4kfU1nISd6WCVxN1tPWSR9WVohJl1aXSR9XV4hJl1eI28kfSNvI3AhJGcjcCNxJH0jcSNyISRnI3J+JH08dSEoeGIlcTdbJWhTJWtXJW5gJXRwJXchYiV5I3RPciR9cnMmUnN3JH13eEhzeCFfJH0hXyFgISpRIWAjTyR9I08jUCEkUiNQI1QkfSNUI1UhK1cjVSNmJH0jZiNnIStXI2cjaCErVyNoI28kfSNvI3AhJWkjcCNxJH0jcSNyISRnI3J+JH08dSEqZVprUiVxN1slaFMla1clbmAldHAldyFiJXkjdE9yJH1ycyZSc3ckfXd4SHN4I08kfSNPI1AhJFIjUCNvJH0jbyNwISVpI3AjcSR9I3EjciEkZyNyfiR9PHUhK2taIWpSJXE3WyVoUyVrVyVuYCV0cCV3IWIleSN0T3IkfXJzJlJzdyR9d3hIc3gjTyR9I08jUCEkUiNQI28kfSNvI3AhJWkjcCNxJH0jcSNyISRnI3J+JH1HeyEsbV8ldXAlcTdbJWhTJWYsWCVuYCV3IWJPWSEtbFlaJ1BaXSEtbF1eJ1BeciEtbHJzIUdec3chLWx3eCEvfHgjTyEtbCNPI1AhQ3AjUCNvIS1sI28jcCFGWyNwI3EhLWwjcSNyIURVI3J+IS1sR1ohLX1fJXE3WyVoUyVrVyVmLFglbmAldyFiJXkjdE9ZIS1sWVonUFpdIS1sXV4nUF5yIS1scnMhLnxzdyEtbHd4IS98eCNPIS1sI08jUCFDcCNQI28hLWwjbyNwIUZbI3AjcSEtbCNxI3IhRFUjcn4hLWxHWiEvWlolcTdbJWhTJWYsWCVuYCV3IWJPcidQcnNGaXN3J1B3eChSeCNPJ1AjTyNQQWUjUCNvJ1AjbyNwRXUjcCNxJ1AjcSNyQXkjcn4nUEZ5ITBYXyVxN1sla1clZixYJXkjdE9ZITFXWVoofVpdITFXXV4ofV5yITFXcnMhMmZzdyExV3d4IUBZeCNPITFXI08jUCEzZCNQI28hMVcjbyNwITt0I3AjcSExVyNxI3IhM3gjcn4hMVdGeSExZ18lcTdbJWhTJWtXJWYsWCV3IWIleSN0T1khMVdZWih9Wl0hMVddXih9XnIhMVdycyEyZnN3ITFXd3ghL3x4I08hMVcjTyNQITNkI1AjbyExVyNvI3AhO3QjcCNxITFXI3EjciEzeCNyfiExV0Z5ITJxWiVxN1slaFMlZixYJXchYk9yKH1ycyp5c3cofXd4KFJ4I08ofSNPI1AyXSNQI28ofSNvI3A6WCNwI3EofSNxI3IycSNyfih9RnkhM2lUJXE3W08jbyExVyNvI3AhM3gjcCNxITFXI3EjciEzeCNyfiExVzBtITRWXSVoUyVrVyVmLFgldyFiJXkjdE9ZITN4WVoycVpdITN4XV4ycV5yITN4cnMhNU9zdyEzeHd4ITV0eCNPITN4I08jUCE7biNQI28hM3gjbyNwITt0I3B+ITN4MG0hNVhYJWhTJWYsWCV3IWJPcjJxcnM0XXN3MnF3eDVQeCNPMnEjTyNQOlIjUCNvMnEjbyNwOlgjcH4ycTBtITV9XSVrVyVmLFgleSN0T1khM3hZWjJxWl0hM3hdXjJxXnIhM3hycyE1T3N3ITN4d3ghNnZ4I08hM3gjTyNQITtuI1AjbyEzeCNvI3AhO3QjcH4hM3gwbSE3UF0la1clZixYJXkjdE9ZITN4WVoycVpdITN4XV4ycV5yITN4cnMhNU9zdyEzeHd4ITd4eCNPITN4I08jUCE7biNQI28hM3gjbyNwITt0I3B+ITN4L1YhOFJaJWtXJWYsWCV5I3RPWSE3eFlaNmdaXSE3eF1eNmdeciE3eHJzITh0cyNPITd4I08jUCE5YCNQI28hN3gjbyNwITlmI3B+ITd4L1YhOHlWJWYsWE9yNmdyczdtcyNPNmcjTyNQOFMjUCNvNmcjbyNwOFkjcH42Zy9WITljUE9+ITd4L1YhOW1aJWtXJWYsWE9ZITpgWVo4dFpdITpgXV44dF5yITpgcnMhO1NzI08hOmAjTyNQITtoI1AjbyE6YCNvI3AhN3gjcH4hOmAsYSE6Z1gla1clZixYT1khOmBZWjh0Wl0hOmBdXjh0XnIhOmBycyE7U3MjTyE6YCNPI1AhO2gjUH4hOmAsYSE7WFQlZixYT3I4dHJzOWxzI084dCNPI1A5eyNQfjh0LGEhO2tQT34hOmAwbSE7cVBPfiEzeDBtITt9XSVoUyVrVyVmLFhPWSE8dllaOntaXSE8dl1eOnteciE8dnJzIT1yc3chPHZ3eCE+YHgjTyE8diNPI1AhQFMjUCNvITx2I28jcCEzeCNwfiE8dixlIT1QWiVoUyVrVyVmLFhPWSE8dllaOntaXSE8dl1eOnteciE8dnJzIT1yc3chPHZ3eCE+YHgjTyE8diNPI1AhQFMjUH4hPHYsZSE9eVYlaFMlZixYT3I6e3JzPFRzdzp7d3g8b3gjTzp7I08jUD11I1B+OnssZSE+Z1ola1clZixYT1khPHZZWjp7Wl0hPHZdXjp7XnIhPHZycyE9cnN3ITx2d3ghP1l4I08hPHYjTyNQIUBTI1B+ITx2LGUhP2FaJWtXJWYsWE9ZITx2WVo6e1pdITx2XV46e15yITx2cnMhPXJzdyE8dnd4ITpgeCNPITx2I08jUCFAUyNQfiE8dixlIUBWUE9+ITx2RnkhQGVfJXE3WyVrVyVmLFgleSN0T1khMVdZWih9Wl0hMVddXih9XnIhMVdycyEyZnN3ITFXd3ghQWR4I08hMVcjTyNQITNkI1AjbyExVyNvI3AhO3QjcCNxITFXI3EjciEzeCNyfiExV0VjIUFvXSVxN1sla1clZixYJXkjdE9ZIUFkWVo+d1pdIUFkXV4+d15yIUFkcnMhQmhzI08hQWQjTyNQIUNbI1AjbyFBZCNvI3AhOWYjcCNxIUFkI3EjciE3eCNyfiFBZEVjIUJvWCVxN1slZixYT3I+d3JzQF9zI08+dyNPI1BBUCNQI28+dyNvI3A4WSNwI3E+dyNxI3I2ZyNyfj53RWMhQ2FUJXE3W08jbyFBZCNvI3AhN3gjcCNxIUFkI3EjciE3eCNyfiFBZEdaIUN1VCVxN1tPI28hLWwjbyNwIURVI3AjcSEtbCNxI3IhRFUjcn4hLWwwfSFEZV0laFMla1clZixYJW5gJXchYiV5I3RPWSFEVVlaQXlaXSFEVV1eQXleciFEVXJzIUVec3chRFV3eCE1dHgjTyFEVSNPI1AhRlUjUCNvIURVI28jcCFGWyNwfiFEVTB9IUVpWCVoUyVmLFglbmAldyFiT3JBeXJzQ2lzd0F5d3g1UHgjT0F5I08jUEVvI1Ajb0F5I28jcEV1I3B+QXkwfSFGWFBPfiFEVTB9IUZlXSVoUyVrVyVmLFhPWSE8dllaOntaXSE8dl1eOnteciE8dnJzIT1yc3chPHZ3eCE+YHgjTyE8diNPI1AhQFMjUCNvITx2I28jcCFEVSNwfiE8dkdaIUdrWiVxN1slaFMlZixYJW5gJXchYk9yJ1BycyFIXnN3J1B3eChSeCNPJ1AjTyNQQWUjUCNvJ1AjbyNwRXUjcCNxJ1AjcSNyQXkjcn4nUEdaIUhtWCVsI3wlcTdbJWhTJWosWCVuYCV3IWJPd0dnd3gsa3gjT0dnI08jUEhfI1Ajb0dnI28jcEVUI3AjcUdnI3EjckRfI3J+R2dNZyFJbV9RMXMlcTdbJWhTJWtXJW5gJXRwJXchYiV5I3RPWSFJWVlaJH1aXSFJWV1eJH1eciFJWXJzIUpsc3chSVl3eCQkW3gjTyFJWSNPI1AkMXYjUCNvIUlZI28jcCQ0WSNwI3EhSVkjcSNyJDJqI3J+IUlZTHUhSnlfUTFzJXE3WyVoUyVuYCV3IWJPWSFLeFlaJ1BaXSFLeF1eJ1BeciFLeHJzJCBVc3chS3h3eCFNWXgjTyFLeCNPI1AjR14jUCNvIUt4I28jcCNOUyNwI3EhS3gjcSNyI0hRI3J+IUt4THUhTFpfUTFzJXE3WyVoUyVrVyVuYCV3IWIleSN0T1khS3hZWidQWl0hS3hdXidQXnIhS3hycyFKbHN3IUt4d3ghTVl4I08hS3gjTyNQI0deI1AjbyFLeCNvI3AjTlMjcCNxIUt4I3EjciNIUSNyfiFLeExlIU1lX1ExcyVxN1sla1cleSN0T1khTmRZWih9Wl0hTmRdXih9XnIhTmRycyMgcnN3IU5kd3gjQlt4I08hTmQjTyNQIy9mI1AjbyFOZCNvI3AjPGIjcCNxIU5kI3EjciMwWSNyfiFOZExlIU5zX1ExcyVxN1slaFMla1cldyFiJXkjdE9ZIU5kWVoofVpdIU5kXV4ofV5yIU5kcnMjIHJzdyFOZHd4IU1ZeCNPIU5kI08jUCMvZiNQI28hTmQjbyNwIzxiI3AjcSFOZCNxI3IjMFkjcn4hTmRMZSMgfV9RMXMlcTdbJWhTJXchYk9ZIU5kWVoofVpdIU5kXV4ofV5yIU5kcnMjIXxzdyFOZHd4IU1ZeCNPIU5kI08jUCMvZiNQI28hTmQjbyNwIzxiI3AjcSFOZCNxI3IjMFkjcn4hTmRMZSMjWF9RMXMlcTdbJWhTJXchYk9ZIU5kWVoofVpdIU5kXV4ofV5yIU5kcnMjJFdzdyFOZHd4IU1ZeCNPIU5kI08jUCMvZiNQI28hTmQjbyNwIzxiI3AjcSFOZCNxI3IjMFkjcn4hTmRJZyMkY11RMXMlcTdbJWhTJXchYk9ZIyRXWVordVpdIyRXXV4rdV53IyRXd3gjJVt4I08jJFcjTyNQIyheI1AjbyMkVyNvI3AjLFEjcCNxIyRXI3EjciMpUSNyfiMkV0lnIyVjXVExcyVxN1tPWSMkV1laK3VaXSMkV11eK3VedyMkV3d4IyZbeCNPIyRXI08jUCMoXiNQI28jJFcjbyNwIyxRI3AjcSMkVyNxI3IjKVEjcn4jJFdJZyMmY11RMXMlcTdbT1kjJFdZWit1Wl0jJFddXit1XncjJFd3eCMnW3gjTyMkVyNPI1AjKF4jUCNvIyRXI28jcCMsUSNwI3EjJFcjcSNyIylRI3J+IyRXSFAjJ2NYUTFzJXE3W09ZIydbWVotfVpdIydbXV4tfV4jbyMnWyNvI3AjKE8jcCNxIydbI3EjciMoTyNyfiMnWzFzIyhUUlExc09ZIyhPWl0jKE9efiMoT0lnIyhlWFExcyVxN1tPWSMkV1laK3VaXSMkV11eK3VeI28jJFcjbyNwIylRI3AjcSMkVyNxI3IjKVEjcn4jJFczWiMpWlpRMXMlaFMldyFiT1kjKVFZWi5xWl0jKVFdXi5xXncjKVF3eCMpfHgjTyMpUSNPI1AjK2wjUCNvIylRI28jcCMsUSNwfiMpUTNaIypSWlExc09ZIylRWVoucVpdIylRXV4ucV53IylRd3gjKnR4I08jKVEjTyNQIytsI1AjbyMpUSNvI3AjLFEjcH4jKVEzWiMqeVpRMXNPWSMpUVlaLnFaXSMpUV1eLnFedyMpUXd4IyhPeCNPIylRI08jUCMrbCNQI28jKVEjbyNwIyxRI3B+IylRM1ojK3FUUTFzT1kjKVFZWi5xWl0jKVFdXi5xXn4jKVEzWiMsWFpRMXMlaFNPWSMsellaMU9aXSMsel1eMU9edyMsend4Iy1ueCNPIyx6I08jUCMvUSNQI28jLHojbyNwIylRI3B+Iyx6MXcjLVJYUTFzJWhTT1kjLHpZWjFPWl0jLHpdXjFPXncjLHp3eCMtbngjTyMseiNPI1AjL1EjUH4jLHoxdyMtc1hRMXNPWSMsellaMU9aXSMsel1eMU9edyMsend4Iy5geCNPIyx6I08jUCMvUSNQfiMsejF3Iy5lWFExc09ZIyx6WVoxT1pdIyx6XV4xT153Iyx6d3gjKE94I08jLHojTyNQIy9RI1B+Iyx6MXcjL1ZUUTFzT1kjLHpZWjFPWl0jLHpdXjFPXn4jLHpMZSMvbVhRMXMlcTdbT1khTmRZWih9Wl0hTmRdXih9XiNvIU5kI28jcCMwWSNwI3EhTmQjcSNyIzBZI3J+IU5kNlgjMGddUTFzJWhTJWtXJXchYiV5I3RPWSMwWVlaMnFaXSMwWV1eMnFeciMwWXJzIzFgc3cjMFl3eCMzZHgjTyMwWSNPI1AjO3wjUCNvIzBZI28jcCM8YiNwfiMwWTZYIzFpXVExcyVoUyV3IWJPWSMwWVlaMnFaXSMwWV1eMnFeciMwWXJzIzJic3cjMFl3eCMzZHgjTyMwWSNPI1AjO3wjUCNvIzBZI28jcCM8YiNwfiMwWTZYIzJrXVExcyVoUyV3IWJPWSMwWVlaMnFaXSMwWV1eMnFeciMwWXJzIylRc3cjMFl3eCMzZHgjTyMwWSNPI1AjO3wjUCNvIzBZI28jcCM8YiNwfiMwWTZYIzNtXVExcyVrVyV5I3RPWSMwWVlaMnFaXSMwWV1eMnFeciMwWXJzIzFgc3cjMFl3eCM0ZngjTyMwWSNPI1AjO3wjUCNvIzBZI28jcCM8YiNwfiMwWTZYIzRvXVExcyVrVyV5I3RPWSMwWVlaMnFaXSMwWV1eMnFeciMwWXJzIzFgc3cjMFl3eCM1aHgjTyMwWSNPI1AjO3wjUCNvIzBZI28jcCM8YiNwfiMwWTRxIzVxWlExcyVrVyV5I3RPWSM1aFlaNmdaXSM1aF1eNmdeciM1aHJzIzZkcyNPIzVoI08jUCM4UyNQI28jNWgjbyNwIzhoI3B+IzVoNHEjNmlaUTFzT1kjNWhZWjZnWl0jNWhdXjZnXnIjNWhycyM3W3MjTyM1aCNPI1AjOFMjUCNvIzVoI28jcCM4aCNwfiM1aDRxIzdhWlExc09ZIzVoWVo2Z1pdIzVoXV42Z15yIzVocnMjKE9zI08jNWgjTyNQIzhTI1AjbyM1aCNvI3AjOGgjcH4jNWg0cSM4WFRRMXNPWSM1aFlaNmdaXSM1aF1eNmdefiM1aDRxIzhvWlExcyVrV09ZIzliWVo4dFpdIzliXV44dF5yIzlicnMjOlVzI08jOWIjTyNQIztoI1AjbyM5YiNvI3AjNWgjcH4jOWIxeyM5aVhRMXMla1dPWSM5YllaOHRaXSM5Yl1eOHReciM5YnJzIzpVcyNPIzliI08jUCM7aCNQfiM5YjF7IzpaWFExc09ZIzliWVo4dFpdIzliXV44dF5yIzlicnMjOnZzI08jOWIjTyNQIztoI1B+IzliMXsjOntYUTFzT1kjOWJZWjh0Wl0jOWJdXjh0XnIjOWJycyMoT3MjTyM5YiNPI1AjO2gjUH4jOWIxeyM7bVRRMXNPWSM5YllaOHRaXSM5Yl1eOHRefiM5YjZYIzxSVFExc09ZIzBZWVoycVpdIzBZXV4ycV5+IzBZNlgjPGtdUTFzJWhTJWtXT1kjPWRZWjp7Wl0jPWRdXjp7XnIjPWRycyM+YHN3Iz1kd3gjQFN4I08jPWQjTyNQI0F2I1AjbyM9ZCNvI3AjMFkjcH4jPWQyUCM9bVpRMXMlaFMla1dPWSM9ZFlaOntaXSM9ZF1eOnteciM9ZHJzIz5gc3cjPWR3eCNAU3gjTyM9ZCNPI1AjQXYjUH4jPWQyUCM+Z1pRMXMlaFNPWSM9ZFlaOntaXSM9ZF1eOnteciM9ZHJzIz9Zc3cjPWR3eCNAU3gjTyM9ZCNPI1AjQXYjUH4jPWQyUCM/YVpRMXMlaFNPWSM9ZFlaOntaXSM9ZF1eOnteciM9ZHJzIyx6c3cjPWR3eCNAU3gjTyM9ZCNPI1AjQXYjUH4jPWQyUCNAWlpRMXMla1dPWSM9ZFlaOntaXSM9ZF1eOnteciM9ZHJzIz5gc3cjPWR3eCNAfHgjTyM9ZCNPI1AjQXYjUH4jPWQyUCNBVFpRMXMla1dPWSM9ZFlaOntaXSM9ZF1eOnteciM9ZHJzIz5gc3cjPWR3eCM5YngjTyM9ZCNPI1AjQXYjUH4jPWQyUCNBe1RRMXNPWSM9ZFlaOntaXSM9ZF1eOntefiM9ZExlI0JnX1ExcyVxN1sla1cleSN0T1khTmRZWih9Wl0hTmRdXih9XnIhTmRycyMgcnN3IU5kd3gjQ2Z4I08hTmQjTyNQIy9mI1AjbyFOZCNvI3AjPGIjcCNxIU5kI3EjciMwWSNyfiFOZEp9I0NxXVExcyVxN1sla1cleSN0T1kjQ2ZZWj53Wl0jQ2ZdXj53XnIjQ2ZycyNEanMjTyNDZiNPI1AjRmojUCNvI0NmI28jcCM4aCNwI3EjQ2YjcSNyIzVoI3J+I0NmSn0jRHFdUTFzJXE3W09ZI0NmWVo+d1pdI0NmXV4+d15yI0NmcnMjRWpzI08jQ2YjTyNQI0ZqI1AjbyNDZiNvI3AjOGgjcCNxI0NmI3EjciM1aCNyfiNDZkp9I0VxXVExcyVxN1tPWSNDZllaPndaXSNDZl1ePndeciNDZnJzIydbcyNPI0NmI08jUCNGaiNQI28jQ2YjbyNwIzhoI3AjcSNDZiNxI3IjNWgjcn4jQ2ZKfSNGcVhRMXMlcTdbT1kjQ2ZZWj53Wl0jQ2ZdXj53XiNvI0NmI28jcCM1aCNwI3EjQ2YjcSNyIzVoI3J+I0NmTHUjR2VYUTFzJXE3W09ZIUt4WVonUFpdIUt4XV4nUF4jbyFLeCNvI3AjSFEjcCNxIUt4I3EjciNIUSNyfiFLeDZpI0hhXVExcyVoUyVrVyVuYCV3IWIleSN0T1kjSFFZWkF5Wl0jSFFdXkF5XnIjSFFycyNJWXN3I0hRd3gjM2R4I08jSFEjTyNQI01uI1AjbyNIUSNvI3AjTlMjcH4jSFE2aSNJZV1RMXMlaFMlbmAldyFiT1kjSFFZWkF5Wl0jSFFdXkF5XnIjSFFycyNKXnN3I0hRd3gjM2R4I08jSFEjTyNQI01uI1AjbyNIUSNvI3AjTlMjcH4jSFE2aSNKaV1RMXMlaFMlbmAldyFiT1kjSFFZWkF5Wl0jSFFdXkF5XnIjSFFycyNLYnN3I0hRd3gjM2R4I08jSFEjTyNQI01uI1AjbyNIUSNvI3AjTlMjcH4jSFEzayNLbVpRMXMlaFMlbmAldyFiT1kjS2JZWkRfWl0jS2JdXkRfXncjS2J3eCMpfHgjTyNLYiNPI1AjTGAjUCNvI0tiI28jcCNMdCNwfiNLYjNrI0xlVFExc09ZI0tiWVpEX1pdI0tiXV5EX15+I0tiM2sjTHtaUTFzJWhTT1kjLHpZWjFPWl0jLHpdXjFPXncjLHp3eCMtbngjTyMseiNPI1AjL1EjUCNvIyx6I28jcCNLYiNwfiMsejZpI01zVFExc09ZI0hRWVpBeVpdI0hRXV5BeV5+I0hRNmkjTl1dUTFzJWhTJWtXT1kjPWRZWjp7Wl0jPWRdXjp7XnIjPWRycyM+YHN3Iz1kd3gjQFN4I08jPWQjTyNQI0F2I1AjbyM9ZCNvI3AjSFEjcH4jPWRMdSQgY19RMXMlcTdbJWhTJW5gJXchYk9ZIUt4WVonUFpdIUt4XV4nUF5yIUt4cnMkIWJzdyFLeHd4IU1ZeCNPIUt4I08jUCNHXiNQI28hS3gjbyNwI05TI3AjcSFLeCNxI3IjSFEjcn4hS3hJdyQhb11RMXMlcTdbJWhTJW5gJXchYk9ZJCFiWVpHZ1pdJCFiXV5HZ153JCFid3gjJVt4I08kIWIjTyNQJCNoI1AjbyQhYiNvI3AjTHQjcCNxJCFiI3EjciNLYiNyfiQhYkl3JCNvWFExcyVxN1tPWSQhYllaR2daXSQhYl1eR2deI28kIWIjbyNwI0tiI3AjcSQhYiNxI3IjS2Ijcn4kIWJNViQkaV9RMXMlcTdbJWtXJXRwJXkjdE9ZJCVoWVpJcVpdJCVoXV5JcV5yJCVocnMjIHJzdyQlaHd4JC5weCNPJCVoI08jUCQmeCNQI28kJWgjbyNwJC1uI3AjcSQlaCNxI3IkJ2wjcn4kJWhNViQleV9RMXMlcTdbJWhTJWtXJXRwJXchYiV5I3RPWSQlaFlaSXFaXSQlaF1eSXFeciQlaHJzIyByc3ckJWh3eCQkW3gjTyQlaCNPI1AkJngjUCNvJCVoI28jcCQtbiNwI3EkJWgjcSNyJCdsI3J+JCVoTVYkJ1BYUTFzJXE3W09ZJCVoWVpJcVpdJCVoXV5JcV4jbyQlaCNvI3AkJ2wjcCNxJCVoI3EjciQnbCNyfiQlaDZ5JCd7XVExcyVoUyVrVyV0cCV3IWIleSN0T1kkJ2xZWktYWl0kJ2xdXktYXnIkJ2xycyMxYHN3JCdsd3gkKHR4I08kJ2wjTyNQJC1ZI1AjbyQnbCNvI3AkLW4jcH4kJ2w2eSQpUF1RMXMla1cldHAleSN0T1kkJ2xZWktYWl0kJ2xdXktYXnIkJ2xycyMxYHN3JCdsd3gkKXh4I08kJ2wjTyNQJC1ZI1AjbyQnbCNvI3AkLW4jcH4kJ2w2eSQqVF1RMXMla1cldHAleSN0T1kkJ2xZWktYWl0kJ2xdXktYXnIkJ2xycyMxYHN3JCdsd3gkKnx4I08kJ2wjTyNQJC1ZI1AjbyQnbCNvI3AkLW4jcH4kJ2w1YyQrWFpRMXMla1cldHAleSN0T1kkKnxZWk1tWl0kKnxdXk1tXnIkKnxycyM2ZHMjTyQqfCNPI1AkK3ojUCNvJCp8I28jcCQsYCNwfiQqfDVjJCxQVFExc09ZJCp8WVpNbVpdJCp8XV5NbV5+JCp8NWMkLGdaUTFzJWtXT1kjOWJZWjh0Wl0jOWJdXjh0XnIjOWJycyM6VXMjTyM5YiNPI1AjO2gjUCNvIzliI28jcCQqfCNwfiM5YjZ5JC1fVFExc09ZJCdsWVpLWFpdJCdsXV5LWF5+JCdsNnkkLXddUTFzJWhTJWtXT1kjPWRZWjp7Wl0jPWRdXjp7XnIjPWRycyM+YHN3Iz1kd3gjQFN4I08jPWQjTyNQI0F2I1AjbyM9ZCNvI3AkJ2wjcH4jPWRNViQufV9RMXMlcTdbJWtXJXRwJXkjdE9ZJCVoWVpJcVpdJCVoXV5JcV5yJCVocnMjIHJzdyQlaHd4JC98eCNPJCVoI08jUCQmeCNQI28kJWgjbyNwJC1uI3AjcSQlaCNxI3IkJ2wjcn4kJWhLbyQwWl1RMXMlcTdbJWtXJXRwJXkjdE9ZJC98WVohIXVaXSQvfF1eISF1XnIkL3xycyNEanMjTyQvfCNPI1AkMVMjUCNvJC98I28jcCQsYCNwI3EkL3wjcSNyJCp8I3J+JC98S28kMVpYUTFzJXE3W09ZJC98WVohIXVaXSQvfF1eISF1XiNvJC98I28jcCQqfCNwI3EkL3wjcSNyJCp8I3J+JC98TWckMX1YUTFzJXE3W09ZIUlZWVokfVpdIUlZXV4kfV4jbyFJWSNvI3AkMmojcCNxIUlZI3EjciQyaiNyfiFJWTdaJDJ7XVExcyVoUyVrVyVuYCV0cCV3IWIleSN0T1kkMmpZWiEkZ1pdJDJqXV4hJGdeciQyanJzI0lZc3ckMmp3eCQodHgjTyQyaiNPI1AkM3QjUCNvJDJqI28jcCQ0WSNwfiQyajdaJDN5VFExc09ZJDJqWVohJGdaXSQyal1eISRnXn4kMmo3WiQ0Y11RMXMlaFMla1dPWSM9ZFlaOntaXSM9ZF1eOnteciM9ZHJzIz5gc3cjPWR3eCNAU3gjTyM9ZCNPI1AjQXYjUCNvIz1kI28jcCQyaiNwfiM9ZEd6JDVvXSR9USVxN1slaFMla1clbmAldHAldyFiJXkjdE9yJH1ycyZSc3ckfXd4SHN4IV8kfSFfIWAkNmghYCNPJH0jTyNQISRSI1AjbyR9I28jcCElaSNwI3EkfSNxI3IhJGcjcn4kfUd6JDZ7WiFzLFclcTdbJWhTJWtXJW5gJXRwJXchYiV5I3RPciR9cnMmUnN3JH13eEhzeCNPJH0jTyNQISRSI1AjbyR9I28jcCElaSNwI3EkfSNxI3IhJGcjcn4kfUd6JDhSXSR3USVxN1slaFMla1clbmAldHAldyFiJXkjdE9yJH1ycyZSc3ckfXd4SHN4IV8kfSFfIWAkNmghYCNPJH0jTyNQISRSI1AjbyR9I28jcCElaSNwI3EkfSNxI3IhJGcjcn4kfUd7JDlaXyVyYCVxN1sla1clZixYJXRwJXkjdE9ZJDpZWVpJcVpdJDpZXV5JcV5yJDpZcnMkO2pzdyQ6WXd4JSV6eCNPJDpZI08jUCUhXiNQI28kOlkjbyNwJSR4I3AjcSQ6WSNxI3IlIXIjcn4kOllHayQ6a18lcTdbJWhTJWtXJWYsWCV0cCV3IWIleSN0T1kkOllZWklxWl0kOlldXklxXnIkOllycyQ7anN3JDpZd3glIF54I08kOlkjTyNQJSFeI1AjbyQ6WSNvI3AlJHgjcCNxJDpZI3EjciUhciNyfiQ6WUZ5JDt1XyVxN1slaFMlZixYJXchYk9ZJDx0WVoofVpdJDx0XV4ofV5yJDx0cnMkS3ZzdyQ8dHd4JD5TeCNPJDx0I08jUCQ/USNQI28kPHQjbyNwJEdiI3AjcSQ8dCNxI3IkP2Yjcn4kPHRGeSQ9VF8lcTdbJWhTJWtXJWYsWCV3IWIleSN0T1kkPHRZWih9Wl0kPHRdXih9XnIkPHRycyQ7anN3JDx0d3gkPlN4I08kPHQjTyNQJD9RI1AjbyQ8dCNvI3AkR2IjcCNxJDx0I3EjciQ/ZiNyfiQ8dEZ5JD5fWiVxN1sla1clZixYJXkjdE9yKH1ycyl9c3cofXd4PXt4I08ofSNPI1AyXSNQI28ofSNvI3A6WCNwI3EofSNxI3IycSNyfih9RnkkP1ZUJXE3W08jbyQ8dCNvI3AkP2YjcCNxJDx0I3EjciQ/ZiNyfiQ8dDBtJD9zXSVoUyVrVyVmLFgldyFiJXkjdE9ZJD9mWVoycVpdJD9mXV4ycV5yJD9mcnMkQGxzdyQ/Znd4JEZmeCNPJD9mI08jUCRHWyNQI28kP2YjbyNwJEdiI3B+JD9mMG0kQHVdJWhTJWYsWCV3IWJPWSQ/ZllaMnFaXSQ/Zl1eMnFeciQ/ZnJzJEFuc3ckP2Z3eCRGZngjTyQ/ZiNPI1AkR1sjUCNvJD9mI28jcCRHYiNwfiQ/ZjBtJEF3XSVoUyVmLFgldyFiT1kkP2ZZWjJxWl0kP2ZdXjJxXnIkP2ZycyRCcHN3JD9md3gkRmZ4I08kP2YjTyNQJEdbI1AjbyQ/ZiNvI3AkR2IjcH4kP2YtbyRCeVolaFMlZixYJXchYk9ZJEJwWVoucVpdJEJwXV4ucV53JEJwd3gkQ2x4I08kQnAjTyNQJERXI1AjbyRCcCNvI3AkRF4jcH4kQnAtbyRDcVYlZixYT3cucXd4L3d4I08ucSNPI1AwXiNQI28ucSNvI3AwZCNwfi5xLW8kRFpQT34kQnAtbyREZVolaFMlZixYT1kkRVdZWjFPWl0kRVddXjFPXnckRVd3eCRFengjTyRFVyNPI1AkRmAjUCNvJEVXI28jcCRCcCNwfiRFVyxdJEVfWCVoUyVmLFhPWSRFV1laMU9aXSRFV11eMU9edyRFV3d4JEV6eCNPJEVXI08jUCRGYCNQfiRFVyxdJEZQVCVmLFhPdzFPd3gxdngjTzFPI08jUDJWI1B+MU8sXSRGY1BPfiRFVzBtJEZvWCVrVyVmLFgleSN0T3IycXJzM2lzdzJxd3g1c3gjTzJxI08jUDpSI1AjbzJxI28jcDpYI3B+MnEwbSRHX1BPfiQ/ZjBtJEdrXSVoUyVrVyVmLFhPWSRIZFlaOntaXSRIZF1eOnteciRIZHJzJElgc3ckSGR3eCRLU3gjTyRIZCNPI1AkS3AjUCNvJEhkI28jcCQ/ZiNwfiRIZCxlJEhtWiVoUyVrVyVmLFhPWSRIZFlaOntaXSRIZF1eOnteciRIZHJzJElgc3ckSGR3eCRLU3gjTyRIZCNPI1AkS3AjUH4kSGQsZSRJZ1olaFMlZixYT1kkSGRZWjp7Wl0kSGRdXjp7XnIkSGRycyRKWXN3JEhkd3gkS1N4I08kSGQjTyNQJEtwI1B+JEhkLGUkSmFaJWhTJWYsWE9ZJEhkWVo6e1pdJEhkXV46e15yJEhkcnMkRVdzdyRIZHd4JEtTeCNPJEhkI08jUCRLcCNQfiRIZCxlJEtaViVrVyVmLFhPcjp7cnM7aXN3Ont3eD1aeCNPOnsjTyNQPXUjUH46eyxlJEtzUE9+JEhkRnkkTFJfJXE3WyVoUyVmLFgldyFiT1kkPHRZWih9Wl0kPHRdXih9XnIkPHRycyRNUXN3JDx0d3gkPlN4I08kPHQjTyNQJD9RI1AjbyQ8dCNvI3AkR2IjcCNxJDx0I3EjciQ/ZiNyfiQ8dEN7JE1dXSVxN1slaFMlZixYJXchYk9ZJE1RWVordVpdJE1RXV4rdV53JE1Rd3gkTlV4I08kTVEjTyNQJE54I1AjbyRNUSNvI3AkRF4jcCNxJE1RI3EjciRCcCNyfiRNUUN7JE5dWCVxN1slZixYT3crdXd4LV14I08rdSNPI1AuXSNQI28rdSNvI3AwZCNwI3ErdSNxI3IucSNyfit1Q3skTn1UJXE3W08jbyRNUSNvI3AkQnAjcCNxJE1RI3EjciRCcCNyfiRNUUdrJSBrWiVxN1sla1clZixYJXRwJXkjdE9ySXFycyl9c3dJcXd4ISB3eCNPSXEjTyNQSnMjUCNvSXEjbyNwISBUI3AjcUlxI3EjcktYI3J+SXFHayUhY1QlcTdbTyNvJDpZI28jcCUhciNwI3EkOlkjcSNyJSFyI3J+JDpZMV8lI1JdJWhTJWtXJWYsWCV0cCV3IWIleSN0T1klIXJZWktYWl0lIXJdXktYXnIlIXJycyRAbHN3JSFyd3glI3p4I08lIXIjTyNQJSRyI1AjbyUhciNvI3AlJHgjcH4lIXIxXyUkVlgla1clZixYJXRwJXkjdE9yS1hyczNpc3dLWHd4THd4I09LWCNPI1BOfSNQI29LWCNvI3AhIFQjcH5LWDFfJSR1UE9+JSFyMV8lJVJdJWhTJWtXJWYsWE9ZJEhkWVo6e1pdJEhkXV46e15yJEhkcnMkSWBzdyRIZHd4JEtTeCNPJEhkI08jUCRLcCNQI28kSGQjbyNwJSFyI3B+JEhkR2slJlhaJXE3WyVrVyVmLFgldHAleSN0T3JJcXJzKX1zd0lxd3glJnp4I09JcSNPI1BKcyNQI29JcSNvI3AhIFQjcCNxSXEjcSNyS1gjcn5JcUdrJSdaWCVpIWYlcTdbJWtXJWcsWCV0cCV5I3RPciEhdXJzP21zI08hIXUjTyNQISNtI1AjbyEhdSNvI3BOYyNwI3EhIXUjcSNyTW0jcn4hIXVHeyUoWlpmLFglcTdbJWhTJWtXJW5gJXRwJXchYiV5I3RPciR9cnMmUnN3JH13eEhzeCNPJH0jTyNQISRSI1AjbyR9I28jcCElaSNwI3EkfSNxI3IhJGcjcn4kfTx1JSlhWmVSJXE3WyVoUyVrVyVuYCV0cCV3IWIleSN0T3IkfXJzJlJzdyR9d3hIc3gjTyR9I08jUCEkUiNQI28kfSNvI3AhJWkjcCNxJH0jcSNyISRnI3J+JH1HeyUqZ19ULFglcTdbJWhTJWtXJW5gJXRwJXchYiV5I3RPciR9cnMmUnN3JH13eEhzeHokfXp7JStmeyFfJH0hXyFgJDZoIWAjTyR9I08jUCEkUiNQI28kfSNvI3AhJWkjcCNxJH0jcSNyISRnI3J+JH1HeyUreV1fUiVxN1slaFMla1clbmAldHAldyFiJXkjdE9yJH1ycyZSc3ckfXd4SHN4IV8kfSFfIWAkNmghYCNPJH0jTyNQISRSI1AjbyR9I28jcCElaSNwI3EkfSNxI3IhJGcjcn4kfUd7JS1WXSR6LFglcTdbJWhTJWtXJW5gJXRwJXchYiV5I3RPciR9cnMmUnN3JH13eEhzeCFfJH0hXyFgJDZoIWAjTyR9I08jUCEkUiNQI28kfSNvI3AhJWkjcCNxJH0jcSNyISRnI3J+JH08dSUuY1p4UiVxN1slaFMla1clbmAldHAldyFiJXkjdE9yJH1ycyZSc3ckfXd4SHN4I08kfSNPI1AhJFIjUCNvJH0jbyNwISVpI3AjcSR9I3EjciEkZyNyfiR9TWclL2leJHssWCVxN1slaFMla1clbmAldHAldyFiJXkjdE9yJH1ycyZSc3ckfXd4SHN4IV8kfSFfIWAkNmghYCFhJTBlIWEjTyR9I08jUCEkUiNQI28kfSNvI3AhJWkjcCNxJH0jcSNyISRnI3J+JH1CXiUweFomVSZqJXE3WyVoUyVrVyVuYCV0cCV3IWIleSN0T3IkfXJzJlJzdyR9d3hIc3gjTyR9I08jUCEkUiNQI28kfSNvI3AhJWkjcCNxJH0jcSNyISRnI3J+JH1HeyUyT18hZFElcTdbJWhTJWtXJW5gJXRwJXchYiV5I3RPciR9cnMmUnN3JH13eEhzeCFPJH0hTyFQJTJ9IVAhUSR9IVEhWyU1XyFbI08kfSNPI1AhJFIjUCNvJH0jbyNwISVpI3AjcSR9I3EjciEkZyNyfiR9R3slM2BdJXE3WyVoUyVrVyVuYCV0cCV3IWIleSN0T3IkfXJzJlJzdyR9d3hIc3ghTyR9IU8hUCU0WCFQI08kfSNPI1AhJFIjUCNvJH0jbyNwISVpI3AjcSR9I3EjciEkZyNyfiR9R3slNGxaIW0sWCVxN1slaFMla1clbmAldHAldyFiJXkjdE9yJH1ycyZSc3ckfXd4SHN4I08kfSNPI1AhJFIjUCNvJH0jbyNwISVpI3AjcSR9I3EjciEkZyNyfiR9R3klNXJnIWYsViVxN1slaFMla1clbmAldHAldyFiJXkjdE9yJH1ycyZSc3ckfXd4SHN4IVEkfSFRIVslNV8hWyFnJH0hZyFoJTdaIWghbCR9IWwhbSU7ayFtI08kfSNPI1AhJFIjUCNSJH0jUiNTJTVfI1MjWCR9I1gjWSU3WiNZI14kfSNeI18lO2sjXyNvJH0jbyNwISVpI3AjcSR9I3EjciEkZyNyfiR9R3klN2xhJXE3WyVoUyVrVyVuYCV0cCV3IWIleSN0T3IkfXJzJlJzdyR9d3hIc3h7JH17fCU4cXx9JH19IU8lOHEhTyFRJH0hUSFbJTl7IVsjTyR9I08jUCEkUiNQI28kfSNvI3AhJWkjcCNxJH0jcSNyISRnI3J+JH1HeSU5U10lcTdbJWhTJWtXJW5gJXRwJXchYiV5I3RPciR9cnMmUnN3JH13eEhzeCFRJH0hUSFbJTl7IVsjTyR9I08jUCEkUiNQI28kfSNvI3AhJWkjcCNxJH0jcSNyISRnI3J+JH1HeSU6YGMhZixWJXE3WyVoUyVrVyVuYCV0cCV3IWIleSN0T3IkfXJzJlJzdyR9d3hIc3ghUSR9IVEhWyU5eyFbIWwkfSFsIW0lO2shbSNPJH0jTyNQISRSI1AjUiR9I1IjUyU5eyNTI14kfSNeI18lO2sjXyNvJH0jbyNwISVpI3AjcSR9I3EjciEkZyNyfiR9R3klPE9aIWYsViVxN1slaFMla1clbmAldHAldyFiJXkjdE9yJH1ycyZSc3ckfXd4SHN4I08kfSNPI1AhJFIjUCNvJH0jbyNwISVpI3AjcSR9I3EjciEkZyNyfiR9R3slPVVfJHxSJXE3WyVoUyVrVyVuYCV0cCV3IWIleSN0T3IkfXJzJlJzdyR9d3hIc3ghUCR9IVAhUSU+VCFRIV8kfSFfIWAkNmghYCNPJH0jTyNQISRSI1AjbyR9I28jcCElaSNwI3EkfSNxI3IhJGcjcn4kfUd6JT5oXSVPUSVxN1slaFMla1clbmAldHAldyFiJXkjdE9yJH1ycyZSc3ckfXd4SHN4IV8kfSFfIWAkNmghYCNPJH0jTyNQISRSI1AjbyR9I28jcCElaSNwI3EkfSNxI3IhJGcjcn4kfUd5JT90dSFmLFYlcTdbJWhTJWtXJW5gJXRwJXchYiV5I3RPciR9cnMmUnN3JH13eEhzeCFPJH0hTyFQJUJYIVAhUSR9IVEhWyVDYyFbIWQkfSFkIWUlRWUhZSFnJH0hZyFoJTdaIWghbCR9IWwhbSU7ayFtIXEkfSFxIXIlSF8hciF6JH0heiF7JUtSIXsjTyR9I08jUCEkUiNQI1IkfSNSI1MlQ2MjUyNVJH0jVSNWJUVlI1YjWCR9I1gjWSU3WiNZI14kfSNeI18lO2sjXyNjJH0jYyNkJUhfI2QjbCR9I2wjbSVLUiNtI28kfSNvI3AhJWkjcCNxJH0jcSNyISRnI3J+JH1HeSVCal0lcTdbJWhTJWtXJW5gJXRwJXchYiV5I3RPciR9cnMmUnN3JH13eEhzeCFRJH0hUSFbJTVfIVsjTyR9I08jUCEkUiNQI28kfSNvI3AhJWkjcCNxJH0jcSNyISRnI3J+JH1HeSVDdmkhZixWJXE3WyVoUyVrVyVuYCV0cCV3IWIleSN0T3IkfXJzJlJzdyR9d3hIc3ghTyR9IU8hUCVCWCFQIVEkfSFRIVslQ2MhWyFnJH0hZyFoJTdaIWghbCR9IWwhbSU7ayFtI08kfSNPI1AhJFIjUCNSJH0jUiNTJUNjI1MjWCR9I1gjWSU3WiNZI14kfSNeI18lO2sjXyNvJH0jbyNwISVpI3AjcSR9I3EjciEkZyNyfiR9R3klRXZgJXE3WyVoUyVrVyVuYCV0cCV3IWIleSN0T3IkfXJzJlJzdyR9d3hIc3ghUSR9IVEhUiVGeCFSIVMlRnghUyNPJH0jTyNQISRSI1AjUiR9I1IjUyVGeCNTI28kfSNvI3AhJWkjcCNxJH0jcSNyISRnI3J+JH1HeSVHXWAhZixWJXE3WyVoUyVrVyVuYCV0cCV3IWIleSN0T3IkfXJzJlJzdyR9d3hIc3ghUSR9IVEhUiVGeCFSIVMlRnghUyNPJH0jTyNQISRSI1AjUiR9I1IjUyVGeCNTI28kfSNvI3AhJWkjcCNxJH0jcSNyISRnI3J+JH1HeSVIcF8lcTdbJWhTJWtXJW5gJXRwJXchYiV5I3RPciR9cnMmUnN3JH13eEhzeCFRJH0hUSFZJUlvIVkjTyR9I08jUCEkUiNQI1IkfSNSI1MlSW8jUyNvJH0jbyNwISVpI3AjcSR9I3EjciEkZyNyfiR9R3klSlNfIWYsViVxN1slaFMla1clbmAldHAldyFiJXkjdE9yJH1ycyZSc3ckfXd4SHN4IVEkfSFRIVklSW8hWSNPJH0jTyNQISRSI1AjUiR9I1IjUyVJbyNTI28kfSNvI3AhJWkjcCNxJH0jcSNyISRnI3J+JH1HeSVLZGMlcTdbJWhTJWtXJW5gJXRwJXchYiV5I3RPciR9cnMmUnN3JH13eEhzeCFRJH0hUSFbJUxvIVshYyR9IWMhaSVMbyFpI08kfSNPI1AhJFIjUCNSJH0jUiNTJUxvI1MjVCR9I1QjWiVMbyNaI28kfSNvI3AhJWkjcCNxJH0jcSNyISRnI3J+JH1HeSVNU2MhZixWJXE3WyVoUyVrVyVuYCV0cCV3IWIleSN0T3IkfXJzJlJzdyR9d3hIc3ghUSR9IVEhWyVMbyFbIWMkfSFjIWklTG8haSNPJH0jTyNQISRSI1AjUiR9I1IjUyVMbyNTI1QkfSNUI1olTG8jWiNvJH0jbyNwISVpI3AjcSR9I3EjciEkZyNyfiR9TWclTnJdeTFzJXE3WyVoUyVrVyVuYCV0cCV3IWIleSN0T3IkfXJzJlJzdyR9d3hIc3ghXyR9IV8hYCYgayFgI08kfSNPI1AhJFIjUCNvJH0jbyNwISVpI3AjcSR9I3EjciEkZyNyfiR9PHUmIU9aJVdSJXE3WyVoUyVrVyVuYCV0cCV3IWIleSN0T3IkfXJzJlJzdyR9d3hIc3gjTyR9I08jUCEkUiNQI28kfSNvI3AhJWkjcCNxJH0jcSNyISRnI3J+JH1HeyYjVVojXixYJXE3WyVoUyVrVyVuYCV0cCV3IWIleSN0T3IkfXJzJlJzdyR9d3hIc3gjTyR9I08jUCEkUiNQI28kfSNvI3AhJWkjcCNxJH0jcSNyISRnI3J+JH1HeyYkW19rUiVxN1slaFMla1clbmAldHAldyFiJXkjdE9yJH1ycyZSc3ckfXd4SHN4IV4kfSFeIV8mJVohXyFgISpRIWAhYSEqUSFhI08kfSNPI1AhJFIjUCNvJH0jbyNwISVpI3AjcSR9I3EjciEkZyNyfiR9R3omJW5dJHhRJXE3WyVoUyVrVyVuYCV0cCV3IWIleSN0T3IkfXJzJlJzdyR9d3hIc3ghXyR9IV8hYCQ2aCFgI08kfSNPI1AhJFIjUCNvJH0jbyNwISVpI3AjcSR9I3EjciEkZyNyfiR9R3smJnpdJVYsWCVxN1slaFMla1clbmAldHAldyFiJXkjdE9yJH1ycyZSc3ckfXd4SHN4IV8kfSFfIWAhKlEhYCNPJH0jTyNQISRSI1AjbyR9I28jcCElaSNwI3EkfSNxI3IhJGcjcn4kfUd7JihXXmtSJXE3WyVoUyVrVyVuYCV0cCV3IWIleSN0T3IkfXJzJlJzdyR9d3hIc3ghXyR9IV8hYCEqUSFgIWEmKVMhYSNPJH0jTyNQISRSI1AjbyR9I28jcCElaSNwI3EkfSNxI3IhJGcjcn4kfUd6JilnXSR5USVxN1slaFMla1clbmAldHAldyFiJXkjdE9yJH1ycyZSc3ckfXd4SHN4IV8kfSFfIWAkNmghYCNPJH0jTyNQISRSI1AjbyR9I28jcCElaSNwI3EkfSNxI3IhJGcjcn4kfUd7Jip1XV1RI3RQJXE3WyVoUyVrVyVuYCV0cCV3IWIleSN0T3IkfXJzJlJzdyR9d3hIc3ghXyR9IV8hYCQ2aCFgI08kfSNPI1AhJFIjUCNvJH0jbyNwISVpI3AjcSR9I3EjciEkZyNyfiR9TWcmLFRjJXE3WyVoUyVrVyVlJmolbmAldHAldyFiJXkjdCVRLFhPciR9cnMmUnN3JH13eEhzeCFRJH0hUSFbJituIVshYyR9IWMhfSYrbiF9I08kfSNPI1AhJFIjUCNSJH0jUiNTJituI1MjVCR9I1QjbyYrbiNvI3AhJWkjcCNxJH0jcSNyISRnI3IkZyR9JGd+JituTWcmLXVnJXE3WyVoUyVrVyVlJmolbmAldHAldyFiJXkjdCVRLFhPciR9cnMmL15zdyR9d3gmMmR4IVEkfSFRIVsmK24hWyFjJH0hYyF0JituIXQhdSY1aiF1IX0mK24hfSNPJH0jTyNQISRSI1AjUiR9I1IjUyYrbiNTI1QkfSNUI2YmK24jZiNnJjVqI2cjbyYrbiNvI3AhJWkjcCNxJH0jcSNyISRnI3IkZyR9JGd+JituR1omL2tfJXE3WyVoUyVmLFglbmAldyFiT1khLWxZWidQWl0hLWxdXidQXnIhLWxycyYwanN3IS1sd3ghL3x4I08hLWwjTyNQIUNwI1AjbyEtbCNvI3AhRlsjcCNxIS1sI3EjciFEVSNyfiEtbEdaJjB3WiVxN1slaFMlZixYJW5gJXchYk9yJ1BycyYxanN3J1B3eChSeCNPJ1AjTyNQQWUjUCNvJ1AjbyNwRXUjcCNxJ1AjcSNyQXkjcn4nUERdJjF3WCVxN1slaFMlaixYJW5gJXchYk93R2d3eCxreCNPR2cjTyNQSF8jUCNvR2cjbyNwRVQjcCNxR2cjcSNyRF8jcn5HZ0drJjJxXyVxN1sla1clZixYJXRwJXkjdE9ZJDpZWVpJcVpdJDpZXV5JcV5yJDpZcnMkO2pzdyQ6WXd4JjNweCNPJDpZI08jUCUhXiNQI28kOlkjbyNwJSR4I3AjcSQ6WSNxI3IlIXIjcn4kOllHayYzfVolcTdbJWtXJWYsWCV0cCV5I3RPcklxcnMpfXN3SXF3eCY0cHgjT0lxI08jUEpzI1Ajb0lxI28jcCEgVCNwI3FJcSNxI3JLWCNyfklxRlQmNH1YJXE3WyVrVyVnLFgldHAleSN0T3IhIXVycz9tcyNPISF1I08jUCEjbSNQI28hIXUjbyNwTmMjcCNxISF1I3Ejck1tI3J+ISF1TWcmNlBjJXE3WyVoUyVrVyVlJmolbmAldHAldyFiJXkjdCVRLFhPciR9cnMmL15zdyR9d3gmMmR4IVEkfSFRIVsmK24hWyFjJH0hYyF9JituIX0jTyR9I08jUCEkUiNQI1IkfSNSI1MmK24jUyNUJH0jVCNvJituI28jcCElaSNwI3EkfSNxI3IhJGcjciRnJH0kZ34mK25NZyY3cWclcTdbJWhTJWtXJWUmaiVuYCV0cCV3IWIleSN0JVEsWE9yJH1ycyY5WXN3JH13eCY8UXghUSR9IVEhWyYrbiFbIWMkfSFjIXQmK24hdCF1Jj54IXUhfSYrbiF9I08kfSNPI1AhJFIjUCNSJH0jUiNTJituI1MjVCR9I1QjZiYrbiNmI2cmPngjZyNvJituI28jcCElaSNwI3EkfSNxI3IhJGcjciRnJH0kZ34mK25HWiY5Z1olcTdbJWhTJW5gJXchYiVzLFhPcidQcnMmOllzdydQd3goUngjTydQI08jUEFlI1AjbydQI28jcEV1I3AjcSdQI3EjckF5I3J+J1BHWiY6ZVolcTdbJWhTJW5gJXchYk9yJ1BycyY7V3N3J1B3eChSeCNPJ1AjTyNQQWUjUCNvJ1AjbyNwRXUjcCNxJ1AjcSNyQXkjcn4nUERdJjtlWCVxN1slaFMleCxYJW5gJXchYk93R2d3eCxreCNPR2cjTyNQSF8jUCNvR2cjbyNwRVQjcCNxR2cjcSNyRF8jcn5HZ0drJjxfWiVxN1sla1cldHAleSN0JW0sWE9ySXFycyl9c3dJcXd4Jj1ReCNPSXEjTyNQSnMjUCNvSXEjbyNwISBUI3AjcUlxI3EjcktYI3J+SXFHayY9XVolcTdbJWtXJXRwJXkjdE9ySXFycyl9c3dJcXd4Jj5PeCNPSXEjTyNQSnMjUCNvSXEjbyNwISBUI3AjcUlxI3EjcktYI3J+SXFGVCY+XVglcTdbJWtXJXYsWCV0cCV5I3RPciEhdXJzP21zI08hIXUjTyNQISNtI1AjbyEhdSNvI3BOYyNwI3EhIXUjcSNyTW0jcn4hIXVNZyY/X2MlcTdbJWhTJWtXJWUmaiVuYCV0cCV3IWIleSN0JVEsWE9yJH1ycyY5WXN3JH13eCY8UXghUSR9IVEhWyYrbiFbIWMkfSFjIX0mK24hfSNPJH0jTyNQISRSI1AjUiR9I1IjUyYrbiNTI1QkfSNUI28mK24jbyNwISVpI3AjcSR9I3EjciEkZyNyJGckfSRnfiYrbk1nJkFQayVxN1slaFMla1clZSZqJW5gJXRwJXchYiV5I3QlUSxYT3IkfXJzJi9ec3ckfXd4JjJkeCFRJH0hUSFbJituIVshYyR9IWMhaCYrbiFoIWkmPnghaSF0JituIXQhdSY1aiF1IX0mK24hfSNPJH0jTyNQISRSI1AjUiR9I1IjUyYrbiNTI1QkfSNUI1UmK24jVSNWJjVqI1YjWSYrbiNZI1omPngjWiNvJituI28jcCElaSNwI3EkfSNxI3IhJGcjciRnJH0kZ34mK25HeyZDWFohVixYJXE3WyVoUyVrVyVuYCV0cCV3IWIleSN0T3IkfXJzJlJzdyR9d3hIc3gjTyR9I08jUCEkUiNQI28kfSNvI3AhJWkjcCNxJH0jcSNyISRnI3J+JH08dSZEX1ohVVIlcTdbJWhTJWtXJW5gJXRwJXchYiV5I3RPciR9cnMmUnN3JH13eEhzeCNPJH0jTyNQISRSI1AjbyR9I28jcCElaSNwI3EkfSNxI3IhJGcjcn4kfUd6JkVlXSR2USVxN1slaFMla1clbmAldHAldyFiJXkjdE9yJH1ycyZSc3ckfXd4SHN4IV8kfSFfIWAkNmghYCNPJH0jTyNQISRSI1AjbyR9I28jcCElaSNwI3EkfSNxI3IhJGcjcn4kfUd5JkZnWCVoUyVrVyFaR21Pcjp7cnM7aXN3Ont3eDxveCNPOnsjTyNQPXUjUCNvOnsjbyNwISRnI3B+OntHeiZHZ10kdVElcTdbJWhTJWtXJW5gJXRwJXchYiV5I3RPciR9cnMmUnN3JH13eEhzeCFfJH0hXyFgJDZoIWAjTyR9I08jUCEkUiNQI28kfSNvI3AhJWkjcCNxJH0jcSNyISRnI3J+JH08dSZIcVghWTdfJWhTJWtXJW5gJXRwJXchYiV5I3RPciEkZ3JzQnNzdyEkZ3d4TFJ4I08hJGcjTyNQISVjI1AjbyEkZyNvI3AhJWkjcH4hJGdHeSZJcVolUCxWJXE3WyVoUyVrVyVuYCV0cCV3IWIleSN0T3IkfXJzJlJzdyR9d3hIc3gjTyR9I08jUCEkUiNQI28kfSNvI3AhJWkjcCNxJH0jcSNyISRnI3J+JH1cIixcbiAgdG9rZW5pemVyczogW2xlZ2FjeVByaW50LCBpbmRlbnRhdGlvbiwgMCwgMSwgMiwgMywgNCwgNSwgNiwgNywgOCwgOSwgMTAsIG5ld2xpbmVzXSxcbiAgdG9wUnVsZXM6IHtcIlNjcmlwdFwiOlswLDNdfSxcbiAgc3BlY2lhbGl6ZWQ6IFt7dGVybTogMTg2LCBnZXQ6IHZhbHVlID0+IHNwZWNfaWRlbnRpZmllclt2YWx1ZV0gfHwgLTF9XSxcbiAgdG9rZW5QcmVjOiA2NTg0XG59KTtcblxuZXhwb3J0cy5wYXJzZXIgPSBwYXJzZXI7XG4iLCIvLyBUaGUgbW9kdWxlIGNhY2hlXG52YXIgX193ZWJwYWNrX21vZHVsZV9jYWNoZV9fID0ge307XG5cbi8vIFRoZSByZXF1aXJlIGZ1bmN0aW9uXG5mdW5jdGlvbiBfX3dlYnBhY2tfcmVxdWlyZV9fKG1vZHVsZUlkKSB7XG5cdC8vIENoZWNrIGlmIG1vZHVsZSBpcyBpbiBjYWNoZVxuXHR2YXIgY2FjaGVkTW9kdWxlID0gX193ZWJwYWNrX21vZHVsZV9jYWNoZV9fW21vZHVsZUlkXTtcblx0aWYgKGNhY2hlZE1vZHVsZSAhPT0gdW5kZWZpbmVkKSB7XG5cdFx0cmV0dXJuIGNhY2hlZE1vZHVsZS5leHBvcnRzO1xuXHR9XG5cdC8vIENyZWF0ZSBhIG5ldyBtb2R1bGUgKGFuZCBwdXQgaXQgaW50byB0aGUgY2FjaGUpXG5cdHZhciBtb2R1bGUgPSBfX3dlYnBhY2tfbW9kdWxlX2NhY2hlX19bbW9kdWxlSWRdID0ge1xuXHRcdGlkOiBtb2R1bGVJZCxcblx0XHQvLyBubyBtb2R1bGUubG9hZGVkIG5lZWRlZFxuXHRcdGV4cG9ydHM6IHt9XG5cdH07XG5cblx0Ly8gRXhlY3V0ZSB0aGUgbW9kdWxlIGZ1bmN0aW9uXG5cdF9fd2VicGFja19tb2R1bGVzX19bbW9kdWxlSWRdLmNhbGwobW9kdWxlLmV4cG9ydHMsIG1vZHVsZSwgbW9kdWxlLmV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pO1xuXG5cdC8vIFJldHVybiB0aGUgZXhwb3J0cyBvZiB0aGUgbW9kdWxlXG5cdHJldHVybiBtb2R1bGUuZXhwb3J0cztcbn1cblxuLy8gZXhwb3NlIHRoZSBtb2R1bGVzIG9iamVjdCAoX193ZWJwYWNrX21vZHVsZXNfXylcbl9fd2VicGFja19yZXF1aXJlX18ubSA9IF9fd2VicGFja19tb2R1bGVzX187XG5cbiIsIi8vIGdldERlZmF1bHRFeHBvcnQgZnVuY3Rpb24gZm9yIGNvbXBhdGliaWxpdHkgd2l0aCBub24taGFybW9ueSBtb2R1bGVzXG5fX3dlYnBhY2tfcmVxdWlyZV9fLm4gPSAobW9kdWxlKSA9PiB7XG5cdHZhciBnZXR0ZXIgPSBtb2R1bGUgJiYgbW9kdWxlLl9fZXNNb2R1bGUgP1xuXHRcdCgpID0+IChtb2R1bGVbJ2RlZmF1bHQnXSkgOlxuXHRcdCgpID0+IChtb2R1bGUpO1xuXHRfX3dlYnBhY2tfcmVxdWlyZV9fLmQoZ2V0dGVyLCB7IGE6IGdldHRlciB9KTtcblx0cmV0dXJuIGdldHRlcjtcbn07IiwiLy8gZGVmaW5lIGdldHRlciBmdW5jdGlvbnMgZm9yIGhhcm1vbnkgZXhwb3J0c1xuX193ZWJwYWNrX3JlcXVpcmVfXy5kID0gKGV4cG9ydHMsIGRlZmluaXRpb24pID0+IHtcblx0Zm9yKHZhciBrZXkgaW4gZGVmaW5pdGlvbikge1xuXHRcdGlmKF9fd2VicGFja19yZXF1aXJlX18ubyhkZWZpbml0aW9uLCBrZXkpICYmICFfX3dlYnBhY2tfcmVxdWlyZV9fLm8oZXhwb3J0cywga2V5KSkge1xuXHRcdFx0T2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIGtleSwgeyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGRlZmluaXRpb25ba2V5XSB9KTtcblx0XHR9XG5cdH1cbn07IiwiX193ZWJwYWNrX3JlcXVpcmVfXy5nID0gKGZ1bmN0aW9uKCkge1xuXHRpZiAodHlwZW9mIGdsb2JhbFRoaXMgPT09ICdvYmplY3QnKSByZXR1cm4gZ2xvYmFsVGhpcztcblx0dHJ5IHtcblx0XHRyZXR1cm4gdGhpcyB8fCBuZXcgRnVuY3Rpb24oJ3JldHVybiB0aGlzJykoKTtcblx0fSBjYXRjaCAoZSkge1xuXHRcdGlmICh0eXBlb2Ygd2luZG93ID09PSAnb2JqZWN0JykgcmV0dXJuIHdpbmRvdztcblx0fVxufSkoKTsiLCJfX3dlYnBhY2tfcmVxdWlyZV9fLm8gPSAob2JqLCBwcm9wKSA9PiAoT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKG9iaiwgcHJvcCkpIiwiLy8gZGVmaW5lIF9fZXNNb2R1bGUgb24gZXhwb3J0c1xuX193ZWJwYWNrX3JlcXVpcmVfXy5yID0gKGV4cG9ydHMpID0+IHtcblx0aWYodHlwZW9mIFN5bWJvbCAhPT0gJ3VuZGVmaW5lZCcgJiYgU3ltYm9sLnRvU3RyaW5nVGFnKSB7XG5cdFx0T2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFN5bWJvbC50b1N0cmluZ1RhZywgeyB2YWx1ZTogJ01vZHVsZScgfSk7XG5cdH1cblx0T2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsICdfX2VzTW9kdWxlJywgeyB2YWx1ZTogdHJ1ZSB9KTtcbn07IiwiX193ZWJwYWNrX3JlcXVpcmVfXy5iID0gZG9jdW1lbnQuYmFzZVVSSSB8fCBzZWxmLmxvY2F0aW9uLmhyZWY7XG5cbi8vIG9iamVjdCB0byBzdG9yZSBsb2FkZWQgYW5kIGxvYWRpbmcgY2h1bmtzXG4vLyB1bmRlZmluZWQgPSBjaHVuayBub3QgbG9hZGVkLCBudWxsID0gY2h1bmsgcHJlbG9hZGVkL3ByZWZldGNoZWRcbi8vIFtyZXNvbHZlLCByZWplY3QsIFByb21pc2VdID0gY2h1bmsgbG9hZGluZywgMCA9IGNodW5rIGxvYWRlZFxudmFyIGluc3RhbGxlZENodW5rcyA9IHtcblx0XCJtYWluXCI6IDBcbn07XG5cbi8vIG5vIGNodW5rIG9uIGRlbWFuZCBsb2FkaW5nXG5cbi8vIG5vIHByZWZldGNoaW5nXG5cbi8vIG5vIHByZWxvYWRlZFxuXG4vLyBubyBITVJcblxuLy8gbm8gSE1SIG1hbmlmZXN0XG5cbi8vIG5vIG9uIGNodW5rcyBsb2FkZWRcblxuLy8gbm8ganNvbnAgZnVuY3Rpb24iLCJfX3dlYnBhY2tfcmVxdWlyZV9fLm5jID0gdW5kZWZpbmVkOyIsIiIsIi8vIHN0YXJ0dXBcbi8vIExvYWQgZW50cnkgbW9kdWxlIGFuZCByZXR1cm4gZXhwb3J0c1xuLy8gVGhpcyBlbnRyeSBtb2R1bGUgaXMgcmVmZXJlbmNlZCBieSBvdGhlciBtb2R1bGVzIHNvIGl0IGNhbid0IGJlIGlubGluZWRcbnZhciBfX3dlYnBhY2tfZXhwb3J0c19fID0gX193ZWJwYWNrX3JlcXVpcmVfXyhcIi4vd2Vic3RhcnQudHNcIik7XG4iLCIiXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=